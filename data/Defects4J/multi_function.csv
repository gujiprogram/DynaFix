slug,class_path,buggy_code
Chart_2,/home/common/huangzhili/defects4j_buggy/Chart_2_buggy/source/org/jfree/data/general/DatasetUtilities.java,"public static Range iterateDomainBounds(XYDataset dataset,
                                            boolean includeInterval) {
        if (dataset == null) {
            throw new IllegalArgumentException(""Null 'dataset' argument."");
        }
        double minimum = Double.POSITIVE_INFINITY;
        double maximum = Double.NEGATIVE_INFINITY;
        int seriesCount = dataset.getSeriesCount();
        double lvalue;
        double uvalue;
        if (includeInterval && dataset instanceof IntervalXYDataset) {
            IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;
             for (int series = 0; series < seriesCount; series++) {
                 int itemCount = dataset.getItemCount(series);
                 for (int item = 0; item < itemCount; item++) {
                     lvalue = intervalXYData.getStartXValue(series, item);
                     uvalue = intervalXYData.getEndXValue(series, item);
                     if (!Double.isNaN(lvalue)) {
                         minimum = Math.min(minimum, lvalue);
                     }
                     if (!Double.isNaN(uvalue)) {
                         maximum = Math.max(maximum, uvalue);
                     }
                 }
            }
        }
        else {
            for (int series = 0; series < seriesCount; series++) {
                int itemCount = dataset.getItemCount(series);
                for (int item = 0; item < itemCount; item++) {
                    lvalue = dataset.getXValue(series, item);
                    uvalue = lvalue;
                    if (!Double.isNaN(lvalue)) {
                        minimum = Math.min(minimum, lvalue);
                        maximum = Math.max(maximum, uvalue);
                    }
                }
            }
        }
        if (minimum > maximum) {
            return null;
        }
        else {
            return new Range(minimum, maximum);
        }
    }"
Chart_2,/home/common/huangzhili/defects4j_buggy/Chart_2_buggy/source/org/jfree/data/general/DatasetUtilities.java,"public static Range iterateRangeBounds(XYDataset dataset,
            boolean includeInterval) {
        double minimum = Double.POSITIVE_INFINITY;
        double maximum = Double.NEGATIVE_INFINITY;
        int seriesCount = dataset.getSeriesCount();

        // handle three cases by dataset type
        if (includeInterval && dataset instanceof IntervalXYDataset) {
            // handle special case of IntervalXYDataset
            IntervalXYDataset ixyd = (IntervalXYDataset) dataset;
             for (int series = 0; series < seriesCount; series++) {
                 int itemCount = dataset.getItemCount(series);
                 for (int item = 0; item < itemCount; item++) {
                     double lvalue = ixyd.getStartYValue(series, item);
                     double uvalue = ixyd.getEndYValue(series, item);
                     if (!Double.isNaN(lvalue)) {
                         minimum = Math.min(minimum, lvalue);
                     }
                     if (!Double.isNaN(uvalue)) {
                         maximum = Math.max(maximum, uvalue);
                     }
                 }
            }
        }
        else if (includeInterval && dataset instanceof OHLCDataset) {
            // handle special case of OHLCDataset
            OHLCDataset ohlc = (OHLCDataset) dataset;
            for (int series = 0; series < seriesCount; series++) {
                int itemCount = dataset.getItemCount(series);
                for (int item = 0; item < itemCount; item++) {
                    double lvalue = ohlc.getLowValue(series, item);
                    double uvalue = ohlc.getHighValue(series, item);
                    if (!Double.isNaN(lvalue)) {
                        minimum = Math.min(minimum, lvalue);
                    }
                    if (!Double.isNaN(uvalue)) {
                        maximum = Math.max(maximum, uvalue);
                    }
                }
            }
        }
        else {
            // standard case - plain XYDataset
            for (int series = 0; series < seriesCount; series++) {
                int itemCount = dataset.getItemCount(series);
                for (int item = 0; item < itemCount; item++) {
                    double value = dataset.getYValue(series, item);
                    if (!Double.isNaN(value)) {
                        minimum = Math.min(minimum, value);
                        maximum = Math.max(maximum, value);
                    }
                }
            }
        }
        if (minimum == Double.POSITIVE_INFINITY) {
            return null;
        }
        else {
            return new Range(minimum, maximum);
        }
    }"
Chart_14,/home/common/huangzhili/defects4j_buggy/Chart_14_buggy/source/org/jfree/chart/plot/CategoryPlot.java,"public boolean removeDomainMarker(int index, Marker marker, Layer layer,
    		boolean notify) {
        ArrayList markers;
        if (layer == Layer.FOREGROUND) {
            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(
                    index));
        }
        else {
             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(
                     index));
         }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();
        }
        return removed;
    }"
Chart_14,/home/common/huangzhili/defects4j_buggy/Chart_14_buggy/source/org/jfree/chart/plot/XYPlot.java,"public boolean removeRangeMarker(int index, Marker marker, Layer layer,
    		boolean notify) {
        if (marker == null) {
            throw new IllegalArgumentException(""Null 'marker' argument."");
        }
        ArrayList markers;
        if (layer == Layer.FOREGROUND) {
            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(
                    index));
        }
        else {
             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(
                     index));
         }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();
        }
        return removed;
    }"
Chart_14,/home/common/huangzhili/defects4j_buggy/Chart_14_buggy/source/org/jfree/chart/plot/XYPlot.java,"public boolean removeDomainMarker(int index, Marker marker, Layer layer,
    		boolean notify) {
        ArrayList markers;
        if (layer == Layer.FOREGROUND) {
            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(
                    index));
        }
        else {
             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(
                     index));
         }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();
        }
        return removed;
    }"
Chart_14,/home/common/huangzhili/defects4j_buggy/Chart_14_buggy/source/org/jfree/chart/plot/CategoryPlot.java,"public boolean removeRangeMarker(int index, Marker marker, Layer layer,
    		boolean notify) {
        if (marker == null) {
            throw new IllegalArgumentException(""Null 'marker' argument."");
        }
        ArrayList markers;
        if (layer == Layer.FOREGROUND) {
            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(
                    index));
        }
        else {
             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(
                     index));
         }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();
        }
        return removed;
    }"
Chart_15,/home/common/huangzhili/defects4j_buggy/Chart_15_buggy/source/org/jfree/chart/plot/PiePlot.java,"public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea,
            PiePlot plot, Integer index, PlotRenderingInfo info) {
      
         PiePlotState state = new PiePlotState(info);
         state.setPassesRequired(2);
             state.setTotal(DatasetUtilities.calculatePieDatasetTotal(
                     plot.getDataset()));
         state.setLatestAngle(plot.getStartAngle());
         return state;
         
    }"
Chart_16,/home/common/huangzhili/defects4j_buggy/Chart_16_buggy/source/org/jfree/data/category/DefaultIntervalCategoryDataset.java,"public void setCategoryKeys(Comparable[] categoryKeys) {
         if (categoryKeys == null) {
             throw new IllegalArgumentException(""Null 'categoryKeys' argument."");
         }
         if (categoryKeys.length != this.startData[0].length) {
             throw new IllegalArgumentException(
                     ""The number of categories does not match the data."");
         }
        for (int i = 0; i < categoryKeys.length; i++) {
            if (categoryKeys[i] == null) {
                throw new IllegalArgumentException(
                    ""DefaultIntervalCategoryDataset.setCategoryKeys(): ""
                    + ""null category not permitted."");
            }
        }
        this.categoryKeys = categoryKeys;
        fireDatasetChanged();
    }"
Chart_18,/home/common/huangzhili/defects4j_buggy/Chart_18_buggy/source/org/jfree/data/DefaultKeyedValues.java,"public void removeValue(int index) {
        this.keys.remove(index);
        this.values.remove(index);
        rebuildIndex();
    }"
Chart_18,/home/common/huangzhili/defects4j_buggy/Chart_18_buggy/source/org/jfree/data/DefaultKeyedValues.java,"public void removeValue(Comparable key) {
        int index = getIndex(key);
        if (index < 0) {
            throw new UnknownKeyException(""The key ("" + key 
                    + "") is not recognised."");
        }
        removeValue(index);
    }
    
    /**"
Chart_19,/home/common/huangzhili/defects4j_buggy/Chart_19_buggy/source/org/jfree/chart/plot/CategoryPlot.java,"    public int getDomainAxisIndex(CategoryAxis axis) {
        return this.domainAxes.indexOf(axis);
    }
"
Chart_19,/home/common/huangzhili/defects4j_buggy/Chart_19_buggy/source/org/jfree/chart/plot/CategoryPlot.java,"    public int getRangeAxisIndex(ValueAxis axis) {
        int result = this.rangeAxes.indexOf(axis);
        if (result < 0) { // try the parent plot
            Plot parent = getParent();
            if (parent instanceof CategoryPlot) {
                CategoryPlot p = (CategoryPlot) parent;
                result = p.getRangeAxisIndex(axis);
            }
        }
        return result;
    }
"
Chart_21,/home/common/huangzhili/defects4j_buggy/Chart_21_buggy/source/org/jfree/data/statistics/DefaultBoxAndWhiskerCategoryDataset.java,"private void updateBounds() {
         this.minimumRangeValue = Double.NaN;
         this.maximumRangeValue = Double.NaN;
     }"
Chart_21,/home/common/huangzhili/defects4j_buggy/Chart_21_buggy/source/org/jfree/data/statistics/DefaultBoxAndWhiskerCategoryDataset.java,"public void add(BoxAndWhiskerItem item, Comparable rowKey, 
            Comparable columnKey) {

        this.data.addObject(item, rowKey, columnKey);
        
        // update cached min and max values
        int r = this.data.getRowIndex(rowKey);
        int c = this.data.getColumnIndex(columnKey);
        if ((this.maximumRangeValueRow == r && this.maximumRangeValueColumn 
                == c) || (this.minimumRangeValueRow == r 
                 && this.minimumRangeValueColumn == c))  {
             updateBounds();
         }
         
             double minval = Double.NaN;
             if (item.getMinOutlier() != null) {
                minval = item.getMinOutlier().doubleValue();
            }
            double maxval = Double.NaN;
            if (item.getMaxOutlier() != null) {
                maxval = item.getMaxOutlier().doubleValue();
            }
        
            if (Double.isNaN(this.maximumRangeValue)) {
                this.maximumRangeValue = maxval;
                this.maximumRangeValueRow = r;
                this.maximumRangeValueColumn = c;
            }
            else if (maxval > this.maximumRangeValue) {
                this.maximumRangeValue = maxval;
                this.maximumRangeValueRow = r;
                this.maximumRangeValueColumn = c;
            }
        
            if (Double.isNaN(this.minimumRangeValue)) {
                this.minimumRangeValue = minval;
                this.minimumRangeValueRow = r;
                this.minimumRangeValueColumn = c;
            }
            else if (minval < this.minimumRangeValue) {
                this.minimumRangeValue = minval;
                this.minimumRangeValueRow = r;
                this.minimumRangeValueColumn = c;
            }
        
        this.rangeBounds = new Range(this.minimumRangeValue,
              this.maximumRangeValue);
        fireDatasetChanged();

    }"
Chart_22,/home/common/huangzhili/defects4j_buggy/Chart_22_buggy/source/org/jfree/data/KeyedObjects2D.java,"public Object getObject(Comparable rowKey, Comparable columnKey) {
        if (rowKey == null) {
            throw new IllegalArgumentException(""Null 'rowKey' argument."");
        }
        if (columnKey == null) {
            throw new IllegalArgumentException(""Null 'columnKey' argument."");
        }
        int row = this.rowKeys.indexOf(rowKey);
        if (row < 0) {
            throw new UnknownKeyException(""Row key ("" + rowKey 
                    + "") not recognised."");
        }
        int column = this.columnKeys.indexOf(columnKey);
        if (column < 0) {
             throw new UnknownKeyException(""Column key ("" + columnKey 
                     + "") not recognised."");
         }
         if (row >= 0) {
         KeyedObjects rowData = (KeyedObjects) this.rows.get(row);
             return rowData.getObject(columnKey);
         }
         else {
             return null;
        }
    }"
Chart_22,/home/common/huangzhili/defects4j_buggy/Chart_22_buggy/source/org/jfree/data/KeyedObjects2D.java,"public void removeObject(Comparable rowKey, Comparable columnKey) {
        setObject(null, rowKey, columnKey);
        
        // 1. check whether the row is now empty.
        boolean allNull = true;
        int rowIndex = getRowIndex(rowKey);
        KeyedObjects row = (KeyedObjects) this.rows.get(rowIndex);

        for (int item = 0, itemCount = row.getItemCount(); item < itemCount; 
             item++) {
            if (row.getObject(item) != null) {
                allNull = false;
                break;
            }
        }
        
        if (allNull) {
            this.rowKeys.remove(rowIndex);
            this.rows.remove(rowIndex);
         }
         
         // 2. check whether the column is now empty.
         
         
     }"
Chart_22,/home/common/huangzhili/defects4j_buggy/Chart_22_buggy/source/org/jfree/data/KeyedObjects2D.java,"public void removeRow(Comparable rowKey) {
         int index = getRowIndex(rowKey);
         removeRow(index);
     }"
Chart_22,/home/common/huangzhili/defects4j_buggy/Chart_22_buggy/source/org/jfree/data/KeyedObjects2D.java,"public void removeColumn(Comparable columnKey) {
        int index = getColumnIndex(columnKey);
        if (index < 0) {
            throw new UnknownKeyException(""Column key ("" + columnKey 
                    + "") not recognised."");
        }
         Iterator iterator = this.rows.iterator();
         while (iterator.hasNext()) {
             KeyedObjects rowData = (KeyedObjects) iterator.next();
                 rowData.removeValue(columnKey);
         }
         this.columnKeys.remove(columnKey);
     }"
Chart_23,/home/common/huangzhili/defects4j_buggy/Chart_23_buggy/source/org/jfree/chart/renderer/category/MinMaxCategoryRenderer.java,"    private Icon getIcon(Shape shape, final Paint fillPaint, 
                        final Paint outlinePaint) {

      final int width = shape.getBounds().width;
      final int height = shape.getBounds().height;
      final GeneralPath path = new GeneralPath(shape);
      return new Icon() {
          public void paintIcon(Component c, Graphics g, int x, int y) {
              Graphics2D g2 = (Graphics2D) g;
              path.transform(AffineTransform.getTranslateInstance(x, y));
              if (fillPaint != null) {
                  g2.setPaint(fillPaint);
                  g2.fill(path);
              }
              if (outlinePaint != null) {
                  g2.setPaint(outlinePaint);
                  g2.draw(path);
              }
              path.transform(AffineTransform.getTranslateInstance(-x, -y));
        }

        public int getIconWidth() {
            return width;
        }

        public int getIconHeight() {
            return height;
        }

      };
    }
"
Chart_25,/home/common/huangzhili/defects4j_buggy/Chart_25_buggy/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java,"protected void drawHorizontalItem(Graphics2D g2,
                                      CategoryItemRendererState state,
                                      Rectangle2D dataArea,
                                      CategoryPlot plot,
                                      CategoryAxis domainAxis,
                                      ValueAxis rangeAxis,
                                      StatisticalCategoryDataset dataset,
                                      int row,
                                      int column) {
                                     
        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();
        
        // BAR Y
        double rectY = domainAxis.getCategoryStart(column, getColumnCount(), 
                dataArea, xAxisLocation);

        int seriesCount = getRowCount();
        int categoryCount = getColumnCount();
        if (seriesCount > 1) {
            double seriesGap = dataArea.getHeight() * getItemMargin()
                               / (categoryCount * (seriesCount - 1));
            rectY = rectY + row * (state.getBarWidth() + seriesGap);
        }
        else {
            rectY = rectY + row * state.getBarWidth();
        }
 
         // BAR X
         Number meanValue = dataset.getMeanValue(row, column);
 
         double value = meanValue.doubleValue();
         double base = 0.0;
        double lclip = getLowerClip();
        double uclip = getUpperClip();

        if (uclip <= 0.0) {  // cases 1, 2, 3 and 4
            if (value >= uclip) {
                return; // bar is not visible
            }
            base = uclip;
            if (value <= lclip) {
                value = lclip;
            }
        }
        else if (lclip <= 0.0) { // cases 5, 6, 7 and 8
            if (value >= uclip) {
                value = uclip;
            }
            else {
                if (value <= lclip) {
                    value = lclip;
                }
            }
        }
        else { // cases 9, 10, 11 and 12
            if (value <= lclip) {
                return; // bar is not visible
            }
            base = getLowerClip();
            if (value >= uclip) {
               value = uclip;
            }
        }

        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();
        double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);
        double transY2 = rangeAxis.valueToJava2D(value, dataArea, 
                yAxisLocation);
        double rectX = Math.min(transY2, transY1);

        double rectHeight = state.getBarWidth();
        double rectWidth = Math.abs(transY2 - transY1);

        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, 
                rectHeight);
        Paint seriesPaint = getItemPaint(row, column);
        g2.setPaint(seriesPaint);
        g2.fill(bar);
        if (isDrawBarOutline() && state.getBarWidth() > 3) {
            g2.setStroke(getItemStroke(row, column));
            g2.setPaint(getItemOutlinePaint(row, column));
            g2.draw(bar);
        }

        // standard deviation lines
            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();
            double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
                    + valueDelta, dataArea, yAxisLocation);
            double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
                    - valueDelta, dataArea, yAxisLocation);

            if (this.errorIndicatorStroke != null) {
                g2.setStroke(this.errorIndicatorStroke);
            }
            else {
                g2.setStroke(getItemOutlineStroke(row, column));
            }
            if (this.errorIndicatorPaint != null) {
                g2.setPaint(this.errorIndicatorPaint);  
            }
            else {
                g2.setPaint(getItemOutlinePaint(row, column));   
            }
        
            Line2D line = null;
            line = new Line2D.Double(lowVal, rectY + rectHeight / 2.0d, 
                                     highVal, rectY + rectHeight / 2.0d);
            g2.draw(line);
            line = new Line2D.Double(highVal, rectY + rectHeight * 0.25, 
                                     highVal, rectY + rectHeight * 0.75);
            g2.draw(line);
            line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, 
                                     lowVal, rectY + rectHeight * 0.75);
            g2.draw(line);
        
        CategoryItemLabelGenerator generator = getItemLabelGenerator(row, 
                column);
        if (generator != null && isItemLabelVisible(row, column)) {
            drawItemLabel(g2, dataset, row, column, plot, generator, bar, 
                    (value < 0.0));
        }        

        // add an item entity, if this information is being collected
        EntityCollection entities = state.getEntityCollection();
        if (entities != null) {
            addItemEntity(entities, dataset, row, column, bar);
        }

    }"
Chart_25,/home/common/huangzhili/defects4j_buggy/Chart_25_buggy/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java,"protected void drawVerticalItem(Graphics2D g2,
                                    CategoryItemRendererState state,
                                    Rectangle2D dataArea,
                                    CategoryPlot plot,
                                    CategoryAxis domainAxis,
                                    ValueAxis rangeAxis,
                                    StatisticalCategoryDataset dataset,
                                    int row,
                                    int column) {
                                     
        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();
        
        // BAR X
        double rectX = domainAxis.getCategoryStart(
            column, getColumnCount(), dataArea, xAxisLocation
        );

        int seriesCount = getRowCount();
        int categoryCount = getColumnCount();
        if (seriesCount > 1) {
            double seriesGap = dataArea.getWidth() * getItemMargin()
                               / (categoryCount * (seriesCount - 1));
            rectX = rectX + row * (state.getBarWidth() + seriesGap);
        }
        else {
            rectX = rectX + row * state.getBarWidth();
        }

        // BAR Y
        Number meanValue = dataset.getMeanValue(row, column);

        double value = meanValue.doubleValue();
        double base = 0.0;
        double lclip = getLowerClip();
        double uclip = getUpperClip();

        if (uclip <= 0.0) {  // cases 1, 2, 3 and 4
            if (value >= uclip) {
                return; // bar is not visible
            }
            base = uclip;
            if (value <= lclip) {
                value = lclip;
            }
        }
        else if (lclip <= 0.0) { // cases 5, 6, 7 and 8
            if (value >= uclip) {
                value = uclip;
            }
            else {
                if (value <= lclip) {
                    value = lclip;
                }
            }
        }
        else { // cases 9, 10, 11 and 12
            if (value <= lclip) {
                return; // bar is not visible
            }
            base = getLowerClip();
            if (value >= uclip) {
               value = uclip;
            }
        }

        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();
        double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);
        double transY2 = rangeAxis.valueToJava2D(value, dataArea, 
                yAxisLocation);
        double rectY = Math.min(transY2, transY1);

        double rectWidth = state.getBarWidth();
        double rectHeight = Math.abs(transY2 - transY1);

        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, 
                rectHeight);
        Paint seriesPaint = getItemPaint(row, column);
        g2.setPaint(seriesPaint);
        g2.fill(bar);
        if (isDrawBarOutline() && state.getBarWidth() > 3) {
            g2.setStroke(getItemStroke(row, column));
            g2.setPaint(getItemOutlinePaint(row, column));
            g2.draw(bar);
        }

        // standard deviation lines
            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();
            double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
                    + valueDelta, dataArea, yAxisLocation);
            double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
                    - valueDelta, dataArea, yAxisLocation);

            if (this.errorIndicatorStroke != null) {
                g2.setStroke(this.errorIndicatorStroke);
            }
            else {
                g2.setStroke(getItemOutlineStroke(row, column));
            }
            if (this.errorIndicatorPaint != null) {
                g2.setPaint(this.errorIndicatorPaint);  
            }
            else {
                g2.setPaint(getItemOutlinePaint(row, column));   
            }
            Line2D line = null;
            line = new Line2D.Double(rectX + rectWidth / 2.0d, lowVal,
                                     rectX + rectWidth / 2.0d, highVal);
            g2.draw(line);
            line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, highVal,
                                     rectX + rectWidth / 2.0d + 5.0d, highVal);
            g2.draw(line);
             line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,
                                      rectX + rectWidth / 2.0d + 5.0d, lowVal);
             g2.draw(line);
         
         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, 
                 column);
        if (generator != null && isItemLabelVisible(row, column)) {
            drawItemLabel(g2, dataset, row, column, plot, generator, bar, 
                    (value < 0.0));
        }        

        // add an item entity, if this information is being collected
        EntityCollection entities = state.getEntityCollection();
        if (entities != null) {
            addItemEntity(entities, dataset, row, column, bar);
        }
    }"
Chart_25,/home/common/huangzhili/defects4j_buggy/Chart_25_buggy/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java,"* @param row  the row index (zero-based).
     * @param column  the column index (zero-based).
     */
    protected void drawVerticalItem(Graphics2D g2,
                                    CategoryItemRendererState state,
                                    Rectangle2D dataArea,
                                    CategoryPlot plot,
                                    CategoryAxis domainAxis,
                                    ValueAxis rangeAxis,
                                    StatisticalCategoryDataset dataset,
                                    int row,
                                    int column) {
                                     
        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();
        
        // BAR X
        double rectX = domainAxis.getCategoryStart(
            column, getColumnCount(), dataArea, xAxisLocation
        );

        int seriesCount = getRowCount();
        int categoryCount = getColumnCount();
        if (seriesCount > 1) {
            double seriesGap = dataArea.getWidth() * getItemMargin()
                               / (categoryCount * (seriesCount - 1));
            rectX = rectX + row * (state.getBarWidth() + seriesGap);
        }
        else {
            rectX = rectX + row * state.getBarWidth();
        }

        // BAR Y
        Number meanValue = dataset.getMeanValue(row, column);

        double value = meanValue.doubleValue();
        double base = 0.0;
        double lclip = getLowerClip();
        double uclip = getUpperClip();

        if (uclip <= 0.0) {  // cases 1, 2, 3 and 4
            if (value >= uclip) {
                return; // bar is not visible
            }
            base = uclip;
            if (value <= lclip) {
                value = lclip;
            }
        }
        else if (lclip <= 0.0) { // cases 5, 6, 7 and 8
            if (value >= uclip) {
                value = uclip;
            }
            else {
                if (value <= lclip) {
                    value = lclip;
                }
            }
        }
        else { // cases 9, 10, 11 and 12
            if (value <= lclip) {
                return; // bar is not visible
            }
            base = getLowerClip();
            if (value >= uclip) {
               value = uclip;
            }
        }

        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();
        double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);
        double transY2 = rangeAxis.valueToJava2D(value, dataArea, 
                yAxisLocation);
        double rectY = Math.min(transY2, transY1);

        double rectWidth = state.getBarWidth();
        double rectHeight = Math.abs(transY2 - transY1);

        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, 
                rectHeight);
        Paint seriesPaint = getItemPaint(row, column);
        g2.setPaint(seriesPaint);
        g2.fill(bar);
        if (isDrawBarOutline() && state.getBarWidth() > 3) {
            g2.setStroke(getItemStroke(row, column));
            g2.setPaint(getItemOutlinePaint(row, column));
            g2.draw(bar);
         }
 
         // standard deviation lines
             double valueDelta = dataset.getStdDevValue(row, column).doubleValue();
             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
                     + valueDelta, dataArea, yAxisLocation);
             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
                    - valueDelta, dataArea, yAxisLocation);

            if (this.errorIndicatorStroke != null) {
                g2.setStroke(this.errorIndicatorStroke);
            }
            else {
                g2.setStroke(getItemOutlineStroke(row, column));
            }
            if (this.errorIndicatorPaint != null) {
                g2.setPaint(this.errorIndicatorPaint);  
            }
            else {
                g2.setPaint(getItemOutlinePaint(row, column));   
            }
            Line2D line = null;
            line = new Line2D.Double(rectX + rectWidth / 2.0d, lowVal,
                                     rectX + rectWidth / 2.0d, highVal);
            g2.draw(line);
            line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, highVal,
                                     rectX + rectWidth / 2.0d + 5.0d, highVal);
            g2.draw(line);
            line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,
                                     rectX + rectWidth / 2.0d + 5.0d, lowVal);
            g2.draw(line);
        
        CategoryItemLabelGenerator generator = getItemLabelGenerator(row, 
                column);
        if (generator != null && isItemLabelVisible(row, column)) {
            drawItemLabel(g2, dataset, row, column, plot, generator, bar, 
                    (value < 0.0));
        }        

        // add an item entity, if this information is being collected
        EntityCollection entities = state.getEntityCollection();
        if (entities != null) {"
Cli_1,/home/common/huangzhili/defects4j_buggy/Cli_1_buggy/src/java/org/apache/commons/cli/CommandLine.java,"    public Option[] getOptions()
    {
        Collection processed = options.values();

        // reinitialise array
        Option[] optionsArray = new Option[processed.size()];

        // return the array
        return (Option[]) processed.toArray(optionsArray);
    }
"
Cli_1,/home/common/huangzhili/defects4j_buggy/Cli_1_buggy/src/java/org/apache/commons/cli/CommandLine.java,"    public Iterator iterator()
    {
        return hashcodeMap.values().iterator();
    }
"
Cli_1,/home/common/huangzhili/defects4j_buggy/Cli_1_buggy/src/java/org/apache/commons/cli/CommandLine.java,"    void addOption(Option opt)
    {
        hashcodeMap.put(new Integer(opt.hashCode()), opt);
        String key = opt.getKey();
        if (key == null)
        {
            key = opt.getLongOpt();
        }
        else
        {
            names.put(opt.getLongOpt(), key);
        }
        options.put(key, opt);
    }"
Cli_1,/home/common/huangzhili/defects4j_buggy/Cli_1_buggy/src/java/org/apache/commons/cli/CommandLine.java,"    public Object getOptionObject(String opt)
    {
        String res = getOptionValue(opt);

        if (!options.containsKey(opt))
        {
            return null;
        }

        Object type = ((Option) options.get(opt)).getType();

        return (res == null)        ? null : TypeHandler.createValue(res, type);
    }
"
Cli_1,/home/common/huangzhili/defects4j_buggy/Cli_1_buggy/src/java/org/apache/commons/cli/CommandLine.java,"    public boolean hasOption(String opt)
    {
        return options.containsKey(opt);
    }
"
Cli_1,/home/common/huangzhili/defects4j_buggy/Cli_1_buggy/src/java/org/apache/commons/cli/CommandLine.java,"    private List args = new LinkedList();

    /** the processed options */
    private Map options = new HashMap();
    private Map names = new HashMap();

    /** Map of unique options for ease to get complete list of options */
//    private Set allOptions = new HashSet();
    private Map hashcodeMap = new HashMap();

    /**
"
Cli_1,/home/common/huangzhili/defects4j_buggy/Cli_1_buggy/src/java/org/apache/commons/cli/CommandLine.java,"    public String[] getOptionValues(String opt)
    {
        opt = Util.stripLeadingHyphens(opt);

        String key = opt;
        if (names.containsKey(opt))
        {
            key = (String) names.get(opt);
        }
        if (options.containsKey(key))
        {
            return ((Option) options.get(key)).getValues();
        }

        return null;
        }
"
Cli_2,/home/common/huangzhili/defects4j_buggy/Cli_2_buggy/src/java/org/apache/commons/cli/PosixParser.java,"protected void burstToken(String token, boolean stopAtNonOption)
    {
        int tokenLength = token.length();

        for (int i = 1; i < tokenLength; i++)
        {
            String ch = String.valueOf(token.charAt(i));
            boolean hasOption = options.hasOption(ch);

            if (hasOption)
            {
                tokens.add(""-"" + ch);
                currentOption = options.getOption(ch);

                if (currentOption.hasArg() && (token.length() != (i + 1)))
                {
                    tokens.add(token.substring(i + 1));

                    break;
                }
            }
            else if (stopAtNonOption)
            {
                process(token.substring(i));
            }
            else
            {
                tokens.add(""-"" + ch);
            }
        }
    }
}"
Cli_3,/home/common/huangzhili/defects4j_buggy/Cli_3_buggy/src/java/org/apache/commons/cli/TypeHandler.java,"public static Number createNumber(String str)
     {
         try
         {
             return NumberUtils.createNumber(str);
         }
         catch (NumberFormatException nfe)
         {
            System.err.println(nfe.getMessage());
        }

        return null;
    }"
Cli_7,/home/common/huangzhili/defects4j_buggy/Cli_7_buggy/src/java/org/apache/commons/cli2/builder/PatternBuilder.java,"    public PatternBuilder(
        final GroupBuilder gbuilder,
        final DefaultOptionBuilder obuilder,
        final ArgumentBuilder abuilder) {
        this.gbuilder = gbuilder;
        this.obuilder = obuilder;
        this.abuilder = abuilder;
    }
"
Cli_10,/home/common/huangzhili/defects4j_buggy/Cli_10_buggy/src/java/org/apache/commons/cli/Parser.java,"protected void setOptions(final Options options) {
         this.options = options;
         this.requiredOptions = options.getRequiredOptions();
     }"
Cli_13,/home/common/huangzhili/defects4j_buggy/Cli_13_buggy/src/java/org/apache/commons/cli2/option/ArgumentImpl.java,"public void processValues(final WriteableCommandLine commandLine,
                              final ListIterator arguments,
                               final Option option)
         throws OptionException {
         // count of arguments processed for this option.
         int argumentCount = 0;
 
         while (arguments.hasNext() && (argumentCount < maximum)) {
             final String allValuesQuoted = (String) arguments.next();
            final String allValues = stripBoundaryQuotes(allValuesQuoted);

            // should we ignore things that look like options?
            if (allValuesQuoted.equals(consumeRemaining)) {
                while (arguments.hasNext() && (argumentCount < maximum)) {
                    ++argumentCount;
                    commandLine.addValue(option, arguments.next());
                }
            }
            // does it look like an option?
            else if (commandLine.looksLikeOption(allValuesQuoted)) {
                arguments.previous();

                break;
            }
            // should we split the string up?
            else if (subsequentSplit) {
                final StringTokenizer values =
                    new StringTokenizer(allValues, String.valueOf(subsequentSeparator));

                arguments.remove();

                while (values.hasMoreTokens() && (argumentCount < maximum)) {
                    ++argumentCount;

                    final String token = values.nextToken();
                    commandLine.addValue(option, token);
                    arguments.add(token);
                }

                if (values.hasMoreTokens()) {
                    throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,
                                              values.nextToken());
                }
            }
            // it must be a value as it is
            else {
                ++argumentCount;
                commandLine.addValue(option, allValues);
            }
        }
    }"
Cli_16,/home/common/huangzhili/defects4j_buggy/Cli_16_buggy/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java,"public void addOption(Option option) {
        options.add(option);
        nameToOption.put(option.getPreferredName(), option);

        for (Iterator i = option.getTriggers().iterator(); i.hasNext();) {
            nameToOption.put(i.next(), option);
         }
 
         // ensure that all parent options are also added
     }"
Cli_18,/home/common/huangzhili/defects4j_buggy/Cli_18_buggy/src/java/org/apache/commons/cli/PosixParser.java,"protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)
    {
        init();
        this.options = options;

        // an iterator for the command line tokens
        Iterator iter = Arrays.asList(arguments).iterator();

        // process each command line token
        while (iter.hasNext())
        {
            // get the next command line token
            String token = (String) iter.next();

            // handle SPECIAL TOKEN
            if (token.startsWith(""--""))
            {
                if (token.indexOf('=') != -1)
                {
                    tokens.add(token.substring(0, token.indexOf('=')));
                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));
                }
                else
                {
                    tokens.add(token);
                }
            }

             // single hyphen
             else if (""-"".equals(token))
             {
                 processSingleHyphen(token);
             }
             else if (token.startsWith(""-""))
             {
                if (token.length() == 2)
                {
                    processOptionToken(token, stopAtNonOption);
                }
                else if (options.hasOption(token))
                {
                    tokens.add(token);
                }
                // requires bursting
                else
                {
                    burstToken(token, stopAtNonOption);
                }
            }
            else if (stopAtNonOption)
            {
                process(token);
            }
            else
            {
                tokens.add(token);
            }

            gobble(iter);
        }

        return (String[]) tokens.toArray(new String[tokens.size()]);
    }"
Cli_18,/home/common/huangzhili/defects4j_buggy/Cli_18_buggy/src/java/org/apache/commons/cli/PosixParser.java,"private void processOptionToken(String token, boolean stopAtNonOption)
    {
        if (options.hasOption(token))
        {
            currentOption = options.getOption(token);
            tokens.add(token);
        }
         else if (stopAtNonOption)
         {
             eatTheRest = true;
         }
     }"
Cli_21,/home/common/huangzhili/defects4j_buggy/Cli_21_buggy/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java,"public boolean looksLikeOption(final String trigger)
    {
            // this is a reentrant call

            for (final Iterator i = prefixes.iterator(); i.hasNext();)
            {
                final String prefix = (String) i.next();

                if (trigger.startsWith(prefix))
                {
                        return true;
                }
            }
            return false;
    }

    public String toString() {
        final StringBuffer buffer = new StringBuffer();

        // need to add group header
        for (final Iterator i = normalised.iterator(); i.hasNext();) {
            final String arg = (String) i.next();

            if (arg.indexOf(' ') >= 0) {
                buffer.append(""\"""").append(arg).append(""\"""");
            } else {
                buffer.append(arg);
            }

            if (i.hasNext()) {
                buffer.append(' ');"
Cli_21,/home/common/huangzhili/defects4j_buggy/Cli_21_buggy/src/java/org/apache/commons/cli2/option/GroupImpl.java,"private boolean looksLikeOption(final WriteableCommandLine commandLine,
             final String trigger) {
             return commandLine.looksLikeOption(trigger);
     }"
Cli_22,/home/common/huangzhili/defects4j_buggy/Cli_22_buggy/src/java/org/apache/commons/cli/PosixParser.java,"protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)
    {
        init();
        this.options = options;

        // an iterator for the command line tokens
        Iterator iter = Arrays.asList(arguments).iterator();

        // process each command line token
        while (iter.hasNext())
        {
            // get the next command line token
            String token = (String) iter.next();

            // handle long option --foo or --foo=bar
            if (token.startsWith(""--""))
            {
                int pos = token.indexOf('=');
                String opt = pos == -1 ? token : token.substring(0, pos); // --foo
 
                 if (!options.hasOption(opt))
                 {
                     processNonOptionToken(token);
                 }
                 else
                 {
                     
                     tokens.add(opt);
                     if (pos != -1)
                    {
                        tokens.add(token.substring(pos + 1));
                    }
                }
            }

            // single hyphen
            else if (""-"".equals(token))
            {
                tokens.add(token);
            }
            else if (token.startsWith(""-""))
            {
                if (token.length() == 2 || options.hasOption(token))
                {
                    processOptionToken(token, stopAtNonOption);
                }
                // requires bursting
                else
                {
                    burstToken(token, stopAtNonOption);
                }
            }
            else if (stopAtNonOption)
            {
                processNonOptionToken(token);
            }
            else
            {
                tokens.add(token);
            }

            gobble(iter);
        }

        return (String[]) tokens.toArray(new String[tokens.size()]);
    }"
Cli_22,/home/common/huangzhili/defects4j_buggy/Cli_22_buggy/src/java/org/apache/commons/cli/PosixParser.java,"private void processOptionToken(String token, boolean stopAtNonOption)
    {
        if (stopAtNonOption && !options.hasOption(token))
        {
             eatTheRest = true;
         }
 
 
         tokens.add(token);
     }"
Cli_22,/home/common/huangzhili/defects4j_buggy/Cli_22_buggy/src/java/org/apache/commons/cli/PosixParser.java,"protected void burstToken(String token, boolean stopAtNonOption)
    {
        Option currentOption;
        for (int i = 1; i < token.length(); i++)
        {
            String ch = String.valueOf(token.charAt(i));

            if (options.hasOption(ch))
            {
                tokens.add(""-"" + ch);
                currentOption = options.getOption(ch);

                if (currentOption.hasArg() && (token.length() != (i + 1)))
                {
                    tokens.add(token.substring(i + 1));

                    break;
                }
             }
             else if (stopAtNonOption)
             {
                 processNonOptionToken(token.substring(i));
                 break;
             }
             else
            {
                tokens.add(token);
                break;
            }
        }
    }"
Cli_30,/home/common/huangzhili/defects4j_buggy/Cli_30_buggy/src/main/java/org/apache/commons/cli/DefaultParser.java,"private void handleProperties(Properties properties) throws ParseException
    {
        if (properties == null)
        {
            return;
        }
        
        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)
         {
             String option = e.nextElement().toString();
             
             if (!cmd.hasOption(option))
             {
                 Option opt = options.getOption(option);
             
             // if the option is part of a group, check if another option of the group has been selected
             
                 // get the value from the properties
                 String value = properties.getProperty(option);
                 
                if (opt.hasArg())
                {
                    if (opt.getValues() == null || opt.getValues().length == 0)
                    {
                        opt.addValueForProcessing(value);
                    }
                }
                else if (!(""yes"".equalsIgnoreCase(value)
                        || ""true"".equalsIgnoreCase(value)
                        || ""1"".equalsIgnoreCase(value)))
                {
                    // if the value is not yes, true or 1 then don't add the option to the CommandLine
                    continue;
                }
                
                handleOption(opt);
                currentOption = null;
            }
        }
    }"
Cli_30,/home/common/huangzhili/defects4j_buggy/Cli_30_buggy/src/main/java/org/apache/commons/cli/Parser.java,"protected void processProperties(Properties properties) throws ParseException
    {
        if (properties == null)
        {
            return;
        }

        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)
         {
             String option = e.nextElement().toString();
             
             if (!cmd.hasOption(option))
             {
                 Option opt = getOptions().getOption(option);
             
             // if the option is part of a group, check if another option of the group has been selected
             
                 // get the value from the properties instance
                 String value = properties.getProperty(option);
 
                if (opt.hasArg())
                {
                    if (opt.getValues() == null || opt.getValues().length == 0)
                    {
                        try
                        {
                            opt.addValueForProcessing(value);
                        }
                        catch (RuntimeException exp)
                        {
                            // if we cannot add the value don't worry about it
                        }
                    }
                }
                else if (!(""yes"".equalsIgnoreCase(value)
                        || ""true"".equalsIgnoreCase(value)
                        || ""1"".equalsIgnoreCase(value)))
                {
                    // if the value is not yes, true or 1 then don't add the
                    // option to the CommandLine
                    continue;
                }

                cmd.addOption(opt);
                updateRequiredOptions(opt);
            }
        }
    }"
Cli_31,/home/common/huangzhili/defects4j_buggy/Cli_31_buggy/src/main/java/org/apache/commons/cli/HelpFormatter.java,"private void appendOption(final StringBuffer buff, final Option option, final boolean required)
    {
        if (!required)
        {
            buff.append(""["");
        }

        if (option.getOpt() != null)
        {
            buff.append(""-"").append(option.getOpt());
        }
        else
        {
            buff.append(""--"").append(option.getLongOpt());
         }
         
         // if the Option has a value and a non blank argname
         if (option.hasArg() && option.hasArgName())
         {
             buff.append(option.getOpt() == null ? longOptSeparator : "" "");
             buff.append(""<"").append(option.getArgName()).append("">"");
         }
         
         // if the Option is not a required option
        if (!required)
        {
            buff.append(""]"");
        }
    }"
Cli_31,/home/common/huangzhili/defects4j_buggy/Cli_31_buggy/src/main/java/org/apache/commons/cli/OptionBuilder.java,"private static void reset()
     {
         description = null;
         argName = ""arg"";
         longopt = null;
         type = null;
         required = false;
        numberOfArgs = Option.UNINITIALIZED;
        optionalArg = false;
        valuesep = (char) 0;
    }"
Cli_33,/home/common/huangzhili/defects4j_buggy/Cli_33_buggy/src/main/java/org/apache/commons/cli/HelpFormatter.java,"public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)
     {
         StringBuffer sb = new StringBuffer(text.length());
 
         renderWrappedText(sb, width, nextLineTabStop, text);
         pw.println(sb.toString());
     }"
Cli_34,/home/common/huangzhili/defects4j_buggy/Cli_34_buggy/src/main/java/org/apache/commons/cli/OptionBuilder.java,"private static void reset()
    {
         description = null;
         argName = null;
         longopt = null;
         type = null;
         required = false;
         numberOfArgs = Option.UNINITIALIZED;
         optionalArg = false;
        valuesep = (char) 0;
    }"
Cli_36,/home/common/huangzhili/defects4j_buggy/Cli_36_buggy/src/main/java/org/apache/commons/cli/Options.java,"    private final List<Object> requiredOpts = new ArrayList<Object>();

    /** a map of the option groups */
    private final Map<String, OptionGroup> optionGroups = new java.util.HashMap<String, OptionGroup>();

    /**
"
Cli_36,/home/common/huangzhili/defects4j_buggy/Cli_36_buggy/src/main/java/org/apache/commons/cli/OptionGroup.java,"    private final Map<String, Option> optionMap = new HashMap<String, Option>();

    /** the name of the selected option */
    private String selected;

    /** specified whether this group is required */
    private boolean required;

    /**
"
Cli_39,/home/common/huangzhili/defects4j_buggy/Cli_39_buggy/src/main/java/org/apache/commons/cli/TypeHandler.java,"public static Object createValue(final String str, final Class<?> clazz) throws ParseException
    {
        if (PatternOptionBuilder.STRING_VALUE == clazz)
        {
            return str;
        }
        else if (PatternOptionBuilder.OBJECT_VALUE == clazz)
        {
            return createObject(str);
        }
        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)
        {
            return createNumber(str);
        }
        else if (PatternOptionBuilder.DATE_VALUE == clazz)
        {
            return createDate(str);
        }
        else if (PatternOptionBuilder.CLASS_VALUE == clazz)
        {
            return createClass(str);
        }
        else if (PatternOptionBuilder.FILE_VALUE == clazz)
        {
            return createFile(str);
         }
         else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)
         {
             return createFile(str);
         }
         else if (PatternOptionBuilder.FILES_VALUE == clazz)
         {
            return createFiles(str);
        }
        else if (PatternOptionBuilder.URL_VALUE == clazz)
        {
            return createURL(str);
        }
        else
        {
            return null;
        }
    }"
Closure_3,/home/common/huangzhili/defects4j_buggy/Closure_3_buggy/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java,"private boolean canInline() {
      // Cannot inline a parameter.
      if (getDefCfgNode().isFunction()) {
        return false;
      }

      // If one of our dependencies has been inlined, then our dependency
      // graph is wrong. Re-computing it would take another CFG computation,
      // so we just back off for now.
      for (Var dependency : defMetadata.depends) {
        if (inlinedNewDependencies.contains(dependency)) {
          return false;
        }
      }

      getDefinition(getDefCfgNode(), null);
      getNumUseInUseCfgNode(useCfgNode, null);

      // Definition was not found.
      if (def == null) {
        return false;
      }

      // Check that the assignment isn't used as a R-Value.
      // TODO(user): Certain cases we can still inline.
      if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {
        return false;
      }

      // The right of the definition has side effect:
      // Example, for x:
      // x = readProp(b), modifyProp(b); print(x);
      if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {
        return false;
      }

      // Similar check as the above but this time, all the sub-expressions
      // left of the use of the variable.
      // x = readProp(b); modifyProp(b), print(x);
      if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {
        return false;
      }

      // TODO(user): Side-effect is OK sometimes. As long as there are no
      // side-effect function down all paths to the use. Once we have all the
      // side-effect analysis tool.
      if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {
        return false;
      }

      // TODO(user): We could inline all the uses if the expression is short.

      // Finally we have to make sure that there are no more than one use
      // in the program and in the CFG node. Even when it is semantically
      // correctly inlining twice increases code size.
      if (numUseWithinUseCfgNode != 1) {
        return false;
      }

      // Make sure that the name is not within a loop
      if (NodeUtil.isWithinLoop(use)) {
        return false;
      }


      Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());

      if (uses.size() != 1) {
        return false;
      }

      // We give up inlining stuff with R-Value that has:
      // 1) GETPROP, GETELEM,
      // 2) anything that creates a new object.
      // 3) a direct reference to a catch expression.
      // Example:
      // var x = a.b.c; j.c = 1; print(x);
      // Inlining print(a.b.c) is not safe consider j and be alias to a.b.
      // TODO(user): We could get more accuracy by looking more in-detail
      // what j is and what x is trying to into to.
      // TODO(johnlenz): rework catch expression handling when we
      // have lexical scope support so catch expressions don't
      // need to be special cased.
      if (NodeUtil.has(def.getLastChild(),
          new Predicate<Node>() {
              @Override
              public boolean apply(Node input) {
                switch (input.getType()) {
                  case Token.GETELEM:
                  case Token.GETPROP:
                  case Token.ARRAYLIT:
                  case Token.OBJECTLIT:
                   case Token.REGEXP:
                   case Token.NEW:
                     return true;
                 }
                 return false;
               }
          },
          new Predicate<Node>() {
              @Override
              public boolean apply(Node input) {
                // Recurse if the node is not a function.
                return !input.isFunction();
              }
          })) {
        return false;
      }

      // We can skip the side effect check along the paths of two nodes if
      // they are just next to each other.
      if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&
          getDefCfgNode().getNext() != useCfgNode) {
        // Similar side effect check as above but this time the side effect is
        // else where along the path.
        // x = readProp(b); while(modifyProp(b)) {}; print(x);
        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>
          pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(
                 cfg,
                 cfg.getDirectedGraphNode(getDefCfgNode()),
                 cfg.getDirectedGraphNode(useCfgNode),
                 SIDE_EFFECT_PREDICATE,
                 Predicates.
                     <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),
                 false);
        if (pathCheck.somePathsSatisfyPredicate()) {
          return false;
        }
      }

      return true;
    }"
Closure_3,/home/common/huangzhili/defects4j_buggy/Closure_3_buggy/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java,"@Override
  public void enterScope(NodeTraversal t) {

    if (t.inGlobalScope()) {
      return; // Don't even brother. All global variables are likely escaped.
    }

    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <
        t.getScope().getVarCount()) {
      return;
    }

    // Compute the forward reaching definition.
    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);
    // Process the body of the function.
    Preconditions.checkState(t.getScopeRoot().isFunction());
    cfa.process(null, t.getScopeRoot().getLastChild());
    cfg = cfa.getCfg();
    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);
    reachingDef.analyze();
    candidates = Lists.newLinkedList();

    // Using the forward reaching definition search to find all the inline
    // candidates
    new NodeTraversal(compiler, new GatherCandiates()).traverse(
        t.getScopeRoot().getLastChild());

    // Compute the backward reaching use. The CFG can be reused.
     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);
     reachingUses.analyze();
     for (Candidate c : candidates) {
       if (c.canInline()) {
         c.inlineVariable();
 
         // If definition c has dependencies, then inlining it may have
        // introduced new dependencies for our other inlining candidates.
        //
        // MustBeReachingVariableDef uses this dependency graph in its
        // analysis, so some of these candidates may no longer be valid.
        // We keep track of when the variable dependency graph changed
        // so that we can back off appropriately.
        if (!c.defMetadata.depends.isEmpty()) {
          inlinedNewDependencies.add(t.getScope().getVar(c.varName));
        }
      }
    }
  }"
Closure_6,/home/common/huangzhili/defects4j_buggy/Closure_6_buggy/src/com/google/javascript/jscomp/TypeValidator.java,"boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,
       JSType leftType, Node owner, String propName) {
     // The NoType check is a hack to make typedefs work OK.
     if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {
       if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
         registerMismatch(rightType, leftType, null);
       } else {
       // Do not type-check interface methods, because we expect that
       // they will have dummy implementations that do not match the type
       // annotations.
      JSType ownerType = getJSType(owner);
      if (ownerType.isFunctionPrototypeType()) {
        FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();
        if (ownerFn.isInterface() &&
            rightType.isFunctionType() && leftType.isFunctionType()) {
          return true;
        }
      }

      mismatch(t, n,
          ""assignment to property "" + propName + "" of "" +
          getReadableJSTypeName(owner, true),
          rightType, leftType);
      }
      return false;
    }
    return true;
  }"
Closure_6,/home/common/huangzhili/defects4j_buggy/Closure_6_buggy/src/com/google/javascript/jscomp/TypeValidator.java,"boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,
       JSType leftType, String msg) {
     if (!rightType.canAssignTo(leftType)) {
       if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
         registerMismatch(rightType, leftType, null);
       } else {
       mismatch(t, n, msg, rightType, leftType);
       }
       return false;
     }
     return true;
  }"
Closure_8,/home/common/huangzhili/defects4j_buggy/Closure_8_buggy/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java,"    private boolean canBeRedeclared(Node n, Scope s) {
      if (!NodeUtil.isExprAssign(n)) {
        return false;
      }
      Node assign = n.getFirstChild();
      Node lhs = assign.getFirstChild();

      if (!lhs.isName()) {
        return false;
      }

      Var var = s.getVar(lhs.getString());
      return var != null
          && var.getScope() == s
          && !blacklistedVars.contains(var);
    }
"
Closure_9,/home/common/huangzhili/defects4j_buggy/Closure_9_buggy/src/com/google/javascript/jscomp/ProcessCommonJSModules.java,"private void visitScript(NodeTraversal t, Node script) {
       Preconditions.checkArgument(scriptNodeCount == 1,
           ""ProcessCommonJSModules supports only one invocation per "" +
           ""CompilerInput / script node"");
       String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));
       script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())
           .copyInformationFromForTree(script));
       if (reportDependencies) {
        CompilerInput ci = t.getInput();
        ci.addProvide(moduleName);
        JSModule m = new JSModule(moduleName);
        m.addAndOverrideModule(ci);
        module = m;
      }
      script.addChildToFront(IR.exprResult(
          IR.call(IR.getprop(IR.name(""goog""), IR.string(""provide"")),
              IR.string(moduleName))).copyInformationFromForTree(script));

      emitOptionalModuleExportsOverride(script, moduleName);

      // Rename vars to not conflict in global scope.
      NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(
          moduleName));

      compiler.reportCodeChange();
    }"
Closure_9,/home/common/huangzhili/defects4j_buggy/Closure_9_buggy/src/com/google/javascript/jscomp/ProcessCommonJSModules.java,"private String normalizeSourceName(String filename) {
     // The DOS command shell will normalize ""/"" to ""\"", so we have to
     // wrestle it back.
 
     if (filename.indexOf(filenamePrefix) == 0) {
       filename = filename.substring(filenamePrefix.length());
    }

    return filename;
  }"
Closure_16,/home/common/huangzhili/defects4j_buggy/Closure_16_buggy/src/com/google/javascript/jscomp/ScopedAliases.java,"private void fixTypeNode(Node typeNode) {
      if (typeNode.isString()) {
        String name = typeNode.getString();
        int endIndex = name.indexOf('.');
        if (endIndex == -1) {
          endIndex = name.length();
        }
        String baseName = name.substring(0, endIndex);
         Var aliasVar = aliases.get(baseName);
         if (aliasVar != null) {
           Node aliasedNode = aliasVar.getInitialValue();
           aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));
         }
       }
 
      for (Node child = typeNode.getFirstChild(); child != null;
           child = child.getNext()) {
        fixTypeNode(child);
      }
    }"
Closure_26,/home/common/huangzhili/defects4j_buggy/Closure_26_buggy/src/com/google/javascript/jscomp/ProcessCommonJSModules.java,"private void emitOptionalModuleExportsOverride(Node script,
         String moduleName) {
 
       Node moduleExportsProp = IR.getprop(IR.name(moduleName),
           IR.string(""module$exports""));
      script.addChildToBack(IR.ifNode(
          moduleExportsProp,
          IR.block(IR.exprResult(IR.assign(IR.name(moduleName),
              moduleExportsProp.cloneTree())))).copyInformationFromForTree(
          script));
    }"
Closure_26,/home/common/huangzhili/defects4j_buggy/Closure_26_buggy/src/com/google/javascript/jscomp/ProcessCommonJSModules.java,"private void visitModuleExports(Node prop) {
      String moduleName = guessCJSModuleName(prop.getSourceFileName());
      Node module = prop.getChildAtIndex(0);
      module.putProp(Node.ORIGINALNAME_PROP, ""module"");
      module.setString(moduleName);
       Node exports = prop.getChildAtIndex(1);
       exports.putProp(Node.ORIGINALNAME_PROP, ""exports"");
       exports.setString(""module$exports"");
     }"
Closure_27,/home/common/huangzhili/defects4j_buggy/Closure_27_buggy/src/com/google/javascript/rhino/IR.java,"public static Node tryCatch(Node tryBody, Node catchNode) {
     Preconditions.checkState(tryBody.isBlock());
     Preconditions.checkState(catchNode.isCatch());
     Node catchBody = block(catchNode).copyInformationFrom(catchNode);
     return new Node(Token.TRY, tryBody, catchBody);
   }"
Closure_28,/home/common/huangzhili/defects4j_buggy/Closure_28_buggy/src/com/google/javascript/jscomp/InlineCostEstimator.java,"/*
 * Copyright 2008 The Closure Compiler Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.javascript.jscomp;

import com.google.javascript.rhino.Node;

/**
 * For use with CodeGenerator to determine the cost of generated code.
 *
 * @see CodeGenerator
 * @see CodePrinter
 */
class InlineCostEstimator {
  // For now simply assume identifiers are 2 characters.
  private static final String ESTIMATED_IDENTIFIER = ""ab"";
  static final int ESTIMATED_IDENTIFIER_COST = ESTIMATED_IDENTIFIER.length();

  private InlineCostEstimator() {
  }

  /**
   * Determines the size of the js code.
   */
  static int getCost(Node root) {
    return getCost(root, Integer.MAX_VALUE);
  }

  /**
   * Determines the estimated size of the js snippet represented by the node.
   */
  static int getCost(Node root, int costThreshhold) {
    CompiledSizeEstimator estimator = new CompiledSizeEstimator(costThreshhold);
    estimator.add(root);
    return estimator.getCost();
  }

  /**
   * Code consumer that estimates compiled size by assuming names are
   * shortened and all whitespace is stripped.
   */
  private static class CompiledSizeEstimator extends CodeConsumer {
    private int maxCost;
    private int cost = 0;
    private char last = '\0';
    private boolean continueProcessing = true;

    CompiledSizeEstimator(int costThreshhold) {
      this.maxCost = costThreshhold;
    }

    void add(Node root) {
      CodeGenerator cg = new CodeGenerator(this);
      cg.add(root);
    }

    int getCost() {
      return cost;
    }

    @Override
    boolean continueProcessing() {
      return continueProcessing;
    }

    @Override
    char getLastChar() {
      return last;
    }

    @Override
    void append(String str){
      last = str.charAt(str.length() - 1);
      cost += str.length();
      if (maxCost <= cost) {
        continueProcessing = false;
      }
    }

    @Override
    void addIdentifier(String identifier) {
      add(ESTIMATED_IDENTIFIER);
    }

    /**
     * Constants (true, false, null) are considered basically free,
     * because it's likely that they will get folded when we're done.
     */
  }
}
"
Closure_30,/home/common/huangzhili/defects4j_buggy/Closure_30_buggy/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java,"boolean dependsOnOuterScopeVars(String name, Node useNode) {
    Preconditions.checkArgument(getCfg().hasNode(useNode));
     GraphNode<Node, Branch> n = getCfg().getNode(useNode);
     FlowState<MustDef> state = n.getAnnotation();
     Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));
 
     for (Var s : def.depends) {
       if (s.scope != jsScope) {
        return true;
      }
    }
    return false;
  }"
Closure_34,/home/common/huangzhili/defects4j_buggy/Closure_34_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"private void unrollBinaryOperator(
      Node n, int op, String opStr, Context context,
      Context rhsContext, int leftPrecedence, int rightPrecedence) {
    Node firstNonOperator = n.getFirstChild();
    while (firstNonOperator.getType() == op) {
      firstNonOperator = firstNonOperator.getFirstChild();
    }

    addExpr(firstNonOperator, leftPrecedence, context);

     Node current = firstNonOperator;
     do {
       current = current.getParent();
       cc.listSeparator();
       addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);
     } while (current != n);
   }"
Closure_34,/home/common/huangzhili/defects4j_buggy/Closure_34_buggy/src/com/google/javascript/jscomp/CodePrinter.java,"@Override
     void appendOp(String op, boolean binOp) {
       if (binOp) {
         if (getLastChar() != ' ') {
           append("" "");
         }
         append(op);
        append("" "");
      } else {
        append(op);
      }
    }"
Closure_34,/home/common/huangzhili/defects4j_buggy/Closure_34_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
      return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    // Handle all binary operators
    if (opstr != null && first != last) {
      Preconditions.checkState(
          childCount == 2,
          ""Bad binary operator \""%s\"": expected 2 arguments but got %s"",
          opstr, childCount);
      int p = NodeUtil.precedence(type);

      // For right-hand-side of operations, only pass context if it's
      // the IN_FOR_INIT_CLAUSE one.
      Context rhsContext = getContextForNoInOperator(context);

      // Handle associativity.
      // e.g. if the parse tree is a * (b * c),
      // we can simply generate a * b * c.
      if (last.getType() == type &&
          NodeUtil.isAssociative(type)) {
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p, rhsContext);
      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
        // Assignments are the only right-associative binary operators
        addExpr(first, p, context);
         cc.addOp(opstr, true);
         addExpr(last, p, rhsContext);
       } else {
         addExpr(first, p, context);
         cc.addOp(opstr, true);
         addExpr(last, p + 1, rhsContext);
       }
       return;
     }

    cc.startSourceMapping(n);

    switch (type) {
      case Token.TRY: {
        Preconditions.checkState(first.getNext().isBlock() &&
                !first.getNext().hasMoreThanOneChild());
        Preconditions.checkState(childCount >= 2 && childCount <= 3);

        add(""try"");
        add(first, Context.PRESERVE_BLOCK);

        // second child contains the catch block, or nothing if there
        // isn't a catch block
        Node catchblock = first.getNext().getFirstChild();
        if (catchblock != null) {
          add(catchblock);
        }

        if (childCount == 3) {
          add(""finally"");
          add(last, Context.PRESERVE_BLOCK);
        }
        break;
      }

      case Token.CATCH:
        Preconditions.checkState(childCount == 2);
        add(""catch("");
        add(first);
        add("")"");
        add(last, Context.PRESERVE_BLOCK);
        break;

      case Token.THROW:
        Preconditions.checkState(childCount == 1);
        add(""throw"");
        add(first);

        // Must have a ';' after a throw statement, otherwise safari can't
        // parse this.
        cc.endStatement(true);
        break;

      case Token.RETURN:
        add(""return"");
        if (childCount == 1) {
          add(first);
        } else {
          Preconditions.checkState(childCount == 0);
        }
        cc.endStatement();
        break;

      case Token.VAR:
        if (first != null) {
          add(""var "");
          addList(first, false, getContextForNoInOperator(context));
        }
        break;

      case Token.LABEL_NAME:
        Preconditions.checkState(!n.getString().isEmpty());
        addIdentifier(n.getString());
        break;

      case Token.NAME:
        if (first == null || first.isEmpty()) {
          addIdentifier(n.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          addIdentifier(n.getString());
          cc.addOp(""="", true);
          if (first.isComma()) {
            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
          } else {
            // Add expression, consider nearby code at lowest level of
            // precedence.
            addExpr(first, 0, getContextForNoInOperator(context));
          }
        }
        break;

      case Token.ARRAYLIT:
        add(""["");
        addArrayList(first);
        add(""]"");
        break;

      case Token.PARAM_LIST:
        add(""("");
        addList(first);
        add("")"");
        break;

      case Token.COMMA:
        Preconditions.checkState(childCount == 2);
        unrollBinaryOperator(n, Token.COMMA, "","", context, Context.OTHER, 0, 0);
        break;

      case Token.NUMBER:
        Preconditions.checkState(childCount == 0);
        cc.addNumber(n.getDouble());
        break;

      case Token.TYPEOF:
      case Token.VOID:
      case Token.NOT:
      case Token.BITNOT:
      case Token.POS: {
        // All of these unary operators are right-associative
        Preconditions.checkState(childCount == 1);
        cc.addOp(NodeUtil.opToStrNoFail(type), false);
        addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        break;
      }

      case Token.NEG: {
        Preconditions.checkState(childCount == 1);

        // It's important to our sanity checker that the code
        // we print produces the same AST as the code we parse back.
        // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
        if (n.getFirstChild().isNumber()) {
          cc.addNumber(-n.getFirstChild().getDouble());
        } else {
          cc.addOp(NodeUtil.opToStrNoFail(type), false);
          addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        }

        break;
      }

      case Token.HOOK: {
        Preconditions.checkState(childCount == 3);
        int p = NodeUtil.precedence(type);
        addExpr(first, p + 1, context);
        cc.addOp(""?"", true);
        addExpr(first.getNext(), 1, Context.OTHER);
        cc.addOp("":"", true);
        addExpr(last, 1, Context.OTHER);
        break;
      }

      case Token.REGEXP:
        if (!first.isString() ||
            !last.isString()) {
          throw new Error(""Expected children to be strings"");
        }

        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);

        // I only use one .add because whitespace matters
        if (childCount == 2) {
          add(regexp + last.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          add(regexp);
        }
        break;

      case Token.FUNCTION:
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        Preconditions.checkState(childCount == 3);
        boolean funcNeedsParens = (context == Context.START_OF_EXPR);
        if (funcNeedsParens) {
          add(""("");
        }

        add(""function"");
        add(first);

        add(first.getNext());
        add(last, Context.PRESERVE_BLOCK);
        cc.endFunction(context == Context.STATEMENT);

        if (funcNeedsParens) {
          add("")"");
        }
        break;

      case Token.GETTER_DEF:
      case Token.SETTER_DEF:
        Preconditions.checkState(n.getParent().isObjectLit());
        Preconditions.checkState(childCount == 1);
        Preconditions.checkState(first.isFunction());

        // Get methods are unnamed
        Preconditions.checkState(first.getFirstChild().getString().isEmpty());
        if (type == Token.GETTER_DEF) {
          // Get methods have no parameters.
          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
          add(""get "");
        } else {
          // Set methods have one parameter.
          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
          add(""set "");
        }

        // The name is on the GET or SET node.
        String name = n.getString();
        Node fn = first;
        Node parameters = fn.getChildAtIndex(1);
        Node body = fn.getLastChild();

        // Add the property name.
        if (!n.isQuotedString() &&
            TokenStream.isJSIdentifier(name) &&
            // do not encode literally any non-literal characters that were
            // unicode escaped.
            NodeUtil.isLatin(name)) {
          add(name);
        } else {
          // Determine if the string is a simple number.
          double d = getSimpleNumber(name);
          if (!Double.isNaN(d)) {
            cc.addNumber(d);
          } else {
            addJsString(n);
          }
        }

        add(parameters);
        add(body, Context.PRESERVE_BLOCK);
        break;

      case Token.SCRIPT:
      case Token.BLOCK: {
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        boolean preserveBlock = context == Context.PRESERVE_BLOCK;
        if (preserveBlock) {
          cc.beginBlock();
        }

        boolean preferLineBreaks =
            type == Token.SCRIPT ||
            (type == Token.BLOCK &&
                !preserveBlock &&
                n.getParent() != null &&
                n.getParent().isScript());
        for (Node c = first; c != null; c = c.getNext()) {
          add(c, Context.STATEMENT);

          // VAR doesn't include ';' since it gets used in expressions
          if (c.isVar()) {
            cc.endStatement();
          }

          if (c.isFunction()) {
            cc.maybeLineBreak();
          }

          // Prefer to break lines in between top-level statements
          // because top level statements are more homogeneous.
          if (preferLineBreaks) {
            cc.notePreferredLineBreak();
          }
        }
        if (preserveBlock) {
          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
        }
        break;
      }

      case Token.FOR:
        if (childCount == 4) {
          add(""for("");
          if (first.isVar()) {
            add(first, Context.IN_FOR_INIT_CLAUSE);
          } else {
            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
          }
          add("";"");
          add(first.getNext());
          add("";"");
          add(first.getNext().getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          Preconditions.checkState(childCount == 3);
          add(""for("");
          add(first);
          add(""in"");
          add(first.getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        }
        break;

      case Token.DO:
        Preconditions.checkState(childCount == 2);
        add(""do"");
        addNonEmptyStatement(first, Context.OTHER, false);
        add(""while("");
        add(last);
        add("")"");
        cc.endStatement();
        break;

      case Token.WHILE:
        Preconditions.checkState(childCount == 2);
        add(""while("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.EMPTY:
        Preconditions.checkState(childCount == 0);
        break;

      case Token.GETPROP: {
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETPROP: expected 2 children, but got %s"", childCount);
        Preconditions.checkState(
            last.isString(),
            ""Bad GETPROP: RHS should be STRING"");
        boolean needsParens = (first.isNumber());
        if (needsParens) {
          add(""("");
        }
        addExpr(first, NodeUtil.precedence(type), context);
        if (needsParens) {
          add("")"");
        }
        add(""."");
        addIdentifier(last.getString());
        break;
      }

      case Token.GETELEM:
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETELEM: expected 2 children but got %s"", childCount);
        addExpr(first, NodeUtil.precedence(type), context);
        add(""["");
        add(first.getNext());
        add(""]"");
        break;

      case Token.WITH:
        Preconditions.checkState(childCount == 2);
        add(""with("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.INC:
      case Token.DEC: {
        Preconditions.checkState(childCount == 1);
        String o = type == Token.INC ? ""++"" : ""--"";
        int postProp = n.getIntProp(Node.INCRDECR_PROP);
        // A non-zero post-prop value indicates a post inc/dec, default of zero
        // is a pre-inc/dec.
        if (postProp != 0) {
          addExpr(first, NodeUtil.precedence(type), context);
          cc.addOp(o, false);
        } else {
          cc.addOp(o, false);
          add(first);
        }
        break;
      }

      case Token.CALL:
        // We have two special cases here:
        // 1) If the left hand side of the call is a direct reference to eval,
        // then it must have a DIRECT_EVAL annotation. If it does not, then
        // that means it was originally an indirect call to eval, and that
        // indirectness must be preserved.
        // 2) If the left hand side of the call is a property reference,
        // then the call must not a FREE_CALL annotation. If it does, then
        // that means it was originally an call without an explicit this and
        // that must be preserved.
        if (isIndirectEval(first)
            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
          add(""(0,"");
          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
          add("")"");
        } else {
          addExpr(first, NodeUtil.precedence(type), context);
        }
        add(""("");
        addList(first.getNext());
        add("")"");
        break;

      case Token.IF:
        boolean hasElse = childCount == 3;
        boolean ambiguousElseClause =
            context == Context.BEFORE_DANGLING_ELSE && !hasElse;
        if (ambiguousElseClause) {
          cc.beginBlock();
        }

        add(""if("");
        add(first);
        add("")"");

        if (hasElse) {
          addNonEmptyStatement(
              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
          add(""else"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          addNonEmptyStatement(first.getNext(), Context.OTHER, false);
          Preconditions.checkState(childCount == 2);
        }

        if (ambiguousElseClause) {
          cc.endBlock();
        }
        break;

      case Token.NULL:
        Preconditions.checkState(childCount == 0);
        add(""null"");
        break;

      case Token.THIS:
        Preconditions.checkState(childCount == 0);
        add(""this"");
        break;

      case Token.FALSE:
        Preconditions.checkState(childCount == 0);
        add(""false"");
        break;

      case Token.TRUE:
        Preconditions.checkState(childCount == 0);
        add(""true"");
        break;

      case Token.CONTINUE:
        Preconditions.checkState(childCount <= 1);
        add(""continue"");
        if (childCount == 1) {
          if (!first.isLabelName()) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.DEBUGGER:
        Preconditions.checkState(childCount == 0);
        add(""debugger"");
        cc.endStatement();
        break;

      case Token.BREAK:
        Preconditions.checkState(childCount <= 1);
        add(""break"");
        if (childCount == 1) {
          if (!first.isLabelName()) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.EXPR_RESULT:
        Preconditions.checkState(childCount == 1);
        add(first, Context.START_OF_EXPR);
        cc.endStatement();
        break;

      case Token.NEW:
        add(""new "");
        int precedence = NodeUtil.precedence(type);

        // If the first child contains a CALL, then claim higher precedence
        // to force parentheses. Otherwise, when parsed, NEW will bind to the
        // first viable parentheses (don't traverse into functions).
        if (NodeUtil.containsType(
            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
          precedence = NodeUtil.precedence(first.getType()) + 1;
        }
        addExpr(first, precedence, Context.OTHER);

        // '()' is optional when no arguments are present
        Node next = first.getNext();
        if (next != null) {
          add(""("");
          addList(next);
          add("")"");
        }
        break;

      case Token.STRING:
        if (childCount !=
            ((n.getParent() != null &&
              n.getParent().isObjectLit()) ? 1 : 0)) {
          throw new IllegalStateException(
              ""Unexpected String children: "" + n.getParent().toStringTree());
        }
        addJsString(n);
        break;

      case Token.DELPROP:
        Preconditions.checkState(childCount == 1);
        add(""delete "");
        add(first);
        break;

      case Token.OBJECTLIT: {
        boolean needsParens = (context == Context.START_OF_EXPR);
        if (needsParens) {
          add(""("");
        }
        add(""{"");
        for (Node c = first; c != null; c = c.getNext()) {
          if (c != first) {
            cc.listSeparator();
          }

          if (c.isGetterDef() || c.isSetterDef()) {
            add(c);
          } else {
            Preconditions.checkState(c.isString());
            String key = c.getString();
            // Object literal property names don't have to be quoted if they
            // are not JavaScript keywords
            if (!c.isQuotedString() &&
                !TokenStream.isKeyword(key) &&
                TokenStream.isJSIdentifier(key) &&
                // do not encode literally any non-literal characters that
                // were unicode escaped.
                NodeUtil.isLatin(key)) {
              add(key);
            } else {
              // Determine if the string is a simple number.
              double d = getSimpleNumber(key);
              if (!Double.isNaN(d)) {
                cc.addNumber(d);
              } else {
                addExpr(c, 1, Context.OTHER);
              }
            }
            add("":"");
            addExpr(c.getFirstChild(), 1, Context.OTHER);
          }
        }
        add(""}"");
        if (needsParens) {
          add("")"");
        }
        break;
      }

      case Token.SWITCH:
        add(""switch("");
        add(first);
        add("")"");
        cc.beginBlock();
        addAllSiblings(first.getNext());
        cc.endBlock(context == Context.STATEMENT);
        break;

      case Token.CASE:
        Preconditions.checkState(childCount == 2);
        add(""case "");
        add(first);
        addCaseBody(last);
        break;

      case Token.DEFAULT_CASE:
        Preconditions.checkState(childCount == 1);
        add(""default"");
        addCaseBody(first);
        break;

      case Token.LABEL:
        Preconditions.checkState(childCount == 2);
        if (!first.isLabelName()) {
          throw new Error(""Unexpected token type. Should be LABEL_NAME."");
        }
        add(first);
        add("":"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), true);
        break;

      default:
        throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }

    cc.endSourceMapping(n);
  }"
Closure_37,/home/common/huangzhili/defects4j_buggy/Closure_37_buggy/src/com/google/javascript/jscomp/parsing/IRFactory.java,"@Override
    Node processFunctionNode(FunctionNode functionNode) {
      Name name = functionNode.getFunctionName();
      Boolean isUnnamedFunction = false;
      if (name == null) {
        int functionType = functionNode.getFunctionType();
        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
          errorReporter.error(
            ""unnamed function statement"",
            sourceName,
            functionNode.getLineno(), """", 0);

          // Return the bare minimum to put the AST in a valid state.
          return newNode(Token.EXPR_RESULT, Node.newNumber(0));
        }
        name = new Name();
        name.setIdentifier("""");
        isUnnamedFunction = true;
      }
      Node node = newNode(Token.FUNCTION);
      Node newName = transform(name);
      if (isUnnamedFunction) {
        // Old Rhino tagged the empty name node with the line number of the
        // declaration.
        newName.setLineno(functionNode.getLineno());
        // TODO(bowdidge) Mark line number of paren correctly.
        // Same problem as below - the left paren might not be on the
        // same line as the function keyword.
        int lpColumn = functionNode.getAbsolutePosition() +
            functionNode.getLp();
        newName.setCharno(position2charno(lpColumn));
        maybeSetLengthFrom(newName, name);
      }

      node.addChildToBack(newName);
      Node lp = newNode(Token.PARAM_LIST);
      // The left paren's complicated because it's not represented by an
      // AstNode, so there's nothing that has the actual line number that it
      // appeared on.  We know the paren has to appear on the same line as the
      // function name (or else a semicolon will be inserted.)  If there's no
      // function name, assume the paren was on the same line as the function.
      // TODO(bowdidge): Mark line number of paren correctly.
      Name fnName = functionNode.getFunctionName();
      if (fnName != null) {
        lp.setLineno(fnName.getLineno());
      } else {
        lp.setLineno(functionNode.getLineno());
      }
      int lparenCharno = functionNode.getLp() +
          functionNode.getAbsolutePosition();

      lp.setCharno(position2charno(lparenCharno));
      for (AstNode param : functionNode.getParams()) {
        lp.addChildToBack(transform(param));
      }
       node.addChildToBack(lp);
 
       Node bodyNode = transform(functionNode.getBody());
         // When in ideMode Rhino tries to parse some constructs the compiler
         // doesn't support, repair it here. see Rhino's
         // Parser#parseFunctionBodyExpr.
       parseDirectives(bodyNode);
       node.addChildToBack(bodyNode);
      return node;
    }"
Closure_37,/home/common/huangzhili/defects4j_buggy/Closure_37_buggy/src/com/google/javascript/jscomp/NodeTraversal.java,"private void traverseFunction(Node n, Node parent) {
    Preconditions.checkState(n.getChildCount() == 3);
    Preconditions.checkState(n.isFunction());

    final Node fnName = n.getFirstChild();

    boolean isFunctionExpression = (parent != null)
        && NodeUtil.isFunctionExpression(n);

    if (!isFunctionExpression) {
      // Functions declarations are in the scope containing the declaration.
      traverseBranch(fnName, n);
    }

    curNode = n;
    pushScope(n);

    if (isFunctionExpression) {
      // Function expression names are only accessible within the function
      // scope.
      traverseBranch(fnName, n);
    }

    final Node args = fnName.getNext();
    final Node body = args.getNext();

    // Args
    traverseBranch(args, n);
 
     // Body
     Preconditions.checkState(body.getNext() == null &&
             body.isBlock());
     traverseBranch(body, n);
 
     popScope();
  }"
Closure_41,/home/common/huangzhili/defects4j_buggy/Closure_41_buggy/src/com/google/javascript/jscomp/FunctionTypeBuilder.java,"FunctionTypeBuilder inferFromOverriddenFunction(
      @Nullable FunctionType oldType, @Nullable Node paramsParent) {
    if (oldType == null) {
      return this;
    }

    returnType = oldType.getReturnType();
    returnTypeInferred = oldType.isReturnTypeInferred();
    if (paramsParent == null) {
      // Not a function literal.
      parametersNode = oldType.getParametersNode();
      if (parametersNode == null) {
        parametersNode = new FunctionParamBuilder(typeRegistry).build();
      }
    } else {
      // We're overriding with a function literal. Apply type information
      // to each parameter of the literal.
      FunctionParamBuilder paramBuilder =
          new FunctionParamBuilder(typeRegistry);
      Iterator<Node> oldParams = oldType.getParameters().iterator();
      boolean warnedAboutArgList = false;
      boolean oldParamsListHitOptArgs = false;
      for (Node currentParam = paramsParent.getFirstChild();
           currentParam != null; currentParam = currentParam.getNext()) {
        if (oldParams.hasNext()) {
          Node oldParam = oldParams.next();
          Node newParam = paramBuilder.newParameterFromNode(oldParam);

          oldParamsListHitOptArgs = oldParamsListHitOptArgs ||
              oldParam.isVarArgs() ||
              oldParam.isOptionalArg();

          // The subclass method might write its var_args as individual
          // arguments.
          if (currentParam.getNext() != null && newParam.isVarArgs()) {
            newParam.setVarArgs(false);
            newParam.setOptionalArg(true);
          }
        } else {
          warnedAboutArgList |= addParameter(
              paramBuilder,
              typeRegistry.getNativeType(UNKNOWN_TYPE),
              warnedAboutArgList,
              codingConvention.isOptionalParameter(currentParam) ||
                  oldParamsListHitOptArgs,
              codingConvention.isVarArgsParameter(currentParam));
        }
       }
 
       // Clone any remaining params that aren't in the function literal.
 
       parametersNode = paramBuilder.build();
     }
    return this;
  }"
Closure_41,/home/common/huangzhili/defects4j_buggy/Closure_41_buggy/src/com/google/javascript/jscomp/FunctionTypeBuilder.java,"FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,
      @Nullable JSDocInfo info) {
    if (argsParent == null) {
      if (info == null) {
        return this;
      } else {
        return inferParameterTypes(info);
      }
    }

    // arguments
    Node oldParameterType = null;
    if (parametersNode != null) {
      oldParameterType = parametersNode.getFirstChild();
    }

    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);
    boolean warnedAboutArgList = false;
    Set<String> allJsDocParams = (info == null) ?
        Sets.<String>newHashSet() :
        Sets.newHashSet(info.getParameterNames());
    boolean foundTemplateType = false;
    boolean isVarArgs = false;
    for (Node arg : argsParent.children()) {
      String argumentName = arg.getString();
      allJsDocParams.remove(argumentName);

      // type from JSDocInfo
      JSType parameterType = null;
      boolean isOptionalParam = isOptionalParameter(arg, info);
      isVarArgs = isVarArgsParameter(arg, info);

      if (info != null && info.hasParameterType(argumentName)) {
        parameterType =
            info.getParameterType(argumentName).evaluate(scope, typeRegistry);
      } else if (oldParameterType != null &&
          oldParameterType.getJSType() != null) {
        parameterType = oldParameterType.getJSType();
        isOptionalParam = oldParameterType.isOptionalArg();
        isVarArgs = oldParameterType.isVarArgs();
      } else {
        parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);
      }

      if (templateTypeName != null &&
          parameterType.restrictByNotNullOrUndefined().isTemplateType()) {
        if (foundTemplateType) {
          reportError(TEMPLATE_TYPE_DUPLICATED, fnName);
        }
        foundTemplateType = true;
      }
      warnedAboutArgList |= addParameter(
          builder, parameterType, warnedAboutArgList,
          isOptionalParam,
          isVarArgs);

      if (oldParameterType != null) {
        oldParameterType = oldParameterType.getNext();
      }
     }
 
     // Copy over any old parameters that aren't in the param list.
 
     if (templateTypeName != null && !foundTemplateType) {
       reportError(TEMPLATE_TYPE_EXPECTED, fnName);
    }

    for (String inexistentName : allJsDocParams) {
      reportWarning(INEXISTANT_PARAM, inexistentName, fnName);
    }

    parametersNode = builder.build();
    return this;
  }"
Closure_43,/home/common/huangzhili/defects4j_buggy/Closure_43_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"@Override
    public void visit(NodeTraversal t, Node n, Node parent) {
      inputId = t.getInputId();
      attachLiteralTypes(t, n);

      switch (n.getType()) {
        case Token.CALL:
          checkForClassDefiningCalls(t, n, parent);
          checkForCallingConventionDefiningCalls(n, delegateCallingConventions);
          break;

        case Token.FUNCTION:
          if (t.getInput() == null || !t.getInput().isExtern()) {
            nonExternFunctions.add(n);
          }

          // Hoisted functions are handled during pre-traversal.
          if (!NodeUtil.isHoistedFunctionDeclaration(n)) {
            defineFunctionLiteral(n, parent);
          }
          break;

        case Token.ASSIGN:
          // Handle initialization of properties.
          Node firstChild = n.getFirstChild();
          if (firstChild.isGetProp() &&
              firstChild.isQualifiedName()) {
            maybeDeclareQualifiedName(t, n.getJSDocInfo(),
                firstChild, n, firstChild.getNext());
          }
          break;

        case Token.CATCH:
          defineCatch(n, parent);
          break;

        case Token.VAR:
          defineVar(n, parent);
          break;

        case Token.GETPROP:
          // Handle stubbed properties.
          if (parent.isExprResult() &&
              n.isQualifiedName()) {
            maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);
          }
          break;
       }
 
       // Analyze any @lends object literals in this statement.
     }"
Closure_43,/home/common/huangzhili/defects4j_buggy/Closure_43_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"private void attachLiteralTypes(NodeTraversal t, Node n) {
      switch (n.getType()) {
        case Token.NULL:
          n.setJSType(getNativeType(NULL_TYPE));
          break;

        case Token.VOID:
          n.setJSType(getNativeType(VOID_TYPE));
          break;

        case Token.STRING:
          // Defer keys to the Token.OBJECTLIT case
          if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
            n.setJSType(getNativeType(STRING_TYPE));
          }
          break;

        case Token.NUMBER:
          n.setJSType(getNativeType(NUMBER_TYPE));
          break;

        case Token.TRUE:
        case Token.FALSE:
          n.setJSType(getNativeType(BOOLEAN_TYPE));
          break;

        case Token.REGEXP:
          n.setJSType(getNativeType(REGEXP_TYPE));
           break;
 
         case Token.OBJECTLIT:
             defineObjectLiteral(n);
           break;
 
           // NOTE(nicksantos): If we ever support Array tuples,
          // we will need to put ARRAYLIT here as well.
      }
    }"
Closure_45,/home/common/huangzhili/defects4j_buggy/Closure_45_buggy/src/com/google/javascript/jscomp/RemoveUnusedVars.java,"private void interpretAssigns() {
    boolean changes = false;
    do {
      changes = false;

      // We can't use traditional iterators and iterables for this list,
      // because our lazily-evaluated continuations will modify it while
      // we traverse it.
      for (int current = 0; current < maybeUnreferenced.size(); current++) {
        Var var = maybeUnreferenced.get(current);
        if (referenced.contains(var)) {
          maybeUnreferenced.remove(current);
          current--;
        } else {
          boolean assignedToUnknownValue = false;
          boolean hasPropertyAssign = false;

          if (var.getParentNode().isVar() &&
              !NodeUtil.isForIn(var.getParentNode().getParent())) {
            Node value = var.getInitialValue();
            assignedToUnknownValue = value != null &&
                !NodeUtil.isLiteralValue(value, true);
          } else {
            // This was initialized to a function arg or a catch param
            // or a for...in variable.
            assignedToUnknownValue = true;
          }

          for (Assign assign : assignsByVar.get(var)) {
            if (assign.isPropertyAssign) {
              hasPropertyAssign = true;
            } else if (!NodeUtil.isLiteralValue(
                 assign.assignNode.getLastChild(), true)) {
               assignedToUnknownValue = true;
             }
           }
 
           if (assignedToUnknownValue && hasPropertyAssign) {
             changes = markReferencedVar(var) || changes;
             maybeUnreferenced.remove(current);
             current--;
          }
        }
      }
    } while (changes);
  }"
Closure_46,/home/common/huangzhili/defects4j_buggy/Closure_46_buggy/src/com/google/javascript/rhino/jstype/RecordType.java,"  public ObjectType getImplicitPrototype() {
    return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
  }
"
Closure_47,/home/common/huangzhili/defects4j_buggy/Closure_47_buggy/src/com/google/javascript/jscomp/SourceMap.java,"public void addMapping(
      Node node,
      FilePosition outputStartPosition,
      FilePosition outputEndPosition) {
    String sourceFile = node.getSourceFileName();

    // If the node does not have an associated source file or
    // its line number is -1, then the node does not have sufficient
    // information for a mapping to be useful.
    if (sourceFile == null || node.getLineno() < 0) {
      return;
    }

    sourceFile = fixupSourceLocation(sourceFile);

    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);

    // Strangely, Rhino source lines are one based but columns are
     // zero based.
     // We don't change this for the v1 or v2 source maps but for
     // v3 we make them both 0 based.
 
     generator.addMapping(
         sourceFile, originalName,
         new FilePosition(node.getLineno(), node.getCharno()),
         outputStartPosition, outputEndPosition);
   }"
Closure_47,/home/common/huangzhili/defects4j_buggy/Closure_47_buggy/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java,"private OriginalMapping getOriginalMappingForEntry(Entry entry) {
    if (entry.getSourceFileId() == UNMAPPED) {
      return null;
    } else {
       // Adjust the line/column here to be start at 1.
       Builder x = OriginalMapping.newBuilder()
         .setOriginalFile(sources[entry.getSourceFileId()])
         .setLineNumber(entry.getSourceLine())
         .setColumnPosition(entry.getSourceColumn());
       if (entry.getNameId() != UNMAPPED) {
         x.setIdentifier(names[entry.getNameId()]);
       }
      return x.build();
    }
  }"
Closure_49,/home/common/huangzhili/defects4j_buggy/Closure_49_buggy/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java,"@Override
  public void enterScope(NodeTraversal t) {
    Node declarationRoot = t.getScopeRoot();
    Renamer renamer;
    if (nameStack.isEmpty()) {
      // If the contextual renamer is being used the starting context can not
      // be a function.
      Preconditions.checkState(
          declarationRoot.getType() != Token.FUNCTION ||
          !(rootRenamer instanceof ContextualRenamer));
      Preconditions.checkState(t.inGlobalScope());
      renamer = rootRenamer;
    } else {
       renamer = nameStack.peek().forChildScope();
     }
 
     if (declarationRoot.getType() == Token.FUNCTION) {
       for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {
         String name = c.getString();
         renamer.addDeclaredName(name);
       }
       Node functionBody = declarationRoot.getLastChild();
       findDeclaredNames(functionBody, null, renamer);
     }  else 
     if (declarationRoot.getType() != Token.FUNCTION) {
       // Add the block declarations
       findDeclaredNames(declarationRoot, null, renamer);
    }
    nameStack.push(renamer);
  }"
Closure_49,/home/common/huangzhili/defects4j_buggy/Closure_49_buggy/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java,"@Override
  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    switch (n.getType()) {
      case Token.FUNCTION:
        {
          // Add recursive function name, if needed.
          // NOTE: ""enterScope"" is called after we need to pick up this name.
          Renamer renamer = nameStack.peek().forChildScope();

          // If needed, add the function recursive name.
          String name = n.getFirstChild().getString();
          if (name != null && !name.isEmpty() && parent != null
              && !NodeUtil.isFunctionDeclaration(n)) {
             renamer.addDeclaredName(name);
           }
 
 
 
           // Add the function parameters
 
           // Add the function body declarations
 
           nameStack.push(renamer);
         }
        break;

      case Token.CATCH:
        {
          Renamer renamer = nameStack.peek().forChildScope();

          String name = n.getFirstChild().getString();
          renamer.addDeclaredName(name);

          nameStack.push(renamer);
        }
        break;
    }

    return true;
  }"
Closure_49,/home/common/huangzhili/defects4j_buggy/Closure_49_buggy/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java,"@Override
  public void visit(NodeTraversal t, Node n, Node parent) {
    switch (n.getType()) {
      case Token.NAME:
        String newName = getReplacementName(n.getString());
        if (newName != null) {
          Renamer renamer = nameStack.peek();
          if (renamer.stripConstIfReplaced()) {
            // TODO(johnlenz): Do we need to do anything about the javadoc?
            n.removeProp(Node.IS_CONSTANT_NAME);
          }
          n.setString(newName);
          t.getCompiler().reportCodeChange();
        }
        break;
 
       case Token.FUNCTION:
         // Remove the function body scope
         // Remove function recursive name (if any).
         nameStack.pop();
         break;
 
         // Note: The parameters and function body variables live in the
         // same scope, we introduce the scope when in the ""shouldTraverse""
         // visit of LP, but remove it when when we exit the function above.
 
       case Token.CATCH:
         // Remove catch except name from the stack of names.
        nameStack.pop();
        break;
    }
  }"
Closure_54,/home/common/huangzhili/defects4j_buggy/Closure_54_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
        Node n, Node parent, Node rhsValue) {
      Node ownerNode = n.getFirstChild();
      String ownerName = ownerNode.getQualifiedName();
      String qName = n.getQualifiedName();
      String propName = n.getLastChild().getString();
      Preconditions.checkArgument(qName != null && ownerName != null);

      // Precedence of type information on GETPROPs:
      // 1) @type annnotation / @enum annotation
      // 2) ASSIGN to FUNCTION literal
      // 3) @param/@return annotation (with no function literal)
      // 4) ASSIGN to something marked @const
      // 5) ASSIGN to anything else
      //
      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff
      // the function has jsdoc or has not been declared before.
      //
      // FUNCTION literals are special because TypedScopeCreator is very smart
      // about getting as much type information as possible for them.

      // Determining type for #1 + #2 + #3 + #4
      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);
      if (valueType == null && rhsValue != null) {
        // Determining type for #5
        valueType = rhsValue.getJSType();
      }
      // Function prototypes are special.
      // It's a common JS idiom to do:
      // F.prototype = { ... };
      // So if F does not have an explicitly declared super type,
      // allow F.prototype to be redefined arbitrarily.
      if (""prototype"".equals(propName)) {
        Var qVar = scope.getVar(qName);
        if (qVar != null) {
          // If the programmer has declared that F inherits from Super,
          // and they assign F.prototype to an object literal,
           // then they are responsible for making sure that the object literal's
           // implicit prototype is set up appropriately. We just obey
           // the @extends tag.
           if (!qVar.isTypeInferred()) {
             // If the programmer has declared that F inherits from Super,
             // and they assign F.prototype to some arbitrary expression,
             // there's not much we can do. We just ignore the expression,
            // and hope they've annotated their code in a way to tell us
            // what props are going to be on that prototype.
            return;
          }
          if (qVar.getScope() == scope) {
            scope.undeclare(qVar);
          }
        }
      }

      if (valueType == null) {
        if (parent.getType() == Token.EXPR_RESULT) {
          stubDeclarations.add(new StubDeclaration(
              n,
              t.getInput() != null && t.getInput().isExtern(),
              ownerName));
        }

        return;
      }

      boolean inferred = true;
      if (info != null) {
        // Determining declaration for #1 + #3 + #4
        inferred = !(info.hasType()
            || info.hasEnumParameterType()
            || (info.isConstant() && valueType != null
                && !valueType.isUnknownType())
            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
      }

      if (inferred) {
        // Determining declaration for #2
        inferred = !(rhsValue != null &&
            rhsValue.getType() == Token.FUNCTION &&
            (info != null || !scope.isDeclared(qName, false)));
      }

      if (!inferred) {
        ObjectType ownerType = getObjectSlot(ownerName);
        if (ownerType != null) {
          // Only declare this as an official property if it has not been
          // declared yet.
          boolean isExtern = t.getInput() != null && t.getInput().isExtern();
          if ((!ownerType.hasOwnProperty(propName) ||
               ownerType.isPropertyTypeInferred(propName)) &&
              ((isExtern && !ownerType.isNativeObjectType()) ||
               !ownerType.isInstanceType())) {
            // If the property is undeclared or inferred, declare it now.
            ownerType.defineDeclaredProperty(propName, valueType, n);
          }
        }

        // If the property is already declared, the error will be
        // caught when we try to declare it in the current scope.
        defineSlot(n, parent, valueType, inferred);
      } else if (rhsValue != null &&
          rhsValue.getType() == Token.TRUE) {
        // We declare these for delegate proxy method properties.
        FunctionType ownerType =
            JSType.toMaybeFunctionType(getObjectSlot(ownerName));
        if (ownerType != null) {
          JSType ownerTypeOfThis = ownerType.getTypeOfThis();
          String delegateName = codingConvention.getDelegateSuperclassName();
          JSType delegateType = delegateName == null ?
              null : typeRegistry.getType(delegateName);
          if (delegateType != null &&
              ownerTypeOfThis.isSubtype(delegateType)) {
            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);
          }
        }
      }
    }"
Closure_54,/home/common/huangzhili/defects4j_buggy/Closure_54_buggy/src/com/google/javascript/rhino/jstype/FunctionType.java,"public void setPrototypeBasedOn(ObjectType baseType) {
    // This is a bit weird. We need to successfully handle these
    // two cases:
    // Foo.prototype = new Bar();
    // and
    // Foo.prototype = {baz: 3};
    // In the first case, we do not want new properties to get
    // added to Bar. In the second case, we do want new properties
    // to get added to the type of the anonymous object.
    //
    // We handle this by breaking it into two cases:
    //
    // In the first case, we create a new PrototypeObjectType and set
    // its implicit prototype to the type being assigned. This ensures
    // that Bar will not get any properties of Foo.prototype, but properties
    // later assigned to Bar will get inherited properly.
     //
     // In the second case, we just use the anonymous object as the prototype.
     if (baseType.hasReferenceName() ||
         baseType.isUnknownType() ||
         isNativeObjectType() ||
         baseType.isFunctionPrototypeType() ||
         !(baseType instanceof PrototypeObjectType)) {

      baseType = new PrototypeObjectType(
          registry, this.getReferenceName() + "".prototype"", baseType);
    }
    setPrototype((PrototypeObjectType) baseType);
  }"
Closure_54,/home/common/huangzhili/defects4j_buggy/Closure_54_buggy/src/com/google/javascript/rhino/jstype/FunctionType.java,"public boolean setPrototype(PrototypeObjectType prototype) {
    if (prototype == null) {
      return false;
    }
    // getInstanceType fails if the function is not a constructor
    if (isConstructor() && prototype == getInstanceType()) {
       return false;
     }
 
     boolean replacedPrototype = prototype != null;
 
     this.prototype = prototype;
     this.prototypeSlot = new SimpleSlot(""prototype"", prototype, true);
     this.prototype.setOwnerFunction(this);
 
       // Disassociating the old prototype makes this easier to debug--
       // we don't have to worry about two prototypes running around.
 
     if (isConstructor() || isInterface()) {
       FunctionType superClass = getSuperClassConstructor();
      if (superClass != null) {
        superClass.addSubType(this);
      }

      if (isInterface()) {
        for (ObjectType interfaceType : getExtendedInterfaces()) {
          if (interfaceType.getConstructor() != null) {
            interfaceType.getConstructor().addSubType(this);
          }
        }
      }
    }

    if (replacedPrototype) {
      clearCachedValues();
    }

    return true;
  }"
Closure_60,/home/common/huangzhili/defects4j_buggy/Closure_60_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static TernaryValue getPureBooleanValue(Node n) {
    switch (n.getType()) {
      case Token.STRING:
        return TernaryValue.forBoolean(n.getString().length() > 0);

      case Token.NUMBER:
        return TernaryValue.forBoolean(n.getDouble() != 0);

      case Token.NOT:
        return getPureBooleanValue(n.getLastChild()).not();

      case Token.NULL:
      case Token.FALSE:
         return TernaryValue.FALSE;
 
       case Token.VOID:
           return TernaryValue.FALSE;
 
       case Token.NAME:
         String name = n.getString();
        if (""undefined"".equals(name)
            || ""NaN"".equals(name)) {
          // We assume here that programs don't change the value of the keyword
          // undefined to something other than the value undefined.
          return TernaryValue.FALSE;
        } else if (""Infinity"".equals(name)) {
          return TernaryValue.TRUE;
        }
        break;

      case Token.TRUE:
      case Token.REGEXP:
        return TernaryValue.TRUE;

      case Token.ARRAYLIT:
      case Token.OBJECTLIT:
        if (!mayHaveSideEffects(n)) {
          return TernaryValue.TRUE;
        }
        break;
    }

    return TernaryValue.UNKNOWN;
  }"
Closure_60,/home/common/huangzhili/defects4j_buggy/Closure_60_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static TernaryValue getImpureBooleanValue(Node n) {
    switch (n.getType()) {
      case Token.ASSIGN:
      case Token.COMMA:
        // For ASSIGN and COMMA the value is the value of the RHS.
        return getImpureBooleanValue(n.getLastChild());
      case Token.NOT:
        TernaryValue value = getImpureBooleanValue(n.getLastChild());
        return value.not();
      case Token.AND: {
        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());
        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());
        return lhs.and(rhs);
      }
      case Token.OR:  {
        TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());
        TernaryValue rhs = getImpureBooleanValue(n.getLastChild());
        return lhs.or(rhs);
      }
      case Token.HOOK:  {
        TernaryValue trueValue = getImpureBooleanValue(
            n.getFirstChild().getNext());
        TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());
        if (trueValue.equals(falseValue)) {
          return trueValue;
        } else {
          return TernaryValue.UNKNOWN;
        }
      }
      case Token.ARRAYLIT:
      case Token.OBJECTLIT:
         // ignoring side-effects
         return TernaryValue.TRUE;
 
 
       default:
         return getPureBooleanValue(n);
    }
  }"
Closure_64,/home/common/huangzhili/defects4j_buggy/Closure_64_buggy/src/com/google/javascript/jscomp/Compiler.java,"public void toSource(final CodeBuilder cb,
                       final int inputSeqNum,
                       final Node root) {
    runInCompilerThread(new Callable<Void>() {
      public Void call() throws Exception {
        if (options.printInputDelimiter) {
          if ((cb.getLength() > 0) && !cb.endsWith(""\n"")) {
            cb.append(""\n"");  // Make sure that the label starts on a new line
          }
          Preconditions.checkState(root.getType() == Token.SCRIPT);

          String delimiter = options.inputDelimiter;

          String sourceName = (String)root.getProp(Node.SOURCENAME_PROP);
          Preconditions.checkState(sourceName != null);
          Preconditions.checkState(!sourceName.isEmpty());

          delimiter = delimiter.replaceAll(""%name%"", sourceName)
            .replaceAll(""%num%"", String.valueOf(inputSeqNum));

          cb.append(delimiter)
            .append(""\n"");
        }
        if (root.getJSDocInfo() != null &&
            root.getJSDocInfo().getLicense() != null) {
          cb.append(""/*\n"")
            .append(root.getJSDocInfo().getLicense())
            .append(""*/\n"");
        }

        // If there is a valid source map, then indicate to it that the current
        // root node's mappings are offset by the given string builder buffer.
        if (options.sourceMapOutputPath != null) {
          sourceMap.setStartingPosition(
              cb.getLineIndex(), cb.getColumnIndex());
        }
 
         // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'
         // for the first input file
         String code = toSource(root, sourceMap);
         if (!code.isEmpty()) {
           cb.append(code);
 
          // In order to avoid parse ambiguity when files are concatenated
          // together, all files should end in a semi-colon. Do a quick
          // heuristic check if there's an obvious semi-colon already there.
          int length = code.length();
          char lastChar = code.charAt(length - 1);
          char secondLastChar = length >= 2 ?
              code.charAt(length - 2) : '\0';
          boolean hasSemiColon = lastChar == ';' ||
              (lastChar == '\n' && secondLastChar == ';');
          if (!hasSemiColon) {
            cb.append("";"");
          }
        }
        return null;
      }
    });
  }"
Closure_68,/home/common/huangzhili/defects4j_buggy/Closure_68_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,"private Node parseFunctionType(JsDocToken token) {
     // NOTE(nicksantos): We're not implementing generics at the moment, so
     // just throw out TypeParameters.
     if (token != JsDocToken.LP) {
       return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp"");
     }
 
    Node functionType = newNode(Token.FUNCTION);
    Node parameters = null;
    skipEOLs();
    if (!match(JsDocToken.RP)) {
      token = next();

      boolean hasParams = true;
      if (token == JsDocToken.STRING) {
        String tokenStr = stream.getString();
        boolean isThis = ""this"".equals(tokenStr);
        boolean isNew = ""new"".equals(tokenStr);
        if (isThis || isNew) {
          if (match(JsDocToken.COLON)) {
            next();
            skipEOLs();
            Node contextType = wrapNode(
                isThis ? Token.THIS : Token.NEW,
                parseTypeName(next()));
            if (contextType == null) {
              return null;
            }

            functionType.addChildToFront(contextType);
          } else {
            return reportTypeSyntaxWarning(""msg.jsdoc.missing.colon"");
          }

          if (match(JsDocToken.COMMA)) {
            next();
            skipEOLs();
            token = next();
          } else {
            hasParams = false;
          }
        }
      }

      if (hasParams) {
        parameters = parseParametersType(token);
        if (parameters == null) {
          return null;
        }
      }
    }

    if (parameters != null) {
      functionType.addChildToBack(parameters);
    }

    skipEOLs();
    if (!match(JsDocToken.RP)) {
      return reportTypeSyntaxWarning(""msg.jsdoc.missing.rp"");
    }

    skipEOLs();
    Node resultType = parseResultType(next());
    if (resultType == null) {
      return null;
    } else {
      functionType.addChildToBack(resultType);
    }
    return functionType;
  }"
Closure_68,/home/common/huangzhili/defects4j_buggy/Closure_68_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,"private Node parseBasicTypeExpression(JsDocToken token) {
    if (token == JsDocToken.STAR) {
      return newNode(Token.STAR);
    } else if (token == JsDocToken.LB) {
      skipEOLs();
      return parseArrayType(next());
    } else if (token == JsDocToken.LC) {
      skipEOLs();
      return parseRecordType(next());
    } else if (token == JsDocToken.LP) {
      skipEOLs();
      return parseUnionType(next());
    } else if (token == JsDocToken.STRING) {
      String string = stream.getString();
      if (""function"".equals(string)) {
        skipEOLs();
        return parseFunctionType(next());
      } else if (""null"".equals(string) || ""undefined"".equals(string)) {
        return newStringNode(string);
      } else {
        return parseTypeName(token);
       }
     }
 
     return reportGenericTypeSyntaxWarning();
   }"
Closure_68,/home/common/huangzhili/defects4j_buggy/Closure_68_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,"boolean parse() {
    int lineno;
    int charno;

    // JSTypes are represented as Rhino AST nodes, and then resolved later.
    JSTypeExpression type;

    state = State.SEARCHING_ANNOTATION;
    skipEOLs();

    JsDocToken token = next();

    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();

    // Always record that we have a comment.
    if (jsdocBuilder.shouldParseDocumentation()) {
      ExtractionInfo blockInfo = extractBlockComment(token);
      token = blockInfo.token;
      if (!blockInfo.string.isEmpty()) {
        jsdocBuilder.recordBlockDescription(blockInfo.string);
      }
    } else {
      if (token != JsDocToken.ANNOTATION &&
          token != JsDocToken.EOC) {
        // Mark that there was a description, but don't bother marking
        // what it was.
        jsdocBuilder.recordBlockDescription("""");
      }
    }

    // Parse the actual JsDoc.
    retry: for (;;) {
      switch (token) {
        case ANNOTATION:
          if (state == State.SEARCHING_ANNOTATION) {
            state = State.SEARCHING_NEWLINE;
            lineno = stream.getLineno();
            charno = stream.getCharno();

            String annotationName = stream.getString();
            Annotation annotation = annotationNames.get(annotationName);
            if (annotation == null) {
              parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName,
                  stream.getLineno(), stream.getCharno());
            } else {
              // Mark the beginning of the annotation.
              jsdocBuilder.markAnnotation(annotationName, lineno, charno);

              switch (annotation) {
                case AUTHOR:
                  if (jsdocBuilder.shouldParseDocumentation()) {
                    ExtractionInfo authorInfo = extractSingleLineBlock();
                    String author = authorInfo.string;

                    if (author.length() == 0) {
                      parser.addParserWarning(""msg.jsdoc.authormissing"",
                          stream.getLineno(), stream.getCharno());
                    } else {
                      jsdocBuilder.addAuthor(author);
                    }
                    token = authorInfo.token;
                  } else {
                    token = eatTokensUntilEOL(token);
                  }
                  continue retry;

                case CONSTANT:
                  if (!jsdocBuilder.recordConstancy()) {
                    parser.addParserWarning(""msg.jsdoc.const"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case CONSTRUCTOR:
                  if (!jsdocBuilder.recordConstructor()) {
                    if (jsdocBuilder.isInterfaceRecorded()) {
                      parser.addTypeWarning(""msg.jsdoc.interface.constructor"",
                          stream.getLineno(), stream.getCharno());
                    } else {
                      parser.addTypeWarning(""msg.jsdoc.incompat.type"",
                          stream.getLineno(), stream.getCharno());
                    }
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case DEPRECATED:
                  if (!jsdocBuilder.recordDeprecated()) {
                    parser.addParserWarning(""msg.jsdoc.deprecated"",
                        stream.getLineno(), stream.getCharno());
                  }

                  // Find the reason/description, if any.
                  ExtractionInfo reasonInfo =
                      extractMultilineTextualBlock(token);

                  String reason = reasonInfo.string;

                  if (reason.length() > 0) {
                    jsdocBuilder.recordDeprecationReason(reason);
                  }

                  token = reasonInfo.token;
                  continue retry;

                case INTERFACE:
                  if (!jsdocBuilder.recordInterface()) {
                    if (jsdocBuilder.isConstructorRecorded()) {
                      parser.addTypeWarning(""msg.jsdoc.interface.constructor"",
                          stream.getLineno(), stream.getCharno());
                    } else {
                      parser.addTypeWarning(""msg.jsdoc.incompat.type"",
                          stream.getLineno(), stream.getCharno());
                    }
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case DESC:
                  if (jsdocBuilder.isDescriptionRecorded()) {
                    parser.addParserWarning(""msg.jsdoc.desc.extra"",
                        stream.getLineno(), stream.getCharno());
                    token = eatTokensUntilEOL();
                    continue retry;
                  } else {
                    ExtractionInfo descriptionInfo =
                        extractMultilineTextualBlock(token);

                    String description = descriptionInfo.string;

                    jsdocBuilder.recordDescription(description);
                    token = descriptionInfo.token;
                    continue retry;
                  }

                case FILE_OVERVIEW:
                  String fileOverview = """";
                  if (jsdocBuilder.shouldParseDocumentation()) {
                    ExtractionInfo fileOverviewInfo =
                        extractMultilineTextualBlock(token,
                            WhitespaceOption.TRIM);

                    fileOverview = fileOverviewInfo.string;

                    token = fileOverviewInfo.token;
                  } else {
                    token = eatTokensUntilEOL(token);
                  }

                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||
                      fileOverviewJSDocInfo != null) {
                    parser.addParserWarning(""msg.jsdoc.fileoverview.extra"",
                        stream.getLineno(), stream.getCharno());
                  }
                  continue retry;

                case LICENSE:
                case PRESERVE:
                  ExtractionInfo preserveInfo =
                      extractMultilineTextualBlock(token,
                                                   WhitespaceOption.PRESERVE);

                  String preserve = preserveInfo.string;

                  if (preserve.length() > 0) {
                    if (fileLevelJsDocBuilder != null) {
                      fileLevelJsDocBuilder.append(preserve);
                    }
                  }

                  token = preserveInfo.token;
                  continue retry;

                case ENUM:
                  token = next();
                  lineno = stream.getLineno();
                  charno = stream.getCharno();

                  type = null;
                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
                    type = createJSTypeExpression(
                        parseAndRecordTypeNode(token));
                  }

                  if (type == null) {
                    type = createJSTypeExpression(newStringNode(""number""));
                  }
                  if (!jsdocBuilder.recordEnumParameterType(type)) {
                    parser.addTypeWarning(
                        ""msg.jsdoc.incompat.type"", lineno, charno);
                  }
                  token = eatTokensUntilEOL(token);
                  continue retry;

                case EXPORT:
                  if (!jsdocBuilder.recordExport()) {
                    parser.addParserWarning(""msg.jsdoc.export"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case EXTERNS:
                  if (!jsdocBuilder.recordExterns()) {
                    parser.addParserWarning(""msg.jsdoc.externs"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case JAVA_DISPATCH:
                  if (!jsdocBuilder.recordJavaDispatch()) {
                    parser.addParserWarning(""msg.jsdoc.javadispatch"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case EXTENDS:
                case IMPLEMENTS:
                  skipEOLs();
                  token = next();
                  lineno = stream.getLineno();
                  charno = stream.getCharno();
                  boolean matchingRc = false;

                  if (token == JsDocToken.LC) {
                    token = next();
                    matchingRc = true;
                  }

                  if (token == JsDocToken.STRING) {
                    Node typeNode = parseAndRecordTypeNameNode(
                        token, lineno, charno, matchingRc);

                    lineno = stream.getLineno();
                    charno = stream.getCharno();

                    typeNode = wrapNode(Token.BANG, typeNode);
                    if (typeNode != null && !matchingRc) {
                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                    }
                    type = createJSTypeExpression(typeNode);

                    if (annotation == Annotation.EXTENDS) {
                      // record the extended type, check later
                      extendedTypes.add(new ExtendedTypeInfo(
                          type, stream.getLineno(), stream.getCharno()));
                    } else {
                      Preconditions.checkState(
                          annotation == Annotation.IMPLEMENTS);
                      if (!jsdocBuilder.recordImplementedInterface(type)) {
                        parser.addTypeWarning(""msg.jsdoc.implements.duplicate"",
                            lineno, charno);
                      }
                    }
                    token = next();
                    if (matchingRc) {
                      if (token != JsDocToken.RC) {
                        parser.addTypeWarning(""msg.jsdoc.missing.rc"",
                            stream.getLineno(), stream.getCharno());
                      }
                    } else if (token != JsDocToken.EOL &&
                        token != JsDocToken.EOF && token != JsDocToken.EOC) {
                      parser.addTypeWarning(""msg.end.annotation.expected"",
                          stream.getLineno(), stream.getCharno());
                    }
                  } else {
                    parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
                  }
                  token = eatTokensUntilEOL(token);
                  continue retry;

                case HIDDEN:
                  if (!jsdocBuilder.recordHiddenness()) {
                    parser.addParserWarning(""msg.jsdoc.hidden"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case LENDS:
                  skipEOLs();

                  matchingRc = false;
                  if (match(JsDocToken.LC)) {
                    token = next();
                    matchingRc = true;
                  }

                  if (match(JsDocToken.STRING)) {
                    token = next();
                    if (!jsdocBuilder.recordLends(stream.getString())) {
                      parser.addTypeWarning(""msg.jsdoc.lends.incompatible"",
                          stream.getLineno(), stream.getCharno());
                    }
                  } else {
                    parser.addTypeWarning(""msg.jsdoc.lends.missing"",
                        stream.getLineno(), stream.getCharno());
                  }

                  if (matchingRc && !match(JsDocToken.RC)) {
                    parser.addTypeWarning(""msg.jsdoc.missing.rc"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case MEANING:
                  ExtractionInfo meaningInfo =
                      extractMultilineTextualBlock(token);
                  String meaning = meaningInfo.string;
                  token = meaningInfo.token;
                  if (!jsdocBuilder.recordMeaning(meaning)) {
                    parser.addParserWarning(""msg.jsdoc.meaning.extra"",
                        stream.getLineno(), stream.getCharno());
                  }
                  continue retry;

                case NO_ALIAS:
                  if (!jsdocBuilder.recordNoAlias()) {
                    parser.addParserWarning(""msg.jsdoc.noalias"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case NO_COMPILE:
                  if (!jsdocBuilder.recordNoCompile()) {
                    parser.addParserWarning(""msg.jsdoc.nocompile"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case NO_TYPE_CHECK:
                  if (!jsdocBuilder.recordNoTypeCheck()) {
                    parser.addParserWarning(""msg.jsdoc.nocheck"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case NOT_IMPLEMENTED:
                  token = eatTokensUntilEOL();
                  continue retry;

                case INHERIT_DOC:
                case OVERRIDE:
                  if (!jsdocBuilder.recordOverride()) {
                    parser.addTypeWarning(""msg.jsdoc.override"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case THROWS:
                  skipEOLs();
                  token = next();
                  lineno = stream.getLineno();
                  charno = stream.getCharno();
                  type = null;

                  if (token == JsDocToken.LC) {
                    type = createJSTypeExpression(
                        parseAndRecordTypeNode(token));

                    if (type == null) {
                      // parsing error reported during recursive descent
                      // recovering parsing
                      token = eatTokensUntilEOL();
                      continue retry;
                    }
                  }

                  // *Update* the token to that after the type annotation.
                  token = current();

                  // Save the throw type.
                  jsdocBuilder.recordThrowType(type);

                  // Find the throw's description (if applicable).
                  if (jsdocBuilder.shouldParseDocumentation()) {
                    ExtractionInfo descriptionInfo =
                        extractMultilineTextualBlock(token);

                    String description = descriptionInfo.string;

                    if (description.length() > 0) {
                      jsdocBuilder.recordThrowDescription(type, description);
                    }

                    token = descriptionInfo.token;
                  } else {
                    token = eatTokensUntilEOL(token);
                  }
                  continue retry;

                case PARAM:
                  skipEOLs();
                  token = next();
                  lineno = stream.getLineno();
                  charno = stream.getCharno();
                  type = null;

                  if (token == JsDocToken.LC) {
                    type = createJSTypeExpression(
                        parseAndRecordParamTypeNode(token));

                    if (type == null) {
                      // parsing error reported during recursive descent
                      // recovering parsing
                      token = eatTokensUntilEOL();
                      continue retry;
                    }
                    skipEOLs();
                    token = next();
                    lineno = stream.getLineno();
                    charno = stream.getCharno();
                  }

                  String name = null;
                  boolean isBracketedParam = JsDocToken.LB == token;
                  if (isBracketedParam) {
                    token = next();
                  }

                  if (JsDocToken.STRING != token) {
                    parser.addTypeWarning(""msg.missing.variable.name"",
                        lineno, charno);
                  } else {
                    name = stream.getString();

                    if (isBracketedParam) {
                      token = next();

                      // Throw out JsDocToolkit's ""default"" parameter
                      // annotation.  It makes no sense under our type
                      // system.
                      if (JsDocToken.EQUALS == token) {
                        token = next();
                        if (JsDocToken.STRING == token) {
                          token = next();
                        }
                      }

                      if (JsDocToken.RB != token) {
                        reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
                      } else if (type != null) {
                        // Make the type expression optional, if it isn't
                        // already.
                        type = JSTypeExpression.makeOptionalArg(type);
                      }
                    }

                    // If the param name has a DOT in it, just throw it out
                    // quietly. We do not handle the JsDocToolkit method
                    // for handling properties of params.
                    if (name.indexOf('.') > -1) {
                      name = null;
                    } else if (!jsdocBuilder.recordParameter(name, type)) {
                      if (jsdocBuilder.hasParameter(name)) {
                        parser.addTypeWarning(""msg.dup.variable.name"", name,
                            lineno, charno);
                      } else {
                        parser.addTypeWarning(""msg.jsdoc.incompat.type"", name,
                            lineno, charno);
                      }
                    }
                  }

                  if (name == null) {
                    token = eatTokensUntilEOL(token);
                    continue retry;
                  }

                  jsdocBuilder.markName(name, lineno, charno);

                  // Find the parameter's description (if applicable).
                  if (jsdocBuilder.shouldParseDocumentation()) {
                    ExtractionInfo paramDescriptionInfo =
                        extractMultilineTextualBlock(token);

                    String paramDescription = paramDescriptionInfo.string;

                    if (paramDescription.length() > 0) {
                      jsdocBuilder.recordParameterDescription(name,
                          paramDescription);
                    }

                    token = paramDescriptionInfo.token;
                  } else {
                    token = eatTokensUntilEOL(token);
                  }
                  continue retry;

                case PRESERVE_TRY:
                  if (!jsdocBuilder.recordPreserveTry()) {
                    parser.addParserWarning(""msg.jsdoc.preservertry"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case PRIVATE:
                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
                    parser.addParserWarning(""msg.jsdoc.visibility.private"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case PROTECTED:
                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
                    parser.addParserWarning(""msg.jsdoc.visibility.protected"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case PUBLIC:
                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
                    parser.addParserWarning(""msg.jsdoc.visibility.public"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case NO_SHADOW:
                  if (!jsdocBuilder.recordNoShadow()) {
                    parser.addParserWarning(""msg.jsdoc.noshadow"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case NO_SIDE_EFFECTS:
                  if (!jsdocBuilder.recordNoSideEffects()) {
                    parser.addParserWarning(""msg.jsdoc.nosideeffects"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case MODIFIES:
                  token = parseModifiesTag(next());
                  continue retry;

                case IMPLICIT_CAST:
                  if (!jsdocBuilder.recordImplicitCast()) {
                    parser.addTypeWarning(""msg.jsdoc.implicitcast"",
                        stream.getLineno(), stream.getCharno());
                  }
                  token = eatTokensUntilEOL();
                  continue retry;

                case SEE:
                  if (jsdocBuilder.shouldParseDocumentation()) {
                    ExtractionInfo referenceInfo = extractSingleLineBlock();
                    String reference = referenceInfo.string;

                    if (reference.length() == 0) {
                      parser.addParserWarning(""msg.jsdoc.seemissing"",
                          stream.getLineno(), stream.getCharno());
                    } else {
                      jsdocBuilder.addReference(reference);
                    }

                    token = referenceInfo.token;
                  } else {
                    token = eatTokensUntilEOL(token);
                  }
                  continue retry;

                case SUPPRESS:
                  token = parseSuppressTag(next());
                  continue retry;

                case TEMPLATE:
                  ExtractionInfo templateInfo = extractSingleLineBlock();
                  String templateTypeName = templateInfo.string;

                  if (templateTypeName.length() == 0) {
                    parser.addTypeWarning(""msg.jsdoc.templatemissing"",
                          stream.getLineno(), stream.getCharno());
                  } else if (!jsdocBuilder.recordTemplateTypeName(
                      templateTypeName)) {
                    parser.addTypeWarning(""msg.jsdoc.template.at.most.once"",
                        stream.getLineno(), stream.getCharno());
                  }

                  token = templateInfo.token;
                  continue retry;

                case VERSION:
                  ExtractionInfo versionInfo = extractSingleLineBlock();
                  String version = versionInfo.string;

                  if (version.length() == 0) {
                    parser.addParserWarning(""msg.jsdoc.versionmissing"",
                          stream.getLineno(), stream.getCharno());
                  } else {
                    if (!jsdocBuilder.recordVersion(version)) {
                       parser.addParserWarning(""msg.jsdoc.extraversion"",
                          stream.getLineno(), stream.getCharno());
                    }
                  }

                  token = versionInfo.token;
                  continue retry;

                case DEFINE:
                case RETURN:
                case THIS:
                case TYPE:
                case TYPEDEF:
                  lineno = stream.getLineno();
                  charno = stream.getCharno();

                  Node typeNode = null;
                  if (!lookAheadForTypeAnnotation() &&
                      annotation == Annotation.RETURN) {
                    // If RETURN doesn't have a type annotation, record
                    // it as the unknown type.
                    typeNode = newNode(Token.QMARK);
                  } else {
                    skipEOLs();
                    token = next();
                    typeNode = parseAndRecordTypeNode(token, lineno, charno);
                  }

                  if (annotation == Annotation.THIS) {
                    typeNode = wrapNode(Token.BANG, typeNode);
                    if (typeNode != null && token != JsDocToken.LC) {
                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
                    }
                  }
                  type = createJSTypeExpression(typeNode);

                  if (type == null) {
                    // error reported during recursive descent
                    // recovering parsing
                  } else {
                    switch (annotation) {
                      case DEFINE:
                        if (!jsdocBuilder.recordDefineType(type)) {
                          parser.addParserWarning(""msg.jsdoc.define"",
                              lineno, charno);
                        }
                        break;

                      case RETURN:
                        if (!jsdocBuilder.recordReturnType(type)) {
                          parser.addTypeWarning(
                              ""msg.jsdoc.incompat.type"", lineno, charno);
                          break;
                        }

                        // Find the return's description (if applicable).
                        if (jsdocBuilder.shouldParseDocumentation()) {
                          ExtractionInfo returnDescriptionInfo =
                              extractMultilineTextualBlock(token);

                          String returnDescription =
                              returnDescriptionInfo.string;

                          if (returnDescription.length() > 0) {
                            jsdocBuilder.recordReturnDescription(
                                returnDescription);
                          }

                          token = returnDescriptionInfo.token;
                        } else {
                          token = eatTokensUntilEOL(token);
                        }
                        continue retry;

                      case THIS:
                        if (!jsdocBuilder.recordThisType(type)) {
                          parser.addTypeWarning(
                              ""msg.jsdoc.incompat.type"", lineno, charno);
                        }
                        break;

                      case TYPE:
                        if (!jsdocBuilder.recordType(type)) {
                          parser.addTypeWarning(
                              ""msg.jsdoc.incompat.type"", lineno, charno);
                        }
                        break;

                      case TYPEDEF:
                        if (!jsdocBuilder.recordTypedef(type)) {
                          parser.addTypeWarning(
                              ""msg.jsdoc.incompat.type"", lineno, charno);
                         }
                         break;
                     }
 
                   token = eatTokensUntilEOL();
                   }
                   continue retry;
               }
             }
          }
          break;

        case EOC:
          if (hasParsedFileOverviewDocInfo()) {
            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
          }
          checkExtendedTypes(extendedTypes);
          return true;

        case EOF:
          // discard any accumulated information
          jsdocBuilder.build(null);
          parser.addParserWarning(""msg.unexpected.eof"",
              stream.getLineno(), stream.getCharno());
          checkExtendedTypes(extendedTypes);
          return false;

        case EOL:
          if (state == State.SEARCHING_NEWLINE) {
            state = State.SEARCHING_ANNOTATION;
          }
          token = next();
          continue retry;

        default:
          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
            token = next();
            continue retry;
          } else {
            state = State.SEARCHING_NEWLINE;
            token = eatTokensUntilEOL();
            continue retry;
          }
      }

      // next token
      token = next();
    }
  }"
Closure_72,/home/common/huangzhili/defects4j_buggy/Closure_72_buggy/src/com/google/javascript/jscomp/FunctionToBlockMutator.java,"private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {
    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();
    // Make variable names unique to this instance.
    NodeTraversal.traverse(
        compiler, fnNode, new MakeDeclaredNamesUnique(
            new InlineRenamer(
                idSupplier,
                 ""inline_"",
                 isCallInLoop)));
     // Make label names unique to this instance.
   }"
Closure_72,/home/common/huangzhili/defects4j_buggy/Closure_72_buggy/src/com/google/javascript/jscomp/RenameLabels.java,"private void visitLabel(Node node, Node parent) {
      Node nameNode = node.getFirstChild();
      Preconditions.checkState(nameNode != null);
       String name = nameNode.getString();
       LabelInfo li = getLabelInfo(name);
       // This is a label...
       if (li.referenced) {
         String newName = getNameForId(li.id);
         if (!name.equals(newName)) {
           // ... and it is used, give it the short name.
          nameNode.setString(newName);
          compiler.reportCodeChange();
        }
      } else {
        // ... and it is not referenced, just remove it.
        Node newChild = node.getLastChild();
        node.removeChild(newChild);
        parent.replaceChild(node, newChild);
        if (newChild.getType() == Token.BLOCK) {
          NodeUtil.tryMergeBlock(newChild);
        }
        compiler.reportCodeChange();
      }

      // Remove the label from the current stack of labels.
      namespaceStack.peek().renameMap.remove(name);
    }"
Closure_74,/home/common/huangzhili/defects4j_buggy/Closure_74_buggy/src/com/google/javascript/jscomp/PeepholeFoldConstants.java,"@SuppressWarnings(""fallthrough"")
  private Node tryFoldComparison(Node n, Node left, Node right) {
    if (!NodeUtil.isLiteralValue(left, false) ||
        !NodeUtil.isLiteralValue(right, false)) {
      // We only handle non-literal operands for LT and GT.
      if (n.getType() != Token.GT && n.getType() != Token.LT) {
        return n;
      }
    }

    int op = n.getType();
    boolean result;

    // TODO(johnlenz): Use the JSType to compare nodes of different types.

    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);
    boolean undefinedRight = ((Token.NAME == right.getType()
           && right.getString().equals(""undefined""))
           || (Token.VOID == right.getType()
               && NodeUtil.isLiteralValue(right.getFirstChild(), false)));
     int lhType = left.getType();
     int rhType = right.getType();
     switch (lhType) {
       case Token.VOID:
         if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
        break;

      case Token.NULL:
      case Token.TRUE:
      case Token.FALSE:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.THIS:
        if (right.getType() != Token.THIS) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = true;
            break;

          case Token.SHNE:
          case Token.NE:
            result = false;
            break;

          // We can only handle == and != here.
          // GT, LT, GE, LE depend on the type of ""this"" and how it will
          // be converted to number.  The results are different depending on
          // whether it is a string, NaN or other number value.
          default:
            return n;
        }
        break;

      case Token.STRING:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.STRING != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = left.getString().equals(right.getString());
            break;

          case Token.SHNE:
          case Token.NE:
            result = !left.getString().equals(right.getString());
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.NUMBER:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.NUMBER != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        Boolean compareResult = compareAsNumbers(op, left, right);
        if (compareResult != null) {
          result = compareResult;
        } else {
          return null;
        }
        break;

      case Token.NAME:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }

        if (rightLiteral) {
          boolean undefinedLeft = (left.getString().equals(""undefined""));
          if (undefinedLeft) {
            result = compareToUndefined(right, op);
            break;
          }
        }

        if (Token.NAME != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        String ln = left.getString();
        String rn = right.getString();
        if (!ln.equals(rn)) {
          return n;  // Not the same value name.
        }

        switch (op) {
          // If we knew the named value wouldn't be NaN, it would be nice
          // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
          case Token.LT:
          case Token.GT:
            result = false;
            break;
          default:
            return n;  // don't handle that op
        }
        break;

      default:
        // assert, this should cover all consts
        return n;
    }

    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);
    n.getParent().replaceChild(n, newNode);
    reportCodeChange();

    return newNode;
  }"
Closure_75,/home/common/huangzhili/defects4j_buggy/Closure_75_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static Double getStringNumberValue(String rawJsString) {
       // vertical tab is not always whitespace
 
     String s = trimJsWhiteSpace(rawJsString);
     // return ScriptRuntime.toNumber(s);
    if (s.length() == 0) {
      return 0.0;
    }

    if (s.length() > 2
        && s.charAt(0) == '0'
        && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {
      // Attempt to convert hex numbers.
      try {
        return Double.valueOf(Integer.parseInt(s.substring(2), 16));
      } catch (NumberFormatException e) {
        return Double.NaN;
      }
    }

    if (s.length() > 3
        && (s.charAt(0) == '-' || s.charAt(0) == '+')
        && s.charAt(1) == '0'
        && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {
      // hex numbers with explicit signs vary between browsers.
      return null;
    }

    // FireFox and IE treat the ""Infinity"" differently. FireFox is case
    // insensitive, but IE treats ""infinity"" as NaN.  So leave it alone.
    if (s.equals(""infinity"")
        || s.equals(""-infinity"")
        || s.equals(""+infinity"")) {
      return null;
    }

    try {
      return Double.parseDouble(s);
    } catch (NumberFormatException e) {
      return Double.NaN;
    }
  }"
Closure_75,/home/common/huangzhili/defects4j_buggy/Closure_75_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static TernaryValue isStrWhiteSpaceChar(int c) {
     switch (c) {
       case '\u000B': // <VT>
         return TernaryValue.TRUE;
       case ' ': // <SP>
       case '\n': // <LF>
       case '\r': // <CR>
      case '\t': // <TAB>
      case '\u00A0': // <NBSP>
      case '\u000C': // <FF>
      case '\u2028': // <LS>
      case '\u2029': // <PS>
      case '\uFEFF': // <BOM>
        return TernaryValue.TRUE;
      default:
        return (Character.getType(c) == Character.SPACE_SEPARATOR)
            ? TernaryValue.TRUE : TernaryValue.FALSE;
    }
  }"
Closure_76,/home/common/huangzhili/defects4j_buggy/Closure_76_buggy/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java,"private VariableLiveness isVariableReadBeforeKill(
      Node n, String variable) {

    if (NodeUtil.isName(n) && variable.equals(n.getString())) {
      if (NodeUtil.isLhs(n, n.getParent())) {
        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);
        // The expression to which the assignment is made is evaluated before
        // the RHS is evaluated (normal left to right evaluation) but the KILL
        // occurs after the RHS is evaluated.
        Node rhs = n.getNext();
        VariableLiveness state = isVariableReadBeforeKill(rhs, variable);
        if (state == VariableLiveness.READ) {
          return state;
        }
        return VariableLiveness.KILL;
      } else {
        return VariableLiveness.READ;
      }
    }

    switch (n.getType()) {
       // Conditionals
       case Token.OR:
       case Token.AND:
         // With a AND/OR the first branch always runs, but the second is
         // may not.
       case Token.HOOK:
         return checkHookBranchReadBeforeKill(
             n.getFirstChild().getNext(), n.getLastChild(), variable);
 
      default:
        // Expressions are evaluated left-right, depth first.
        for (Node child = n.getFirstChild();
            child != null; child = child.getNext()) {
          if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION
          VariableLiveness state = isVariableReadBeforeKill(child, variable);
          if (state != VariableLiveness.MAYBE_LIVE) {
            return state;
          }
        }
      }
    }

    return VariableLiveness.MAYBE_LIVE;
  }"
Closure_76,/home/common/huangzhili/defects4j_buggy/Closure_76_buggy/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java,"private boolean isVariableStillLiveWithinExpression(
      Node n, Node exprRoot, String variable) {
    while (n != exprRoot) {
      VariableLiveness state = VariableLiveness.MAYBE_LIVE;
      switch (n.getParent().getType()) {
        case Token.OR:
        case Token.AND:
           // If the currently node is the first child of
           // AND/OR, be conservative only consider the READs
           // of the second operand.
 
         case Token.HOOK:
           // If current node is the condition, check each following
           // branch, otherwise it is a conditional branch and the
           // other branch can be ignored.
 
         default:
           for(Node sibling = n.getNext(); sibling != null;
               sibling = sibling.getNext()) {
             if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {
             state = isVariableReadBeforeKill(sibling, variable);
 
       // If we see a READ or KILL there is no need to continue.
       if (state == VariableLiveness.READ) {
         return true;
       } else if (state == VariableLiveness.KILL) {
         return false;
             }
           }
       }
       }
       n = n.getParent();
     }
    return false;
  }"
Closure_79,/home/common/huangzhili/defects4j_buggy/Closure_79_buggy/src/com/google/javascript/jscomp/Normalize.java,"@Override
   public void process(Node externs, Node root) {
     new NodeTraversal(
         compiler, new NormalizeStatements(compiler, assertOnChange))
         .traverse(root);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
      t.traverseRoots(externs, root);
    }
    // It is important that removeDuplicateDeclarations runs after
    // MakeDeclaredNamesUnique in order for catch block exception names to be
    // handled properly. Specifically, catch block exception names are
    // only valid within the catch block, but our currect Scope logic
    // has no concept of this and includes it in the containing function
    // (or global scope). MakeDeclaredNamesUnique makes the catch exception
    // names unique so that removeDuplicateDeclarations() will properly handle
    // cases where a function scope variable conflict with a exception name:
    //   function f() {
    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}
    //      var e = 1; // f scope 'e'
    //   }
    // otherwise 'var e = 1' would be rewritten as 'e = 1'.
    // TODO(johnlenz): Introduce a seperate scope for catch nodes.
    removeDuplicateDeclarations(externs, root);
    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange)
        .process(externs, root);

    if (!compiler.getLifeCycleStage().isNormalized()) {
      compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);
    }
  }"
Closure_79,/home/common/huangzhili/defects4j_buggy/Closure_79_buggy/src/com/google/javascript/jscomp/VarCheck.java,"private void createSynthesizedExternVar(String varName) {
    Node nameNode = Node.newString(Token.NAME, varName);

    // Mark the variable as constant if it matches the coding convention
    // for constant vars.
    // NOTE(nicksantos): honestly, i'm not sure how much this matters.
    // AFAIK, all people who use the CONST coding convention also
    // compile with undeclaredVars as errors. We have some test
    // cases for this configuration though, and it makes them happier.
    if (compiler.getCodingConvention().isConstant(varName)) {
      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
    }

     getSynthesizedExternsRoot().addChildToBack(
         new Node(Token.VAR, nameNode));
     varsToDeclareInExterns.remove(varName);
   }"
Closure_80,/home/common/huangzhili/defects4j_buggy/Closure_80_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static boolean isBooleanResultHelper(Node n) {
    switch (n.getType()) {
      // Primitives
      case Token.TRUE:
      case Token.FALSE:
      // Comparisons
      case Token.EQ:
      case Token.NE:
      case Token.SHEQ:
      case Token.SHNE:
      case Token.LT:
      case Token.GT:
      case Token.LE:
      case Token.GE:
      // Queryies
      case Token.IN:
      case Token.INSTANCEOF:
       // Inversion
       case Token.NOT:
       // delete operator returns a boolean.
         return true;
       default:
         return false;
    }
  }"
Closure_80,/home/common/huangzhili/defects4j_buggy/Closure_80_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
    switch (value.getType()) {
      case Token.ASSIGN:
        // A result that is aliased by a non-local name, is the effectively the
        // same as returning a non-local name, but this doesn't matter if the
        // value is immutable.
        return NodeUtil.isImmutableValue(value.getLastChild())
            || (locals.apply(value)
                && evaluatesToLocalValue(value.getLastChild(), locals));
      case Token.COMMA:
        return evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.AND:
      case Token.OR:
        return evaluatesToLocalValue(value.getFirstChild(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.HOOK:
        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)
           && evaluatesToLocalValue(value.getLastChild(), locals);
      case Token.INC:
      case Token.DEC:
        if (value.getBooleanProp(Node.INCRDECR_PROP)) {
          return evaluatesToLocalValue(value.getFirstChild(), locals);
        } else {
          return true;
        }
      case Token.THIS:
        return locals.apply(value);
      case Token.NAME:
        return isImmutableValue(value) || locals.apply(value);
      case Token.GETELEM:
      case Token.GETPROP:
        // There is no information about the locality of object properties.
        return locals.apply(value);
      case Token.CALL:
        return callHasLocalResult(value)
            || isToStringMethodCall(value)
            || locals.apply(value);
      case Token.NEW:
        return newHasLocalResult(value)
               || locals.apply(value);
      case Token.FUNCTION:
      case Token.REGEXP:
      case Token.ARRAYLIT:
       case Token.OBJECTLIT:
         // Literals objects with non-literal children are allowed.
         return true;
       case Token.IN:
         // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
         return true;
      default:
        // Other op force a local value:
        //  x = '' + g (x is now an local string)
        //  x -= g (x is now an local number)
        if (isAssignmentOp(value)
            || isSimpleOperator(value)
            || isImmutableValue(value)) {
          return true;
        }

        throw new IllegalStateException(
            ""Unexpected expression node"" + value +
            ""\n parent:"" + value.getParent());
    }
  }"
Closure_84,/home/common/huangzhili/defects4j_buggy/Closure_84_buggy/src/com/google/javascript/jscomp/parsing/IRFactory.java,"@Override
     Node processAssignment(Assignment assignmentNode) {
       Node assign = processInfixExpression(assignmentNode);
       return assign;
     }"
Closure_84,/home/common/huangzhili/defects4j_buggy/Closure_84_buggy/src/com/google/javascript/jscomp/parsing/IRFactory.java,"@Override
    Node processUnaryExpression(UnaryExpression exprNode) {
      int type = transformTokenType(exprNode.getType());
      Node operand = transform(exprNode.getOperand());
      if (type == Token.NEG && operand.getType() == Token.NUMBER) {
         operand.setDouble(-operand.getDouble());
         return operand;
       } else {
 
         Node node = newNode(type, operand);
         if (exprNode.isPostfix()) {
          node.putBooleanProp(Node.INCRDECR_PROP, true);
        }
        return node;
      }
    }"
Closure_85,/home/common/huangzhili/defects4j_buggy/Closure_85_buggy/src/com/google/javascript/jscomp/UnreachableCodeElimination.java,"private Node computeFollowing(Node n) {
     Node next = ControlFlowAnalysis.computeFollowNode(n);
     return next;
   }"
Closure_85,/home/common/huangzhili/defects4j_buggy/Closure_85_buggy/src/com/google/javascript/jscomp/UnreachableCodeElimination.java,"@SuppressWarnings(""fallthrough"")
  private Node tryRemoveUnconditionalBranching(Node n) {
    /*
     * For each of the unconditional branching control flow node, check to see
     * if the ControlFlowAnalysis.computeFollowNode of that node is same as
     * the branching target. If it is, the branch node is safe to be removed.
     *
     * This is not as clever as MinimizeExitPoints because it doesn't do any
     * if-else conversion but it handles more complicated switch statements
     * much nicer.
     */

    // If n is null the target is the end of the function, nothing to do.
    if (n == null) {
       return n;
    }

    DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);

    if (gNode == null) {
       return n;
     }
 
     if (n.getParent() == null) {
       List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();
       if (outEdges.size() == 1) {
         return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());
       }
     }
     switch (n.getType()) {
       case Token.BLOCK:
         if (n.hasChildren()) {
           Node first = n.getFirstChild();
           return tryRemoveUnconditionalBranching(first);
         } else {
           return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n));
         }
       case Token.RETURN:
         if (n.hasChildren()) {
           break;
        }
      case Token.BREAK:
      case Token.CONTINUE:

        // We are looking for a control flow changing statement that always
        // branches to the same node. If removing it the control flow still
        // branches to that same node. It is safe to remove it.
        List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();
        if (outEdges.size() == 1 &&
            // If there is a next node, there is no chance this jump is useless.
            (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {

          Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);
          Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));
          Node nextCfgNode = outEdges.get(0).getDestination().getValue();
          if (nextCfgNode == fallThrough) {
            removeDeadExprStatementSafely(n);
            return fallThrough;
          }
        }
    }
    return n;
  }"
Closure_89,/home/common/huangzhili/defects4j_buggy/Closure_89_buggy/src/com/google/javascript/jscomp/CollapseProperties.java,"private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {
    Node rvalue = ref.node.getNext();
    Node parent = ref.node.getParent();
    Node gramps = parent.getParent();
     Node greatGramps = gramps.getParent();
     Node greatGreatGramps = greatGramps.getParent();
 
 
     // Create the new alias node.
     Node nameNode = NodeUtil.newName(
        compiler.getCodingConvention(), alias, gramps.getFirstChild(),
        refName.fullName());
    NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);

    if (gramps.getType() == Token.EXPR_RESULT) {
      // BEFORE: a.b.c = ...;
      //   exprstmt
      //     assign
      //       getprop
      //         getprop
      //           name a
      //           string b
      //         string c
      //       NODE
      // AFTER: var a$b$c = ...;
      //   var
      //     name a$b$c
      //       NODE

      // Remove the rvalue (NODE).
      parent.removeChild(rvalue);
      nameNode.addChildToFront(rvalue);

      Node varNode = new Node(Token.VAR, nameNode);
      greatGramps.replaceChild(gramps, varNode);
    } else {
      // This must be a complex assignment.
      Preconditions.checkNotNull(ref.getTwin());

      // BEFORE:
      // ... (x.y = 3);
      //
      // AFTER:
      // var x$y;
      // ... (x$y = 3);

      Node current = gramps;
      Node currentParent = gramps.getParent();
      for (; currentParent.getType() != Token.SCRIPT &&
             currentParent.getType() != Token.BLOCK;
           current = currentParent,
           currentParent = currentParent.getParent()) {}

      // Create a stub variable declaration right
      // before the current statement.
      Node stubVar = new Node(Token.VAR, nameNode.cloneTree())
          .copyInformationFrom(nameNode);
      currentParent.addChildBefore(stubVar, current);

      parent.replaceChild(ref.node, nameNode);
    }

    compiler.reportCodeChange();
  }"
Closure_89,/home/common/huangzhili/defects4j_buggy/Closure_89_buggy/src/com/google/javascript/jscomp/GlobalNamespace.java,"boolean canCollapseUnannotatedChildNames() {
      if (type == Type.OTHER || globalSets != 1 || localSets != 0) {
        return false;
      }

      // Don't try to collapse if the one global set is a twin reference.
      // We could theoretically handle this case in CollapseProperties, but
      // it's probably not worth the effort.
      Preconditions.checkNotNull(declaration);
      if (declaration.getTwin() != null) {
        return false;
      }

      if (isClassOrEnum) {
        return true;
      }

      // If this is a key of an aliased object literal, then it will be aliased
      // later. So we won't be able to collapse its properties.
      if (parent != null && parent.shouldKeepKeys()) {
        return false;
       }
 
       // If this is aliased, then its properties can't be collapsed either.
       if (type != Type.FUNCTION && aliasingGets > 0) {
         return false;
       }
 
      return (parent == null || parent.canCollapseUnannotatedChildNames());
    }"
Closure_90,/home/common/huangzhili/defects4j_buggy/Closure_90_buggy/src/com/google/javascript/rhino/jstype/FunctionType.java,"@Override
  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {
    setResolvedTypeInternal(this);

    call = (ArrowType) safeResolve(call, t, scope);
    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);

    // Warning about typeOfThis if it doesn't resolve to an ObjectType
    // is handled further upstream.
    //
    // TODO(nicksantos): Handle this correctly if we have a UnionType.
    //
    // TODO(nicksantos): In ES3, the runtime coerces ""null"" to the global
    // activation object. In ES5, it leaves it as null. Just punt on this
    // issue for now by coercing out null. This is complicated by the
    // fact that when most people write @this {Foo}, they really don't
     // mean ""nullable Foo"". For certain tags (like @extends) we de-nullify
     // the name for them.
     JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);
     if (maybeTypeOfThis instanceof ObjectType) {
       typeOfThis = (ObjectType) maybeTypeOfThis;
     }

    boolean changed = false;
    ImmutableList.Builder<ObjectType> resolvedInterfaces =
        ImmutableList.builder();
    for (ObjectType iface : implementedInterfaces) {
      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);
      resolvedInterfaces.add(resolvedIface);
      changed |= (resolvedIface != iface);
    }
    if (changed) {
      implementedInterfaces = resolvedInterfaces.build();
    }

    if (subTypes != null) {
      for (int i = 0; i < subTypes.size(); i++) {
        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));
      }
    }

    return super.resolveInternal(t, scope);
  }"
Closure_90,/home/common/huangzhili/defects4j_buggy/Closure_90_buggy/src/com/google/javascript/jscomp/FunctionTypeBuilder.java,"@Override
    public boolean apply(JSType type) {
      // TODO(user): Doing an instanceof check here is too
      // restrictive as (Date,Error) is, for instance, an object type
      // even though its implementation is a UnionType. Would need to
       // create interfaces JSType, ObjectType, FunctionType etc and have
       // separate implementation instead of the class hierarchy, so that
       // union types can also be object types, etc.
       if (!type.isSubtype(
               typeRegistry.getNativeType(OBJECT_TYPE))) {
         reportWarning(THIS_TYPE_NON_OBJECT, type.toString());
         return false;
      }
      return true;
    }"
Closure_98,/home/common/huangzhili/defects4j_buggy/Closure_98_buggy/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java,"boolean isAssignedOnceInLifetime() {
      Reference ref = getOneAndOnlyAssignment();
      if (ref == null) {
        return false;
       }
 
       // Make sure this assignment is not in a loop.
 
       return true;
     }"
Closure_100,/home/common/huangzhili/defects4j_buggy/Closure_100_buggy/src/com/google/javascript/jscomp/CheckGlobalThis.java,"private boolean shouldReportThis(Node n, Node parent) {
    if (assignLhsChild != null) {
      // Always report a THIS on the left side of an assign.
      return true;
     }
 
     // Also report a THIS with a property access.
     return false;
   }"
Closure_100,/home/common/huangzhili/defects4j_buggy/Closure_100_buggy/src/com/google/javascript/jscomp/CheckGlobalThis.java,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // annotation.
      JSDocInfo jsDoc = getFunctionJsDocInfo(n);
      if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {
        return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
       // var a = function() { }; // or
       // function a() {} // or
       // a.x = function() {};
     }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();
      
      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
        if (lhs.getType() == Token.GETPROP) {
          if (lhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
          String leftName = lhs.getQualifiedName();
          if (leftName != null && leftName.contains("".prototype."")) {
            return false;
          }
        }
      }
    }

    return true;
  }"
Closure_103,/home/common/huangzhili/defects4j_buggy/Closure_103_buggy/src/com/google/javascript/jscomp/DisambiguateProperties.java,"@Override public ObjectType getTypeWithProperty(String field, JSType type) {
      if (!(type instanceof ObjectType)) {
        if (type.autoboxesTo() != null) {
          type = type.autoboxesTo();
        } else {
          return null;
        }
      }

      // Ignore the prototype itself at all times.
      if (""prototype"".equals(field)) {
        return null;
      }

      // We look up the prototype chain to find the highest place (if any) that
      // this appears.  This will make references to overriden properties look
      // like references to the initial property, so they are renamed alike.
      ObjectType foundType = null;
      ObjectType objType = ObjectType.cast(type);
      while (objType != null && objType.getImplicitPrototype() != objType) {
        if (objType.hasOwnProperty(field)) {
          foundType = objType;
        }
        objType = objType.getImplicitPrototype();
       }
       // If the property does not exist on the referenced type but the original
       // type is an object type, see if any subtype has the property.
         // getGreatestSubtypeWithProperty does not guarantee that the property
         // is defined on the returned type, it just indicates that it might be,
         // so we have to double check.
       return foundType;
     }"
Closure_103,/home/common/huangzhili/defects4j_buggy/Closure_103_buggy/src/com/google/javascript/jscomp/ControlFlowAnalysis.java,"private static boolean mayThrowException(Node n) {
    switch (n.getType()) {
      case Token.CALL:
      case Token.GETPROP:
      case Token.GETELEM:
      case Token.THROW:
      case Token.NEW:
       case Token.ASSIGN:
       case Token.INC:
       case Token.DEC:
         return true;
       case Token.FUNCTION:
         return false;
    }
    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
      if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {
        return true;
      }
    }
    return false;
  }"
Closure_106,/home/common/huangzhili/defects4j_buggy/Closure_106_buggy/src/com/google/javascript/jscomp/GlobalNamespace.java,"boolean canCollapseUnannotatedChildNames() {
      if (type == Type.OTHER || globalSets != 1 || localSets != 0) {
        return false;
      }

       // Don't try to collapse if the one global set is a twin reference.
       // We could theoretically handle this case in CollapseProperties, but
       // it's probably not worth the effort.
 
       if (isClassOrEnum) {
         return true;
      }
      return (type == Type.FUNCTION || aliasingGets == 0) &&
          (parent == null || parent.canCollapseUnannotatedChildNames());
    }"
Closure_108,/home/common/huangzhili/defects4j_buggy/Closure_108_buggy/src/com/google/javascript/jscomp/ScopedAliases.java,"private void findAliases(NodeTraversal t) {
      Scope scope = t.getScope();
      for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        Node parent = n.getParent();
        boolean isVar = parent.isVar();
        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);
        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
          recordAlias(v);
        } else if (v.isBleedingFunction()) {
          // Bleeding functions already get a BAD_PARAMETERS error, so just
          // do nothing.
        } else if (parent.getType() == Token.LP) {
          // Parameters of the scope function also get a BAD_PARAMETERS
          // error.
        } else if (isVar || isFunctionDecl) {
          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);
          Node grandparent = parent.getParent();
          Node value = v.getInitialValue() != null ?
              v.getInitialValue() :
              null;
          Node varNode = null;

          String name = n.getString();
          int nameCount = scopedAliasNames.count(name);
          scopedAliasNames.add(name);
          String globalName =
              ""$jscomp.scope."" + name + (nameCount == 0 ? """" : (""$"" + nameCount));

          compiler.ensureLibraryInjected(""base"");

          // First, we need to free up the function expression (EXPR)
          // to be used in another expression.
          if (isFunctionDecl) {
            // Replace ""function NAME() { ... }"" with ""var NAME;"".
            Node existingName = v.getNameNode();

            // We can't keep the local name on the function expression,
            // because IE is buggy and will leak the name into the global
            // scope. This is covered in more detail here:
            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf
            //
            // This will only cause problems if this is a hoisted, recursive
            // function, and the programmer is using the hoisting.
            Node newName = IR.name("""").useSourceInfoFrom(existingName);
            value.replaceChild(existingName, newName);

            varNode = IR.var(existingName).useSourceInfoFrom(existingName);
            grandparent.replaceChild(parent, varNode);
          } else {
            if (value != null) {
              // If this is a VAR, we can just detach the expression and
              // the tree will still be valid.
              value.detachFromParent();
            }
            varNode = parent;
          }

          // Add $jscomp.scope.name = EXPR;
          // Make sure we copy over all the jsdoc and debug info.
          if (value != null || v.getJSDocInfo() != null) {
            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(
                compiler.getCodingConvention(),
                globalName,
                value,
                v.getJSDocInfo())
                .useSourceInfoIfMissingFromForTree(n);
            NodeUtil.setDebugInformation(
                newDecl.getFirstChild().getFirstChild(), n, name);

            if (isHoisted) {
              grandparent.addChildToFront(newDecl);
             } else {
               grandparent.addChildBefore(newDecl, varNode);
             }
           }
 
           // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;""
          v.getNameNode().addChildToFront(
              NodeUtil.newQualifiedNameNode(
                  compiler.getCodingConvention(), globalName, n, name));

          recordAlias(v);
        } else {
          // Do not other kinds of local symbols, like catch params.
          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
      }
    }"
Closure_108,/home/common/huangzhili/defects4j_buggy/Closure_108_buggy/src/com/google/javascript/jscomp/ScopedAliases.java,"@Override
    public void exitScope(NodeTraversal t) {
      if (t.getScopeDepth() > 2) {
        findNamespaceShadows(t);
      }
 
       if (t.getScopeDepth() == 2) {
         renameNamespaceShadows(t);
         aliases.clear();
         forbiddenLocals.clear();
         transformation = null;
        hasNamespaceShadows = false;
      }
    }"
Closure_108,/home/common/huangzhili/defects4j_buggy/Closure_108_buggy/src/com/google/javascript/jscomp/ScopedAliases.java,"@Override
    public void visit(NodeTraversal t, Node n, Node parent) {
      if (isCallToScopeMethod(n)) {
        validateScopeCall(t, n, n.getParent());
      }

      if (t.getScopeDepth() < 2) {
        return;
      }

      int type = n.getType();
      Var aliasVar = null;
      if (type == Token.NAME) {
        String name = n.getString();
        Var lexicalVar = t.getScope().getVar(n.getString());
        if (lexicalVar != null && lexicalVar == aliases.get(name)) {
          aliasVar = lexicalVar;
        }
      }

      // Validate the top-level of the goog.scope block.
      if (t.getScopeDepth() == 2) {
        if (aliasVar != null && NodeUtil.isLValue(n)) {
          if (aliasVar.getNode() == n) {
            aliasDefinitionsInOrder.add(n);

            // Return early, to ensure that we don't record a definition
            // twice.
            return;
          } else {
            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());
          }
        }

        if (type == Token.RETURN) {
          report(t, n, GOOG_SCOPE_USES_RETURN);
        } else if (type == Token.THIS) {
          report(t, n, GOOG_SCOPE_REFERENCES_THIS);
        } else if (type == Token.THROW) {
          report(t, n, GOOG_SCOPE_USES_THROW);
        }
      }

      // Validate all descendent scopes of the goog.scope block.
      if (t.getScopeDepth() >= 2) {
        // Check if this name points to an alias.
        if (aliasVar != null) {
          // Note, to support the transitive case, it's important we don't
          // clone aliasedNode here.  For example,
          // var g = goog; var d = g.dom; d.createElement('DIV');
          // The node in aliasedNode (which is ""g"") will be replaced in the
          // changes pass above with ""goog"".  If we cloned here, we'd end up
          // with <code>g.dom.createElement('DIV')</code>.
          aliasUsages.add(new AliasedNode(aliasVar, n));
        }

         // When we inject declarations, we duplicate jsdoc. Make sure
         // we only process that jsdoc once.
         JSDocInfo info = n.getJSDocInfo();
         if (info != null) {
           for (Node node : info.getTypeNodes()) {
             fixTypeNode(node);
           }
        }

        // TODO(robbyw): Error for goog.scope not at root.
      }
    }"
Closure_110,/home/common/huangzhili/defects4j_buggy/Closure_110_buggy/src/com/google/javascript/rhino/Node.java,"public Node getChildBefore(Node child) {
    if (child == first) {
       return null;
     }
     Node n = first;
 
     while (n.next != child) {
       n = n.next;
      if (n == null) {
        throw new RuntimeException(""node is not a child"");
      }
    }
    return n;
  }"
Closure_110,/home/common/huangzhili/defects4j_buggy/Closure_110_buggy/src/com/google/javascript/jscomp/ScopedAliases.java,"private void findAliases(NodeTraversal t) {
      Scope scope = t.getScope();
      for (Var v : scope.getVarIterable()) {
         Node n = v.getNode();
         Node parent = n.getParent();
         boolean isVar = parent.isVar();
         if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
           recordAlias(v);
         } else if (v.isBleedingFunction()) {
          // Bleeding functions already get a BAD_PARAMETERS error, so just
          // do nothing.
        } else if (parent.getType() == Token.LP) {
          // Parameters of the scope function also get a BAD_PARAMETERS
          // error.
        } else if (isVar) {
          Node grandparent = parent.getParent();
          Node value = n.hasChildren() ?
              v.getInitialValue().detachFromParent() :
              null;
          Node varNode = parent;

          String name = n.getString();
          int nameCount = scopedAliasNames.count(name);
          scopedAliasNames.add(name);
          String globalName =
              ""$jscomp.scope."" + name + (nameCount == 0 ? """" : (""$"" + nameCount));

          compiler.ensureLibraryInjected(""base"");

          // First, we need to free up the function expression (EXPR)
          // to be used in another expression.
            // Replace ""function NAME() { ... }"" with ""var NAME;"".

            // We can't keep the local name on the function expression,
            // because IE is buggy and will leak the name into the global
            // scope. This is covered in more detail here:
            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf
            //
            // This will only cause problems if this is a hoisted, recursive
            // function, and the programmer is using the hoisting.

              // If this is a VAR, we can just detach the expression and
              // the tree will still be valid.

          // Add $jscomp.scope.name = EXPR;
          // Make sure we copy over all the jsdoc and debug info.
          if (value != null || v.getJSDocInfo() != null) {
            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(
                compiler.getCodingConvention(),
                globalName,
                value,
                v.getJSDocInfo())
                .useSourceInfoIfMissingFromForTree(n);
            NodeUtil.setDebugInformation(
                newDecl.getFirstChild().getFirstChild(), n, name);

              grandparent.addChildBefore(newDecl, varNode);
          }

          // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;""
          v.getNameNode().addChildToFront(
              NodeUtil.newQualifiedNameNode(
                  compiler.getCodingConvention(), globalName, n, name));

          recordAlias(v);
        } else {
          // Do not other kinds of local symbols, like catch params.
          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
      }
    }"
Closure_127,/home/common/huangzhili/defects4j_buggy/Closure_127_buggy/src/com/google/javascript/jscomp/UnreachableCodeElimination.java,"    private Node computeFollowing(Node n) {
      Node next = ControlFlowAnalysis.computeFollowNode(n);
      while (next != null && next.isBlock()) {
        if (next.hasChildren()) {
          next = next.getFirstChild();
        } else {
          next = computeFollowing(next);
        }
      }
      return next;
    }
"
Closure_134,/home/common/huangzhili/defects4j_buggy/Closure_134_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"private FunctionType findOverriddenFunction(
        ObjectType ownerType, String propName) {
      // First, check to see if the property is implemented
      // on a superclass.
       JSType propType = ownerType.getPropertyType(propName);
       if (propType instanceof FunctionType) {
         return (FunctionType) propType;
       }
         // If it's not, then check to see if it's implemented
         // on an implemented interface.
 
       return null;
     }"
Closure_134,/home/common/huangzhili/defects4j_buggy/Closure_134_buggy/src/com/google/javascript/jscomp/AmbiguateProperties.java,"private void addNonUnionType(JSType newType) {
      if (skipAmbiguating || isInvalidatingType(newType)) {
        skipAmbiguating = true;
         return;
       }
 
       if (type == null) {
         type = newType;
       } else {
         type = type.getLeastSupertype(newType);
       }
       typesSet.set(getIntForType(newType));
     }"
Closure_134,/home/common/huangzhili/defects4j_buggy/Closure_134_buggy/src/com/google/javascript/jscomp/AmbiguateProperties.java,"public void process(Node externs, Node root) {
    NodeTraversal.traverse(compiler, externs, new ProcessExterns());
    NodeTraversal.traverse(compiler, root, new ProcessProperties());

    Set<String> reservedNames =
        new HashSet<String>(externedNames.size() + quotedNames.size());
    reservedNames.addAll(externedNames);
    reservedNames.addAll(quotedNames);

    int numRenamedPropertyNames = 0;
    int numSkippedPropertyNames = 0;
    Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);
     for (Property p : propertyMap.values()) {
       if (!p.skipAmbiguating) {
         ++numRenamedPropertyNames;
         computeRelatedTypes(p.type);
         propsByFreq.add(p);
       } else {
         ++numSkippedPropertyNames;
        reservedNames.add(p.oldName);
      }
    }

    PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));
    GraphColoring<Property, Void> coloring =
        new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR);
    int numNewPropertyNames = coloring.color();

    NameGenerator nameGen = new NameGenerator(
        reservedNames, """", reservedCharacters);
    for (int i = 0; i < numNewPropertyNames; ++i) {
      colorMap.put(i, nameGen.generateNextName());
    }
    for (GraphNode<Property, Void> node : graph.getNodes()) {
      node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());
      renamingMap.put(node.getValue().oldName, node.getValue().newName);
    }

    // Update the string nodes.
    for (Node n : stringNodesToRename) {
      String oldName = n.getString();
      Property p = propertyMap.get(oldName);
      if (p != null && p.newName != null) {
        Preconditions.checkState(oldName.equals(p.oldName));
        if (!p.newName.equals(oldName)) {
          n.setString(p.newName);
          compiler.reportCodeChange();
        }
      }
    }

    logger.info(""Collapsed "" + numRenamedPropertyNames + "" properties into ""
                + numNewPropertyNames + "" and skipped renaming ""
                + numSkippedPropertyNames + "" properties."");
  }"
Closure_134,/home/common/huangzhili/defects4j_buggy/Closure_134_buggy/src/com/google/javascript/jscomp/AmbiguateProperties.java,"public boolean isIndependentOf(Property prop) {
       if (typesRelatedToSet.intersects(prop.typesSet)) {
         return false;
       }
       return !getRelated(prop.type).intersects(typesInSet);
     }"
Closure_134,/home/common/huangzhili/defects4j_buggy/Closure_134_buggy/src/com/google/javascript/jscomp/AmbiguateProperties.java,"public void addNode(Property prop) {
       typesInSet.or(prop.typesSet);
       typesRelatedToSet.or(getRelated(prop.type));
     }"
Closure_135,/home/common/huangzhili/defects4j_buggy/Closure_135_buggy/src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java,"private void replaceReferencesToThis(Node node, String name) {
    if (NodeUtil.isFunction(node)) {
      return;
    }

     for (Node child : node.children()) {
       if (NodeUtil.isThis(child)) {
         Node newName = Node.newString(Token.NAME, name);
         node.replaceChild(child, newName);
       } else {
         replaceReferencesToThis(child, name);
      }
    }
  }"
Closure_135,/home/common/huangzhili/defects4j_buggy/Closure_135_buggy/src/com/google/javascript/rhino/jstype/FunctionType.java,"@Override
  boolean defineProperty(String name, JSType type,
      boolean inferred, boolean inExterns) {
     if (""prototype"".equals(name)) {
       ObjectType objType = type.toObjectType();
       if (objType != null) {
         return setPrototype(
             new FunctionPrototypeType(
                 registry, this, objType, isNativeObjectType()));
      } else {
        return false;
      }
    }
    return super.defineProperty(name, type, inferred, inExterns);
  }"
Closure_136,/home/common/huangzhili/defects4j_buggy/Closure_136_buggy/src/com/google/javascript/jscomp/RenameVars.java,"@Override
    public void visit(NodeTraversal t, Node n, Node parent) {
      if (n.getType() != Token.NAME) {
        return;
      }

      String name = n.getString();

      // Ignore anonymous functions
      if (name.length() == 0) {
        return;
      }

      // Is this local or Global?
      Scope.Var var = t.getScope().getVar(name);
      boolean local = (var != null) && var.isLocal();

      // Are we renaming global variables?
      if (!local && localRenamingOnly) {
        reservedNames.add(name);
        return;
      }

      // Are we renaming anonymous function names?
      if (preserveAnonymousFunctionNames
          && var != null
          && NodeUtil.isAnonymousFunction(var.getParentNode())) {
        reservedNames.add(name);
        return;
      }
 
       // Check if we can rename this.
       if (!okToRenameVar(name, local)) {
           // Blindly de-uniquify for the Prototype library for issue 103.
         return;
       }
 
      if (isExternsPass_) {
        // Keep track of extern globals.
        if (!local) {
          externNames.add(name);
        }
        return;
      }

      if (local) {
        // Local var: assign a new name
        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();
        incCount(tempName, null);
        localNameNodes.add(n);
        localTempNames.add(tempName);
      } else if (var != null) {  // Not an extern
        // If it's global, increment global count
        incCount(name, var.input);
        globalNameNodes.add(n);
      }
    }"
Closure_137,/home/common/huangzhili/defects4j_buggy/Closure_137_buggy/src/com/google/javascript/jscomp/Normalize.java,"@Override
   public void process(Node externs, Node root) {
     NodeTraversal.traverse(compiler, root,
         new NormalizeStatements(compiler, assertOnChange));
     removeDuplicateDeclarations(root);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
      t.traverseRoots(externs, root);
    }
    // It is important that removeDuplicateDeclarations runs after
    // MakeDeclaredNamesUnique in order for catch block exception names to be
    // handled properly. Specifically, catch block exception names are
    // only valid within the catch block, but our currect Scope logic
    // has no concept of this and includes it in the containing function 
    // (or global scope). MakeDeclaredNamesUnique makes the catch exception
    // names unique so that removeDuplicateDeclarations() will properly handle
    // cases where a function scope variable conflict with a exception name:
    //   function f() {
    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}
    //      var e = 1; // f scope 'e'
    //   }
    // otherwise 'var e = 1' would be rewritten as 'e = 1'.
    // TODO(johnlenz): Introduce a seperate scope for catch nodes. 
    new PropogateConstantAnnotations(compiler, assertOnChange)
        .process(externs, root);
  }"
Closure_137,/home/common/huangzhili/defects4j_buggy/Closure_137_buggy/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java,"@Override
    public void addDeclaredName(String name) {
        if (global) {
          reserveName(name);
        } else {
          // It hasn't been declared locally yet, so increment the count.
          if (!declarations.containsKey(name)) {
            int id = incrementNameCount(name);
             String newName = null;
             if (id != 0) {
               newName = getUniqueName(name, id);
           }
           declarations.put(name, newName);
         }
       }
     }"
Closure_138,/home/common/huangzhili/defects4j_buggy/Closure_138_buggy/src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java,"@Override
  public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,
      FlowScope blindScope, boolean outcome) {
    if (condition.getType() == CALL && condition.getChildCount() == 2) {
      Node callee = condition.getFirstChild();
      Node param = condition.getLastChild();
      if (callee.getType() == GETPROP && param.isQualifiedName()) {
        JSType paramType =  getTypeIfRefinable(param, blindScope);
        if (paramType != null) {
        Node left = callee.getFirstChild();
        Node right = callee.getLastChild();
        if (left.getType() == NAME && ""goog"".equals(left.getString()) &&
            right.getType() == STRING) {
          Function<TypeRestriction, JSType> restricter =
              restricters.get(right.getString());
           if (restricter != null) {
             return restrictParameter(param, paramType, blindScope, restricter,
                 outcome);
             }
           }
         }
       }
    }
    return nextPreciserScopeKnowingConditionOutcome(
        condition, blindScope, outcome);
  }"
Closure_138,/home/common/huangzhili/defects4j_buggy/Closure_138_buggy/src/com/google/javascript/jscomp/TypeInference.java,"private FlowScope traverseName(Node n, FlowScope scope) {
    String varName = n.getString();
    Node value = n.getFirstChild();
    JSType type = n.getJSType();
    if (value != null) {
      scope = traverse(value, scope);
      updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */,
          getJSType(value));
       return scope;
     } else {
       StaticSlot<JSType> var = scope.getSlot(varName);
       if (var != null &&
           !(var.isTypeInferred() && unflowableVarNames.contains(varName))) {
         // There are two situations where we don't want to use type information
         // from the scope, even if we have it.
 
         // 1) The var is escaped in a weird way, e.g.,
         // function f() { var x = 3; function g() { x = null } (x); }
 
         // 2) We're reading type information from another scope for an
         // inferred variable.
         // var t = null; function f() { (t); }
 
           type = var.getType();
           if (type == null) {
             type = getNativeType(UNKNOWN_TYPE);
         }
       }
     }
    n.setJSType(type);
    return scope;
  }"
Closure_139,/home/common/huangzhili/defects4j_buggy/Closure_139_buggy/src/com/google/javascript/jscomp/Normalize.java,"@Override
    public void onRedeclaration(
         Scope s, String name, Node n, Node parent, Node gramps,
         Node nodeWithLineNumber) {
       Preconditions.checkState(n.getType() == Token.NAME);
       if (parent.getType() == Token.VAR) {
       // If name is ""arguments"", Var maybe null.
         Preconditions.checkState(parent.hasOneChild());
 
         replaceVarWithAssignment(n, parent, gramps);
      }
    }"
Closure_139,/home/common/huangzhili/defects4j_buggy/Closure_139_buggy/src/com/google/javascript/jscomp/Normalize.java,"@Override
    public void visit(NodeTraversal t, Node n, Node parent) {
      switch (n.getType()) {
        case Token.WHILE:
          if (CONVERT_WHILE_TO_FOR) {
            Node expr = n.getFirstChild();
            n.setType(Token.FOR);
            n.addChildBefore(new Node(Token.EMPTY), expr);
            n.addChildAfter(new Node(Token.EMPTY), expr);
            reportCodeChange(""WHILE node"");
           }
           break;
 
       }
     }"
Closure_140,/home/common/huangzhili/defects4j_buggy/Closure_140_buggy/src/com/google/javascript/jscomp/Compiler.java,"public void init(JSSourceFile[] externs, JSModule[] modules,
      CompilerOptions options) {
     initOptions(options);
 
     checkFirstModule(modules);
 
     this.externs = makeCompilerInput(externs, true);
     this.modules = modules;
    // Generate the module graph, and report any errors in the module
    // specification as errors.
    try {
      this.moduleGraph = new JSModuleGraph(modules);
    } catch (JSModuleGraph.ModuleDependenceException e) {
      // problems with the module format.  Report as an error.  The
      // message gives all details.
      report(JSError.make(MODULE_DEPENDENCY_ERROR,
          e.getModule().getName(), e.getDependentModule().getName()));
      return;
    }
    this.inputs = getAllInputsFromModules();
    initBasedOnOptions();

    initInputsByNameMap();
  }"
Closure_140,/home/common/huangzhili/defects4j_buggy/Closure_140_buggy/src/com/google/javascript/jscomp/Compiler.java,"@Override
  Node getNodeForCodeInsertion(JSModule module) {
    if (module == null) {
      if (inputs.length == 0) {
        throw new IllegalStateException(""No inputs"");
      }

      return inputs[0].getAstRoot(this);
    }

    List<CompilerInput> inputs = module.getInputs();
     if (inputs.size() > 0) {
       return inputs.get(0).getAstRoot(this);
     }
     for (JSModule m : getModuleGraph().getTransitiveDepsDeepestFirst(module)) {
       inputs = m.getInputs();
       if (inputs.size() > 0) {
         return inputs.get(0).getAstRoot(this);
       }
     }
     throw new IllegalStateException(""Root module has no inputs"");
   }"
Closure_141,/home/common/huangzhili/defects4j_buggy/Closure_141_buggy/src/com/google/javascript/jscomp/PureFunctionIdentifier.java,"private static Collection<Definition> getCallableDefinitions(
      DefinitionProvider definitionProvider, Node name) {
      List<Definition> result = Lists.newArrayList();

      if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {
        return null;
      }
      Collection<Definition> decls =
          definitionProvider.getDefinitionsReferencedAt(name);
      if (decls == null) {
        return null;
      }

      for (Definition current : decls) {
        Node rValue = current.getRValue();
        if ((rValue != null) && NodeUtil.isFunction(rValue)) {
          result.add(current);
        } else {
          return null;
        }
      }

      return result;
  }

  /**
   * Propagate side effect information by building a graph based on
   * call site information stored in FunctionInformation and the
   * DefinitionProvider and then running GraphReachability to
   * determine the set of functions that have side effects.
   */
  private void propagateSideEffects() {
    // Nodes are function declarations; Edges are function call sites.
    DiGraph<FunctionInformation, Node> sideEffectGraph =
        new LinkedDirectedGraph<FunctionInformation, Node>();

    // create graph nodes
    for (FunctionInformation functionInfo : functionSideEffectMap.values()) {
      sideEffectGraph.createNode(functionInfo);
    }

    // add connections to called functions and side effect root.
    for (FunctionInformation functionInfo : functionSideEffectMap.values()) {
      if (!functionInfo.mayHaveSideEffects()) {"
Closure_141,/home/common/huangzhili/defects4j_buggy/Closure_141_buggy/src/com/google/javascript/jscomp/PureFunctionIdentifier.java,"private static Collection<Definition> getCallableDefinitions(
       DefinitionProvider definitionProvider, Node name) {
       List<Definition> result = Lists.newArrayList();
 
       if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {
         return null;
       }
       Collection<Definition> decls =
           definitionProvider.getDefinitionsReferencedAt(name);
       if (decls == null) {
        return null;
      }

      for (Definition current : decls) {
        Node rValue = current.getRValue();
        if ((rValue != null) && NodeUtil.isFunction(rValue)) {
          result.add(current);
        } else {
          return null;
        }
      }

      return result;
  }"
Closure_141,/home/common/huangzhili/defects4j_buggy/Closure_141_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static boolean canBeSideEffected(Node n, Set<String> knownConstants) {
    switch (n.getType()) {
      case Token.CALL:
      case Token.NEW:
        // Function calls or constructor can reference changed values.
        // TODO(johnlenz): Add some mechanism for determining that functions
        // are unaffected by side effects.
        return true;
      case Token.NAME:
        // Non-constant names values may have been changed.
        return !NodeUtil.isConstantName(n)
            && !knownConstants.contains(n.getString());

      // Properties on constant NAMEs can still be side-effected.
      case Token.GETPROP:
       case Token.GETELEM:
         return true;
 
         // Anonymous functions definitions are not changed by side-effects,
         // and named functions are not part of expressions.
     }
 
     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
      if (canBeSideEffected(c, knownConstants)) {
        return true;
      }
    }

    return false;
  }"
Closure_142,/home/common/huangzhili/defects4j_buggy/Closure_142_buggy/src/com/google/javascript/jscomp/CoalesceVariableNames.java,"@Override
  public void enterScope(NodeTraversal t) {
    // TODO(user): We CAN do this in the global scope, just need to be
    // careful when something is exported. Liveness uses bit-vector for live
    // sets so I don't see compilation time will be a problem for running this
    // pass in the global scope.
    Scope scope = t.getScope();
    if (scope.isGlobal()) {
      return;
    }
    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();

    LiveVariablesAnalysis liveness =
        new LiveVariablesAnalysis(cfg, scope, compiler);
    // If the function has exactly 2 params, mark them as escaped. This is
     // a work-around for an IE bug where it throws an exception if you
     // write to the parameters of the callback in a sort(). See:
     // http://code.google.com/p/closure-compiler/issues/detail?id=58
     liveness.analyze();
 
     UndiGraph<Var, Void> interferenceGraph =
        computeVariableNamesInterferenceGraph(
            t, cfg, liveness.getEscapedLocals());

    GraphColoring<Var, Void> coloring =
        new GreedyGraphColoring<Var, Void>(interferenceGraph,
            coloringTieBreaker);

    coloring.color();
    colorings.push(coloring);
  }"
Closure_142,/home/common/huangzhili/defects4j_buggy/Closure_142_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,"@SuppressWarnings(""fallthrough"")
  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
                                                      WhitespaceOption option) {

    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||
        token == JsDocToken.EOF) {
      return new ExtractionInfo("""", token);
    }

    stream.update();
    int startLineno = stream.getLineno();
    int startCharno = stream.getCharno() + 1;

    // Read the content from the first line.
    String line = stream.getRemainingJSDocLine();

    if (option != WhitespaceOption.PRESERVE) {
      line = line.trim();
    }

    StringBuilder builder = new StringBuilder();
    builder.append(line);

    state = State.SEARCHING_ANNOTATION;
    token = next();

    boolean ignoreStar = false;

    do {
      switch (token) {
        case STAR:
          if (!ignoreStar) {
            if (builder.length() > 0) {
              builder.append(' ');
            }

            builder.append('*');
          }

          token = next();
          continue;

        case EOL:
          if (option != WhitespaceOption.SINGLE_LINE) {
            builder.append(""\n"");
          }

          ignoreStar = true;
          token = next();
          continue;

        case ANNOTATION:
        case EOC:
         case EOF:
           // When we're capturing a license block, annotations
           // in the block are ok.
             String multilineText = builder.toString();
 
             if (option != WhitespaceOption.PRESERVE) {
              multilineText = multilineText.trim();
            }

            int endLineno = stream.getLineno();
            int endCharno = stream.getCharno();

            if (multilineText.length() > 0) {
              jsdocBuilder.markText(multilineText, startLineno, startCharno,
                  endLineno, endCharno);
            }

            return new ExtractionInfo(multilineText, token);

          // FALL THROUGH

        default:
          ignoreStar = false;
          state = State.SEARCHING_ANNOTATION;

          if (builder.length() > 0) {
            builder.append(' ');
          }

          builder.append(toString(token));

          line = stream.getRemainingJSDocLine();

          if (option != WhitespaceOption.PRESERVE) {
            line = trimEnd(line);
          }

          builder.append(line);
          token = next();
      }
    } while (true);
  }"
Closure_143,/home/common/huangzhili/defects4j_buggy/Closure_143_buggy/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java,"@VisibleForTesting
  static void createDefineReplacements(List<String> definitions,
      CompilerOptions options) {
    // Parse the definitions
    for (String override : definitions) {
      String[] assignment = override.split(""="", 2);
      String defName = assignment[0];

      if (defName.length() > 0) {
        if (assignment.length == 1) {
          options.setDefineToBooleanLiteral(defName, true);
          continue;
        } else {
          String defValue = assignment[1];

          if (defValue.equals(""true"")) {
            options.setDefineToBooleanLiteral(defName, true);
            continue;
          } else if (defValue.equals(""false"")) {
            options.setDefineToBooleanLiteral(defName, false);
            continue;
           } else if (defValue.length() > 1
               && ((defValue.charAt(0) == '\'' &&
                   defValue.charAt(defValue.length() - 1) == '\'')
             )) {
             // If the value starts and ends with a single quote,
             // we assume that it's a string.
             String maybeStringVal =
                defValue.substring(1, defValue.length() - 1);
            if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {
              options.setDefineToStringLiteral(defName, maybeStringVal);
              continue;
            }
          } else {
            try {
              options.setDefineToDoubleLiteral(defName,
                  Double.parseDouble(defValue));
              continue;
            } catch (NumberFormatException e) {
              // do nothing, it will be caught at the end
            }
          }
        }
      }

      throw new RuntimeException(
          ""--define flag syntax invalid: "" + override);
    }
  }"
Closure_143,/home/common/huangzhili/defects4j_buggy/Closure_143_buggy/src/com/google/javascript/jscomp/RemoveConstantExpressions.java,"private void trySimplify(Node parent, Node node) {
      if (node.getType() != Token.EXPR_RESULT) {
        return;
      }
 
       Node exprBody = node.getFirstChild();
       if (!NodeUtil.nodeTypeMayHaveSideEffects(exprBody)
       ) {
         changeProxy.replaceWith(parent, node, getSideEffectNodes(exprBody));
       }
     }"
Closure_144,/home/common/huangzhili/defects4j_buggy/Closure_144_buggy/src/com/google/javascript/jscomp/FunctionTypeBuilder.java,"FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {
     returnType = info != null && info.hasReturnType() ?
         info.getReturnType().evaluate(scope, typeRegistry) :
         typeRegistry.getNativeType(UNKNOWN_TYPE);
     if (templateTypeName != null &&
         returnType.restrictByNotNullOrUndefined().isTemplateType()) {
       reportError(TEMPLATE_TYPE_EXPECTED, fnName);
     }
    return this;
  }"
Closure_144,/home/common/huangzhili/defects4j_buggy/Closure_144_buggy/src/com/google/javascript/jscomp/FunctionTypeBuilder.java,"FunctionType buildAndRegister() {
    if (returnType == null) {
      returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);
    }

    if (parametersNode == null) {
      throw new IllegalStateException(
          ""All Function types must have params and a return type"");
    }

    FunctionType fnType;
    if (isConstructor) {
      fnType = getOrCreateConstructor();
    } else if (isInterface) {
      fnType = typeRegistry.createInterfaceType(fnName, sourceNode);
      if (scope.isGlobal() && !fnName.isEmpty()) {
        typeRegistry.declareType(fnName, fnType.getInstanceType());
      }
      maybeSetBaseType(fnType);
    } else {
      fnType = new FunctionBuilder(typeRegistry)
           .withName(fnName)
           .withSourceNode(sourceNode)
           .withParamsNode(parametersNode)
           .withReturnType(returnType)
           .withTypeOfThis(thisType)
           .withTemplateName(templateTypeName)
           .build();
      maybeSetBaseType(fnType);
    }

    if (implementedInterfaces != null) {
      fnType.setImplementedInterfaces(implementedInterfaces);
    }

    typeRegistry.clearTemplateTypeName();

    return fnType;
  }"
Closure_144,/home/common/huangzhili/defects4j_buggy/Closure_144_buggy/src/com/google/javascript/rhino/jstype/FunctionType.java,"FunctionType cloneWithNewReturnType(JSType newReturnType, boolean inferred) {
     return new FunctionType(
         registry, null, null,
         new ArrowType(
             registry, call.parameters, newReturnType, inferred),
         typeOfThis, null, false, false);
  }"
Closure_144,/home/common/huangzhili/defects4j_buggy/Closure_144_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"private FunctionType getFunctionType(String name,
        Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {
      FunctionType functionType = null;

      // Handle function aliases.
      if (rValue != null && rValue.isQualifiedName()) {
        Var var = scope.getVar(rValue.getQualifiedName());
        if (var != null && var.getType() instanceof FunctionType) {
          functionType = (FunctionType) var.getType();
          if (functionType != null && functionType.isConstructor()) {
            typeRegistry.declareType(name, functionType.getInstanceType());
          }
        }
        return functionType;
      }

      Node owner = null;
      if (lvalueNode != null) {
        owner = getPrototypePropertyOwner(lvalueNode);
      }

      Node errorRoot = rValue == null ? lvalueNode : rValue;
      boolean isFnLiteral =
          rValue != null && rValue.getType() == Token.FUNCTION;
      Node fnRoot = isFnLiteral ? rValue : null;
      Node parametersNode = isFnLiteral ?
          rValue.getFirstChild().getNext() : null;

      if (functionType == null && info != null && info.hasType()) {
        JSType type = info.getType().evaluate(scope, typeRegistry);

        // Known to be not null since we have the FUNCTION token there.
        type = type.restrictByNotNullOrUndefined();
        if (type.isFunctionType()) {
          functionType = (FunctionType) type;
          functionType.setJSDocInfo(info);
        }
      }

      if (functionType == null) {
        if (info == null ||
            !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {
          // We don't really have any type information in the annotation.
          // Before we give up on this function, look at the object we're
          // assigning it to. For example, if the function looks like this:
          // SubFoo.prototype.bar = function() { ... };
          // We can use type information on Foo.prototype.bar and apply it
          // to this function.
          if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP &&
              lvalueNode.isQualifiedName()) {
            Var var = scope.getVar(
                lvalueNode.getFirstChild().getQualifiedName());
            if (var != null) {
              ObjectType ownerType = ObjectType.cast(var.getType());
              FunctionType propType = null;
              if (ownerType != null) {
                String propName = lvalueNode.getLastChild().getString();
                propType = findOverriddenFunction(ownerType, propName);
              }

              if (propType != null) {
                functionType =
                    new FunctionTypeBuilder(
                        name, compiler, errorRoot, sourceName, scope)
                     .setSourceNode(fnRoot)
                     .inferFromOverriddenFunction(propType, parametersNode)
                     .inferThisType(info, owner)
                     .buildAndRegister();
               }
             }
          }
        }
      } // end if (functionType == null)

      if (functionType == null) {
        functionType =
            new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,
                scope)
            .setSourceNode(fnRoot)
            .inferTemplateTypeName(info)
            .inferReturnType(info)
            .inferInheritance(info)
            .inferThisType(info, owner)
            .inferParameterTypes(parametersNode, info)
            .buildAndRegister();
      }

      // assigning the function type to the function node
      if (rValue != null) {
        setDeferredType(rValue, functionType);
      }

      // all done
      return functionType;
    }"
Closure_147,/home/common/huangzhili/defects4j_buggy/Closure_147_buggy/src/com/google/javascript/jscomp/RuntimeTypeCheck.java,"    private void visitFunction(NodeTraversal t, Node n) {
      FunctionType funType = (FunctionType) n.getJSType();
      Node block = n.getLastChild();
      Node paramName = NodeUtil.getFnParameters(n).getFirstChild();
      Node insertionPoint = null;

      // To satisfy normalization constraints, the type checking must be
      // added after any inner function declarations.

      for (Node paramType : funType.getParameters()) {
        // Can this ever happen?
        if (paramName == null) {
          return;
        }

        Node checkNode = createCheckTypeCallNode(
            paramType.getJSType(), paramName.cloneTree());

        if (checkNode == null) {
          // We don't know how to check this parameter type.
          paramName = paramName.getNext();
          continue;
        }

        checkNode = new Node(Token.EXPR_RESULT, checkNode);
        if (insertionPoint == null) {
          block.addChildToFront(checkNode);
        } else {
          block.addChildAfter(checkNode, insertionPoint);
        }

        compiler.reportCodeChange();
        paramName = paramName.getNext();
        insertionPoint = checkNode;
      }
    }
"
Closure_147,/home/common/huangzhili/defects4j_buggy/Closure_147_buggy/src/com/google/javascript/jscomp/CheckGlobalThis.java,"  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

    if (n.getType() == Token.FUNCTION) {
      // Don't traverse functions that are constructors or have the @this
      // or @override annotation.
      JSDocInfo jsDoc = getFunctionJsDocInfo(n);
      if (jsDoc != null &&
          (jsDoc.isConstructor() ||
           jsDoc.isInterface() ||
           jsDoc.hasThisType() ||
           jsDoc.isOverride())) {
        return false;
      }

      // Don't traverse functions unless they would normally
      // be able to have a @this annotation associated with them. e.g.,
      // var a = function() { }; // or
      // function a() {} // or
      // a.x = function() {}; // or
      // var a = {x: function() {}};
      int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN)) {
        return false;
      }
    }

    if (parent != null && parent.getType() == Token.ASSIGN) {
      Node lhs = parent.getFirstChild();
      Node rhs = lhs.getNext();

      if (n == lhs) {
        // Always traverse the left side of the assignment. To handle
        // nested assignments properly (e.g., (a = this).property = c;),
        // assignLhsChild should not be overridden.
        if (assignLhsChild == null) {
          assignLhsChild = lhs;
        }
      } else {
        // Only traverse the right side if it's not an assignment to a prototype
        // property or subproperty.
        if (NodeUtil.isGet(lhs)) {
          if (lhs.getType() == Token.GETPROP &&
              lhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
          Node llhs = lhs.getFirstChild();
          if (llhs.getType() == Token.GETPROP &&
              llhs.getLastChild().getString().equals(""prototype"")) {
            return false;
          }
        }
      }
    }

    return true;
  }
"
Closure_148,/home/common/huangzhili/defects4j_buggy/Closure_148_buggy/src/com/google/javascript/jscomp/PeepholeFoldConstants.java,"private Node tryFoldTypeof(Node originalTypeofNode) {
    Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF);

    Node argumentNode = originalTypeofNode.getFirstChild();
    if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {
      return originalTypeofNode;
    }

    String typeNameString = null;

    switch (argumentNode.getType()) {
      case Token.STRING:
        typeNameString = ""string"";
        break;
      case Token.NUMBER:
        typeNameString = ""number"";
        break;
      case Token.TRUE:
      case Token.FALSE:
        typeNameString = ""boolean"";
        break;
      case Token.NULL:
      case Token.OBJECTLIT:
       case Token.ARRAYLIT:
         typeNameString = ""object"";
         break;
       case Token.NAME:
         // We assume here that programs don't change the value of the
         // keyword undefined to something other than the value undefined.
        if (""undefined"".equals(argumentNode.getString())) {
          typeNameString = ""undefined"";
        }
        break;
    }

    if (typeNameString != null) {
      Node newNode = Node.newString(typeNameString);
      originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode);
      reportCodeChange();

      return newNode;
    }

    return originalTypeofNode;
  }"
Closure_148,/home/common/huangzhili/defects4j_buggy/Closure_148_buggy/src/com/google/javascript/jscomp/SourceMap.java,"void addMapping(Node node, Position startPosition, Position endPosition) {
    String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP);

    // If the node does not have an associated source file or
    // its line number is -1, then the node does not have sufficient
    // information for a mapping to be useful.
    if (sourceFile == null || node.getLineno() < 0) {
       return;
     }
 
     String escapedSourceFile;
     if (lastSourceFile != sourceFile) {  // yes, ""s1 != s2"" not ""!s1.equals(s2)""
       lastSourceFile = sourceFile;
       lastSourceFileEscaped = escapeString(sourceFile);
     }
     escapedSourceFile = lastSourceFileEscaped;
     // Create the new mapping.
     Mapping mapping = new Mapping();
     mapping.id = mappings.size();
     mapping.sourceFile = escapedSourceFile;
     mapping.originalPosition = new Position(node.getLineno(), node.getCharno());
 
     String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);
     if (originalName != null) {
       mapping.originalName = escapeString(originalName);
     }
 
       // If the mapping is found on the first line, we need to offset
       // its character position by the number of characters found on
       // the *last* line of the source file to which the code is
      // being generated.
      int offsetLine = offsetPosition.getLineNumber();
      int startOffsetPosition = offsetPosition.getCharacterIndex();
      int endOffsetPosition = offsetPosition.getCharacterIndex();

      if (startPosition.getLineNumber() > 0) {
        startOffsetPosition = 0;
      }

      if (endPosition.getLineNumber() > 0) {
        endOffsetPosition = 0;
      }

      mapping.startPosition =
          new Position(startPosition.getLineNumber() + offsetLine,
                       startPosition.getCharacterIndex() + startOffsetPosition);

      mapping.endPosition =
          new Position(endPosition.getLineNumber() + offsetLine,
                       endPosition.getCharacterIndex() + endOffsetPosition);

    mappings.add(mapping);
  }"
Closure_148,/home/common/huangzhili/defects4j_buggy/Closure_148_buggy/src/com/google/javascript/jscomp/SourceMap.java,"public void appendTo(Appendable out, String name) throws IOException {
    // Write the mappings out to the file. The format of the generated
    // source map is three sections, each deliminated by a magic comment.
    //
    // The first section contains an array for each line of the generated
    // code, where each element in the array is the ID of the mapping which
    // best represents the index-th character found on that line of the
    // generated source code.
    //
    // The second section contains an array per generated line. Unused.
    //
    // The third and final section contains an array per line, each of which
    // represents a mapping with a unique ID. The mappings are added in order.
    // The array itself contains a tuple representing
    // ['source file', line, col (, 'original name')]
    //
    // Example for 2 lines of generated code (with line numbers added for
    // readability):
    //
    // 1)  /** Begin line maps. **/{ ""count"": 2 }
    // 2)  [0,0,0,0,0,0,1,1,1,1,2]
    // 3)  [2,2,2,2,2,2,3,4,4,4,4,4]
    // 4)  /** Begin file information. **/
    // 5)  []
    // 6)  []
    // 7)  /** Begin mapping definitions. **/
    // 8)  [""a.js"", 1, 34]
    // 9)  [""a.js"", 5, 2]
    // 10) [""b.js"", 1, 3, ""event""]
     // 11) [""c.js"", 1, 4]
     // 12) [""d.js"", 3, 78, ""foo""]
 
     int maxLine = findLastLine();
 
     // Add the line character maps.
     out.append(""/** Begin line maps. **/{ \""file\"" : "");
    out.append(escapeString(name));
    out.append("", \""count\"": "");
    out.append(String.valueOf(maxLine + 1));
    out.append("" }\n"");
    (new LineMapper(out)).appendLineMappings();

    // Add the source file maps.
    out.append(""/** Begin file information. **/\n"");

    // This section is unused but we need one entry per line to
    // prevent changing the format.
    for (int i = 0; i <= maxLine; ++i) {
      out.append(""[]\n"");
    }

    // Add the mappings themselves.
    out.append(""/** Begin mapping definitions. **/\n"");

    for (Mapping mapping : mappings) {
      mapping.appendTo(out);
      out.append(""\n"");
    }
  }"
Closure_148,/home/common/huangzhili/defects4j_buggy/Closure_148_buggy/src/com/google/javascript/jscomp/SourceMap.java,"void appendLineMappings() throws IOException {
      Preconditions.checkState(!mappings.isEmpty());

      // Start the first line.
      openLine();


      // And close the final line.

    /**
     * Begin the entry for a new line.
     */

    /**
     * End the entry for a line.
     */

    /**
     * Add a new char position entry.
     * @param id The mapping id to record.
     */

  /**
   * Mark any visited mapping as ""used"".
   */
    /**
     * @throws IOException
     */

    /**
     * @param m The mapping for the current code segment. null if the segment
     *     is unmapped.
     * @param line The starting line for this code segment.
     * @param col The starting column for this code segment.
     * @param endLine The ending line
     * @param endCol The ending column
     * @throws IOException
     */

  /**
   * Walk the mappings and visit each segment of the mappings, unmapped
   * segments are visited with a null mapping, unused mapping are not visited.
   */
    // The last line and column written


    // Append the line mapping entries.

      // The mapping list is ordered as a pre-order traversal.  The mapping
      // positions give us enough information to rebuild the stack and this
      // allows the building of the source map in O(n) time.
      Deque<Mapping> stack = new ArrayDeque<Mapping>();
      for (Mapping m : mappings) {
        // Find the closest ancestor of the current mapping:
        // An overlapping mapping is an ancestor of the current mapping, any
        // non-overlapping mappings are siblings (or cousins) and must be
         // closed in the reverse order of when they encountered.
         while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {
           Mapping previous = stack.pop();
           writeClosedMapping(previous);
         }
 
         // Any gaps between the current line position and the start of the
         // current mapping belong to the parent.
         Mapping parent = stack.peek();
         writeCharsBetween(parent, m);
 
         stack.push(m);
       }

      // There are no more children to be had, simply close the remaining
      // mappings in the reverse order of when they encountered.
      while (!stack.isEmpty()) {
        Mapping m = stack.pop();
        writeClosedMapping(m);
      }
      closeLine();
    }"
Closure_149,/home/common/huangzhili/defects4j_buggy/Closure_149_buggy/src/com/google/javascript/jscomp/Compiler.java,"private String toSource(Node n, SourceMap sourceMap) {
    CodePrinter.Builder builder = new CodePrinter.Builder(n);
    builder.setPrettyPrint(options.prettyPrint);
    builder.setLineBreak(options.lineBreak);
     builder.setSourceMap(sourceMap);
     builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);
 
     Charset charset = options.outputCharset;
     builder.setOutputCharset(charset);
 
     return builder.build();
  }"
Closure_149,/home/common/huangzhili/defects4j_buggy/Closure_149_buggy/src/com/google/javascript/jscomp/CommandLineRunner.java,"@Override
  protected CompilerOptions createOptions() {
    CompilerOptions options = new CompilerOptions();
    options.setCodingConvention(new ClosureCodingConvention());
    CompilationLevel level = flags.compilation_level;
    level.setOptionsForCompilationLevel(options);
    if (flags.debug) {
      level.setDebugOptionsForCompilationLevel(options);
    }

    WarningLevel wLevel = flags.warning_level;
    wLevel.setOptionsForWarningLevel(options);
    for (FormattingOption formattingOption : flags.formatting) {
      formattingOption.applyToOptions(options);
     }
 
     options.closurePass = flags.process_closure_primitives;
     initOptionsFromFlags(options);
     return options;
   }"
Closure_149,/home/common/huangzhili/defects4j_buggy/Closure_149_buggy/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java,"final protected void setRunOptions(CompilerOptions options)
      throws FlagUsageException, IOException {
    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();

    diagnosticGroups.setWarningLevels(
        options, config.jscompError, CheckLevel.ERROR);
    diagnosticGroups.setWarningLevels(
        options, config.jscompWarning, CheckLevel.WARNING);
    diagnosticGroups.setWarningLevels(
        options, config.jscompOff, CheckLevel.OFF);

    createDefineReplacements(config.define, options);

    options.manageClosureDependencies = config.manageClosureDependencies;
    options.devMode = config.jscompDevMode;
     options.setCodingConvention(config.codingConvention);
     options.setSummaryDetailLevel(config.summaryDetailLevel);
 
     inputCharset = getInputCharset();
 
     if (config.jsOutputFile.length() > 0) {
      options.jsOutputFile = config.jsOutputFile;
    }

    if (config.createSourceMap.length() > 0) {
      options.sourceMapOutputPath = config.createSourceMap;
    }
    options.sourceMapDetailLevel = config.sourceMapDetailLevel;

    if (!config.variableMapInputFile.equals("""")) {
      options.inputVariableMapSerialized =
          VariableMap.load(config.variableMapInputFile).toBytes();
    }

    if (!config.propertyMapInputFile.equals("""")) {
      options.inputPropertyMapSerialized =
          VariableMap.load(config.propertyMapInputFile).toBytes();
    }
  }"
Closure_149,/home/common/huangzhili/defects4j_buggy/Closure_149_buggy/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java,"protected int doRun() throws FlagUsageException, IOException {
    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));

    List<JSSourceFile> externsList = createExterns();
    JSSourceFile[] externs = new JSSourceFile[externsList.size()];
    externsList.toArray(externs);

    compiler = createCompiler();
    B options = createOptions();

    JSModule[] modules = null;
     Result result;
 
     setRunOptions(options);
     if (inputCharset == Charsets.UTF_8) {
       options.outputCharset = Charsets.US_ASCII;
     } else {
       options.outputCharset = inputCharset;
     }
 
     boolean writeOutputToFile = !options.jsOutputFile.isEmpty();
     if (writeOutputToFile) {
      out = toWriter(options.jsOutputFile, inputCharset.name());
    }

    List<String> jsFiles = config.js;
    List<String> moduleSpecs = config.module;
    if (!moduleSpecs.isEmpty()) {
      modules = createJsModules(moduleSpecs, jsFiles);
      result = compiler.compile(externs, modules, options);
    } else {
      List<JSSourceFile> inputList = createSourceInputs(jsFiles);
      JSSourceFile[] inputs = new JSSourceFile[inputList.size()];
      inputList.toArray(inputs);
      result = compiler.compile(externs, inputs, options);
    }

    int errCode = processResults(result, modules, options);
    // Close the output if we are writing to a file.
    if (writeOutputToFile) {
      ((Writer)out).close();
    }
    return errCode;
  }"
Closure_151,/home/common/huangzhili/defects4j_buggy/Closure_151_buggy/src/com/google/javascript/jscomp/CommandLineRunner.java,"private void initConfigFromFlags(String[] args, PrintStream err) {
    // Args4j has a different format that the old command-line parser.
    // So we use some voodoo to get the args into the format that args4j
    // expects.
    Pattern argPattern = Pattern.compile(""(--[a-zA-Z_]+)=(.*)"");
    Pattern quotesPattern = Pattern.compile(""^['\""](.*)['\""]$"");
    List<String> processedArgs = Lists.newArrayList();
    for (String arg : args) {
      Matcher matcher = argPattern.matcher(arg);
      if (matcher.matches()) {
        processedArgs.add(matcher.group(1));

        String value = matcher.group(2);
        Matcher quotesMatcher = quotesPattern.matcher(value);
        if (quotesMatcher.matches()) {
          processedArgs.add(quotesMatcher.group(1));
        } else {
          processedArgs.add(value);
        }
      } else {
        processedArgs.add(arg);
      }
    }

    CmdLineParser parser = new CmdLineParser(flags);
    isConfigValid = true;
    try {
      parser.parseArgument(processedArgs.toArray(new String[] {}));
    } catch (CmdLineException e) {
      err.println(e.getMessage());
       isConfigValid = false;
     }
 
 
     if (!isConfigValid || flags.display_help) {
       isConfigValid = false;
      parser.printUsage(err);
    } else {
      getCommandLineConfig()
          .setPrintTree(flags.print_tree)
          .setComputePhaseOrdering(flags.compute_phase_ordering)
          .setPrintAst(flags.print_ast)
          .setPrintPassGraph(flags.print_pass_graph)
          .setJscompDevMode(flags.jscomp_dev_mode)
          .setLoggingLevel(flags.logging_level)
          .setExterns(flags.externs)
          .setJs(flags.js)
          .setJsOutputFile(flags.js_output_file)
          .setModule(flags.module)
          .setVariableMapInputFile(flags.variable_map_input_file)
          .setPropertyMapInputFile(flags.property_map_input_file)
          .setVariableMapOutputFile(flags.variable_map_output_file)
          .setCreateNameMapFiles(flags.create_name_map_files)
          .setPropertyMapOutputFile(flags.property_map_output_file)
          .setCodingConvention(flags.third_party ?
               new DefaultCodingConvention() :
               new ClosureCodingConvention())
          .setSummaryDetailLevel(flags.summary_detail_level)
          .setOutputWrapper(flags.output_wrapper)
          .setOutputWrapperMarker(flags.output_wrapper_marker)
          .setModuleWrapper(flags.module_wrapper)
          .setModuleOutputPathPrefix(flags.module_output_path_prefix)
          .setCreateSourceMap(flags.create_source_map)
          .setJscompError(flags.jscomp_error)
          .setJscompWarning(flags.jscomp_warning)
          .setJscompOff(flags.jscomp_off)
          .setDefine(flags.define)
          .setCharset(flags.charset)
          .setManageClosureDependencies(flags.manage_closure_dependencies)
          .setOutputManifest(flags.output_manifest);
    }
  }"
Closure_153,/home/common/huangzhili/defects4j_buggy/Closure_153_buggy/src/com/google/javascript/jscomp/SyntacticScopeCreator.java,"private void scanRoot(Node n, Scope parent) {
    if (n.getType() == Token.FUNCTION) {
      sourceName = (String) n.getProp(Node.SOURCENAME_PROP);

      final Node fnNameNode = n.getFirstChild();
      final Node args = fnNameNode.getNext();
      final Node body = args.getNext();

      // Bleed the function name into the scope, if it hasn't
       // been declared in the outer scope.
       String fnName = fnNameNode.getString();
       if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {
         declareVar(fnName, fnNameNode, n, null, null, n);
       }
 
       // Args: Declare function variables
      Preconditions.checkState(args.getType() == Token.LP);
      for (Node a = args.getFirstChild(); a != null;
           a = a.getNext()) {
        Preconditions.checkState(a.getType() == Token.NAME);
        declareVar(a.getString(), a, args, n, null, n);
      }

      // Body
      scanVars(body, n);
    } else {
      // It's the global block
      Preconditions.checkState(scope.getParent() == null);
      scanVars(n, null);
    }
  }"
Closure_153,/home/common/huangzhili/defects4j_buggy/Closure_153_buggy/src/com/google/javascript/jscomp/SyntacticScopeCreator.java,"void onRedeclaration(
         Scope s, String name,
         Node n, Node parent, Node gramps, Node nodeWithLineNumber);"
Closure_153,/home/common/huangzhili/defects4j_buggy/Closure_153_buggy/src/com/google/javascript/jscomp/SyntacticScopeCreator.java,"private void scanVars(Node n, Node parent) {
    switch (n.getType()) {
      case Token.VAR:
        // Declare all variables. e.g. var x = 1, y, z;
        for (Node child = n.getFirstChild();
             child != null;) {
          Node next = child.getNext();
          Preconditions.checkState(child.getType() == Token.NAME);
          String name = child.getString();
          declareVar(name, child, n, parent, null, n);
          child = next;
        }
        return;

      case Token.FUNCTION:
        if (NodeUtil.isFunctionExpression(n)) {
          return;
        }

        String fnName = n.getFirstChild().getString();
        if (fnName.isEmpty()) {
           // This is invalid, but allow it so the checks can catch it.
           return;
         }
         declareVar(fnName, n.getFirstChild(), n, parent, null, n);
         return;   // should not examine function's children
 
       case Token.CATCH:
        Preconditions.checkState(n.getChildCount() == 2);
        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);
        // the first child is the catch var and the third child
        // is the code block

        final Node var = n.getFirstChild();
        final Node block = var.getNext();

        declareVar(var.getString(), var, n, parent, null, n);
        scanVars(block, n);
        return;  // only one child to scan

      case Token.SCRIPT:
        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);
        break;
    }

    // Variables can only occur in statement-level nodes, so
    // we only need to traverse children in a couple special cases.
    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {
      for (Node child = n.getFirstChild();
           child != null;) {
        Node next = child.getNext();
        scanVars(child, n);
        child = next;
      }
    }
  }"
Closure_153,/home/common/huangzhili/defects4j_buggy/Closure_153_buggy/src/com/google/javascript/jscomp/Normalize.java,"@Override
    public void onRedeclaration(
        Scope s, String name, Node n, Node parent, Node gramps,
        Node nodeWithLineNumber) {
      Preconditions.checkState(n.getType() == Token.NAME);
      Var v = s.getVar(name);

        // We allow variables to be duplicate declared if one
        // declaration appears in source and the other in externs.
        // This deals with issues where a browser built-in is declared
        // in one browser but not in another.

      // If name is ""arguments"", Var maybe null.
      if (v != null && v.getParentNode().getType() == Token.CATCH) {
        // Redeclaration of a catch expression variable is hard to model
        // without support for ""with"" expressions.
        // The EcmaScript spec (section 12.14), declares that a catch
        // ""catch (e) {}"" is handled like ""with ({'e': e}) {}"" so that
        // ""var e"" would refer to the scope variable, but any following
        // reference would still refer to ""e"" of the catch expression.
        // Until we have support for this disallow it.
        // Currently the Scope object adds the catch expression to the
        // function scope, which is technically not true but a good
        // approximation for most uses.

        // TODO(johnlenz): Consider improving how scope handles catch
        // expression.

        // Use the name of the var before it was made unique.
        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(
             name);
         compiler.report(
             JSError.make(
                 NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber,
                 CATCH_BLOCK_VAR_ERROR, name));
       } else if (v != null && parent.getType() == Token.FUNCTION) {
         if (v.getParentNode().getType() == Token.VAR) {
          s.undeclare(v);
          s.declare(name, n, n.getJSType(), v.input);
          replaceVarWithAssignment(v.getNameNode(), v.getParentNode(),
              v.getParentNode().getParent());
        }
      } else if (parent.getType() == Token.VAR) {
        Preconditions.checkState(parent.hasOneChild());

        replaceVarWithAssignment(n, parent, gramps);
      }
    }"
Closure_154,/home/common/huangzhili/defects4j_buggy/Closure_154_buggy/src/com/google/javascript/jscomp/TypeValidator.java,"private void expectInterfaceProperty(NodeTraversal t, Node n,
      ObjectType instance, ObjectType implementedInterface, String prop) {
    if (!instance.hasProperty(prop)) {
      // Not implemented
      String sourceName = (String) n.getProp(Node.SOURCENAME_PROP);
      sourceName = sourceName == null ? """" : sourceName;
      if (shouldReport) {
        compiler.report(JSError.make(sourceName, n,
            INTERFACE_METHOD_NOT_IMPLEMENTED,
             prop, implementedInterface.toString(), instance.toString()));
       }
       registerMismatch(instance, implementedInterface);
         // Implemented, but not correctly typed
     }
   }"
Closure_154,/home/common/huangzhili/defects4j_buggy/Closure_154_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"private void checkDeclaredPropertyInheritance(
      NodeTraversal t, Node n, FunctionType ctorType, String propertyName,
      JSDocInfo info, JSType propertyType) {
    // If the supertype doesn't resolve correctly, we've warned about this
    // already.
    if (hasUnknownOrEmptySupertype(ctorType)) {
      return;
    }

    FunctionType superClass = ctorType.getSuperClassConstructor();
    boolean superClassHasProperty = superClass != null &&
        superClass.getPrototype().hasProperty(propertyName);
    boolean declaredOverride = info != null && info.isOverride();

    boolean foundInterfaceProperty = false;
    if (ctorType.isConstructor()) {
      for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {
        if (implementedInterface.isUnknownType() ||
            implementedInterface.isEmptyType()) {
          continue;
        }
        FunctionType interfaceType =
            implementedInterface.toObjectType().getConstructor();
        Preconditions.checkNotNull(interfaceType);
        boolean interfaceHasProperty =
            interfaceType.getPrototype().hasProperty(propertyName);
        foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;
        if (reportMissingOverride.isOn() && !declaredOverride &&
            interfaceHasProperty) {
          // @override not present, but the property does override an interface
          // property
          compiler.report(t.makeError(n, reportMissingOverride,
               HIDDEN_INTERFACE_PROPERTY, propertyName,
               interfaceType.getTopMostDefiningType(propertyName).toString()));
         }
         if (interfaceHasProperty) {
           JSType interfacePropType =
               interfaceType.getPrototype().getPropertyType(propertyName);
           if (!propertyType.canAssignTo(interfacePropType)) {
             compiler.report(t.makeError(n,
                 HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName,
                 interfaceType.getTopMostDefiningType(propertyName).toString(),
                 interfacePropType.toString(), propertyType.toString()));
           }
         }
       }
     }
 
    if (!declaredOverride && !superClassHasProperty) {
      // nothing to do here, it's just a plain new property
      return;
    }

    JSType topInstanceType = superClassHasProperty ?
        superClass.getTopMostDefiningType(propertyName) : null;
    if (reportMissingOverride.isOn() && ctorType.isConstructor() &&
        !declaredOverride && superClassHasProperty) {
      // @override not present, but the property does override a superclass
      // property
      compiler.report(t.makeError(n, reportMissingOverride,
          HIDDEN_SUPERCLASS_PROPERTY, propertyName,
          topInstanceType.toString()));
    }
    if (!declaredOverride) {
      // there's no @override to check
      return;
    }
    // @override is present and we have to check that it is ok
    if (superClassHasProperty) {
      // there is a superclass implementation
      JSType superClassPropType =
          superClass.getPrototype().getPropertyType(propertyName);
      if (!propertyType.canAssignTo(superClassPropType)) {
        compiler.report(
            t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,
                propertyName, topInstanceType.toString(),
                superClassPropType.toString(), propertyType.toString()));
      }
    } else if (!foundInterfaceProperty) {
      // there is no superclass nor interface implementation
      compiler.report(
          t.makeError(n, UNKNOWN_OVERRIDE,
              propertyName, ctorType.getInstanceType().toString()));
    }
  }"
Closure_155,/home/common/huangzhili/defects4j_buggy/Closure_155_buggy/src/com/google/javascript/jscomp/InlineVariables.java,"private void inlineNonConstants(
        Var v, ReferenceCollection referenceInfo) {
      int refCount = referenceInfo.references.size();
      Reference declaration = referenceInfo.references.get(0);
      Reference init = referenceInfo.getInitializingReference();
      int firstRefAfterInit = (declaration == init) ? 2 : 3;

      if (refCount > 1 &&
          isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        // if the variable is referenced more than once, we can only
        // inline it if it's immutable and never defined before referenced.
        Node value;
        if (init != null) {
          value = init.getAssignedValue();
        } else {
          // Create a new node for variable that is never initialized.
          Node srcLocation = declaration.getNameNode();
          value = NodeUtil.newUndefinedNode(srcLocation);
        }
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
      } else if (refCount == firstRefAfterInit) {
        // The variable likely only read once, try some more
        // complex inlining heuristics.
        Reference reference = referenceInfo.references.get(
            firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
          inline(v, declaration, init, reference);
          staleVars.add(v);
        }
      } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
          // The only reference is the initialization, remove the assignment and
          // the variable declaration.
          Node value = init.getAssignedValue();
          Preconditions.checkNotNull(value);
          inlineWellDefinedVariable(v, value, referenceInfo.references);
          staleVars.add(v);
        }
      }

      // If this variable was not inlined normally, check if we can
       // inline an alias of it. (If the variable was inlined, then the
       // reference data is out of sync. We're better off just waiting for
       // the next pass.)
       if (
           !staleVars.contains(v) && referenceInfo.isWellDefined() &&
           referenceInfo.isAssignedOnceInLifetime()) {
         List<Reference> refs = referenceInfo.references;
        for (int i = 1 /* start from a read */; i < refs.size(); i++) {
          Node nameNode = refs.get(i).getNameNode();
          if (aliasCandidates.containsKey(nameNode)) {
            AliasCandidate candidate = aliasCandidates.get(nameNode);
            if (!staleVars.contains(candidate.alias) &&
                !isVarInlineForbidden(candidate.alias)) {
              Reference aliasInit;
              aliasInit = candidate.refInfo.getInitializingReference();
              Node value = aliasInit.getAssignedValue();
              Preconditions.checkNotNull(value);
              inlineWellDefinedVariable(candidate.alias,
                  value,
                  candidate.refInfo.references);
              staleVars.add(candidate.alias);
            }
          }
        }
      }
    }"
Closure_155,/home/common/huangzhili/defects4j_buggy/Closure_155_buggy/src/com/google/javascript/jscomp/InlineVariables.java,"private void doInlinesForScope(NodeTraversal t,
         Map<Var, ReferenceCollection> referenceMap) {
 
       for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {
         Var v = it.next();
 
        ReferenceCollection referenceInfo = referenceMap.get(v);

        // referenceInfo will be null if we're in constants-only mode
        // and the variable is not a constant.
        if (referenceInfo == null || isVarInlineForbidden(v)) {
          // Never try to inline exported variables or variables that
          // were not collected or variables that have already been inlined.
          continue;
        } else if (isInlineableDeclaredConstant(v, referenceInfo)) {
          Reference init = referenceInfo.getInitializingReferenceForConstants();
          Node value = init.getAssignedValue();
          inlineDeclaredConstant(v, value, referenceInfo.references);
          staleVars.add(v);
        } else if (mode == Mode.CONSTANTS_ONLY) {
          // If we're in constants-only mode, don't run more aggressive
          // inlining heuristics. See InlineConstantsTest.
          continue;
        } else {
          inlineNonConstants(v, referenceInfo);
        }
      }
    }"
Closure_155,/home/common/huangzhili/defects4j_buggy/Closure_155_buggy/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java,"public void visit(NodeTraversal t, Node n, Node parent) {
     if (n.getType() == Token.NAME) {
       Var v = t.getScope().getVar(n.getString());
       if (v != null && varFilter.apply(v)) {
         addReference(t, v,
             new Reference(n, parent, t, blockStack.peek()));
      }
    }

    if (isBlockBoundary(n, parent)) {
      blockStack.pop();
    }
  }"
Closure_156,/home/common/huangzhili/defects4j_buggy/Closure_156_buggy/src/com/google/javascript/jscomp/CollapseProperties.java,"private void updateObjLitOrFunctionDeclarationAtAssignNode(
      Name n, String alias) {
    // NOTE: It's important that we don't add additional nodes
    // (e.g. a var node before the exprstmt) because the exprstmt might be
    // the child of an if statement that's not inside a block).

    Ref ref = n.declaration;
    Node rvalue = ref.node.getNext();
    Node varNode = new Node(Token.VAR);
    Node varParent = ref.node.getAncestor(3);
    Node gramps = ref.node.getAncestor(2);
    boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;
    boolean insertedVarNode = false;

    if (isObjLit && n.canEliminate()) {
      // Eliminate the object literal altogether.
      varParent.replaceChild(gramps, varNode);
      ref.node = null;
      insertedVarNode = true;

    } else if (!n.isSimpleName()) {
      // Create a VAR node to declare the name.
      if (rvalue.getType() == Token.FUNCTION) {
        checkForHosedThisReferences(rvalue, n.docInfo, n);
      }

      ref.node.getParent().removeChild(rvalue);

      Node nameNode = NodeUtil.newName(
          compiler.getCodingConvention(),
          alias, ref.node.getAncestor(2), n.fullName());

      if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {
        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);
      }

      varNode.addChildToBack(nameNode);
      nameNode.addChildToFront(rvalue);
      varParent.replaceChild(gramps, varNode);

      // Update the node ancestry stored in the reference.
      ref.node = nameNode;
       insertedVarNode = true;
     }
 
     if (isObjLit) {
         declareVarsForObjLitValues(
             n, alias, rvalue,
             varNode, varParent.getChildBefore(varNode), varParent);
 
     }
       addStubsForUndeclaredProperties(n, alias, varParent, varNode);
 
     if (insertedVarNode) {
       if (!varNode.hasChildren()) {
        varParent.removeChild(varNode);
      }
      compiler.reportCodeChange();
    }
  }"
Closure_156,/home/common/huangzhili/defects4j_buggy/Closure_156_buggy/src/com/google/javascript/jscomp/CollapseProperties.java,"private void updateObjLitOrFunctionDeclaration(Name n, String alias) {
    if (n.declaration == null) {
      // Some names do not have declarations, because they
      // are only defined in local scopes.
      return;
    }

    if (n.declaration.getTwin() != null) {
      // Twin declarations will get handled when normal references
      // are handled.
      return;
    }
 
     switch (n.declaration.node.getParent().getType()) {
       case Token.ASSIGN:
         updateObjLitOrFunctionDeclarationAtAssignNode(n, alias);
         break;
       case Token.VAR:
         updateObjLitOrFunctionDeclarationAtVarNode(n);
         break;
       case Token.FUNCTION:
         updateFunctionDeclarationAtFunctionNode(n);
         break;
     }
   }"
Closure_156,/home/common/huangzhili/defects4j_buggy/Closure_156_buggy/src/com/google/javascript/jscomp/CollapseProperties.java,"private void collapseDeclarationOfNameAndDescendants(Name n, String alias) {
     boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames();
 
     // Handle this name first so that nested object literals get unrolled.
     if (n.canCollapse() && canCollapseChildNames) {
       updateObjLitOrFunctionDeclaration(n, alias);
     }
 
     if (n.props != null) {
      for (Name p : n.props) {
        // Recurse first so that saved node ancestries are intact when needed.
        collapseDeclarationOfNameAndDescendants(
            p, appendPropForAlias(alias, p.name));

        if (!p.inExterns && canCollapseChildNames && p.declaration != null &&
            p.declaration.node != null &&
            p.declaration.node.getParent() != null &&
            p.declaration.node.getParent().getType() == Token.ASSIGN) {
          updateSimpleDeclaration(
              appendPropForAlias(alias, p.name), p, p.declaration);
        }
      }
    }
  }"
Closure_157,/home/common/huangzhili/defects4j_buggy/Closure_157_buggy/src/com/google/javascript/jscomp/RenamePrototypes.java,"private void processPrototypeParent(Node n, CompilerInput input) {
      switch (n.getType()) {
        // Foo.prototype.getBar = function() { ... }
        case Token.GETPROP:
        case Token.GETELEM:
          Node dest = n.getFirstChild().getNext();
          if (dest.getType() == Token.STRING) {
            markPrototypePropertyCandidate(dest, input);
          }
          break;

        // Foo.prototype = { ""getBar"" : function() { ... } }
        case Token.ASSIGN:
        case Token.CALL:
          Node map;
          if (n.getType() == Token.ASSIGN) {
            map = n.getFirstChild().getNext();
          } else {
            map = n.getLastChild();
          }
          if (map.getType() == Token.OBJECTLIT) {
            // Remember this node so that we can avoid processing it again when
            // the traversal reaches it.
            prototypeObjLits.add(map);
 
             for (Node key = map.getFirstChild();
                  key != null; key = key.getNext()) {
               if (key.getType() != Token.NUMBER) {
                // May be STRING, GET, or SET
                 markPrototypePropertyCandidate(key, input);
               }
            }
          }
          break;
      }
    }"
Closure_157,/home/common/huangzhili/defects4j_buggy/Closure_157_buggy/src/com/google/javascript/jscomp/RenamePrototypes.java,"public void visit(NodeTraversal t, Node n, Node parent) {
      switch (n.getType()) {
        case Token.GETPROP:
        case Token.GETELEM:
          Node dest = n.getFirstChild().getNext();
          if (dest.getType() == Token.STRING) {
            String s = dest.getString();
            if (s.equals(""prototype"")) {
              processPrototypeParent(parent, t.getInput());
            } else {
              markPropertyAccessCandidate(dest, t.getInput());
            }
          }
          break;
        case Token.OBJECTLIT:
          if (!prototypeObjLits.contains(n)) {
            // Object literals have their property name/value pairs as a flat
            // list as their children. We want every other node in order to get
            // only the property names.
            for (Node child = n.getFirstChild();
                  child != null;
                  child = child.getNext()) {
 
               if (child.getType() != Token.NUMBER) {
                 markObjLitPropertyCandidate(child, t.getInput());
               }
             }
          }
          break;
      }
    }"
Closure_157,/home/common/huangzhili/defects4j_buggy/Closure_157_buggy/src/com/google/javascript/jscomp/parsing/IRFactory.java,"private Node transformAsString(AstNode n) {
       Node ret;
       if (n instanceof Name) {
         ret = transformNameAsString((Name)n);
       } else {
         ret = transform(n);
         Preconditions.checkState(ret.getType() == Token.NUMBER
             || ret.getType() == Token.STRING);
         if (ret.getType() == Token.STRING) {
         ret.putBooleanProp(Node.QUOTED_PROP, true);
         }
       }
       return ret;
     }"
Closure_157,/home/common/huangzhili/defects4j_buggy/Closure_157_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
      return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    // Handle all binary operators
    if (opstr != null && first != last) {
      Preconditions.checkState(
          childCount == 2,
          ""Bad binary operator \""%s\"": expected 2 arguments but got %s"",
          opstr, childCount);
      int p = NodeUtil.precedence(type);
      addLeftExpr(first, p, context);
      cc.addOp(opstr, true);

      // For right-hand-side of operations, only pass context if it's
      // the IN_FOR_INIT_CLAUSE one.
      Context rhsContext = getContextForNoInOperator(context);

      // Handle associativity.
      // e.g. if the parse tree is a * (b * c),
      // we can simply generate a * b * c.
      if (last.getType() == type &&
          NodeUtil.isAssociative(type)) {
        addExpr(last, p, rhsContext);
      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
        // Assignments are the only right-associative binary operators
        addExpr(last, p, rhsContext);
      } else {
        addExpr(last, p + 1, rhsContext);
      }
      return;
    }

    cc.startSourceMapping(n);

    switch (type) {
      case Token.TRY: {
        Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&
                !first.getNext().hasMoreThanOneChild());
        Preconditions.checkState(childCount >= 2 && childCount <= 3);

        add(""try"");
        add(first, Context.PRESERVE_BLOCK);

        // second child contains the catch block, or nothing if there
        // isn't a catch block
        Node catchblock = first.getNext().getFirstChild();
        if (catchblock != null) {
          add(catchblock);
        }

        if (childCount == 3) {
          add(""finally"");
          add(last, Context.PRESERVE_BLOCK);
        }
        break;
      }

      case Token.CATCH:
        Preconditions.checkState(childCount == 2);
        add(""catch("");
        add(first);
        add("")"");
        add(last, Context.PRESERVE_BLOCK);
        break;

      case Token.THROW:
        Preconditions.checkState(childCount == 1);
        add(""throw"");
        add(first);

        // Must have a ';' after a throw statement, otherwise safari can't
        // parse this.
        cc.endStatement(true);
        break;

      case Token.RETURN:
        add(""return"");
        if (childCount == 1) {
          add(first);
        } else {
          Preconditions.checkState(childCount == 0);
        }
        cc.endStatement();
        break;

      case Token.VAR:
        if (first != null) {
          add(""var "");
          addList(first, false, getContextForNoInOperator(context));
        }
        break;

      case Token.LABEL_NAME:
        Preconditions.checkState(!n.getString().isEmpty());
        addIdentifier(n.getString());
        break;

      case Token.NAME:
        if (first == null || first.getType() == Token.EMPTY) {
          addIdentifier(n.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          addIdentifier(n.getString());
          cc.addOp(""="", true);
          if (first.getType() == Token.COMMA) {
            addExpr(first, NodeUtil.precedence(Token.ASSIGN));
          } else {
            // Add expression, consider nearby code at lowest level of
            // precedence.
            addExpr(first, 0, getContextForNoInOperator(context));
          }
        }
        break;

      case Token.ARRAYLIT:
        add(""["");
        addArrayList(first);
        add(""]"");
        break;

      case Token.LP:
        add(""("");
        addList(first);
        add("")"");
        break;

      case Token.COMMA:
        Preconditions.checkState(childCount == 2);
        addList(first, false, context);
        break;

      case Token.NUMBER:
        Preconditions.checkState(
            childCount ==
            ((n.getParent() != null &&
              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));
        cc.addNumber(n.getDouble());
        break;

      case Token.TYPEOF:
      case Token.VOID:
      case Token.NOT:
      case Token.BITNOT:
      case Token.POS: {
        // All of these unary operators are right-associative
        Preconditions.checkState(childCount == 1);
        cc.addOp(NodeUtil.opToStrNoFail(type), false);
        addExpr(first, NodeUtil.precedence(type));
        break;
      }

      case Token.NEG: {
        Preconditions.checkState(childCount == 1);

        // It's important to our sanity checker that the code
        // we print produces the same AST as the code we parse back.
        // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
        if (n.getFirstChild().getType() == Token.NUMBER) {
          cc.addNumber(-n.getFirstChild().getDouble());
        } else {
          cc.addOp(NodeUtil.opToStrNoFail(type), false);
          addExpr(first, NodeUtil.precedence(type));
        }

        break;
      }

      case Token.HOOK: {
        Preconditions.checkState(childCount == 3);
        int p = NodeUtil.precedence(type);
        addLeftExpr(first, p + 1, context);
        cc.addOp(""?"", true);
        addExpr(first.getNext(), 1);
        cc.addOp("":"", true);
        addExpr(last, 1);
        break;
      }

      case Token.REGEXP:
        if (first.getType() != Token.STRING ||
            last.getType() != Token.STRING) {
          throw new Error(""Expected children to be strings"");
        }

        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);

        // I only use one .add because whitespace matters
        if (childCount == 2) {
          add(regexp + last.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          add(regexp);
        }
        break;

      case Token.GET_REF:
        add(first);
        break;

      case Token.REF_SPECIAL:
        Preconditions.checkState(childCount == 1);
        add(first);
        add(""."");
        add((String) n.getProp(Node.NAME_PROP));
        break;

      case Token.FUNCTION:
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        Preconditions.checkState(childCount == 3);
        boolean funcNeedsParens = (context == Context.START_OF_EXPR);
        if (funcNeedsParens) {
          add(""("");
        }

        add(""function"");
        add(first);

        add(first.getNext());
        add(last, Context.PRESERVE_BLOCK);
        cc.endFunction(context == Context.STATEMENT);

        if (funcNeedsParens) {
          add("")"");
        }
        break;

      case Token.GET:
      case Token.SET:
        Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);
        Preconditions.checkState(childCount == 1);
        Preconditions.checkState(first.getType() == Token.FUNCTION);

        // Get methods are unnamed
        Preconditions.checkState(first.getFirstChild().getString().isEmpty());
        if (type == Token.GET) {
          // Get methods have no parameters.
          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
          add(""get "");
        } else {
          // Set methods have one parameter.
          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
          add(""set "");
        }

        // The name is on the GET or SET node.
        String name = n.getString();
        Node fn = first;
        Node parameters = fn.getChildAtIndex(1);
         Node body = fn.getLastChild();
 
         // Add the property name.
         if (TokenStream.isJSIdentifier(name) &&
             // do not encode literally any non-literal characters that were
             // unicode escaped.
             NodeUtil.isLatin(name)) {
           add(name);
         } else {
           // Determine if the string is a simple number.
           add(jsString(n.getString(), outputCharsetEncoder));
         }
 
         add(parameters);
        add(body, Context.PRESERVE_BLOCK);
        break;

      case Token.SCRIPT:
      case Token.BLOCK: {
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        boolean preserveBlock = context == Context.PRESERVE_BLOCK;
        if (preserveBlock) {
          cc.beginBlock();
        }

        boolean preferLineBreaks =
            type == Token.SCRIPT ||
            (type == Token.BLOCK &&
                !preserveBlock &&
                n.getParent() != null &&
                n.getParent().getType() == Token.SCRIPT);
        for (Node c = first; c != null; c = c.getNext()) {
          add(c, Context.STATEMENT);

          // VAR doesn't include ';' since it gets used in expressions
          if (c.getType() == Token.VAR) {
            cc.endStatement();
          }

          if (c.getType() == Token.FUNCTION) {
            cc.maybeLineBreak();
          }

          // Prefer to break lines in between top-level statements
          // because top level statements are more homogeneous.
          if (preferLineBreaks) {
            cc.notePreferredLineBreak();
          }
        }
        if (preserveBlock) {
          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
        }
        break;
      }

      case Token.FOR:
        if (childCount == 4) {
          add(""for("");
          if (first.getType() == Token.VAR) {
            add(first, Context.IN_FOR_INIT_CLAUSE);
          } else {
            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
          }
          add("";"");
          add(first.getNext());
          add("";"");
          add(first.getNext().getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          Preconditions.checkState(childCount == 3);
          add(""for("");
          add(first);
          add(""in"");
          add(first.getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        }
        break;

      case Token.DO:
        Preconditions.checkState(childCount == 2);
        add(""do"");
        addNonEmptyStatement(first, Context.OTHER, false);
        add(""while("");
        add(last);
        add("")"");
        cc.endStatement();
        break;

      case Token.WHILE:
        Preconditions.checkState(childCount == 2);
        add(""while("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.EMPTY:
        Preconditions.checkState(childCount == 0);
        break;

      case Token.GETPROP: {
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETPROP: expected 2 children, but got %s"", childCount);
        Preconditions.checkState(
            last.getType() == Token.STRING,
            ""Bad GETPROP: RHS should be STRING"");
        boolean needsParens = (first.getType() == Token.NUMBER);
        if (needsParens) {
          add(""("");
        }
        addLeftExpr(first, NodeUtil.precedence(type), context);
        if (needsParens) {
          add("")"");
        }
        add(""."");
        addIdentifier(last.getString());
        break;
      }

      case Token.GETELEM:
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETELEM: expected 2 children but got %s"", childCount);
        addLeftExpr(first, NodeUtil.precedence(type), context);
        add(""["");
        add(first.getNext());
        add(""]"");
        break;

      case Token.WITH:
        Preconditions.checkState(childCount == 2);
        add(""with("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.INC:
      case Token.DEC: {
        Preconditions.checkState(childCount == 1);
        String o = type == Token.INC ? ""++"" : ""--"";
        int postProp = n.getIntProp(Node.INCRDECR_PROP);
        // A non-zero post-prop value indicates a post inc/dec, default of zero
        // is a pre-inc/dec.
        if (postProp != 0) {
          addLeftExpr(first, NodeUtil.precedence(type), context);
          cc.addOp(o, false);
        } else {
          cc.addOp(o, false);
          add(first);
        }
        break;
      }

      case Token.CALL:
        // We have two special cases here:
        // 1) If the left hand side of the call is a direct reference to eval,
        // then it must have a DIRECT_EVAL annotation. If it does not, then
        // that means it was originally an indirect call to eval, and that
        // indirectness must be preserved.
        // 2) If the left hand side of the call is a property reference,
        // then the call must not a FREE_CALL annotation. If it does, then
        // that means it was originally an call without an explicit this and
        // that must be preserved.
        if (isIndirectEval(first)
            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
          add(""(0,"");
          addExpr(first, NodeUtil.precedence(Token.COMMA));
          add("")"");
        } else {
          addLeftExpr(first, NodeUtil.precedence(type), context);
        }
        add(""("");
        addList(first.getNext());
        add("")"");
        break;

      case Token.IF:
        boolean hasElse = childCount == 3;
        boolean ambiguousElseClause =
            context == Context.BEFORE_DANGLING_ELSE && !hasElse;
        if (ambiguousElseClause) {
          cc.beginBlock();
        }

        add(""if("");
        add(first);
        add("")"");

        if (hasElse) {
          addNonEmptyStatement(
              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
          add(""else"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          addNonEmptyStatement(first.getNext(), Context.OTHER, false);
          Preconditions.checkState(childCount == 2);
        }

        if (ambiguousElseClause) {
          cc.endBlock();
        }
        break;

      case Token.NULL:
      case Token.THIS:
      case Token.FALSE:
      case Token.TRUE:
        Preconditions.checkState(childCount == 0);
        add(Node.tokenToName(type));
        break;

      case Token.CONTINUE:
        Preconditions.checkState(childCount <= 1);
        add(""continue"");
        if (childCount == 1) {
          if (first.getType() != Token.LABEL_NAME) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.DEBUGGER:
        Preconditions.checkState(childCount == 0);
        add(""debugger"");
        cc.endStatement();
        break;

      case Token.BREAK:
        Preconditions.checkState(childCount <= 1);
        add(""break"");
        if (childCount == 1) {
          if (first.getType() != Token.LABEL_NAME) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.EXPR_VOID:
        throw new Error(""Unexpected EXPR_VOID. Should be EXPR_RESULT."");

      case Token.EXPR_RESULT:
        Preconditions.checkState(childCount == 1);
        add(first, Context.START_OF_EXPR);
        cc.endStatement();
        break;

      case Token.NEW:
        add(""new "");
        int precedence = NodeUtil.precedence(type);

        // If the first child contains a CALL, then claim higher precedence
        // to force parentheses. Otherwise, when parsed, NEW will bind to the
        // first viable parentheses (don't traverse into functions).
        if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {
          precedence = NodeUtil.precedence(first.getType()) + 1;
        }
        addExpr(first, precedence);

        // '()' is optional when no arguments are present
        Node next = first.getNext();
        if (next != null) {
          add(""("");
          addList(next);
          add("")"");
        }
        break;

      case Token.STRING:
        if (childCount !=
            ((n.getParent() != null &&
              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {
          throw new IllegalStateException(
              ""Unexpected String children: "" + n.getParent().toStringTree());
        }
        add(jsString(n.getString(), outputCharsetEncoder));
        break;

      case Token.DELPROP:
        Preconditions.checkState(childCount == 1);
        add(""delete "");
        add(first);
        break;

      case Token.OBJECTLIT: {
        boolean needsParens = (context == Context.START_OF_EXPR);
        if (needsParens) {
          add(""("");
        }
        add(""{"");
        for (Node c = first; c != null; c = c.getNext()) {
          if (c != first) {
            cc.listSeparator();
          }

          if (c.getType() == Token.GET || c.getType() == Token.SET) {
            add(c);
          } else {
            // Object literal property names don't have to be quoted if they
            // are not JavaScript keywords
            if (c.getType() == Token.STRING &&
                !c.isQuotedString() &&
                !TokenStream.isKeyword(c.getString()) &&
                TokenStream.isJSIdentifier(c.getString()) &&
                // do not encode literally any non-literal characters that
                // were unicode escaped.
                NodeUtil.isLatin(c.getString())) {
              add(c.getString());
            } else {
              // Determine if the string is a simple number.
              addExpr(c, 1);
            }
            add("":"");
            addExpr(c.getFirstChild(), 1);
          }
        }
        add(""}"");
        if (needsParens) {
          add("")"");
        }
        break;
      }

      case Token.SWITCH:
        add(""switch("");
        add(first);
        add("")"");
        cc.beginBlock();
        addAllSiblings(first.getNext());
        cc.endBlock(context == Context.STATEMENT);
        break;

      case Token.CASE:
        Preconditions.checkState(childCount == 2);
        add(""case "");
        add(first);
        addCaseBody(last);
        break;

      case Token.DEFAULT:
        Preconditions.checkState(childCount == 1);
        add(""default"");
        addCaseBody(first);
        break;

      case Token.LABEL:
        Preconditions.checkState(childCount == 2);
        if (first.getType() != Token.LABEL_NAME) {
          throw new Error(""Unexpected token type. Should be LABEL_NAME."");
        }
        add(first);
        add("":"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), true);
        break;

      // This node is auto generated in anonymous functions and should just get
      // ignored for our purposes.
      case Token.SETNAME:
        break;

      default:
        throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }

    cc.endSourceMapping(n);
  }"
Closure_158,/home/common/huangzhili/defects4j_buggy/Closure_158_buggy/src/com/google/javascript/jscomp/AbstractCommandLineRunner.java,"final protected void setRunOptions(CompilerOptions options)
       throws FlagUsageException, IOException {
     DiagnosticGroups diagnosticGroups = getDiagnosticGroups();
 
     diagnosticGroups.setWarningLevels(
         options, config.jscompError, CheckLevel.ERROR);
     diagnosticGroups.setWarningLevels(
         options, config.jscompWarning, CheckLevel.WARNING);
     diagnosticGroups.setWarningLevels(
         options, config.jscompOff, CheckLevel.OFF);
 
     createDefineOrTweakReplacements(config.define, options, false);
 
    options.setTweakProcessing(config.tweakProcessing);
    createDefineOrTweakReplacements(config.tweak, options, true);

    options.manageClosureDependencies = config.manageClosureDependencies;
    if (config.closureEntryPoints.size() > 0) {
      options.setManageClosureDependencies(config.closureEntryPoints);
    }
    options.devMode = config.jscompDevMode;
    options.setCodingConvention(config.codingConvention);
    options.setSummaryDetailLevel(config.summaryDetailLevel);

    outputCharset = options.outputCharset = getOutputCharset();
    inputCharset = getInputCharset();

    if (config.jsOutputFile.length() > 0) {
      options.jsOutputFile = config.jsOutputFile;
    }

    if (config.createSourceMap.length() > 0) {
      options.sourceMapOutputPath = config.createSourceMap;
    }
    options.sourceMapDetailLevel = config.sourceMapDetailLevel;
    options.sourceMapFormat = config.sourceMapFormat;

    if (!config.variableMapInputFile.equals("""")) {
      options.inputVariableMapSerialized =
          VariableMap.load(config.variableMapInputFile).toBytes();
    }

    if (!config.propertyMapInputFile.equals("""")) {
      options.inputPropertyMapSerialized =
          VariableMap.load(config.propertyMapInputFile).toBytes();
    }

    if (config.languageIn.length() > 0) {
      if (config.languageIn.equals(""ECMASCRIPT5_STRICT"") ||
          config.languageIn.equals(""ES5_STRICT"")) {
        options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);
      } else if (config.languageIn.equals(""ECMASCRIPT5"") ||
          config.languageIn.equals(""ES5"")) {
        options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);
      } else if (config.languageIn.equals(""ECMASCRIPT3"") ||
                 config.languageIn.equals(""ES3"")) {
        options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT3);
      } else {
        throw new FlagUsageException(""Unknown language `"" + config.languageIn +
                                     ""' specified."");
      }
    }

    options.acceptConstKeyword = config.acceptConstKeyword;
  }"
Closure_158,/home/common/huangzhili/defects4j_buggy/Closure_158_buggy/src/com/google/javascript/jscomp/CommandLineRunner.java,"private void processFlagFile(PrintStream err)
            throws CmdLineException, IOException {
    List<String> argsInFile = Lists.newArrayList();
    File flagFileInput = new File(flags.flag_file);
    StringTokenizer tokenizer = new StringTokenizer(
        Files.toString(flagFileInput, Charset.defaultCharset()));

    while (tokenizer.hasMoreTokens()) {
        argsInFile.add(tokenizer.nextToken());
    }

    flags.flag_file = """";
     List<String> processedFileArgs
         = processArgs(argsInFile.toArray(new String[] {}));
     CmdLineParser parserFileArgs = new CmdLineParser(flags);
     parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {}));
 
     // Currently we are not supporting this (prevent direct/indirect loops)
    if (!flags.flag_file.equals("""")) {
      err.println(""ERROR - Arguments in the file cannot contain ""
          + ""--flagfile option."");
      isConfigValid = false;
    }
  }"
Closure_158,/home/common/huangzhili/defects4j_buggy/Closure_158_buggy/src/com/google/javascript/jscomp/CommandLineRunner.java,"private void initConfigFromFlags(String[] args, PrintStream err) {

     List<String> processedArgs = processArgs(args);
 
     CmdLineParser parser = new CmdLineParser(flags);
     isConfigValid = true;
     try {
       parser.parseArgument(processedArgs.toArray(new String[] {}));
      // For contains --flagfile flag
      if (!flags.flag_file.equals("""")) {
        processFlagFile(err);
      }
    } catch (CmdLineException e) {
      err.println(e.getMessage());
      isConfigValid = false;
    } catch (IOException ioErr) {
      err.println(""ERROR - "" + flags.flag_file + "" read error."");
      isConfigValid = false;
    }

    if (flags.version) {
      ResourceBundle config = ResourceBundle.getBundle(configResource);
      err.println(
          ""Closure Compiler (http://code.google.com/closure/compiler)\n"" +
          ""Version: "" + config.getString(""compiler.version"") + ""\n"" +
          ""Built on: "" + config.getString(""compiler.date""));
      err.flush();
    }

    if (!isConfigValid || flags.display_help) {
      isConfigValid = false;
      parser.printUsage(err);
    } else {
      getCommandLineConfig()
          .setPrintTree(flags.print_tree)
          .setComputePhaseOrdering(flags.compute_phase_ordering)
          .setPrintAst(flags.print_ast)
          .setPrintPassGraph(flags.print_pass_graph)
          .setJscompDevMode(flags.jscomp_dev_mode)
          .setLoggingLevel(flags.logging_level)
          .setExterns(flags.externs)
          .setJs(flags.js)
          .setJsOutputFile(flags.js_output_file)
          .setModule(flags.module)
          .setVariableMapInputFile(flags.variable_map_input_file)
          .setPropertyMapInputFile(flags.property_map_input_file)
          .setVariableMapOutputFile(flags.variable_map_output_file)
          .setCreateNameMapFiles(flags.create_name_map_files)
          .setPropertyMapOutputFile(flags.property_map_output_file)
          .setCodingConvention(flags.third_party ?
               new DefaultCodingConvention() :
               new ClosureCodingConvention())
          .setSummaryDetailLevel(flags.summary_detail_level)
          .setOutputWrapper(flags.output_wrapper)
          .setModuleWrapper(flags.module_wrapper)
          .setModuleOutputPathPrefix(flags.module_output_path_prefix)
          .setCreateSourceMap(flags.create_source_map)
          .setJscompError(flags.jscomp_error)
          .setJscompWarning(flags.jscomp_warning)
          .setJscompOff(flags.jscomp_off)
          .setDefine(flags.define)
          .setCharset(flags.charset)
          .setManageClosureDependencies(flags.manage_closure_dependencies)
          .setClosureEntryPoints(flags.closure_entry_point)
          .setOutputManifest(flags.output_manifest)
          .setAcceptConstKeyword(flags.accept_const_keyword)
          .setLanguageIn(flags.language_in);
    }
  }"
Closure_162,/home/common/huangzhili/defects4j_buggy/Closure_162_buggy/src/com/google/javascript/jscomp/ScopedAliases.java,"@Override
    public void visit(NodeTraversal t, Node n, Node parent) {
      if (isCallToScopeMethod(n)) {
         validateScopeCall(t, n, n.getParent());
       }
 
 
 
       // Validate the top level of the goog.scope block.
       if (t.getScopeDepth() == 2) {
         int type = n.getType();
         if (type == Token.NAME && parent.getType() == Token.VAR) {
           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
             String name = n.getString();
             Var aliasVar = t.getScope().getVar(name);
             aliases.put(name, aliasVar);
             aliasDefinitionsInOrder.add(n);
 
             String qualifiedName =
                 aliasVar.getInitialValue().getQualifiedName();
             transformation.addAlias(name, qualifiedName);
             // Return early, to ensure that we don't record a definition
             // twice.
             return;
           } else {
             report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
           }
         }
         if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) &&
             n == parent.getFirstChild()) {
             report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());
         }
 
         if (type == Token.RETURN) {
           report(t, n, GOOG_SCOPE_USES_RETURN);
        } else if (type == Token.THIS) {
          report(t, n, GOOG_SCOPE_REFERENCES_THIS);
        } else if (type == Token.THROW) {
          report(t, n, GOOG_SCOPE_USES_THROW);
        }
      }

      // Validate all descendent scopes of the goog.scope block.
      if (t.getScopeDepth() >= 2) {
        // Check if this name points to an alias.
        if (n.getType() == Token.NAME) {
          String name = n.getString();
          Var aliasVar = aliases.get(name);
          if (aliasVar != null &&
              t.getScope().getVar(name) == aliasVar) {
          // Note, to support the transitive case, it's important we don't
          // clone aliasedNode here.  For example,
          // var g = goog; var d = g.dom; d.createElement('DIV');
          // The node in aliasedNode (which is ""g"") will be replaced in the
          // changes pass above with ""goog"".  If we cloned here, we'd end up
          // with <code>g.dom.createElement('DIV')</code>.
          Node aliasedNode = aliasVar.getInitialValue();
          aliasUsages.add(new AliasedNode(n, aliasedNode));
          }
        }

        JSDocInfo info = n.getJSDocInfo();
        if (info != null) {
          for (Node node : info.getTypeNodes()) {
            fixTypeNode(node);
          }
        }

        // TODO(robbyw): Error for goog.scope not at root.
      }
    }"
Closure_162,/home/common/huangzhili/defects4j_buggy/Closure_162_buggy/src/com/google/javascript/jscomp/ScopedAliases.java,"@Override
    public void enterScope(NodeTraversal t) {
      Node n = t.getCurrentNode().getParent();
       if (n != null && isCallToScopeMethod(n)) {
         transformation = transformationHandler.logAliasTransformation(
             n.getSourceFileName(), getSourceRegion(n));
       }
     }"
Closure_163,/home/common/huangzhili/defects4j_buggy/Closure_163_buggy/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java,"private boolean processGlobalFunctionDeclaration(NodeTraversal t,
        Node nameNode, Node parent, Node gramps) {
      Node firstChild = nameNode.getFirstChild();

      if (// Check for a named FUNCTION.
          isGlobalFunctionDeclaration(t, parent) ||
          // Check for a VAR declaration.
          firstChild != null &&
           isGlobalFunctionDeclaration(t, firstChild)) {
         String name = nameNode.getString();
         getNameInfoForName(name, VAR).getDeclarations().add(
             new GlobalFunction(nameNode, parent, gramps, t.getModule()));
 
         // If the function name is exported, we should create an edge here
         // so that it's never removed.
        if (compiler.getCodingConvention().isExported(name) ||
            anchorUnusedVars) {
          addGlobalUseOfSymbol(name, t.getModule(), VAR);
        }

        return true;
      }
      return false;
    }"
Closure_163,/home/common/huangzhili/defects4j_buggy/Closure_163_buggy/src/com/google/javascript/jscomp/CrossModuleMethodMotion.java,"private void moveMethods(Collection<NameInfo> allNameInfo) {
    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();
    for (NameInfo nameInfo : allNameInfo) {
      if (!nameInfo.isReferenced()) {
        // The code below can't do anything with unreferenced name
        // infos.  They should be skipped to avoid NPE since their
        // deepestCommonModuleRef is null.
        continue;
      }

      if (nameInfo.readsClosureVariables()) {
        continue;
      }

      JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();
      if (deepestCommonModuleRef == null) {
        compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));
        continue;
      }

      Iterator<Symbol> declarations =
          nameInfo.getDeclarations().descendingIterator();
      while (declarations.hasNext()) {
        Symbol symbol = declarations.next();
        if (!(symbol instanceof Property)) {
          continue;
        }
        Property prop = (Property) symbol;

        // We should only move a property across modules if:
        // 1) We can move it deeper in the module graph, and
        // 2) it's a function, and
        // 3) it is not a get or a set, and
        // 4) the class is available in the global scope.
        //
        // #1 should be obvious. #2 is more subtle. It's possible
        // to copy off of a prototype, as in the code:
        // for (var k in Foo.prototype) {
        //   doSomethingWith(Foo.prototype[k]);
        // }
        // This is a common way to implement pseudo-multiple inheritance in JS.
        //
         // So if we move a prototype method into a deeper module, we must
         // replace it with a stub function so that it preserves its original
         // behavior.
 
         Node value = prop.getValue();
         if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) &&
            value.isFunction()) {
          Node valueParent = value.getParent();
          if (valueParent.isGetterDef()
              || valueParent.isSetterDef()) {
            // TODO(johnlenz): a GET or SET can't be deferred like a normal
            // FUNCTION property definition as a mix-in would get the result
            // of a GET instead of the function itself.
            continue;
          }
          Node proto = prop.getPrototype();
          int stubId = idGenerator.newId();

          // example: JSCompiler_stubMethod(id);
          Node stubCall = IR.call(
              IR.name(STUB_METHOD_NAME),
              IR.number(stubId))
              .copyInformationFromForTree(value);
          stubCall.putBooleanProp(Node.FREE_CALL, true);

          // stub out the method in the original module
          // A.prototype.b = JSCompiler_stubMethod(id);
          valueParent.replaceChild(value, stubCall);

          // unstub the function body in the deeper module
          Node unstubParent = compiler.getNodeForCodeInsertion(
              deepestCommonModuleRef);
          Node unstubCall = IR.call(
              IR.name(UNSTUB_METHOD_NAME),
              IR.number(stubId),
              value);
          unstubCall.putBooleanProp(Node.FREE_CALL, true);
          unstubParent.addChildToFront(
              // A.prototype.b = JSCompiler_unstubMethod(id, body);
              IR.exprResult(
                  IR.assign(
                      IR.getprop(
                          proto.cloneTree(),
                          IR.string(nameInfo.name)),
                      unstubCall))
                  .copyInformationFromForTree(value));

          compiler.reportCodeChange();
        }
      }
    }

    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {
      // Declare stub functions in the top-most module.
      Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);
      compiler.getNodeForCodeInsertion(null).addChildrenToFront(
          declarations.removeChildren());
    }
  }"
Closure_163,/home/common/huangzhili/defects4j_buggy/Closure_163_buggy/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java,"private void processPrototypeParent(NodeTraversal t, Node n) {

      switch (n.getType()) {
        // Foo.prototype.getBar = function() { ... }
        case Token.GETPROP:
          Node dest = n.getFirstChild().getNext();
          Node parent = n.getParent();
          Node grandParent = parent.getParent();

          if (dest.isString() &&
              NodeUtil.isExprAssign(grandParent) &&
              NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {
             String name = dest.getString();
             Property prop = new AssignmentProperty(
                 grandParent,
                 t.getModule());
             getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);
           }
           break;
 
        // Foo.prototype = { ""getBar"" : function() { ... } }
        case Token.ASSIGN:
          Node map = n.getFirstChild().getNext();
          if (map.isObjectLit()) {
            for (Node key = map.getFirstChild();
                 key != null; key = key.getNext()) {
              // May be STRING, GET, or SET,
              String name = key.getString();
              Property prop = new LiteralProperty(
                  key, key.getFirstChild(), map, n,
                  t.getModule());
              getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);
            }
          }
          break;
      }
    }"
Closure_163,/home/common/huangzhili/defects4j_buggy/Closure_163_buggy/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java,"@Override
    public void visit(NodeTraversal t, Node n, Node parent) {
      if (n.isGetProp()) {
        String propName = n.getFirstChild().getNext().getString();

          if (propName.equals(""prototype"")) {
          processPrototypeParent(t, parent);
          } else if (compiler.getCodingConvention().isExported(propName)) {
            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);
          } else {
            // Do not mark prototype prop assigns as a 'use' in the global scope.
          addSymbolUse(propName, t.getModule(), PROPERTY);
        }

      } else if (n.isObjectLit() &&
        // Make sure that we're not handling object literals being
        // assigned to a prototype, as in:
        // Foo.prototype = {bar: 3, baz: 5};
          !(parent.isAssign() &&
            parent.getFirstChild().isGetProp() &&
            parent.getFirstChild().getLastChild().getString().equals(
                ""prototype""))) {

        // var x = {a: 1, b: 2}
        // should count as a use of property a and b.
        for (Node propNameNode = n.getFirstChild(); propNameNode != null;
             propNameNode = propNameNode.getNext()) {
          // May be STRING, GET, or SET, but NUMBER isn't interesting.
          if (!propNameNode.isQuotedString()) {
            addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);
          }
        }
      } else if (n.isName()) {
        String name = n.getString();

        Var var = t.getScope().getVar(name);
        if (var != null) {
          // Only process global functions.
          if (var.isGlobal()) {
             if (var.getInitialValue() != null &&
                 var.getInitialValue().isFunction()) {
               if (t.inGlobalScope()) {
                 if (!processGlobalFunctionDeclaration(t, n, parent,
                         parent.getParent())) {
                   addGlobalUseOfSymbol(name, t.getModule(), VAR);
                 }
               } else {
                addSymbolUse(name, t.getModule(), VAR);
              }
            }

          // If it is not a global, it might be accessing a local of the outer
          // scope. If that's the case the functions between the variable's
          // declaring scope and the variable reference scope cannot be moved.
          } else if (var.getScope() != t.getScope()){
            for (int i = symbolStack.size() - 1; i >= 0; i--) {
              NameContext context = symbolStack.get(i);
              if (context.scope == var.getScope()) {
                break;
              }

              context.name.readClosureVariables = true;
            }
          }
        }
      }

      // Process prototype assignments to non-functions.
      if (isPrototypePropertyAssign(n) ||
          isGlobalFunctionDeclaration(t, n) ||
          n.isFunction()) {
        symbolStack.pop();
      }
    }"
Closure_165,/home/common/huangzhili/defects4j_buggy/Closure_165_buggy/src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java,"public JSType build() {
     // If we have an empty record, simply return the object type.
    if (isEmpty) {
       return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);
     }
 
     return new RecordType(
         registry, Collections.unmodifiableMap(properties));
   }"
Closure_165,/home/common/huangzhili/defects4j_buggy/Closure_165_buggy/src/com/google/javascript/rhino/jstype/RecordType.java,"JSType getGreatestSubtypeHelper(JSType that) {
     if (that.isRecordType()) {
       RecordType thatRecord = that.toMaybeRecordType();
       RecordTypeBuilder builder = new RecordTypeBuilder(registry);
 
       // The greatest subtype consists of those *unique* properties of both
       // record types. If any property conflicts, then the NO_TYPE type
      // is returned.
      for (String property : properties.keySet()) {
        if (thatRecord.hasProperty(property) &&
            !thatRecord.getPropertyType(property).isEquivalentTo(
                getPropertyType(property))) {
          return registry.getNativeObjectType(JSTypeNative.NO_TYPE);
        }

        builder.addProperty(property, getPropertyType(property),
            getPropertyNode(property));
      }

      for (String property : thatRecord.properties.keySet()) {
        if (!hasProperty(property)) {
          builder.addProperty(property, thatRecord.getPropertyType(property),
              thatRecord.getPropertyNode(property));
        }
      }

      return builder.build();
    }

    JSType greatestSubtype = registry.getNativeType(
        JSTypeNative.NO_OBJECT_TYPE);
    JSType thatRestrictedToObj =
        registry.getNativeType(JSTypeNative.OBJECT_TYPE)
        .getGreatestSubtype(that);
    if (!thatRestrictedToObj.isEmptyType()) {
      // In this branch, the other type is some object type. We find
      // the greatest subtype with the following algorithm:
      // 1) For each property ""x"" of this record type, take the union
      //    of all classes with a property ""x"" with a compatible property type.
      //    and which are a subtype of {@code that}.
      // 2) Take the intersection of all of these unions.
      for (Map.Entry<String, JSType> entry : properties.entrySet()) {
        String propName = entry.getKey();
        JSType propType = entry.getValue();
        UnionTypeBuilder builder = new UnionTypeBuilder(registry);
        for (ObjectType alt :
                 registry.getEachReferenceTypeWithProperty(propName)) {
          JSType altPropType = alt.getPropertyType(propName);
          if (altPropType != null && !alt.isEquivalentTo(this) &&
              alt.isSubtype(that) &&
              (propType.isUnknownType() || altPropType.isUnknownType() ||
                  altPropType.isEquivalentTo(propType))) {
            builder.addAlternate(alt);
          }
        }
        greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());
      }
    }
    return greatestSubtype;
  }"
Closure_165,/home/common/huangzhili/defects4j_buggy/Closure_165_buggy/src/com/google/javascript/rhino/jstype/JSTypeRegistry.java,"public boolean canPropertyBeDefined(JSType type, String propertyName) {
    if (typesIndexedByProperty.containsKey(propertyName)) {
      for (JSType alt :
               typesIndexedByProperty.get(propertyName).getAlternates()) {
        JSType greatestSubtype = alt.getGreatestSubtype(type);
         if (!greatestSubtype.isEmptyType()) {
           // We've found a type with this property. Now we just have to make
           // sure it's not a type used for internal bookkeeping.
 
           return true;
         }
      }
    }
    return false;
  }"
Closure_167,/home/common/huangzhili/defects4j_buggy/Closure_167_buggy/src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java,"private FlowScope caseNameOrGetProp(Node name, FlowScope blindScope,
       boolean outcome) {
     JSType type = getTypeIfRefinable(name, blindScope);
     if (type != null) {
       JSType restrictedType =
           type.getRestrictedTypeGivenToBooleanOutcome(outcome);
       FlowScope informed = blindScope.createChildFlowScope();
       declareNameInScope(informed, name, restrictedType);
       return informed;
     }
     return blindScope;
   }"
Closure_167,/home/common/huangzhili/defects4j_buggy/Closure_167_buggy/src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java,"private FlowScope maybeRestrictTwoNames(
       FlowScope blindScope,
       Node left, boolean leftIsRefineable, JSType restrictedLeftType,
       Node right, boolean rightIsRefineable, JSType restrictedRightType) {
     boolean shouldRefineLeft =
         leftIsRefineable && restrictedLeftType != null;
     boolean shouldRefineRight =
         rightIsRefineable && restrictedRightType != null;
     if (shouldRefineLeft || shouldRefineRight) {
       FlowScope informed = blindScope.createChildFlowScope();
       if (shouldRefineLeft) {
        declareNameInScope(informed, left, restrictedLeftType);
      }
      if (shouldRefineRight) {
        declareNameInScope(informed, right, restrictedRightType);
      }
      return informed;
    }
    return blindScope;
  }"
Closure_167,/home/common/huangzhili/defects4j_buggy/Closure_167_buggy/src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java,"private FlowScope caseAndOrNotShortCircuiting(Node left, Node right,
        FlowScope blindScope, boolean condition) {
    // left type
    JSType leftType = getTypeIfRefinable(left, blindScope);
    boolean leftIsRefineable;
    if (leftType != null) {
      leftIsRefineable = true;
    } else {
      leftIsRefineable = false;
      leftType = left.getJSType();
      blindScope = firstPreciserScopeKnowingConditionOutcome(
          left, blindScope, condition);
    }

    // restricting left type
    JSType restrictedLeftType = (leftType == null) ? null :
        leftType.getRestrictedTypeGivenToBooleanOutcome(condition);
    if (restrictedLeftType == null) {
      return firstPreciserScopeKnowingConditionOutcome(
          right, blindScope, condition);
    }

    // right type
    JSType rightType = getTypeIfRefinable(right, blindScope);
    boolean rightIsRefineable;
    if (rightType != null) {
      rightIsRefineable = true;
    } else {
      rightIsRefineable = false;
      rightType = right.getJSType();
      blindScope = firstPreciserScopeKnowingConditionOutcome(
          right, blindScope, condition);
    }

    if (condition) {
      JSType restrictedRightType = (rightType == null) ? null :
          rightType.getRestrictedTypeGivenToBooleanOutcome(condition);

       // creating new scope
       return maybeRestrictTwoNames(
           blindScope,
           left, leftIsRefineable, restrictedLeftType,
           right, rightIsRefineable, restrictedRightType);
     }
     return blindScope;
   }"
Closure_167,/home/common/huangzhili/defects4j_buggy/Closure_167_buggy/src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java,"private FlowScope caseEquality(Node left, Node right, FlowScope blindScope,
      Function<TypePair, TypePair> merging) {
    // left type
    JSType leftType = getTypeIfRefinable(left, blindScope);
    boolean leftIsRefineable;
    if (leftType != null) {
      leftIsRefineable = true;
    } else {
      leftIsRefineable = false;
      leftType = left.getJSType();
    }

    // right type
    JSType rightType = getTypeIfRefinable(right, blindScope);
    boolean rightIsRefineable;
    if (rightType != null) {
      rightIsRefineable = true;
    } else {
      rightIsRefineable = false;
      rightType = right.getJSType();
    }

    // merged types
    TypePair merged = merging.apply(new TypePair(leftType, rightType));

    // creating new scope
     if (merged != null) {
       return maybeRestrictTwoNames(
           blindScope,
           left, leftIsRefineable, merged.typeA,
           right, rightIsRefineable, merged.typeB);
     }
     return blindScope;
   }"
Closure_167,/home/common/huangzhili/defects4j_buggy/Closure_167_buggy/src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java,"private FlowScope maybeRestrictName(
       FlowScope blindScope, Node node, JSType originalType, JSType restrictedType) {
     if (restrictedType != null && !restrictedType.equals(originalType)) {
       FlowScope informed = blindScope.createChildFlowScope();
       declareNameInScope(informed, node, restrictedType);
       return informed;
    }
    return blindScope;
  }"
Closure_169,/home/common/huangzhili/defects4j_buggy/Closure_169_buggy/src/com/google/javascript/rhino/jstype/ArrowType.java,"boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) {
    Node thisParam = parameters.getFirstChild();
    Node otherParam = that.parameters.getFirstChild();
    while (thisParam != null && otherParam != null) {
      JSType thisParamType = thisParam.getJSType();
      JSType otherParamType = otherParam.getJSType();
      if (thisParamType != null) {
         // Both parameter lists give a type for this param, it should be equal
         if (otherParamType != null &&
             !thisParamType.checkEquivalenceHelper(
                 otherParamType, tolerateUnknowns)) {
           return false;
         }
       } else {
        if (otherParamType != null) {
          return false;
        }
      }
      thisParam = thisParam.getNext();
      otherParam = otherParam.getNext();
    }
    // One of the parameters is null, so the types are only equal if both
    // parameter lists are null (they are equal).
    return thisParam == otherParam;
  }"
Closure_169,/home/common/huangzhili/defects4j_buggy/Closure_169_buggy/src/com/google/javascript/rhino/jstype/RecordType.java,"JSType getGreatestSubtypeHelper(JSType that) {
    if (that.isRecordType()) {
      RecordType thatRecord = that.toMaybeRecordType();
      RecordTypeBuilder builder = new RecordTypeBuilder(registry);
      builder.setSynthesized(true);

      // The greatest subtype consists of those *unique* properties of both
      // record types. If any property conflicts, then the NO_TYPE type
      // is returned.
      for (String property : properties.keySet()) {
        if (thatRecord.hasProperty(property) &&
            !thatRecord.getPropertyType(property).isInvariant(
                getPropertyType(property))) {
          return registry.getNativeObjectType(JSTypeNative.NO_TYPE);
        }

        builder.addProperty(property, getPropertyType(property),
            getPropertyNode(property));
      }

      for (String property : thatRecord.properties.keySet()) {
        if (!hasProperty(property)) {
          builder.addProperty(property, thatRecord.getPropertyType(property),
              thatRecord.getPropertyNode(property));
        }
      }

      return builder.build();
    }

    JSType greatestSubtype = registry.getNativeType(
        JSTypeNative.NO_OBJECT_TYPE);
    JSType thatRestrictedToObj =
        registry.getNativeType(JSTypeNative.OBJECT_TYPE)
        .getGreatestSubtype(that);
    if (!thatRestrictedToObj.isEmptyType()) {
      // In this branch, the other type is some object type. We find
      // the greatest subtype with the following algorithm:
      // 1) For each property ""x"" of this record type, take the union
      //    of all classes with a property ""x"" with a compatible property type.
      //    and which are a subtype of {@code that}.
      // 2) Take the intersection of all of these unions.
      for (Map.Entry<String, JSType> entry : properties.entrySet()) {
        String propName = entry.getKey();
        JSType propType = entry.getValue();
        UnionTypeBuilder builder = new UnionTypeBuilder(registry);
        for (ObjectType alt :
                 registry.getEachReferenceTypeWithProperty(propName)) {
           JSType altPropType = alt.getPropertyType(propName);
           if (altPropType != null && !alt.isEquivalentTo(this) &&
               alt.isSubtype(that) &&
               (propType.isUnknownType() || altPropType.isUnknownType() ||
                   altPropType.isEquivalentTo(propType))) {
             builder.addAlternate(alt);
           }
         }
        greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());
      }
    }
    return greatestSubtype;
  }"
Closure_169,/home/common/huangzhili/defects4j_buggy/Closure_169_buggy/src/com/google/javascript/rhino/jstype/FunctionType.java,"boolean checkFunctionEquivalenceHelper(
      FunctionType that, boolean tolerateUnknowns) {
    if (isConstructor()) {
      if (that.isConstructor()) {
        return this == that;
      }
      return false;
    }
    if (isInterface()) {
      if (that.isInterface()) {
        return getReferenceName().equals(that.getReferenceName());
      }
      return false;
    }
    if (that.isInterface()) {
      return false;
     }
 
     return typeOfThis.checkEquivalenceHelper(
         that.typeOfThis, tolerateUnknowns) &&
         call.checkArrowEquivalenceHelper(that.call, tolerateUnknowns);
   }"
Closure_169,/home/common/huangzhili/defects4j_buggy/Closure_169_buggy/src/com/google/javascript/rhino/jstype/RecordType.java,"boolean checkRecordEquivalenceHelper(
       RecordType otherRecord, boolean tolerateUnknowns) {
     Set<String> keySet = properties.keySet();
     Map<String, JSType> otherProps = otherRecord.properties;
     if (!otherProps.keySet().equals(keySet)) {
      return false;
    }
    for (String key : keySet) {
      if (!otherProps.get(key).checkEquivalenceHelper(
              properties.get(key), tolerateUnknowns)) {
        return false;
      }
    }
    return true;
  }"
Closure_169,/home/common/huangzhili/defects4j_buggy/Closure_169_buggy/src/com/google/javascript/rhino/jstype/RecordType.java,"static boolean isSubtype(ObjectType typeA, RecordType typeB) {
    // typeA is a subtype of record type typeB iff:
    // 1) typeA has all the properties declared in typeB.
    // 2) And for each property of typeB,
    //    2a) if the property of typeA is declared, it must be equal
    //        to the type of the property of typeB,
    //    2b) otherwise, it must be a subtype of the property of typeB.
    //
    // To figure out why this is true, consider the following pseudo-code:
    // /** @type {{a: (Object,null)}} */ var x;
    // /** @type {{a: !Object}} */ var y;
    // var z = {a: {}};
    // x.a = null;
    //
    // y cannot be assigned to x, because line 4 would violate y's declared
    // properties. But z can be assigned to x. Even though z and y are the
    // same type, the properties of z are inferred--and so an assignment
    // to the property of z would not violate any restrictions on it.
    for (String property : typeB.properties.keySet()) {
      if (!typeA.hasProperty(property)) {
        return false;
      }
 
       JSType propA = typeA.getPropertyType(property);
       JSType propB = typeB.getPropertyType(property);
       if (!propA.isUnknownType() && !propB.isUnknownType()) {
       if (typeA.isPropertyTypeDeclared(property)) {
         // If one declared property isn't invariant,
         // then the whole record isn't covariant.
        if (!propA.isInvariant(propB)) {
          return false;
        }
      } else {
        // If one inferred property isn't a subtype,
        // then the whole record isn't covariant.
        if (!propA.isSubtype(propB)) {
          return false;
          }
        }
      }
    }

    return true;
  }"
Closure_169,/home/common/huangzhili/defects4j_buggy/Closure_169_buggy/src/com/google/javascript/rhino/jstype/ArrowType.java,"boolean checkArrowEquivalenceHelper(
       ArrowType that, boolean tolerateUnknowns) {
     // Please keep this method in sync with the hashCode() method below.
     if (!returnType.checkEquivalenceHelper(that.returnType, tolerateUnknowns)) {
       return false;
     }
     return hasEqualParameters(that, tolerateUnknowns);
   }"
Closure_169,/home/common/huangzhili/defects4j_buggy/Closure_169_buggy/src/com/google/javascript/rhino/jstype/FunctionType.java,"private FunctionType tryMergeFunctionPiecewise(
       FunctionType other, boolean leastSuper) {
     Node newParamsNode = null;
     if (call.hasEqualParameters(other.call, false)) {
       newParamsNode = call.parameters;
     } else {
       // If the parameters are not equal, don't try to merge them.
      // Someday, we should try to merge the individual params.
      return null;
    }

    JSType newReturnType = leastSuper ?
        call.returnType.getLeastSupertype(other.call.returnType) :
        call.returnType.getGreatestSubtype(other.call.returnType);

    ObjectType newTypeOfThis = null;
    if (isEquivalent(typeOfThis, other.typeOfThis)) {
      newTypeOfThis = typeOfThis;
    } else {
      JSType maybeNewTypeOfThis = leastSuper ?
          typeOfThis.getLeastSupertype(other.typeOfThis) :
          typeOfThis.getGreatestSubtype(other.typeOfThis);
      if (maybeNewTypeOfThis instanceof ObjectType) {
        newTypeOfThis = (ObjectType) maybeNewTypeOfThis;
      } else {
        newTypeOfThis = leastSuper ?
            registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) :
            registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);
      }
    }

    boolean newReturnTypeInferred =
        call.returnTypeInferred || other.call.returnTypeInferred;

    return new FunctionType(
        registry, null, null,
        new ArrowType(
            registry, newParamsNode, newReturnType, newReturnTypeInferred),
        newTypeOfThis, null, false, false);
  }"
Closure_169,/home/common/huangzhili/defects4j_buggy/Closure_169_buggy/src/com/google/javascript/rhino/jstype/JSType.java,"boolean checkEquivalenceHelper(JSType that, boolean tolerateUnknowns) {
    if (this == that) {
      return true;
    }

    boolean thisUnknown = isUnknownType();
    boolean thatUnknown = that.isUnknownType();
    if (thisUnknown || thatUnknown) {
      if (tolerateUnknowns) {
        // If we're checking for invariance, the unknown type is invariant
        // with everyone.
        // If we're checking data flow, then two types are the same if they're
        // both unknown.
        return thisUnknown && thatUnknown;
      } else if (thisUnknown && thatUnknown &&
          (isNominalType() ^ that.isNominalType())) {
        // If they're both unknown, but one is a nominal type and the other
        // is not, then we should fail out immediately. This ensures that
        // we won't unbox the unknowns further down.
        return false;
      }
    }

    if (isUnionType() && that.isUnionType()) {
      return this.toMaybeUnionType().checkUnionEquivalenceHelper(
          that.toMaybeUnionType(), tolerateUnknowns);
    }

    if (isFunctionType() && that.isFunctionType()) {
      return this.toMaybeFunctionType().checkFunctionEquivalenceHelper(
          that.toMaybeFunctionType(), tolerateUnknowns);
    }

    if (isRecordType() && that.isRecordType()) {
      return this.toMaybeRecordType().checkRecordEquivalenceHelper(
          that.toMaybeRecordType(), tolerateUnknowns);
    }

    ParameterizedType thisParamType = toMaybeParameterizedType();
    ParameterizedType thatParamType = that.toMaybeParameterizedType();
    if (thisParamType != null || thatParamType != null) {
      // Check if one type is parameterized, but the other is not.
      boolean paramsMatch = false;
      if (thisParamType != null && thatParamType != null) {
        paramsMatch = thisParamType.getParameterType().checkEquivalenceHelper(
            thatParamType.getParameterType(), tolerateUnknowns);
      } else if (tolerateUnknowns) {
        // If one of the type parameters is unknown, but the other is not,
        // then we consider these the same for the purposes of data flow
        // and invariance.
        paramsMatch = true;
      } else {
        paramsMatch = false;
      }

      JSType thisRootType = thisParamType == null ?
          this : thisParamType.getReferencedTypeInternal();
       JSType thatRootType = thatParamType == null ?
           that : thatParamType.getReferencedTypeInternal();
       return paramsMatch &&
           thisRootType.checkEquivalenceHelper(thatRootType, tolerateUnknowns);
     }
 
     if (isNominalType() && that.isNominalType()) {
      return toObjectType().getReferenceName().equals(
          that.toObjectType().getReferenceName());
    }

    // Unbox other proxies.
    if (this instanceof ProxyObjectType) {
      return ((ProxyObjectType) this)
          .getReferencedTypeInternal().checkEquivalenceHelper(
              that, tolerateUnknowns);
    }

    if (that instanceof ProxyObjectType) {
      return checkEquivalenceHelper(
          ((ProxyObjectType) that).getReferencedTypeInternal(),
          tolerateUnknowns);
    }

    // Relies on the fact that for the base {@link JSType}, only one
    // instance of each sub-type will ever be created in a given registry, so
    // there is no need to verify members. If the object pointers are not
    // identical, then the type member must be different.
    return this == that;
  }"
Closure_170,/home/common/huangzhili/defects4j_buggy/Closure_170_buggy/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java,"    private void getNumUseInUseCfgNode(final Node cfgNode) {

      numUsesWithinCfgNode = 0;
      AbstractCfgNodeTraversalCallback gatherCb =
          new AbstractCfgNodeTraversalCallback() {

        @Override
        public void visit(NodeTraversal t, Node n, Node parent) {
          if (n.isName() && n.getString().equals(varName) &&
            // We make a special exception when the entire cfgNode is a chain
            // of assignments, since in that case the assignment statements
            // will happen after the inlining of the right hand side.
            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact
            //   and remove this special case.
              !(parent.isAssign() &&
               (parent.getFirstChild() == n))) {
              // Don't count lhs of top-level assignment chain
              numUsesWithinCfgNode++;
          }
        }

      };

      NodeTraversal.traverse(compiler, cfgNode, gatherCb);
    }
"
Closure_171,/home/common/huangzhili/defects4j_buggy/Closure_171_buggy/src/com/google/javascript/jscomp/TypeInference.java,"  private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {
    JSType type = n.getJSType();
    Preconditions.checkNotNull(type);

    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {
      scope = traverse(name.getFirstChild(), scope);
    }

    // Object literals can be reflected on other types.
    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.
    // Ignore these types of literals.
    ObjectType objectType = ObjectType.cast(type);
    if (objectType == null) {
      return scope;
    }
    boolean hasLendsName = n.getJSDocInfo() != null &&
        n.getJSDocInfo().getLendsName() != null;
    if (objectType.hasReferenceName() && !hasLendsName) {
      return scope;
    }

    String qObjName = NodeUtil.getBestLValueName(
        NodeUtil.getBestLValue(n));
    for (Node name = n.getFirstChild(); name != null;
         name = name.getNext()) {
      String memberName = NodeUtil.getObjectLitKeyName(name);
      if (memberName != null) {
        JSType rawValueType =  name.getFirstChild().getJSType();
        JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(
            name, rawValueType);
        if (valueType == null) {
          valueType = unknownType;
        }
        objectType.defineInferredProperty(memberName, valueType, name);

        // Do normal flow inference if this is a direct property assignment.
        if (qObjName != null && name.isStringKey()) {
          String qKeyName = qObjName + ""."" + memberName;
          Var var = syntacticScope.getVar(qKeyName);
          JSType oldType = var == null ? null : var.getType();
          if (var != null && var.isTypeInferred()) {
            var.setType(oldType == null ?
                valueType : oldType.getLeastSupertype(oldType));
          }

          scope.inferQualifiedSlot(name, qKeyName,
              oldType == null ? unknownType : oldType,
              valueType);
        }
      } else {
        n.setJSType(unknownType);
      }
    }
    return scope;
  }
"
Closure_171,/home/common/huangzhili/defects4j_buggy/Closure_171_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"    private boolean isQualifiedNameInferred(
        String qName, Node n, JSDocInfo info,
        Node rhsValue, JSType valueType) {
      if (valueType == null) {
        return true;
      }

      // Prototype sets are always declared.

      boolean inferred = true;
      if (info != null) {
        inferred = !(info.hasType()
            || info.hasEnumParameterType()
            || (isConstantSymbol(info, n) && valueType != null
                && !valueType.isUnknownType())
            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
      }

      if (inferred && rhsValue != null && rhsValue.isFunction()) {
        if (info != null) {
          return false;
        } else if (!scope.isDeclared(qName, false) &&
            n.isUnscopedQualifiedName()) {

          // Check if this is in a conditional block.
          // Functions assigned in conditional blocks are inferred.
          for (Node current = n.getParent();
               !(current.isScript() || current.isFunction());
               current = current.getParent()) {
            if (NodeUtil.isControlStructure(current)) {
              return true;
            }
          }

          // Check if this is assigned in an inner scope.
          // Functions assigned in inner scopes are inferred.
          AstFunctionContents contents =
              getFunctionAnalysisResults(scope.getRootNode());
          if (contents == null ||
              !contents.getEscapedQualifiedNames().contains(qName)) {
            return false;
          }
        }
      }
      return inferred;
    }
"
Closure_173,/home/common/huangzhili/defects4j_buggy/Closure_173_buggy/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,"  public Node optimizeSubtree(Node node) {
    switch(node.getType()) {
      case Token.TRUE:
      case Token.FALSE:
        return reduceTrueFalse(node);

      case Token.NEW:
        node = tryFoldStandardConstructors(node);
        if (!node.isCall()) {
          return node;
        }
        // Fall through on purpose because tryFoldStandardConstructors() may
        // convert a NEW node into a CALL node
      case Token.CALL:
        Node result =  tryFoldLiteralConstructor(node);
        if (result == node) {
          result = tryFoldSimpleFunctionCall(node);
          if (result == node) {
            result = tryFoldImmediateCallToBoundFunction(node);
          }
        }
        return result;

      case Token.RETURN:
        return tryReduceReturn(node);

      case Token.COMMA:
        return trySplitComma(node);

      case Token.NAME:
        return tryReplaceUndefined(node);

      case Token.ARRAYLIT:
        return tryMinimizeArrayLiteral(node);


      default:
        return node; //Nothing changed
    }
  }
"
Closure_173,/home/common/huangzhili/defects4j_buggy/Closure_173_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"  void add(Node n, Context context) {
    if (!cc.continueProcessing()) {
      return;
    }

    int type = n.getType();
    String opstr = NodeUtil.opToStr(type);
    int childCount = n.getChildCount();
    Node first = n.getFirstChild();
    Node last = n.getLastChild();

    // Handle all binary operators
    if (opstr != null && first != last) {
      Preconditions.checkState(
          childCount == 2,
          ""Bad binary operator \""%s\"": expected 2 arguments but got %s"",
          opstr, childCount);
      int p = NodeUtil.precedence(type);

      // For right-hand-side of operations, only pass context if it's
      // the IN_FOR_INIT_CLAUSE one.
      Context rhsContext = getContextForNoInOperator(context);

      if (last.getType() == type &&
          NodeUtil.isAssociative(type)) {
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p, rhsContext);
      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {
        // Assignments are the only right-associative binary operators
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p, rhsContext);
      } else {
        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
      }
      return;
    }

    cc.startSourceMapping(n);

    switch (type) {
      case Token.TRY: {
        Preconditions.checkState(first.getNext().isBlock() &&
                !first.getNext().hasMoreThanOneChild());
        Preconditions.checkState(childCount >= 2 && childCount <= 3);

        add(""try"");
        add(first, Context.PRESERVE_BLOCK);

        // second child contains the catch block, or nothing if there
        // isn't a catch block
        Node catchblock = first.getNext().getFirstChild();
        if (catchblock != null) {
          add(catchblock);
        }

        if (childCount == 3) {
          add(""finally"");
          add(last, Context.PRESERVE_BLOCK);
        }
        break;
      }

      case Token.CATCH:
        Preconditions.checkState(childCount == 2);
        add(""catch("");
        add(first);
        add("")"");
        add(last, Context.PRESERVE_BLOCK);
        break;

      case Token.THROW:
        Preconditions.checkState(childCount == 1);
        add(""throw"");
        add(first);

        // Must have a ';' after a throw statement, otherwise safari can't
        // parse this.
        cc.endStatement(true);
        break;

      case Token.RETURN:
        add(""return"");
        if (childCount == 1) {
          add(first);
        } else {
          Preconditions.checkState(childCount == 0);
        }
        cc.endStatement();
        break;

      case Token.VAR:
        if (first != null) {
          add(""var "");
          addList(first, false, getContextForNoInOperator(context));
        }
        break;

      case Token.LABEL_NAME:
        Preconditions.checkState(!n.getString().isEmpty());
        addIdentifier(n.getString());
        break;

      case Token.NAME:
        if (first == null || first.isEmpty()) {
          addIdentifier(n.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          addIdentifier(n.getString());
          cc.addOp(""="", true);
          if (first.isComma()) {
            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);
          } else {
            // Add expression, consider nearby code at lowest level of
            // precedence.
            addExpr(first, 0, getContextForNoInOperator(context));
          }
        }
        break;

      case Token.ARRAYLIT:
        add(""["");
        addArrayList(first);
        add(""]"");
        break;

      case Token.PARAM_LIST:
        add(""("");
        addList(first);
        add("")"");
        break;

      case Token.COMMA:
        Preconditions.checkState(childCount == 2);
        unrollBinaryOperator(n, Token.COMMA, "","", context,
            getContextForNoInOperator(context), 0, 0);
        break;

      case Token.NUMBER:
        Preconditions.checkState(childCount == 0);
        cc.addNumber(n.getDouble());
        break;

      case Token.TYPEOF:
      case Token.VOID:
      case Token.NOT:
      case Token.BITNOT:
      case Token.POS: {
        // All of these unary operators are right-associative
        Preconditions.checkState(childCount == 1);
        cc.addOp(NodeUtil.opToStrNoFail(type), false);
        addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        break;
      }

      case Token.NEG: {
        Preconditions.checkState(childCount == 1);

        // It's important to our sanity checker that the code
        // we print produces the same AST as the code we parse back.
        // NEG is a weird case because Rhino parses ""- -2"" as ""2"".
        if (n.getFirstChild().isNumber()) {
          cc.addNumber(-n.getFirstChild().getDouble());
        } else {
          cc.addOp(NodeUtil.opToStrNoFail(type), false);
          addExpr(first, NodeUtil.precedence(type), Context.OTHER);
        }

        break;
      }

      case Token.HOOK: {
        Preconditions.checkState(childCount == 3);
        int p = NodeUtil.precedence(type);
        Context rhsContext = getContextForNoInOperator(context);
        addExpr(first, p + 1, context);
        cc.addOp(""?"", true);
        addExpr(first.getNext(), 1, rhsContext);
        cc.addOp("":"", true);
        addExpr(last, 1, rhsContext);
        break;
      }

      case Token.REGEXP:
        if (!first.isString() ||
            !last.isString()) {
          throw new Error(""Expected children to be strings"");
        }

        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);

        // I only use one .add because whitespace matters
        if (childCount == 2) {
          add(regexp + last.getString());
        } else {
          Preconditions.checkState(childCount == 1);
          add(regexp);
        }
        break;

      case Token.FUNCTION:
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        Preconditions.checkState(childCount == 3);
        boolean funcNeedsParens = (context == Context.START_OF_EXPR);
        if (funcNeedsParens) {
          add(""("");
        }

        add(""function"");
        add(first);

        add(first.getNext());
        add(last, Context.PRESERVE_BLOCK);
        cc.endFunction(context == Context.STATEMENT);

        if (funcNeedsParens) {
          add("")"");
        }
        break;

      case Token.GETTER_DEF:
      case Token.SETTER_DEF:
        Preconditions.checkState(n.getParent().isObjectLit());
        Preconditions.checkState(childCount == 1);
        Preconditions.checkState(first.isFunction());

        // Get methods are unnamed
        Preconditions.checkState(first.getFirstChild().getString().isEmpty());
        if (type == Token.GETTER_DEF) {
          // Get methods have no parameters.
          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());
          add(""get "");
        } else {
          // Set methods have one parameter.
          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());
          add(""set "");
        }

        // The name is on the GET or SET node.
        String name = n.getString();
        Node fn = first;
        Node parameters = fn.getChildAtIndex(1);
        Node body = fn.getLastChild();

        // Add the property name.
        if (!n.isQuotedString() &&
            TokenStream.isJSIdentifier(name) &&
            // do not encode literally any non-literal characters that were
            // Unicode escaped.
            NodeUtil.isLatin(name)) {
          add(name);
        } else {
          // Determine if the string is a simple number.
          double d = getSimpleNumber(name);
          if (!Double.isNaN(d)) {
            cc.addNumber(d);
          } else {
            addJsString(n);
          }
        }

        add(parameters);
        add(body, Context.PRESERVE_BLOCK);
        break;

      case Token.SCRIPT:
      case Token.BLOCK: {
        if (n.getClass() != Node.class) {
          throw new Error(""Unexpected Node subclass."");
        }
        boolean preserveBlock = context == Context.PRESERVE_BLOCK;
        if (preserveBlock) {
          cc.beginBlock();
        }

        boolean preferLineBreaks =
            type == Token.SCRIPT ||
            (type == Token.BLOCK &&
                !preserveBlock &&
                n.getParent() != null &&
                n.getParent().isScript());
        for (Node c = first; c != null; c = c.getNext()) {
          add(c, Context.STATEMENT);

          // VAR doesn't include ';' since it gets used in expressions
          if (c.isVar()) {
            cc.endStatement();
          }

          if (c.isFunction()) {
            cc.maybeLineBreak();
          }

          // Prefer to break lines in between top-level statements
          // because top-level statements are more homogeneous.
          if (preferLineBreaks) {
            cc.notePreferredLineBreak();
          }
        }
        if (preserveBlock) {
          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));
        }
        break;
      }

      case Token.FOR:
        if (childCount == 4) {
          add(""for("");
          if (first.isVar()) {
            add(first, Context.IN_FOR_INIT_CLAUSE);
          } else {
            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);
          }
          add("";"");
          add(first.getNext());
          add("";"");
          add(first.getNext().getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          Preconditions.checkState(childCount == 3);
          add(""for("");
          add(first);
          add(""in"");
          add(first.getNext());
          add("")"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        }
        break;

      case Token.DO:
        Preconditions.checkState(childCount == 2);
        add(""do"");
        addNonEmptyStatement(first, Context.OTHER, false);
        add(""while("");
        add(last);
        add("")"");
        cc.endStatement();
        break;

      case Token.WHILE:
        Preconditions.checkState(childCount == 2);
        add(""while("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.EMPTY:
        Preconditions.checkState(childCount == 0);
        break;

      case Token.GETPROP: {
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETPROP: expected 2 children, but got %s"", childCount);
        Preconditions.checkState(
            last.isString(),
            ""Bad GETPROP: RHS should be STRING"");
        boolean needsParens = (first.isNumber());
        if (needsParens) {
          add(""("");
        }
        addExpr(first, NodeUtil.precedence(type), context);
        if (needsParens) {
          add("")"");
        }
        if (this.languageMode == LanguageMode.ECMASCRIPT3
            && TokenStream.isKeyword(last.getString())) {
          // Check for ECMASCRIPT3 keywords.
          add(""["");
          add(last);
          add(""]"");
        } else {
          add(""."");
          addIdentifier(last.getString());
        }
        break;
      }

      case Token.GETELEM:
        Preconditions.checkState(
            childCount == 2,
            ""Bad GETELEM: expected 2 children but got %s"", childCount);
        addExpr(first, NodeUtil.precedence(type), context);
        add(""["");
        add(first.getNext());
        add(""]"");
        break;

      case Token.WITH:
        Preconditions.checkState(childCount == 2);
        add(""with("");
        add(first);
        add("")"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), false);
        break;

      case Token.INC:
      case Token.DEC: {
        Preconditions.checkState(childCount == 1);
        String o = type == Token.INC ? ""++"" : ""--"";
        int postProp = n.getIntProp(Node.INCRDECR_PROP);
        // A non-zero post-prop value indicates a post inc/dec, default of zero
        // is a pre-inc/dec.
        if (postProp != 0) {
          addExpr(first, NodeUtil.precedence(type), context);
          cc.addOp(o, false);
        } else {
          cc.addOp(o, false);
          add(first);
        }
        break;
      }

      case Token.CALL:
        // We have two special cases here:
        // 1) If the left hand side of the call is a direct reference to eval,
        // then it must have a DIRECT_EVAL annotation. If it does not, then
        // that means it was originally an indirect call to eval, and that
        // indirectness must be preserved.
        // 2) If the left hand side of the call is a property reference,
        // then the call must not a FREE_CALL annotation. If it does, then
        // that means it was originally an call without an explicit this and
        // that must be preserved.
        if (isIndirectEval(first)
            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {
          add(""(0,"");
          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);
          add("")"");
        } else {
          addExpr(first, NodeUtil.precedence(type), context);
        }
        add(""("");
        addList(first.getNext());
        add("")"");
        break;

      case Token.IF:
        boolean hasElse = childCount == 3;
        boolean ambiguousElseClause =
            context == Context.BEFORE_DANGLING_ELSE && !hasElse;
        if (ambiguousElseClause) {
          cc.beginBlock();
        }

        add(""if("");
        add(first);
        add("")"");

        if (hasElse) {
          addNonEmptyStatement(
              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);
          add(""else"");
          addNonEmptyStatement(
              last, getContextForNonEmptyExpression(context), false);
        } else {
          addNonEmptyStatement(first.getNext(), Context.OTHER, false);
          Preconditions.checkState(childCount == 2);
        }

        if (ambiguousElseClause) {
          cc.endBlock();
        }
        break;

      case Token.NULL:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""null"");
        break;

      case Token.THIS:
        Preconditions.checkState(childCount == 0);
        add(""this"");
        break;

      case Token.FALSE:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""false"");
        break;

      case Token.TRUE:
        Preconditions.checkState(childCount == 0);
        cc.addConstant(""true"");
        break;

      case Token.CONTINUE:
        Preconditions.checkState(childCount <= 1);
        add(""continue"");
        if (childCount == 1) {
          if (!first.isLabelName()) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.DEBUGGER:
        Preconditions.checkState(childCount == 0);
        add(""debugger"");
        cc.endStatement();
        break;

      case Token.BREAK:
        Preconditions.checkState(childCount <= 1);
        add(""break"");
        if (childCount == 1) {
          if (!first.isLabelName()) {
            throw new Error(""Unexpected token type. Should be LABEL_NAME."");
          }
          add("" "");
          add(first);
        }
        cc.endStatement();
        break;

      case Token.EXPR_RESULT:
        Preconditions.checkState(childCount == 1);
        add(first, Context.START_OF_EXPR);
        cc.endStatement();
        break;

      case Token.NEW:
        add(""new "");
        int precedence = NodeUtil.precedence(type);

        // If the first child contains a CALL, then claim higher precedence
        // to force parentheses. Otherwise, when parsed, NEW will bind to the
        // first viable parentheses (don't traverse into functions).
        if (NodeUtil.containsType(
            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {
          precedence = NodeUtil.precedence(first.getType()) + 1;
        }
        addExpr(first, precedence, Context.OTHER);

        // '()' is optional when no arguments are present
        Node next = first.getNext();
        if (next != null) {
          add(""("");
          addList(next);
          add("")"");
        }
        break;

      case Token.STRING_KEY:
        Preconditions.checkState(
            childCount == 1, ""Object lit key must have 1 child"");
        addJsString(n);
        break;

      case Token.STRING:
        Preconditions.checkState(
            childCount == 0, ""A string may not have children"");
        addJsString(n);
        break;

      case Token.DELPROP:
        Preconditions.checkState(childCount == 1);
        add(""delete "");
        add(first);
        break;

      case Token.OBJECTLIT: {
        boolean needsParens = (context == Context.START_OF_EXPR);
        if (needsParens) {
          add(""("");
        }
        add(""{"");
        for (Node c = first; c != null; c = c.getNext()) {
          if (c != first) {
            cc.listSeparator();
          }

          if (c.isGetterDef() || c.isSetterDef()) {
            add(c);
          } else {
            Preconditions.checkState(c.isStringKey());
            String key = c.getString();
            // Object literal property names don't have to be quoted if they
            // are not JavaScript keywords
            if (!c.isQuotedString()
                && !(languageMode == LanguageMode.ECMASCRIPT3
                    && TokenStream.isKeyword(key))
                && TokenStream.isJSIdentifier(key)
                // do not encode literally any non-literal characters that
                // were Unicode escaped.
                && NodeUtil.isLatin(key)) {
              add(key);
            } else {
              // Determine if the string is a simple number.
              double d = getSimpleNumber(key);
              if (!Double.isNaN(d)) {
                cc.addNumber(d);
              } else {
                addExpr(c, 1, Context.OTHER);
              }
            }
            add("":"");
            addExpr(c.getFirstChild(), 1, Context.OTHER);
          }
        }
        add(""}"");
        if (needsParens) {
          add("")"");
        }
        break;
      }

      case Token.SWITCH:
        add(""switch("");
        add(first);
        add("")"");
        cc.beginBlock();
        addAllSiblings(first.getNext());
        cc.endBlock(context == Context.STATEMENT);
        break;

      case Token.CASE:
        Preconditions.checkState(childCount == 2);
        add(""case "");
        add(first);
        addCaseBody(last);
        break;

      case Token.DEFAULT_CASE:
        Preconditions.checkState(childCount == 1);
        add(""default"");
        addCaseBody(first);
        break;

      case Token.LABEL:
        Preconditions.checkState(childCount == 2);
        if (!first.isLabelName()) {
          throw new Error(""Unexpected token type. Should be LABEL_NAME."");
        }
        add(first);
        add("":"");
        addNonEmptyStatement(
            last, getContextForNonEmptyExpression(context), true);
        break;

      case Token.CAST:
        add(""("");
        add(first);
        add("")"");
        break;

      default:
        throw new Error(""Unknown type "" + type + ""\n"" + n.toStringTree());
    }

    cc.endSourceMapping(n);
  }
"
Closure_174,/home/common/huangzhili/defects4j_buggy/Closure_174_buggy/src/com/google/javascript/jscomp/JsAst.java,"  public void setSourceFile(SourceFile file) {
    Preconditions.checkState(fileName.equals(file.getName()));
    sourceFile = file;
  }
"
Closure_174,/home/common/huangzhili/defects4j_buggy/Closure_174_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"  public static Node newQualifiedNameNodeDeclaration(
      CodingConvention convention, String name, Node value, JSDocInfo info) {
    Node result;
    Node nameNode = newQualifiedNameNode(convention, name);
    if (nameNode.isName()) {
      result = IR.var(nameNode, value);
      result.setJSDocInfo(info);
    } else {
      result = IR.exprResult(IR.assign(nameNode, value));
      result.getFirstChild().setJSDocInfo(info);
    }
    return result;
  }
"
Closure_174,/home/common/huangzhili/defects4j_buggy/Closure_174_buggy/src/com/google/javascript/jscomp/JsAst.java,"  private void parse(AbstractCompiler compiler) {
    try {
      ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),
          compiler.getParserConfig(),
          compiler.getDefaultErrorReporter(),
          logger_);
      root = result.ast;
      compiler.setOldParseTree(sourceFile.getName(), result.oldAst);
    } catch (IOException e) {
      compiler.report(
          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));
    }


    if (root == null || compiler.hasHaltingErrors()) {
        // Most passes try to report as many errors as possible,
        // so there may already be errors. We only care if there were
        // errors in the code we just parsed.
      // There was a parse error or IOException, so use a dummy block.
      root = IR.script();
    } else {
      compiler.prepareAst(root);
    }

    // Set the source name so that the compiler passes can track
    // the source file and module.
    root.setStaticSourceFile(sourceFile);
  }
"
Closure_174,/home/common/huangzhili/defects4j_buggy/Closure_174_buggy/src/com/google/javascript/jscomp/ScopedAliases.java,"    private void findAliases(NodeTraversal t) {
      Scope scope = t.getScope();
      for (Var v : scope.getVarIterable()) {
        Node n = v.getNode();
        Node parent = n.getParent();
        boolean isVarAssign = parent.isVar() && n.hasChildren();
        if (isVarAssign && n.getFirstChild().isQualifiedName()) {
          recordAlias(v);
        } else if (v.isBleedingFunction()) {
          // Bleeding functions already get a BAD_PARAMETERS error, so just
          // do nothing.
        } else if (parent.getType() == Token.LP) {
          // Parameters of the scope function also get a BAD_PARAMETERS
          // error.
        } else if (isVarAssign) {
          Node value = v.getInitialValue().detachFromParent();
          String name = n.getString();
          int nameCount = scopedAliasNames.count(name);
          scopedAliasNames.add(name);
          String globalName =
              ""$jscomp.scope."" + name + (nameCount == 0 ? """" : (""$"" + nameCount));

          compiler.ensureLibraryInjected(""base"");

          // Add $jscomp.scope.name = EXPR;
          // Make sure we copy over all the jsdoc and debug info.
            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(
                compiler.getCodingConvention(),
                globalName,
                value,
                v.getJSDocInfo())
                .useSourceInfoIfMissingFromForTree(n);
            NodeUtil.setDebugInformation(
                newDecl.getFirstChild().getFirstChild(), n, name);
            parent.getParent().addChildBefore(newDecl, parent);

          // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;""
          v.getNameNode().addChildToFront(
              NodeUtil.newQualifiedNameNode(
                  compiler.getCodingConvention(), globalName, n, name));

          recordAlias(v);
        } else {
          // Do not allow hoisted functions or other kinds of local symbols.
          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
        }
      }
    }
"
Closure_175,/home/common/huangzhili/defects4j_buggy/Closure_175_buggy/src/com/google/javascript/jscomp/FunctionInjector.java,"  CanInlineResult canInlineReferenceToFunction(NodeTraversal t,
      Node callNode, Node fnNode, Set<String> needAliases,
      InliningMode mode, boolean referencesThis, boolean containsFunctions) {
    // TODO(johnlenz): This function takes too many parameter, without
    // context.  Modify the API to take a structure describing the function.

    // Allow direct function calls or ""fn.call"" style calls.
    if (!isSupportedCallType(callNode)) {
      return CanInlineResult.NO;
    }

    // Limit where functions that contain functions can be inline.  Introducing
    // an inner function into another function can capture a variable and cause
    // a memory leak.  This isn't a problem in the global scope as those values
    // last until explicitly cleared.
    if (containsFunctions) {
      if (!assumeMinimumCapture && !t.inGlobalScope()) {
        // TODO(johnlenz): Allow inlining into any scope without local names or
        // inner functions.
        return CanInlineResult.NO;
      } else if (NodeUtil.isWithinLoop(callNode)) {
        // An inner closure maybe relying on a local value holding a value for a
        // single iteration through a loop.
        return CanInlineResult.NO;
      }
    }

    // TODO(johnlenz): Add support for 'apply'
    if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {
      // TODO(johnlenz): Allow 'this' references to be replaced with a
      // global 'this' object.
      return CanInlineResult.NO;
    }

    if (mode == InliningMode.DIRECT) {
      return canInlineReferenceDirectly(callNode, fnNode);
    } else {
      return canInlineReferenceAsStatementBlock(
          t, callNode, fnNode, needAliases);
    }
  }"
Closure_175,/home/common/huangzhili/defects4j_buggy/Closure_175_buggy/src/com/google/javascript/jscomp/FunctionInjector.java,"  private CanInlineResult canInlineReferenceDirectly(
      Node callNode, Node fnNode) {
    if (!isDirectCallNodeReplacementPossible(fnNode)) {
      return CanInlineResult.NO;
    }

    Node block = fnNode.getLastChild();
    // CALL NODE: [ NAME, ARG1, ARG2, ... ]
    Node cArg = callNode.getFirstChild().getNext();

    // Functions called via 'call' and 'apply' have a this-object as
    // the first parameter, but this is not part of the called function's
    // parameter list.
    if (!callNode.getFirstChild().isName()) {
      if (NodeUtil.isFunctionObjectCall(callNode)) {
        // TODO(johnlenz): Support replace this with a value.
        if (cArg == null || !cArg.isThis()) {
          return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      } else {
        // "".apply"" call should be filtered before this.
        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
      }
    }

    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
    while (cArg != null || fnParam != null) {
      if (fnParam != null) {
        if (cArg != null) {
          if (NodeUtil.mayEffectMutableState(cArg, compiler)
              && NodeUtil.getNameReferenceCount(
                  block, fnParam.getString()) > 1) {
            return CanInlineResult.NO;
          }
        }
        fnParam = fnParam.getNext();
      }
      // Limit the inlining
      if (cArg != null) {
        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
        return CanInlineResult.NO;
        }
        cArg = cArg.getNext();
      }
    }

    return CanInlineResult.YES;
  }
"
Closure_175,/home/common/huangzhili/defects4j_buggy/Closure_175_buggy/src/com/google/javascript/jscomp/FunctionInjector.java,"  private Set<String> knownConstants = Sets.newHashSet();
  private final boolean assumeStrictThis;
  private final boolean assumeMinimumCapture;
  private final Supplier<String> safeNameIdSupplier;

  /**
"
Codec_1,/home/common/huangzhili/defects4j_buggy/Codec_1_buggy/src/java/org/apache/commons/codec/language/Caverphone.java,"    public String caverphone(String txt) {
        // NOTE: Version 1.0 of Caverphone is easily derivable from this code 
        // by commenting out the 2.0 lines and adding in the 1.0 lines

        if( txt == null || txt.length() == 0 ) {
            return ""1111111111"";
        }

        // 1. Convert to lowercase
        txt = txt.toLowerCase();

        // 2. Remove anything not A-Z
        txt = txt.replaceAll(""[^a-z]"", """");

        // 2.5. Remove final e
        txt = txt.replaceAll(""e$"", """");             // 2.0 only

        // 3. Handle various start options
        txt = txt.replaceAll(""^cough"", ""cou2f"");
        txt = txt.replaceAll(""^rough"", ""rou2f"");
        txt = txt.replaceAll(""^tough"", ""tou2f"");
        txt = txt.replaceAll(""^enough"", ""enou2f"");  // 2.0 only
        txt = txt.replaceAll(""^trough"", ""trou2f"");  // 2.0 only - note the spec says ^enough here again, c+p error I assume
        txt = txt.replaceAll(""^gn"", ""2n"");
        txt = txt.replaceAll(""^mb"", ""m2"");

        // 4. Handle replacements
        txt = txt.replaceAll(""cq"", ""2q"");
        txt = txt.replaceAll(""ci"", ""si"");
        txt = txt.replaceAll(""ce"", ""se"");
        txt = txt.replaceAll(""cy"", ""sy"");
        txt = txt.replaceAll(""tch"", ""2ch"");
        txt = txt.replaceAll(""c"", ""k"");
        txt = txt.replaceAll(""q"", ""k"");
        txt = txt.replaceAll(""x"", ""k"");
        txt = txt.replaceAll(""v"", ""f"");
        txt = txt.replaceAll(""dg"", ""2g"");
        txt = txt.replaceAll(""tio"", ""sio"");
        txt = txt.replaceAll(""tia"", ""sia"");
        txt = txt.replaceAll(""d"", ""t"");
        txt = txt.replaceAll(""ph"", ""fh"");
        txt = txt.replaceAll(""b"", ""p"");
        txt = txt.replaceAll(""sh"", ""s2"");
        txt = txt.replaceAll(""z"", ""s"");
        txt = txt.replaceAll(""^[aeiou]"", ""A"");
        txt = txt.replaceAll(""[aeiou]"", ""3"");
        txt = txt.replaceAll(""j"", ""y"");        // 2.0 only
        txt = txt.replaceAll(""^y3"", ""Y3"");     // 2.0 only
        txt = txt.replaceAll(""^y"", ""A"");       // 2.0 only
        txt = txt.replaceAll(""y"", ""3"");        // 2.0 only
        txt = txt.replaceAll(""3gh3"", ""3kh3"");
        txt = txt.replaceAll(""gh"", ""22"");
        txt = txt.replaceAll(""g"", ""k"");
        txt = txt.replaceAll(""s+"", ""S"");
        txt = txt.replaceAll(""t+"", ""T"");
        txt = txt.replaceAll(""p+"", ""P"");
        txt = txt.replaceAll(""k+"", ""K"");
        txt = txt.replaceAll(""f+"", ""F"");
        txt = txt.replaceAll(""m+"", ""M"");
        txt = txt.replaceAll(""n+"", ""N"");
        txt = txt.replaceAll(""w3"", ""W3"");
        //txt = txt.replaceAll(""wy"", ""Wy"");    // 1.0 only
        txt = txt.replaceAll(""wh3"", ""Wh3"");
        txt = txt.replaceAll(""w$"", ""3"");       // 2.0 only
        //txt = txt.replaceAll(""why"", ""Why"");  // 1.0 only
        txt = txt.replaceAll(""w"", ""2"");
        txt = txt.replaceAll(""^h"", ""A"");
        txt = txt.replaceAll(""h"", ""2"");
        txt = txt.replaceAll(""r3"", ""R3"");
        txt = txt.replaceAll(""r$"", ""3"");       // 2.0 only
        //txt = txt.replaceAll(""ry"", ""Ry"");    // 1.0 only
        txt = txt.replaceAll(""r"", ""2"");
        txt = txt.replaceAll(""l3"", ""L3"");
        txt = txt.replaceAll(""l$"", ""3"");       // 2.0 only
        //txt = txt.replaceAll(""ly"", ""Ly"");    // 1.0 only
        txt = txt.replaceAll(""l"", ""2"");
        //txt = txt.replaceAll(""j"", ""y"");      // 1.0 only
        //txt = txt.replaceAll(""y3"", ""Y3"");    // 1.0 only
        //txt = txt.replaceAll(""y"", ""2"");      // 1.0 only

        // 5. Handle removals
        txt = txt.replaceAll(""2"", """");
        txt = txt.replaceAll(""3$"", ""A"");       // 2.0 only
        txt = txt.replaceAll(""3"", """");

        // 6. put ten 1s on the end
        txt = txt + ""111111"" + ""1111"";        // 1.0 only has 6 1s

        // 7. take the first six characters as the code
        return txt.substring(0, 10);          // 1.0 truncates to 6
    }
"
Codec_1,/home/common/huangzhili/defects4j_buggy/Codec_1_buggy/src/java/org/apache/commons/codec/language/SoundexUtils.java,"    static String clean(String str) {
        if (str == null || str.length() == 0) {
            return str;
        }
        int len = str.length();
        char[] chars = new char[len];
        int count = 0;
        for (int i = 0; i < len; i++) {
            if (Character.isLetter(str.charAt(i))) {
                chars[count++] = str.charAt(i);
            }
        }
        if (count == len) {
            return str.toUpperCase();
        }
        return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);
    }
"
Codec_1,/home/common/huangzhili/defects4j_buggy/Codec_1_buggy/src/java/org/apache/commons/codec/language/Metaphone.java,"    public String metaphone(String txt) {
        boolean hard = false ;
        if ((txt == null) || (txt.length() == 0)) {
            return """" ;
        }
        // single character is itself
        if (txt.length() == 1) {
            return txt.toUpperCase() ;
        }
      
        char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray() ;
      
        StringBuffer local = new StringBuffer(40); // manipulate
        StringBuffer code = new StringBuffer(10) ; //   output
        // handle initial 2 characters exceptions
        switch(inwd[0]) {
        case 'K' : 
        case 'G' : 
        case 'P' : /* looking for KN, etc*/
            if (inwd[1] == 'N') {
                local.append(inwd, 1, inwd.length - 1);
            } else {
                local.append(inwd);
            }
            break;
        case 'A': /* looking for AE */
            if (inwd[1] == 'E') {
                local.append(inwd, 1, inwd.length - 1);
            } else {
                local.append(inwd);
            }
            break;
        case 'W' : /* looking for WR or WH */
            if (inwd[1] == 'R') {   // WR -> R
                local.append(inwd, 1, inwd.length - 1); 
                break ;
            }
            if (inwd[1] == 'H') {
                local.append(inwd, 1, inwd.length - 1);
                local.setCharAt(0, 'W'); // WH -> W
            } else {
                local.append(inwd);
            }
            break;
        case 'X' : /* initial X becomes S */
            inwd[0] = 'S';
            local.append(inwd);
            break ;
        default :
            local.append(inwd);
        } // now local has working string with initials fixed

        int wdsz = local.length();
        int n = 0 ;

        while ((code.length() < this.getMaxCodeLen()) && 
        	   (n < wdsz) ) { // max code size of 4 works well
            char symb = local.charAt(n) ;
            // remove duplicate letters except C
            if ((symb != 'C') && (isPreviousChar( local, n, symb )) ) {
                n++ ;
            } else { // not dup
                switch(symb) {
                case 'A' : case 'E' : case 'I' : case 'O' : case 'U' :
                    if (n == 0) { 
                        code.append(symb);
                    }
                    break ; // only use vowel if leading char
                case 'B' :
                    if ( isPreviousChar(local, n, 'M') && 
                         isLastChar(wdsz, n) ) { // B is silent if word ends in MB
						break;
                    }
                    code.append(symb);
                    break;
                case 'C' : // lots of C special cases
                    /* discard if SCI, SCE or SCY */
                    if ( isPreviousChar(local, n, 'S') && 
                         !isLastChar(wdsz, n) && 
                         (FRONTV.indexOf(local.charAt(n + 1)) >= 0) ) { 
                        break;
                    }
                    if (regionMatch(local, n, ""CIA"")) { // ""CIA"" -> X
                        code.append('X'); 
                        break;
                    }
                    if (!isLastChar(wdsz, n) && 
                        (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
                        code.append('S');
                        break; // CI,CE,CY -> S
                    }
                    if (isPreviousChar(local, n, 'S') &&
						isNextChar(local, n, 'H') ) { // SCH->sk
                        code.append('K') ; 
                        break ;
                    }
                    if (isNextChar(local, n, 'H')) { // detect CH
                        if ((n == 0) && 
                        	(wdsz >= 3) && 
                            isVowel(local,2) ) { // CH consonant -> K consonant
                            code.append('K');
                        } else { 
                            code.append('X'); // CHvowel -> X
                        }
                    } else { 
                        code.append('K');
                    }
                    break ;
                case 'D' :
                    if (!isLastChar(wdsz, n + 1) && 
                        isNextChar(local, n, 'G') && 
                        (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) { // DGE DGI DGY -> J 
                        code.append('J'); n += 2 ;
                    } else { 
                        code.append('T');
                    }
                    break ;
                case 'G' : // GH silent at end or before consonant
                    if (isLastChar(wdsz, n + 1) && 
                        isNextChar(local, n, 'H')) {
                        break;
                    }
                    if (!isLastChar(wdsz, n + 1) &&  
                        isNextChar(local,n,'H') && 
                        !isVowel(local,n+2)) {
                        break;
                    }
                    if ((n > 0) && 
                    	( regionMatch(local, n, ""GN"") ||
					      regionMatch(local, n, ""GNED"") ) ) {
                        break; // silent G
                    }
                    if (isPreviousChar(local, n, 'G')) {
                        hard = true ;
                    } else {
                        hard = false ;
                    }
                    if (!isLastChar(wdsz, n) && 
                        (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && 
                        (!hard)) {
                        code.append('J');
                    } else {
                        code.append('K');
                    }
                    break ;
                case 'H':
                    if (isLastChar(wdsz, n)) {
                        break ; // terminal H
                    }
                    if ((n > 0) && 
                        (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
                        break;
                    }
                    if (isVowel(local,n+1)) {
                        code.append('H'); // Hvowel
                    }
                    break;
                case 'F': 
                case 'J' : 
                case 'L' :
                case 'M': 
                case 'N' : 
                case 'R' :
                    code.append(symb); 
                    break;
                case 'K' :
                    if (n > 0) { // not initial
                        if (!isPreviousChar(local, n, 'C')) {
                            code.append(symb);
                        }
                    } else {
                        code.append(symb); // initial K
                    }
                    break ;
                case 'P' :
                    if (isNextChar(local,n,'H')) {
                        // PH -> F
                        code.append('F');
                    } else {
                        code.append(symb);
                    }
                    break ;
                case 'Q' :
                    code.append('K');
                    break;
                case 'S' :
                    if (regionMatch(local,n,""SH"") || 
					    regionMatch(local,n,""SIO"") || 
					    regionMatch(local,n,""SIA"")) {
                        code.append('X');
                    } else {
                        code.append('S');
                    }
                    break;
                case 'T' :
                    if (regionMatch(local,n,""TIA"") || 
						regionMatch(local,n,""TIO"")) {
                        code.append('X'); 
                        break;
                    }
                    if (regionMatch(local,n,""TCH"")) {
						// Silent if in ""TCH""
                        break;
                    }
                    // substitute numeral 0 for TH (resembles theta after all)
                    if (regionMatch(local,n,""TH"")) {
                        code.append('0');
                    } else {
                        code.append('T');
                    }
                    break ;
                case 'V' :
                    code.append('F'); break ;
                case 'W' : case 'Y' : // silent if not followed by vowel
                    if (!isLastChar(wdsz,n) && 
                    	isVowel(local,n+1)) {
                        code.append(symb);
                    }
                    break ;
                case 'X' :
                    code.append('K'); code.append('S');
                    break ;
                case 'Z' :
                    code.append('S'); break ;
                } // end switch
                n++ ;
            } // end else from symb != 'C'
            if (code.length() > this.getMaxCodeLen()) { 
            	code.setLength(this.getMaxCodeLen()); 
            }
        }
        return code.toString();
    }
"
Codec_8,/home/common/huangzhili/defects4j_buggy/Codec_8_buggy/src/java/org/apache/commons/codec/binary/Base64InputStream.java,"public int read(byte b[], int offset, int len) throws IOException {
        if (b == null) {
            throw new NullPointerException();
        } else if (offset < 0 || len < 0) {
            throw new IndexOutOfBoundsException();
        } else if (offset > b.length || offset + len > b.length) {
            throw new IndexOutOfBoundsException();
        } else if (len == 0) {
            return 0;
        } else {
            int readLen = 0;
            /*
             Rationale for while-loop on (readLen == 0):
             -----
             Base64.readResults() usually returns > 0 or EOF (-1).  In the
             rare case where it returns 0, we just keep trying.

             This is essentially an undocumented contract for InputStream
             implementors that want their code to work properly with
             java.io.InputStreamReader, since the latter hates it when
             InputStream.read(byte[]) returns a zero.  Unfortunately our
             readResults() call must return 0 if a large amount of the data
             being decoded was non-base64, so this while-loop enables proper
             interop with InputStreamReader for that scenario.
             -----
             This is a fix for CODEC-101
            */
            while (readLen == 0) {
                 if (!base64.hasData()) {
                     byte[] buf = new byte[doEncode ? 4096 : 8192];
                     int c = in.read(buf);
                     if (c > 0 && b.length == len) {
                         base64.setInitialBuffer(b, offset, len);
                     }
                     if (doEncode) {
                         base64.encode(buf, 0, c);
                     } else {
                        base64.decode(buf, 0, c);
                    }
                }
                readLen = base64.readResults(b, offset, len);
            }
            return readLen;
        }
    }"
Codec_11,/home/common/huangzhili/defects4j_buggy/Codec_11_buggy/src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java,"public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
        if (bytes == null) {
            return null;
        }
        if (printable == null) {
             printable = PRINTABLE_CHARS;
         }
         ByteArrayOutputStream buffer = new ByteArrayOutputStream();
         // encode up to buffer.length - 3, the last three octets will be treated
         // separately for simplification of note #3
                 // up to this length it is safe to add any byte, encoded or not
         for (byte c : bytes) {
             int b = c;
             if (b < 0) {
                 b = 256 + b;
             }
             if (printable.get(b)) {
                 buffer.write(b);
             } else {
                 // rule #3: whitespace at the end of a line *must* be encoded
 
                 // rule #5: soft line break
                 encodeQuotedPrintable(b, buffer);
             }
         }
 
         // rule #3: whitespace at the end of a line *must* be encoded
         // if we would do a soft break line after this octet, encode whitespace
 
         // note #3: '=' *must not* be the ultimate or penultimate character
         // simplification: if < 6 bytes left, do a soft line break as we may need
         //                 exactly 6 bytes space for the last 2 bytes
             // rule #3: trailing whitespace shall be encoded
 
         return buffer.toByteArray();
     }"
Codec_11,/home/common/huangzhili/defects4j_buggy/Codec_11_buggy/src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java,"public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
        if (bytes == null) {
            return null;
        }
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        for (int i = 0; i < bytes.length; i++) {
            final int b = bytes[i];
             if (b == ESCAPE_CHAR) {
                 try {
                     // if the next octet is a CR we have found a soft line break
                     int u = Utils.digit16(bytes[++i]);
                     int l = Utils.digit16(bytes[++i]);
                     buffer.write((char) ((u << 4) + l));
                 } catch (ArrayIndexOutOfBoundsException e) {
                     throw new DecoderException(""Invalid quoted-printable encoding"", e);
                 }
             } else {
                 // every other octet is appended except for CR & LF
                 buffer.write(b);
             }
        }
        return buffer.toByteArray();
    }"
Codec_12,/home/common/huangzhili/defects4j_buggy/Codec_12_buggy/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.codec.binary;

import static org.apache.commons.codec.binary.BaseNCodec.EOF;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Abstract superclass for Base-N input streams.
 * 
 * @since 1.5
 */
public class BaseNCodecInputStream extends FilterInputStream {

    private final boolean doEncode;

    private final BaseNCodec baseNCodec;

    private final byte[] singleByte = new byte[1];

    protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) {
        super(in);
        this.doEncode = doEncode;
        this.baseNCodec = baseNCodec;
    }

    /**
     * Reads one <code>byte</code> from this input stream.
     * 
     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.
     * @throws IOException
     *             if an I/O error occurs.
     */
    @Override
    public int read() throws IOException {
        int r = read(singleByte, 0, 1);
        while (r == 0) {
            r = read(singleByte, 0, 1);
        }
        if (r > 0) {
            final byte b = singleByte[0];
            return b < 0 ? 256 + b : b;
        }
        return EOF;
    }

    /**
     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>
     * from this InputStream.
     * 
     * @param b
     *            destination byte array
     * @param offset
     *            where to start writing the bytes
     * @param len
     *            maximum number of bytes to read
     * 
     * @return number of bytes read
     * @throws IOException
     *             if an I/O error occurs.
     * @throws NullPointerException
     *             if the byte array parameter is null
     * @throws IndexOutOfBoundsException
     *             if offset, len or buffer size are invalid
     */
    @Override
    public int read(byte b[], int offset, int len) throws IOException {
        if (b == null) {
            throw new NullPointerException();
        } else if (offset < 0 || len < 0) {
            throw new IndexOutOfBoundsException();
        } else if (offset > b.length || offset + len > b.length) {
            throw new IndexOutOfBoundsException();
        } else if (len == 0) {
            return 0;
        } else {
            int readLen = 0;
            /*
             Rationale for while-loop on (readLen == 0):
             -----
             Base32.readResults() usually returns > 0 or EOF (-1).  In the
             rare case where it returns 0, we just keep trying.

             This is essentially an undocumented contract for InputStream
             implementors that want their code to work properly with
             java.io.InputStreamReader, since the latter hates it when
             InputStream.read(byte[]) returns a zero.  Unfortunately our
             readResults() call must return 0 if a large amount of the data
             being decoded was non-base32, so this while-loop enables proper
             interop with InputStreamReader for that scenario.
             -----
             This is a fix for CODEC-101
            */
            while (readLen == 0) {
                if (!baseNCodec.hasData()) {
                    byte[] buf = new byte[doEncode ? 4096 : 8192];
                    int c = in.read(buf);
                    if (doEncode) {
                        baseNCodec.encode(buf, 0, c);
                    } else {
                        baseNCodec.decode(buf, 0, c);
                    }
                }
                readLen = baseNCodec.readResults(b, offset, len);
            }
            return readLen;
        }
    }
    /**
     * {@inheritDoc}
     * 
     * @return false
     */
    @Override
    public boolean markSupported() {
        return false; // not an easy job to support marks
    }

    /**
     * {@inheritDoc}
     *
     * @throws IllegalArgumentException if the provided skip length is negative
     */

        // skip in chunks of 512 bytes


    /**
     * {@inheritDoc}
     *
     * @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>,
     * <code>1</code> otherwise
     */
        // Note: the logic is similar to the InflaterInputStream:
        //       as long as we have not reached EOF, indicate that there is more
        //       data available. As we do not know for sure how much data is left,
        //       just return 1 as a safe guess.

        // use the EOF flag of the underlying codec instance
}
"
Codec_13,/home/common/huangzhili/defects4j_buggy/Codec_13_buggy/src/main/java/org/apache/commons/codec/language/DoubleMetaphone.java,"    public boolean isDoubleMetaphoneEqual(final String value1, final String value2, final boolean alternate) {
        return doubleMetaphone(value1, alternate).equals(doubleMetaphone(value2, alternate));
    }
"
Codec_13,/home/common/huangzhili/defects4j_buggy/Codec_13_buggy/src/main/java/org/apache/commons/codec/binary/StringUtils.java,"    private static byte[] getBytes(final String string, final Charset charset) {
        if (string == null) {
            return null;
        }
        return string.getBytes(charset);
    }
"
Codec_14,/home/common/huangzhili/defects4j_buggy/Codec_14_buggy/src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java,"private PhonemeBuilder applyFinalRules(final PhonemeBuilder phonemeBuilder,
                                           final Map<String, List<Rule>> finalRules) {
        if (finalRules == null) {
            throw new NullPointerException(""finalRules can not be null"");
        }
        if (finalRules.isEmpty()) {
             return phonemeBuilder;
         }
 
         final Set<Rule.Phoneme> phonemes = new TreeSet<Rule.Phoneme>(Rule.Phoneme.COMPARATOR);
 
         for (final Rule.Phoneme phoneme : phonemeBuilder.getPhonemes()) {
             PhonemeBuilder subBuilder = PhonemeBuilder.empty(phoneme.getLanguages());
            final String phonemeText = phoneme.getPhonemeText().toString();

            for (int i = 0; i < phonemeText.length();) {
                final RulesApplication rulesApplication =
                        new RulesApplication(finalRules, phonemeText, subBuilder, i, maxPhonemes).invoke();
                final boolean found = rulesApplication.isFound();
                subBuilder = rulesApplication.getPhonemeBuilder();

                if (!found) {
                    // not found, appending as-is
                    subBuilder.append(phonemeText.subSequence(i, i + 1));
                }

                i = rulesApplication.getI();
            }

            // the phonemes map orders the phonemes only based on their text, but ignores the language set
            // when adding new phonemes, check for equal phonemes and merge their language set, otherwise
            // phonemes with the same text but different language set get lost
            phonemes.addAll(subBuilder.getPhonemes());
        }

        return new PhonemeBuilder(phonemes);
    }"
Codec_16,/home/common/huangzhili/defects4j_buggy/Codec_16_buggy/src/main/java/org/apache/commons/codec/binary/Base32.java,"    public Base32() {
        this(false);
    }
"
Collections_1,/home/common/huangzhili/defects4j_buggy/Collections_1_buggy/src/java/org/apache/commons/collections/map/Flat3Map.java,"        public Object setValue(Object value) {
            if (canRemove == false) {
                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);
            }
            Object old = getValue();
            switch (nextIndex) {
                case 3: 
                    parent.value3 = value;
                case 2:
                    parent.value2 = value;
                case 1:
                    parent.value1 = value;
            }
            return old;
        }
"
Collections_2,/home/common/huangzhili/defects4j_buggy/Collections_2_buggy/src/java/org/apache/commons/collections/ExtendedProperties.java,"    public String getInclude() {
            return include;  // backwards compatability
    }
"
Collections_2,/home/common/huangzhili/defects4j_buggy/Collections_2_buggy/src/java/org/apache/commons/collections/ExtendedProperties.java,"    protected ArrayList keysAsListed = new ArrayList();

    protected final static String START_TOKEN=""${"";
    protected final static String END_TOKEN=""}"";
"
Collections_2,/home/common/huangzhili/defects4j_buggy/Collections_2_buggy/src/java/org/apache/commons/collections/ExtendedProperties.java,"    public void setInclude(String inc) {
        include = inc;
    }
"
Collections_2,/home/common/huangzhili/defects4j_buggy/Collections_2_buggy/src/java/org/apache/commons/collections/ExtendedProperties.java,"    public synchronized void load(InputStream input, String enc) throws IOException {
        PropertiesReader reader = null;
        if (enc != null) {
            try {
                reader = new PropertiesReader(new InputStreamReader(input, enc));
                
            } catch (UnsupportedEncodingException ex) {
                // Another try coming up....
            }
        }
        
        if (reader == null) {
            try {
                reader = new PropertiesReader(new InputStreamReader(input, ""8859_1""));
                
            } catch (UnsupportedEncodingException ex) {
                // ISO8859-1 support is required on java platforms but....
                // If it's not supported, use the system default encoding
                reader = new PropertiesReader(new InputStreamReader(input));
            }
        }

        try {
            while (true) {
                String line = reader.readProperty();
                if (line == null) {
                    return;  // EOF
                }
                int equalSign = line.indexOf('=');

                if (equalSign > 0) {
                    String key = line.substring(0, equalSign).trim();
                    String value = line.substring(equalSign + 1).trim();

                    // Configure produces lines like this ... just ignore them
                    if ("""".equals(value)) {
                        continue;
                    }

                    if (getInclude() != null && key.equalsIgnoreCase(getInclude())) {
                        // Recursively load properties files.
                        File file = null;

                        if (value.startsWith(fileSeparator)) {
                            // We have an absolute path so we'll use this
                            file = new File(value);
                            
                        } else {
                            // We have a relative path, and we have two 
                            // possible forms here. If we have the ""./"" form
                            // then just strip that off first before continuing.
                            if (value.startsWith(""."" + fileSeparator)) {
                                value = value.substring(2);
                            }

                            file = new File(basePath + value);
                        }

                        if (file != null && file.exists() && file.canRead()) {
                            load(new FileInputStream(file));
                        }
                    } else {
                        addProperty(key, value);
                    }
                }
            }
        } finally {
            // Loading is initializing
            isInitialized = true;
        }
    }
"
Collections_3,/home/common/huangzhili/defects4j_buggy/Collections_3_buggy/src/java/org/apache/commons/collections/CollectionUtils.java,"    public static Collection removeAll(Collection collection, Collection remove) {
        return ListUtils.retainAll(collection, remove);
    }
"
Collections_4,/home/common/huangzhili/defects4j_buggy/Collections_4_buggy/src/java/org/apache/commons/collections/map/MultiValueMap.java,"    public Object put(Object key, Object value) {
        boolean result = false;
        Collection coll = getCollection(key);
        if (coll == null) {
            coll = createCollection(1);  // might produce a non-empty collection
            result = coll.add(value);
            if (coll.size() > 0) {
                // only add if non-zero size to maintain class state
                getMap().put(key, coll);
                result = false;
            }
        } else {
            result = coll.add(value);
        }
        return (result ? value : null);
    }
"
Collections_4,/home/common/huangzhili/defects4j_buggy/Collections_4_buggy/src/java/org/apache/commons/collections/map/MultiValueMap.java,"    public boolean putAll(Object key, Collection values) {
        if (values == null || values.size() == 0) {
            return false;
        }
        Collection coll = getCollection(key);
        if (coll == null) {
            coll = createCollection(values.size());  // might produce a non-empty collection
            boolean result = coll.addAll(values);
            if (coll.size() > 0) {
                // only add if non-zero size to maintain class state
                getMap().put(key, coll);
                result = false;
            }
            return result;
        } else {
            return coll.addAll(values);
        }
    }
"
Collections_5,/home/common/huangzhili/defects4j_buggy/Collections_5_buggy/src/java/org/apache/commons/collections/list/SetUniqueList.java,"    public boolean addAll(int index, Collection coll) {
        // gets initial size
        final int sizeBefore = size();

        // adds all elements
        for (final Iterator it = coll.iterator(); it.hasNext();) {
            add(it.next());
            // if it was inserted, then increase the target index
        }

        // compares sizes to detect if collection changed
        return sizeBefore != size();
    }"
Collections_6,/home/common/huangzhili/defects4j_buggy/Collections_6_buggy/src/java/org/apache/commons/collections/map/Flat3Map.java,"    public Object remove(Object key) {
        if (delegateMap != null) {
            return delegateMap.remove(key);
        }
        if (size == 0) {
            return null;
        }
        if (key == null) {
            switch (size) {  // drop through
                case 3:
                    if (key3 == null) {
                        Object old = value3;
                        hash3 = 0;
                        key3 = null;
                        value3 = null;
                        size = 2;
                        return old;
                    }
                    if (key2 == null) {
                        Object old = value3;
                        hash2 = hash3;
                        key2 = key3;
                        value2 = value3;
                        hash3 = 0;
                        key3 = null;
                        value3 = null;
                        size = 2;
                        return old;
                    }
                    if (key1 == null) {
                        Object old = value3;
                        hash1 = hash3;
                        key1 = key3;
                        value1 = value3;
                        hash3 = 0;
                        key3 = null;
                        value3 = null;
                        size = 2;
                        return old;
                    }
                    return null;
                case 2:
                    if (key2 == null) {
                        Object old = value2;
                        hash2 = 0;
                        key2 = null;
                        value2 = null;
                        size = 1;
                        return old;
                    }
                    if (key1 == null) {
                        Object old = value2;
                        hash1 = hash2;
                        key1 = key2;
                        value1 = value2;
                        hash2 = 0;
                        key2 = null;
                        value2 = null;
                        size = 1;
                        return old;
                    }
                    return null;
                case 1:
                    if (key1 == null) {
                        Object old = value1;
                        hash1 = 0;
                        key1 = null;
                        value1 = null;
                        size = 0;
                        return old;
                    }
            }
        } else {
            if (size > 0) {
                int hashCode = key.hashCode();
                switch (size) {  // drop through
                    case 3:
                        if (hash3 == hashCode && key.equals(key3)) {
                            Object old = value3;
                            hash3 = 0;
                            key3 = null;
                            value3 = null;
                            size = 2;
                            return old;
                        }
                        if (hash2 == hashCode && key.equals(key2)) {
                            Object old = value3;
                            hash2 = hash3;
                            key2 = key3;
                            value2 = value3;
                            hash3 = 0;
                            key3 = null;
                            value3 = null;
                            size = 2;
                            return old;
                        }
                        if (hash1 == hashCode && key.equals(key1)) {
                            Object old = value3;
                            hash1 = hash3;
                            key1 = key3;
                            value1 = value3;
                            hash3 = 0;
                            key3 = null;
                            value3 = null;
                            size = 2;
                            return old;
                        }
                        return null;
                    case 2:
                        if (hash2 == hashCode && key.equals(key2)) {
                            Object old = value2;
                            hash2 = 0;
                            key2 = null;
                            value2 = null;
                            size = 1;
                            return old;
                        }
                        if (hash1 == hashCode && key.equals(key1)) {
                            Object old = value2;
                            hash1 = hash2;
                            key1 = key2;
                            value1 = value2;
                            hash2 = 0;
                            key2 = null;
                            value2 = null;
                            size = 1;
                            return old;
                        }
                        return null;
                    case 1:
                        if (hash1 == hashCode && key.equals(key1)) {
                            Object old = value1;
                            hash1 = 0;
                            key1 = null;
                            value1 = null;
                            size = 0;
                            return old;
                        }
                }
            }
        }
        return null;
    }
"
Collections_7,/home/common/huangzhili/defects4j_buggy/Collections_7_buggy/src/java/org/apache/commons/collections/ExtendedProperties.java,"    public Short getShort(String key, Short defaultValue) {
        Object value = get(key);

        if (value instanceof Short) {
            return (Short) value;
            
        } else if (value instanceof String) {
            Short s = new Short((String) value);
            put(key, s);
            return s;
            
        } else if (value == null) {
            if (defaults != null) {
                return defaults.getShort(key, defaultValue);
            } else {
                return defaultValue;
            }
        } else {
            throw new ClassCastException('\'' + key + ""' doesn't map to a Short object"");
        }
    }
"
Collections_7,/home/common/huangzhili/defects4j_buggy/Collections_7_buggy/src/java/org/apache/commons/collections/ExtendedProperties.java,"    /**
     * Remove the property specified by the key from the 
     * ExtendedProperties.
     *
     * @param key specifying the property
     * @return old value of the property
     */"
Collections_7,/home/common/huangzhili/defects4j_buggy/Collections_7_buggy/src/java/org/apache/commons/collections/ExtendedProperties.java,"    public void putAll(Map map) {
        if (map instanceof ExtendedProperties) {
            for (Iterator it = ((ExtendedProperties) map).getKeys(); it.hasNext(); ) {
                Object key = it.next();
                put(key, map.get(key));
            }
        } else {
            for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {
                Map.Entry entry = (Map.Entry) it.next();
                put(entry.getKey(), entry.getValue());
            }
        }
    }
"
Collections_7,/home/common/huangzhili/defects4j_buggy/Collections_7_buggy/src/java/org/apache/commons/collections/ExtendedProperties.java,"    public Double getDouble(String key, Double defaultValue) {
        Object value = get(key);

        if (value instanceof Double) {
            return (Double) value;
            
        } else if (value instanceof String) {
            Double d = new Double((String) value);
            put(key, d);
            return d;
            
        } else if (value == null) {
            if (defaults != null) {
                return defaults.getDouble(key, defaultValue);
            } else {
                return defaultValue;
            }
        } else {
            throw new ClassCastException('\'' + key + ""' doesn't map to a Double object"");
        }
    }
"
Collections_7,/home/common/huangzhili/defects4j_buggy/Collections_7_buggy/src/java/org/apache/commons/collections/ExtendedProperties.java,"    public Long getLong(String key, Long defaultValue) {
        Object value = get(key);

        if (value instanceof Long) {
            return (Long) value;
            
        } else if (value instanceof String) {
            Long l = new Long((String) value);
            put(key, l);
            return l;
            
        } else if (value == null) {
            if (defaults != null) {
                return defaults.getLong(key, defaultValue);
            } else {
                return defaultValue;
            }
        } else {
            throw new ClassCastException('\'' + key + ""' doesn't map to a Long object"");
        }
    }
"
Collections_7,/home/common/huangzhili/defects4j_buggy/Collections_7_buggy/src/java/org/apache/commons/collections/ExtendedProperties.java,"    public Integer getInteger(String key, Integer defaultValue) {
        Object value = get(key);

        if (value instanceof Integer) {
            return (Integer) value;
            
        } else if (value instanceof String) {
            Integer i = new Integer((String) value);
            put(key, i);
            return i;
            
        } else if (value == null) {
            if (defaults != null) {
                return defaults.getInteger(key, defaultValue);
            } else {
                return defaultValue;
            }
        } else {
            throw new ClassCastException('\'' + key + ""' doesn't map to a Integer object"");
        }
    }
"
Collections_7,/home/common/huangzhili/defects4j_buggy/Collections_7_buggy/src/java/org/apache/commons/collections/ExtendedProperties.java,"    public Byte getByte(String key, Byte defaultValue) {
        Object value = get(key);

        if (value instanceof Byte) {
            return (Byte) value;
            
        } else if (value instanceof String) {
            Byte b = new Byte((String) value);
            put(key, b);
            return b;
            
        } else if (value == null) {
            if (defaults != null) {
                return defaults.getByte(key, defaultValue);
            } else {
                return defaultValue;
            }
        } else {
            throw new ClassCastException('\'' + key + ""' doesn't map to a Byte object"");
        }
    }
"
Collections_7,/home/common/huangzhili/defects4j_buggy/Collections_7_buggy/src/java/org/apache/commons/collections/ExtendedProperties.java,"    private void addPropertyDirect(String key, Object value) {
        // safety check
        if (!containsKey(key)) {
            keysAsListed.add(key);
        }
        put(key, value);
    }
"
Collections_7,/home/common/huangzhili/defects4j_buggy/Collections_7_buggy/src/java/org/apache/commons/collections/ExtendedProperties.java,"    public Float getFloat(String key, Float defaultValue) {
        Object value = get(key);

        if (value instanceof Float) {
            return (Float) value;
            
        } else if (value instanceof String) {
            Float f = new Float((String) value);
            put(key, f);
            return f;
            
        } else if (value == null) {
            if (defaults != null) {
                return defaults.getFloat(key, defaultValue);
            } else {
                return defaultValue;
            }
        } else {
            throw new ClassCastException('\'' + key + ""' doesn't map to a Float object"");
        }
    }
"
Collections_7,/home/common/huangzhili/defects4j_buggy/Collections_7_buggy/src/java/org/apache/commons/collections/ExtendedProperties.java,"    public Vector getVector(String key, Vector defaultValue) {
        Object value = get(key);

        if (value instanceof List) {
            return new Vector((List) value);
            
        } else if (value instanceof String) {
            Vector values = new Vector(1);
            values.add(value);
            put(key, values);
            return values;
            
        } else if (value == null) {
            if (defaults != null) {
                return defaults.getVector(key, defaultValue);
            } else {
                return ((defaultValue == null) ? new Vector() : defaultValue);
            }
        } else {
            throw new ClassCastException('\'' + key + ""' doesn't map to a Vector object"");
        }
    }
"
Collections_7,/home/common/huangzhili/defects4j_buggy/Collections_7_buggy/src/java/org/apache/commons/collections/ExtendedProperties.java,"    public void clearProperty(String key) {
        if (containsKey(key)) {
            // we also need to rebuild the keysAsListed or else
            // things get *very* confusing
            for (int i = 0; i < keysAsListed.size(); i++) {
                if (( keysAsListed.get(i)).equals(key)) {
                    keysAsListed.remove(i);
                    break;
                }
            }
            remove(key);
        }
    }
"
Collections_7,/home/common/huangzhili/defects4j_buggy/Collections_7_buggy/src/java/org/apache/commons/collections/ExtendedProperties.java,"    public Object getProperty(String key) {
        // first, try to get from the 'user value' store
        Object obj = this.get(key);

        if (obj == null) {
            // if there isn't a value there, get it from the
            // defaults if we have them
            if (defaults != null) {
                obj = defaults.get(key);
            }
        }

        return obj;
    }
"
Collections_7,/home/common/huangzhili/defects4j_buggy/Collections_7_buggy/src/java/org/apache/commons/collections/ExtendedProperties.java,"    public List getList(String key, List defaultValue) {
        Object value = get(key);

        if (value instanceof List) {
            return new ArrayList((List) value);
            
        } else if (value instanceof String) {
            List values = new ArrayList(1);
            values.add(value);
            put(key, values);
            return values;
            
        } else if (value == null) {
            if (defaults != null) {
                return defaults.getList(key, defaultValue);
            } else {
                return ((defaultValue == null) ? new ArrayList() : defaultValue);
            }
        } else {
            throw new ClassCastException('\'' + key + ""' doesn't map to a List object"");
        }
    }
"
Collections_7,/home/common/huangzhili/defects4j_buggy/Collections_7_buggy/src/java/org/apache/commons/collections/ExtendedProperties.java,"    private void addPropertyInternal(String key, Object value) {
        Object current = this.get(key);

        if (current instanceof String) {
            // one object already in map - convert it to a vector
            List values = new Vector(2);
            values.add(current);
            values.add(value);
            put(key, values);
            
        } else if (current instanceof List) {
            // already a list - just add the new token
            ((List) current).add(value);
            
        } else {
            // brand new key - store in keysAsListed to retain order
            if (!containsKey(key)) {
                keysAsListed.add(key);
            }
            put(key, value);
        }
    }
"
Collections_7,/home/common/huangzhili/defects4j_buggy/Collections_7_buggy/src/java/org/apache/commons/collections/ExtendedProperties.java,"    public Boolean getBoolean(String key, Boolean defaultValue) {

        Object value = get(key);

        if (value instanceof Boolean) {
            return (Boolean) value;
            
        } else if (value instanceof String) {
            String s = testBoolean((String) value);
            Boolean b = new Boolean(s);
            put(key, b);
            return b;
            
        } else if (value == null) {
            if (defaults != null) {
                return defaults.getBoolean(key, defaultValue);
            } else {
                return defaultValue;
            }
        } else {
            throw new ClassCastException('\'' + key + ""' doesn't map to a Boolean object"");
        }
    }
"
Collections_8,/home/common/huangzhili/defects4j_buggy/Collections_8_buggy/src/java/org/apache/commons/collections/buffer/UnboundedFifoBuffer.java,"    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        int size = in.readInt();
        buffer = new Object[size + 1];
        for (int i = 0; i < size; i++) {
            buffer[i] = in.readObject();
        }
        head = 0;
        tail = size;
    }
"
Collections_8,/home/common/huangzhili/defects4j_buggy/Collections_8_buggy/src/java/org/apache/commons/collections/buffer/UnboundedFifoBuffer.java,"    private void writeObject(ObjectOutputStream out) throws IOException {
        out.defaultWriteObject();
        out.writeInt(size());
        for (Iterator it = iterator(); it.hasNext();) {
            out.writeObject(it.next());
        }
    }
"
Collections_9,/home/common/huangzhili/defects4j_buggy/Collections_9_buggy/src/java/org/apache/commons/collections/ExtendedProperties.java,"    public void combine(ExtendedProperties props) {
        for (Iterator it = props.getKeys(); it.hasNext();) {
            String key = (String) it.next();
            setProperty(key, props.get(key));
        }
    }
"
Collections_10,/home/common/huangzhili/defects4j_buggy/Collections_10_buggy/src/java/org/apache/commons/collections/map/MultiValueMap.java,"        public Object next() {
            return iterator.next();
        }
"
Collections_10,/home/common/huangzhili/defects4j_buggy/Collections_10_buggy/src/java/org/apache/commons/collections/map/MultiValueMap.java,"    public static MultiValueMap decorate(Map map) {
        return new MultiValueMap(map, new ReflectionFactory(ArrayList.class));
    }
"
Collections_11,/home/common/huangzhili/defects4j_buggy/Collections_11_buggy/src/java/org/apache/commons/collections/keyvalue/MultiKey.java,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the ""License""); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an ""AS IS"" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.apache.commons.collections.keyvalue;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.util.Arrays;

/** 
 * A <code>MultiKey</code> allows multiple map keys to be merged together.
 * <p>
 * The purpose of this class is to avoid the need to write code to handle
 * maps of maps. An example might be the need to look up a file name by 
 * key and locale. The typical solution might be nested maps. This class
 * can be used instead by creating an instance passing in the key and locale.
 * <p>
 * Example usage:
 * <pre>
 * // populate map with data mapping key+locale to localizedText
 * Map map = new HashMap();
 * MultiKey multiKey = new MultiKey(key, locale);
 * map.put(multiKey, localizedText);
 *
 * // later retrieve the localized text
 * MultiKey multiKey = new MultiKey(key, locale);
 * String localizedText = (String) map.get(multiKey);
 * </pre>
 * 
 * @since Commons Collections 3.0
 * @version $Revision$ $Date$
 * 
 * @author Howard Lewis Ship
 * @author Stephen Colebourne
 */
public class MultiKey implements Serializable {
    // This class could implement List, but that would confuse it's purpose

    /** Serialisation version */
    private static final long serialVersionUID = 4465448607415788805L;

    /** The individual keys */
    private final Object[] keys;
    /** The cached hashCode */
    private transient int hashCode;
    
    /**
     * Constructor taking two keys.
     * <p>
     * The keys should be immutable
     * If they are not then they must not be changed after adding to the MultiKey.
     * 
     * @param key1  the first key
     * @param key2  the second key
     */
    public MultiKey(Object key1, Object key2) {
        this(new Object[] {key1, key2}, false);
    }
    
    /**
     * Constructor taking three keys.
     * <p>
     * The keys should be immutable
     * If they are not then they must not be changed after adding to the MultiKey.
     * 
     * @param key1  the first key
     * @param key2  the second key
     * @param key3  the third key
     */
    public MultiKey(Object key1, Object key2, Object key3) {
        this(new Object[] {key1, key2, key3}, false);
    }
    
    /**
     * Constructor taking four keys.
     * <p>
     * The keys should be immutable
     * If they are not then they must not be changed after adding to the MultiKey.
     * 
     * @param key1  the first key
     * @param key2  the second key
     * @param key3  the third key
     * @param key4  the fourth key
     */
    public MultiKey(Object key1, Object key2, Object key3, Object key4) {
        this(new Object[] {key1, key2, key3, key4}, false);
    }
    
    /**
     * Constructor taking five keys.
     * <p>
     * The keys should be immutable
     * If they are not then they must not be changed after adding to the MultiKey.
     * 
     * @param key1  the first key
     * @param key2  the second key
     * @param key3  the third key
     * @param key4  the fourth key
     * @param key5  the fifth key
     */
    public MultiKey(Object key1, Object key2, Object key3, Object key4, Object key5) {
        this(new Object[] {key1, key2, key3, key4, key5}, false);
    }
    
    /**
     * Constructor taking an array of keys which is cloned.
     * <p>
     * The keys should be immutable
     * If they are not then they must not be changed after adding to the MultiKey.
     * <p>
     * This is equivalent to <code>new MultiKey(keys, true)</code>.
     *
     * @param keys  the array of keys, not null
     * @throws IllegalArgumentException if the key array is null
     */
    public MultiKey(Object[] keys) {
        this(keys, true);
    }
    
    /**
     * Constructor taking an array of keys, optionally choosing whether to clone.
     * <p>
     * <b>If the array is not cloned, then it must not be modified.</b>
     * <p>
     * This method is public for performance reasons only, to avoid a clone.
     * The hashcode is calculated once here in this method.
     * Therefore, changing the array passed in would not change the hashcode but
     * would change the equals method, which is a bug.
     * <p>
     * This is the only fully safe usage of this constructor, as the object array
     * is never made available in a variable:
     * <pre>
     * new MultiKey(new Object[] {...}, false);
     * </pre>
     * <p>
     * The keys should be immutable
     * If they are not then they must not be changed after adding to the MultiKey.
     *
     * @param keys  the array of keys, not null
     * @param makeClone  true to clone the array, false to assign it
     * @throws IllegalArgumentException if the key array is null
     * @since Commons Collections 3.1
     */
    public MultiKey(Object[] keys, boolean makeClone) {
        super();
        if (keys == null) {
            throw new IllegalArgumentException(""The array of keys must not be null"");
        }
        if (makeClone) {
            this.keys = (Object[]) keys.clone();
        } else {
            this.keys = keys;
        }
        
        calculateHashCode(keys);
    }
    
    //-----------------------------------------------------------------------
    /**
     * Gets a clone of the array of keys.
     * <p>
     * The keys should be immutable
     * If they are not then they must not be changed.
     * 
     * @return the individual keys
     */
    public Object[] getKeys() {
        return (Object[]) keys.clone();
    }
    
    /**
     * Gets the key at the specified index.
     * <p>
     * The key should be immutable.
     * If it is not then it must not be changed.
     * 
     * @param index  the index to retrieve
     * @return the key at the index
     * @throws IndexOutOfBoundsException if the index is invalid
     * @since Commons Collections 3.1
     */
    public Object getKey(int index) {
        return keys[index];
    }
    
    /**
     * Gets the size of the list of keys.
     * 
     * @return the size of the list of keys
     * @since Commons Collections 3.1
     */
    public int size() {
        return keys.length;
    }
    
    //-----------------------------------------------------------------------
    /**
     * Compares this object to another.
     * <p>
     * To be equal, the other object must be a <code>MultiKey</code> with the
     * same number of keys which are also equal.
     * 
     * @param other  the other object to compare to
     * @return true if equal
     */
    public boolean equals(Object other) {
        if (other == this) {
            return true;
        }
        if (other instanceof MultiKey) {
            MultiKey otherMulti = (MultiKey) other;
            return Arrays.equals(keys, otherMulti.keys);
        }
        return false;
    }

    /**
     * Gets the combined hash code that is computed from all the keys.
     * <p>
     * This value is computed once and then cached, so elements should not
     * change their hash codes once created (note that this is the same 
     * constraint that would be used if the individual keys elements were
     * themselves {@link java.util.Map Map} keys.
     * 
     * @return the hash code
     */
    public int hashCode() {
        return hashCode;
    }

    /**
     * Gets a debugging string version of the key.
     * 
     * @return a debugging string
     */
    public String toString() {
        return ""MultiKey"" + Arrays.asList(keys).toString();
    }

 /**
  * Calculate the hash code of the instance using the provided keys.
  * @param keys
  */
 private void calculateHashCode(Object[] keys)
 {
  int total = 0;
        for (int i = 0; i < keys.length; i++) {
            if (keys[i] != null) {
                total ^= keys[i].hashCode();
            }
        }
        hashCode = total;
 }
 
 /**
  * Recalculate the hash code after deserialization. The hash code of some
  * keys might have change (hash codes based on the system hash code are
  * only stable for the same process). 
  * @return the instance with recalculated hash code
  */
}
"
Collections_12,/home/common/huangzhili/defects4j_buggy/Collections_12_buggy/src/java/org/apache/commons/collections/ExtendedProperties.java,"    public void combine(ExtendedProperties props) {
        for (Iterator it = props.getKeys(); it.hasNext();) {
            String key = (String) it.next();
            super.put(key, props.get(key));
        }
    }
"
Collections_13,/home/common/huangzhili/defects4j_buggy/Collections_13_buggy/src/java/org/apache/commons/collections/ExtendedProperties.java,"    public static ExtendedProperties convertProperties(Properties props) {
        ExtendedProperties c = new ExtendedProperties();

        for (Enumeration e = props.propertyNames(); e.hasMoreElements();) {
            String s = (String) e.nextElement();
            c.setProperty(s, props.getProperty(s));
        }

        return c;
    }
"
Collections_14,/home/common/huangzhili/defects4j_buggy/Collections_14_buggy/src/java/org/apache/commons/collections/map/CaseInsensitiveMap.java,"    protected Object convertKey(Object key) {
        if (key != null) {
            return key.toString().toLowerCase();
        } else {
            return AbstractHashedMap.NULL;
        }
    }   
"
Collections_15,/home/common/huangzhili/defects4j_buggy/Collections_15_buggy/src/java/org/apache/commons/collections/list/SetUniqueList.java,"    public Object set(int index, Object object) {
        int pos = indexOf(object);
        Object removed = super.set(index, object);

        if (pos == -1 || pos == index) {
            // the object is already in the uniq list
            // (and it hasn't been swapped with itself)
            return removed;
        }

        super.remove(pos);
        set.remove(removed);  // remove the item deleted by the set

        return removed;  // return the item deleted by the set
    }
"
Collections_16,/home/common/huangzhili/defects4j_buggy/Collections_16_buggy/src/java/org/apache/commons/collections/list/SetUniqueList.java,"    public ListIterator listIterator(int index) {
        return new SetListListIterator(super.listIterator(index), set);
    }
"
Collections_17,/home/common/huangzhili/defects4j_buggy/Collections_17_buggy/src/main/java/org/apache/commons/collections/functors/EqualPredicate.java,"    public EqualPredicate(T object) {
        // do not use the DefaultEquator to keep backwards compatibility
        // the DefaultEquator returns also true if the two object references are equal
        this(object, new DefaultEquator<T>());
    }
"
Collections_17,/home/common/huangzhili/defects4j_buggy/Collections_17_buggy/src/main/java/org/apache/commons/collections/functors/EqualPredicate.java,"    public boolean evaluate(T object) {
            return equator.equate(iValue, object);
    }
"
Collections_18,/home/common/huangzhili/defects4j_buggy/Collections_18_buggy/src/main/java/org/apache/commons/collections/set/ListOrderedSet.java,"    public boolean removeAll(Collection<?> coll) {
        boolean result = false;
        for (Iterator<?> it = coll.iterator(); it.hasNext();) {
            result |= remove(it.next());
        }
        return result;
    }
"
Collections_19,/home/common/huangzhili/defects4j_buggy/Collections_19_buggy/src/main/java/org/apache/commons/collections/list/SetUniqueList.java,"    public E set(final int index, final E object) {
        final int pos = indexOf(object);
        final E removed = super.set(index, object);

        if (pos != -1 && pos != index) {
            // the object is already in the uniq list
            // (and it hasn't been swapped with itself)
            super.remove(pos); // remove the duplicate by index
        }
        set.add(object); 
        set.remove(removed);
        return removed; // return the item deleted by the set
    }"
Collections_20,/home/common/huangzhili/defects4j_buggy/Collections_20_buggy/src/main/java/org/apache/commons/collections/list/TreeList.java,"        public void remove() {
            checkModCount();
            if (currentIndex == -1) {
                throw new IllegalStateException();
            }
            if (nextIndex == currentIndex) {
                next = next.next();
                parent.remove(currentIndex);
            } else {
                // remove() following next()
                parent.remove(currentIndex);
                nextIndex--;
            }
            // the AVL node referenced by next may have become stale after a remove
            // reset it now: will be retrieved by next call to next()/previous() via nextIndex
            current = null;
            currentIndex = -1;
            expectedModCount++;
        }
"
Collections_21,/home/common/huangzhili/defects4j_buggy/Collections_21_buggy/src/main/java/org/apache/commons/collections4/list/SetUniqueList.java,"    public List<E> subList(final int fromIndex, final int toIndex) {
        final List<E> superSubList = super.subList(fromIndex, toIndex);
        final Set<E> subSet = createSetBasedOnList(set, superSubList);
        return new SetUniqueList<E>(superSubList, subSet);
    }
"
Collections_22,/home/common/huangzhili/defects4j_buggy/Collections_22_buggy/src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java,"    public void putAll(int index, final Map<? extends K, ? extends V> map) {
        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {
            final V old = put(index, entry.getKey(), entry.getValue());
            if (old == null) {
            // The return value of put is null if the key did not exist OR the value was null
            // so it cannot be used to determine whether the key was added
                // if no key was replaced, increment the index
                index++;
            } else {
                // otherwise put the next item after the currently inserted key
                index = indexOf(entry.getKey()) + 1;
            }
        }
    }
"
Collections_23,/home/common/huangzhili/defects4j_buggy/Collections_23_buggy/src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java,"    public static <K, V> UnmodifiableTrie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) {
        return new UnmodifiableTrie<K, V>(trie);
    }
"
Collections_24,/home/common/huangzhili/defects4j_buggy/Collections_24_buggy/src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java,"    public static <E> BoundedCollection<E> unmodifiableBoundedCollection(final BoundedCollection<? extends E> coll) {
        return new UnmodifiableBoundedCollection<E>(coll);
    }
"
Collections_25,/home/common/huangzhili/defects4j_buggy/Collections_25_buggy/src/main/java/org/apache/commons/collections4/IteratorUtils.java,"    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,
                                                   final Iterator<? extends E> iterator1,
                                                   final Iterator<? extends E> iterator2) {
        return new CollatingIterator<E>(comparator, iterator1, iterator2);
    }
"
Collections_25,/home/common/huangzhili/defects4j_buggy/Collections_25_buggy/src/main/java/org/apache/commons/collections4/IteratorUtils.java,"    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,
                                                   final Iterator<? extends E>... iterators) {
        return new CollatingIterator<E>(comparator, iterators);
    }
"
Collections_25,/home/common/huangzhili/defects4j_buggy/Collections_25_buggy/src/main/java/org/apache/commons/collections4/IteratorUtils.java,"    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,
                                                   final Collection<Iterator<? extends E>> iterators) {
        return new CollatingIterator<E>(comparator, iterators);
    }
"
Collections_27,/home/common/huangzhili/defects4j_buggy/Collections_27_buggy/src/main/java/org/apache/commons/collections4/map/MultiValueMap.java,"        public T create() {
            try {
                return clazz.newInstance();
            } catch (final Exception ex) {
                throw new FunctorException(""Cannot instantiate class: "" + clazz, ex);
            }
        }
"
Collections_28,/home/common/huangzhili/defects4j_buggy/Collections_28_buggy/src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java,"        protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,
                                                 final K toKey, final boolean toInclusive) {
            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);
        }
"
Compress_2,/home/common/huangzhili/defects4j_buggy/Compress_2_buggy/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java,"public int read(byte[] b, final int off, final int len) throws IOException {
         int toRead = len;
         final int ret = this.input.read(b, off, toRead);
         offset += (ret > 0 ? ret : 0);
         return ret;
    }"
Compress_2,/home/common/huangzhili/defects4j_buggy/Compress_2_buggy/src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java,"public ArArchiveEntry getNextArEntry() throws IOException {
                    // hit EOF before previous entry was complete
                    // TODO: throw an exception instead?

        if (offset == 0) {
            final byte[] expected = ArArchiveEntry.HEADER.getBytes();
            final byte[] realized = new byte[expected.length]; 
            final int read = read(realized);
            if (read != expected.length) {
                throw new IOException(""failed to read header"");
            }
            for (int i = 0; i < expected.length; i++) {
                if (expected[i] != realized[i]) {
                    throw new IOException(""invalid header "" + new String(realized));
                }
            }
        }

                // hit eof

        if (input.available() == 0) {
            return null;
        }

        if (offset % 2 != 0) {
            read();
        }
        final byte[] name = new byte[16];
        final byte[] lastmodified = new byte[12];
        final byte[] userid = new byte[6];
        final byte[] groupid = new byte[6];
        final byte[] filemode = new byte[8];
        final byte[] length = new byte[10];

        read(name);
        read(lastmodified);
        read(userid);
        read(groupid);
        read(filemode);
        read(length);

        {
            final byte[] expected = ArArchiveEntry.TRAILER.getBytes();
            final byte[] realized = new byte[expected.length]; 
            final int read = read(realized);
            if (read != expected.length) {
                throw new IOException(""failed to read entry header"");
            }
            for (int i = 0; i < expected.length; i++) {
                if (expected[i] != realized[i]) {
                    throw new IOException(""invalid entry header. not read the content?"");
                }
             }
         }
 
         return new ArArchiveEntry(new String(name).trim(),
                                           Long.parseLong(new String(length)
                                                          .trim()));
     }"
Compress_3,/home/common/huangzhili/defects4j_buggy/Compress_3_buggy/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java,"public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {
        TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;
        if (entry.getName().length() >= TarConstants.NAMELEN) {

            if (longFileMode == LONGFILE_GNU) {
                // create a TarEntry for the LongLink, the contents
                // of which are the entry's name
                TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,
                                                                    TarConstants.LF_GNUTYPE_LONGNAME);

                final byte[] nameBytes = entry.getName().getBytes(); // TODO is it correct to use the default charset here?
                longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL
                putArchiveEntry(longLinkEntry);
                write(nameBytes);
                write(0); // NUL terminator
                closeArchiveEntry();
            } else if (longFileMode != LONGFILE_TRUNCATE) {
                throw new RuntimeException(""file name '"" + entry.getName()
                                           + ""' is too long ( > ""
                                           + TarConstants.NAMELEN + "" bytes)"");
            }
        }

        entry.writeEntryHeader(recordBuf);
        buffer.writeRecord(recordBuf);

        currBytes = 0;

        if (entry.isDirectory()) {
            currSize = 0;
        } else {
             currSize = entry.getSize();
         }
         currName = entry.getName();
     }"
Compress_3,/home/common/huangzhili/defects4j_buggy/Compress_3_buggy/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java,"public void closeArchiveEntry() throws IOException {
        if (assemLen > 0) {
            for (int i = assemLen; i < assemBuf.length; ++i) {
                assemBuf[i] = 0;
            }

            buffer.writeRecord(assemBuf);

            currBytes += assemLen;
            assemLen = 0;
        }

        if (currBytes < currSize) {
            throw new IOException(""entry '"" + currName + ""' closed at '""
                                  + currBytes
                                   + ""' before the '"" + currSize
                                   + ""' bytes specified in the header were written"");
         }
     }"
Compress_4,/home/common/huangzhili/defects4j_buggy/Compress_4_buggy/src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java,"public ChangeSetResults perform(ArchiveInputStream in, ArchiveOutputStream out)
            throws IOException {
        ChangeSetResults results = new ChangeSetResults();
        
        Set workingSet = new LinkedHashSet(changes);
        
        for (Iterator it = workingSet.iterator(); it.hasNext();) {
            Change change = (Change) it.next();

            if (change.type() == Change.TYPE_ADD && change.isReplaceMode()) {
                copyStream(change.getInput(), out, change.getEntry());
                it.remove();
                results.addedFromChangeSet(change.getEntry().getName());
            }
        }

        ArchiveEntry entry = null;
        while ((entry = in.getNextEntry()) != null) {
            boolean copy = true;

            for (Iterator it = workingSet.iterator(); it.hasNext();) {
                Change change = (Change) it.next();

                final int type = change.type();
                final String name = entry.getName();
                if (type == Change.TYPE_DELETE && name != null) {
                    if (name.equals(change.targetFile())) {
                        copy = false;
                        it.remove();
                        results.deleted(name);
                        break;
                    }
                } else if(type == Change.TYPE_DELETE_DIR && name != null) {
                    if (name.startsWith(change.targetFile() + ""/"")) {
                        copy = false;
                        results.deleted(name);
                        break;
                    }
                }
            }

            if (copy) {
                if (!isDeletedLater(workingSet, entry) && !results.hasBeenAdded(entry.getName())) {
                    copyStream(in, out, entry);
                    results.addedFromStream(entry.getName());
                }
            }
        }
        
        // Adds files which hasn't been added from the original and do not have replace mode on
        for (Iterator it = workingSet.iterator(); it.hasNext();) {
            Change change = (Change) it.next();

            if (change.type() == Change.TYPE_ADD && 
                !change.isReplaceMode() && 
                !results.hasBeenAdded(change.getEntry().getName())) {
                copyStream(change.getInput(), out, change.getEntry());
                it.remove();
                 results.addedFromChangeSet(change.getEntry().getName());
             }
         }
         return results;
     }"
Compress_4,/home/common/huangzhili/defects4j_buggy/Compress_4_buggy/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java,"public void close() throws IOException {
         if (!this.closed) {
             this.finish();
             out.close();
             this.closed = true;
         }
    }"
Compress_4,/home/common/huangzhili/defects4j_buggy/Compress_4_buggy/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java,"public void close() throws IOException {
         if (!closed) {
             finish();
             buffer.close();
             out.close();
             closed = true;
        }
    }"
Compress_6,/home/common/huangzhili/defects4j_buggy/Compress_6_buggy/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java,"public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
             return false;
         }
         ZipArchiveEntry other = (ZipArchiveEntry) obj;
         if (name == null) {
             if (other.name != null) {
                 return false;
             }
         } else if (!name.equals(other.name)) {
             return false;
         }
         return true;
    }"
Compress_9,/home/common/huangzhili/defects4j_buggy/Compress_9_buggy/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java,"@Override
    public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {
        if ((currBytes + numToWrite) > currSize) {
            throw new IOException(""request to write '"" + numToWrite
                                  + ""' bytes exceeds size in header of '""
                                  + currSize + ""' bytes for entry '""
                                  + currName + ""'"");

            //
            // We have to deal with assembly!!!
            // The programmer can be writing little 32 byte chunks for all
            // we know, and we must assemble complete records for writing.
            // REVIEW Maybe this should be in TarBuffer? Could that help to
            // eliminate some of the buffer copying.
            //
        }

        if (assemLen > 0) {
            if ((assemLen + numToWrite) >= recordBuf.length) {
                int aLen = recordBuf.length - assemLen;

                System.arraycopy(assemBuf, 0, recordBuf, 0,
                                 assemLen);
                System.arraycopy(wBuf, wOffset, recordBuf,
                                 assemLen, aLen);
                buffer.writeRecord(recordBuf);

                currBytes += recordBuf.length;
                wOffset += aLen;
                numToWrite -= aLen;
                assemLen = 0;
            } else {
                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,
                                 numToWrite);

                wOffset += numToWrite;
                assemLen += numToWrite;
                numToWrite = 0;
            }
        }

        //
        // When we get here we have EITHER:
        // o An empty ""assemble"" buffer.
        // o No bytes to write (numToWrite == 0)
        //
        while (numToWrite > 0) {
            if (numToWrite < recordBuf.length) {
                System.arraycopy(wBuf, wOffset, assemBuf, assemLen,
                                 numToWrite);

                assemLen += numToWrite;

                break;
            }

            buffer.writeRecord(wBuf, wOffset);

            int num = recordBuf.length;

            currBytes += num;
             numToWrite -= num;
             wOffset += num;
         }
         count(numToWrite);
     }"
Compress_20,/home/common/huangzhili/defects4j_buggy/Compress_20_buggy/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java,"private CpioArchiveEntry readNewEntry(final boolean hasCrc)
            throws IOException {
        CpioArchiveEntry ret;
        if (hasCrc) {
            ret = new CpioArchiveEntry(FORMAT_NEW_CRC);
        } else {
            ret = new CpioArchiveEntry(FORMAT_NEW);
        }

        ret.setInode(readAsciiLong(8, 16));
        long mode = readAsciiLong(8, 16);
        if (mode != 0){
            ret.setMode(mode);
        }
        ret.setUID(readAsciiLong(8, 16));
        ret.setGID(readAsciiLong(8, 16));
        ret.setNumberOfLinks(readAsciiLong(8, 16));
        ret.setTime(readAsciiLong(8, 16));
        ret.setSize(readAsciiLong(8, 16));
        ret.setDeviceMaj(readAsciiLong(8, 16));
        ret.setDeviceMin(readAsciiLong(8, 16));
        ret.setRemoteDeviceMaj(readAsciiLong(8, 16));
        ret.setRemoteDeviceMin(readAsciiLong(8, 16));
        long namesize = readAsciiLong(8, 16);
         ret.setChksum(readAsciiLong(8, 16));
         String name = readCString((int) namesize);
         ret.setName(name);
         if (mode == 0 && !name.equals(CPIO_TRAILER)){
             throw new IOException(""Mode 0 only allowed in the trailer. Found entry name: ""+name + "" Occured at byte: "" + getBytesRead());
         }
         skip(ret.getHeaderPadCount());

        return ret;
    }"
Compress_20,/home/common/huangzhili/defects4j_buggy/Compress_20_buggy/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java,"private CpioArchiveEntry readOldAsciiEntry() throws IOException {
        CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII);

         ret.setDevice(readAsciiLong(6, 8));
         ret.setInode(readAsciiLong(6, 8));
         final long mode = readAsciiLong(6, 8);
         if (mode != 0) {
             ret.setMode(mode);
         }
         ret.setUID(readAsciiLong(6, 8));
        ret.setGID(readAsciiLong(6, 8));
        ret.setNumberOfLinks(readAsciiLong(6, 8));
        ret.setRemoteDevice(readAsciiLong(6, 8));
        ret.setTime(readAsciiLong(11, 8));
        long namesize = readAsciiLong(6, 8);
        ret.setSize(readAsciiLong(11, 8));
        final String name = readCString((int) namesize);
        ret.setName(name);
        if (mode == 0 && !name.equals(CPIO_TRAILER)){
            throw new IOException(""Mode 0 only allowed in the trailer. Found entry: ""+ name + "" Occured at byte: "" + getBytesRead());
        }

        return ret;
    }"
Compress_20,/home/common/huangzhili/defects4j_buggy/Compress_20_buggy/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java,"private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord)
            throws IOException {
        CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);

        ret.setDevice(readBinaryLong(2, swapHalfWord));
        ret.setInode(readBinaryLong(2, swapHalfWord));
        final long mode = readBinaryLong(2, swapHalfWord);
        if (mode != 0){
            ret.setMode(mode);
        }
        ret.setUID(readBinaryLong(2, swapHalfWord));
        ret.setGID(readBinaryLong(2, swapHalfWord));
        ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord));
        ret.setRemoteDevice(readBinaryLong(2, swapHalfWord));
        ret.setTime(readBinaryLong(4, swapHalfWord));
        long namesize = readBinaryLong(2, swapHalfWord);
         ret.setSize(readBinaryLong(4, swapHalfWord));
         final String name = readCString((int) namesize);
         ret.setName(name);
         if (mode == 0 && !name.equals(CPIO_TRAILER)){
             throw new IOException(""Mode 0 only allowed in the trailer. Found entry: ""+name + ""Occured at byte: "" + getBytesRead());
         }
         skip(ret.getHeaderPadCount());

        return ret;
    }"
Compress_22,/home/common/huangzhili/defects4j_buggy/Compress_22_buggy/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java,"private int setupNoRandPartC() throws IOException {
         if (this.su_j2 < this.su_z) {
             int su_ch2Shadow = this.su_ch2;
             this.currentChar = su_ch2Shadow;
             this.crc.updateCRC(su_ch2Shadow);
             this.su_j2++;
             this.currentState = NO_RAND_PART_C_STATE;
            return su_ch2Shadow;
        } else {
            this.su_i2++;
            this.su_count = 0;
            return setupNoRandPartA();
        }
    }"
Compress_22,/home/common/huangzhili/defects4j_buggy/Compress_22_buggy/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java,"private int setupRandPartC() throws IOException {
         if (this.su_j2 < this.su_z) {
             this.currentChar = this.su_ch2;
             this.crc.updateCRC(this.su_ch2);
             this.su_j2++;
             return this.su_ch2;
        } else {
            this.currentState = RAND_PART_A_STATE;
            this.su_i2++;
            this.su_count = 0;
            return setupRandPartA();
        }
    }"
Compress_22,/home/common/huangzhili/defects4j_buggy/Compress_22_buggy/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java,"private int setupNoRandPartA() throws IOException {
        if (this.su_i2 <= this.last) {
            this.su_chPrev = this.su_ch2;
            int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;
             this.su_ch2 = su_ch2Shadow;
             this.su_tPos = this.data.tt[this.su_tPos];
             this.su_i2++;
             this.currentChar = su_ch2Shadow;
             this.currentState = NO_RAND_PART_B_STATE;
             this.crc.updateCRC(su_ch2Shadow);
             return su_ch2Shadow;
        } else {
            this.currentState = NO_RAND_PART_A_STATE;
            endBlock();
            initBlock();
            return setupBlock();
        }
    }"
Compress_22,/home/common/huangzhili/defects4j_buggy/Compress_22_buggy/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java,"private int setupRandPartA() throws IOException {
        if (this.su_i2 <= this.last) {
            this.su_chPrev = this.su_ch2;
            int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;
            this.su_tPos = this.data.tt[this.su_tPos];
            if (this.su_rNToGo == 0) {
                this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1;
                if (++this.su_rTPos == 512) {
                    this.su_rTPos = 0;
                }
            } else {
                this.su_rNToGo--;
             }
             this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0;
             this.su_i2++;
             this.currentChar = su_ch2Shadow;
             this.currentState = RAND_PART_B_STATE;
             this.crc.updateCRC(su_ch2Shadow);
             return su_ch2Shadow;
        } else {
            endBlock();
            initBlock();
            return setupBlock();
        }
    }"
Compress_29,/home/common/huangzhili/defects4j_buggy/Compress_29_buggy/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java,"public ArchiveInputStream createArchiveInputStream(final InputStream in)
            throws ArchiveException {
        if (in == null) {
            throw new IllegalArgumentException(""Stream must not be null."");
        }

        if (!in.markSupported()) {
            throw new IllegalArgumentException(""Mark is not supported."");
        }

        final byte[] signature = new byte[12];
        in.mark(signature.length);
        try {
            int signatureLength = IOUtils.readFully(in, signature);
            in.reset();
            if (ZipArchiveInputStream.matches(signature, signatureLength)) {
                if (entryEncoding != null) {
                    return new ZipArchiveInputStream(in, entryEncoding);
                } else {
                    return new ZipArchiveInputStream(in);
                }
            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {
                if (entryEncoding != null) {
                    return new JarArchiveInputStream(in, entryEncoding);
                } else {
                    return new JarArchiveInputStream(in);
                }
            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {
                return new ArArchiveInputStream(in);
            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {
                if (entryEncoding != null) {
                    return new CpioArchiveInputStream(in, entryEncoding);
                } else {
                     return new CpioArchiveInputStream(in);
                 }
             } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {
                     return new ArjArchiveInputStream(in);
             } else if (SevenZFile.matches(signature, signatureLength)) {
                 throw new StreamingNotSupportedException(SEVEN_Z);
             }

            // Dump needs a bigger buffer to check the signature;
            final byte[] dumpsig = new byte[32];
            in.mark(dumpsig.length);
            signatureLength = IOUtils.readFully(in, dumpsig);
            in.reset();
            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {
                return new DumpArchiveInputStream(in, entryEncoding);
            }

            // Tar needs an even bigger buffer to check the signature; read the first block
            final byte[] tarheader = new byte[512];
            in.mark(tarheader.length);
            signatureLength = IOUtils.readFully(in, tarheader);
            in.reset();
            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {
                return new TarArchiveInputStream(in, entryEncoding);
            }
            // COMPRESS-117 - improve auto-recognition
            if (signatureLength >= 512) {
                TarArchiveInputStream tais = null;
                try {
                    tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));
                    // COMPRESS-191 - verify the header checksum
                    if (tais.getNextTarEntry().isCheckSumOK()) {
                        return new TarArchiveInputStream(in, encoding);
                    }
                } catch (Exception e) { // NOPMD
                    // can generate IllegalArgumentException as well
                    // as IOException
                    // autodetection, simply not a TAR
                    // ignored
                } finally {
                    IOUtils.closeQuietly(tais);
                }
            }
        } catch (IOException e) {
            throw new ArchiveException(""Could not use reset and mark operations."", e);
        }

        throw new ArchiveException(""No Archiver found for the stream signature"");
    }"
Compress_29,/home/common/huangzhili/defects4j_buggy/Compress_29_buggy/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java,"public ArchiveOutputStream createArchiveOutputStream(
            final String archiverName, final OutputStream out)
            throws ArchiveException {
        if (archiverName == null) {
            throw new IllegalArgumentException(""Archivername must not be null."");
        }
        if (out == null) {
            throw new IllegalArgumentException(""OutputStream must not be null."");
        }

        if (AR.equalsIgnoreCase(archiverName)) {
            return new ArArchiveOutputStream(out);
        }
        if (ZIP.equalsIgnoreCase(archiverName)) {
            ZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);
            if (entryEncoding != null) {
                zip.setEncoding(entryEncoding);
            }
            return zip;
        }
        if (TAR.equalsIgnoreCase(archiverName)) {
            if (entryEncoding != null) {
                return new TarArchiveOutputStream(out, entryEncoding);
            } else {
                return new TarArchiveOutputStream(out);
             }
         }
         if (JAR.equalsIgnoreCase(archiverName)) {
                 return new JarArchiveOutputStream(out);
         }
         if (CPIO.equalsIgnoreCase(archiverName)) {
             if (entryEncoding != null) {
                return new CpioArchiveOutputStream(out, entryEncoding);
            } else {
                return new CpioArchiveOutputStream(out);
            }
        }
        if (SEVEN_Z.equalsIgnoreCase(archiverName)) {
            throw new StreamingNotSupportedException(SEVEN_Z);
        }
        throw new ArchiveException(""Archiver: "" + archiverName + "" not found."");
    }"
Compress_33,/home/common/huangzhili/defects4j_buggy/Compress_33_buggy/src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java,"public CompressorInputStream createCompressorInputStream(final InputStream in)
            throws CompressorException {
        if (in == null) {
            throw new IllegalArgumentException(""Stream must not be null."");
        }

        if (!in.markSupported()) {
            throw new IllegalArgumentException(""Mark is not supported."");
        }

        final byte[] signature = new byte[12];
        in.mark(signature.length);
        try {
            int signatureLength = IOUtils.readFully(in, signature);
            in.reset();

            if (BZip2CompressorInputStream.matches(signature, signatureLength)) {
                return new BZip2CompressorInputStream(in, decompressConcatenated);
            }

            if (GzipCompressorInputStream.matches(signature, signatureLength)) {
                return new GzipCompressorInputStream(in, decompressConcatenated);
            }

            if (Pack200CompressorInputStream.matches(signature, signatureLength)) {
                return new Pack200CompressorInputStream(in);
            }

            if (FramedSnappyCompressorInputStream.matches(signature, signatureLength)) {
                return new FramedSnappyCompressorInputStream(in);
            }

            if (ZCompressorInputStream.matches(signature, signatureLength)) {
                 return new ZCompressorInputStream(in);
             }
 
 
             if (XZUtils.matches(signature, signatureLength) &&
                 XZUtils.isXZCompressionAvailable()) {
                return new XZCompressorInputStream(in, decompressConcatenated);
            }

            if (LZMAUtils.matches(signature, signatureLength) &&
                LZMAUtils.isLZMACompressionAvailable()) {
                return new LZMACompressorInputStream(in);
            }

        } catch (IOException e) {
            throw new CompressorException(""Failed to detect Compressor from InputStream."", e);
        }

        throw new CompressorException(""No Compressor found for the stream signature."");
    }"
Compress_34,/home/common/huangzhili/defects4j_buggy/Compress_34_buggy/src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java,"    private static final ZipShort HEADER_ID = new ZipShort(0x7875);
    private static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);
    private static final long serialVersionUID = 1L;

    private int version = 1; // always '1' according to current info-zip spec.

    // BigInteger helps us with little-endian / big-endian conversions.
    // (thanks to BigInteger.toByteArray() and a reverse() method we created).
    // Also, the spec theoretically allows UID/GID up to 255 bytes long!
    //
    // NOTE:  equals() and hashCode() currently assume these can never be null.
    private BigInteger uid;
    private BigInteger gid;

    /**
"
Compress_34,/home/common/huangzhili/defects4j_buggy/Compress_34_buggy/src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java,"    public ZipShort getCentralDirectoryLength() {
        return getLocalFileDataLength();
    }
"
Compress_39,/home/common/huangzhili/defects4j_buggy/Compress_39_buggy/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java,"    private ArchiveUtils(){
    }
"
Compress_39,/home/common/huangzhili/defects4j_buggy/Compress_39_buggy/src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java,"    public static String sanitize(String s) {
        final char[] chars = s.toCharArray();
        final int len = chars.length;
        final StringBuilder sb = new StringBuilder();
        for (int i = 0; i < len; i++) {
            final char c = chars[i];
            if (!Character.isISOControl(c)) {
                Character.UnicodeBlock block = Character.UnicodeBlock.of(c);
                if (block != null && block != Character.UnicodeBlock.SPECIALS) {
                    sb.append(c);
                    continue;
                }
            }
            sb.append('?');
        }
        return sb.toString();
    }
"
Compress_42,/home/common/huangzhili/defects4j_buggy/Compress_42_buggy/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java,"    public boolean isUnixSymlink() {
        return (getUnixMode() & UnixStat.LINK_FLAG) == UnixStat.LINK_FLAG;
    }
"
Compress_42,/home/common/huangzhili/defects4j_buggy/Compress_42_buggy/src/main/java/org/apache/commons/compress/archivers/zip/UnixStat.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * ""License""); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.commons.compress.archivers.zip;

/**
 * Constants from stat.h on Unix systems.
 */
// CheckStyle:InterfaceIsTypeCheck OFF - backward compatible
public interface UnixStat {

    /**
     * Bits used for permissions (and sticky bit)
     */
    int PERM_MASK = 07777;
    /**
     * Bits used to indicate the filesystem object type.
     * @since 1.14
     */
    /**
     * Indicates symbolic links.
     */
    int LINK_FLAG = 0120000;
    /**
     * Indicates plain files.
     */
    int FILE_FLAG = 0100000;
    /**
     * Indicates directories.
     */
    int DIR_FLAG = 040000;

    // ----------------------------------------------------------
    // somewhat arbitrary choices that are quite common for shared
    // installations
    // -----------------------------------------------------------

    /**
     * Default permissions for symbolic links.
     */
    int DEFAULT_LINK_PERM = 0777;

    /**
     * Default permissions for directories.
     */
    int DEFAULT_DIR_PERM = 0755;

    /**
     * Default permissions for plain files.
     */
    int DEFAULT_FILE_PERM = 0644;
}
"
Compress_43,/home/common/huangzhili/defects4j_buggy/Compress_43_buggy/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java,"private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {
        final boolean encodable = zipEncoding.canEncode(ze.getName());
        final ByteBuffer name = getName(ze);

        if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {
            addUnicodeExtraFields(ze, encodable, name);
        }
 
         final long localHeaderStart = streamCompressor.getTotalBytesWritten();
         final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);
         metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));
         entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset
         writeCounted(localHeader);
         entry.dataStart = streamCompressor.getTotalBytesWritten();
    }"
Compress_43,/home/common/huangzhili/defects4j_buggy/Compress_43_buggy/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java,"private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,
                                         final boolean phased, long archiveOffset) throws IOException {
        ResourceAlignmentExtraField oldAlignmentEx =
            (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);
        if (oldAlignmentEx != null) {
            ze.removeExtraField(ResourceAlignmentExtraField.ID);
        }

        int alignment = ze.getAlignment();
        if (alignment <= 0 && oldAlignmentEx != null) {
            alignment = oldAlignmentEx.getAlignment();
        }

        if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {
            int oldLength = LFH_FILENAME_OFFSET +
                            name.limit() - name.position() +
                            ze.getLocalFileDataExtra().length;

            int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE
                            - ResourceAlignmentExtraField.BASE_SIZE) &
                            (alignment - 1));
            ze.addExtraField(new ResourceAlignmentExtraField(alignment,
                            oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));
        }

        final byte[] extra = ze.getLocalFileDataExtra();
        final int nameLen = name.limit() - name.position();
        final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;
        final byte[] buf = new byte[len];

        System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);
 
         //store method in local variable to prevent multiple method calls
         final int zipMethod = ze.getMethod();
         final boolean dataDescriptor = usesDataDescriptor(zipMethod);
 
         putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);
 
        final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);
        generalPurposeBit.encode(buf, LFH_GPB_OFFSET);

        // compression method
        putShort(zipMethod, buf, LFH_METHOD_OFFSET);

        ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);

        // CRC
        if (phased){
            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);
        } else if (zipMethod == DEFLATED || channel != null) {
            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);
        } else {
            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);
        }

        // compressed length
        // uncompressed length
        if (hasZip64Extra(entry.entry)){
            // point to ZIP64 extended information extra field for
            // sizes, may get rewritten once sizes are known if
            // stream is seekable
            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);
            ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);
        } else if (phased) {
            putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);
            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);
        } else if (zipMethod == DEFLATED || channel != null) {
            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);
            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);
        } else { // Stored
            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);
            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);
        }
        // file name length
        putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);

        // extra field length
        putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);

        // file name
        System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);

        // extra fields
        System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);

        return buf;
    }"
Compress_47,/home/common/huangzhili/defects4j_buggy/Compress_47_buggy/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java,"@Override
    public boolean canReadEntryData(final ArchiveEntry ae) {
         if (ae instanceof ZipArchiveEntry) {
             final ZipArchiveEntry ze = (ZipArchiveEntry) ae;
             return ZipUtil.canHandleEntryData(ze)
                 && supportsDataDescriptorFor(ze);
         }
         return false;
     }"
Compress_47,/home/common/huangzhili/defects4j_buggy/Compress_47_buggy/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java,"@Override
    public int read(final byte[] buffer, final int offset, final int length) throws IOException {
        if (closed) {
            throw new IOException(""The stream is closed"");
        }

        if (current == null) {
            return -1;
        }

        // avoid int overflow, check null buffer
        if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {
            throw new ArrayIndexOutOfBoundsException();
        }

        ZipUtil.checkRequestedFeatures(current.entry);
        if (!supportsDataDescriptorFor(current.entry)) {
             throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR,
                     current.entry);
         }
 
         int read;
         if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {
            read = readStored(buffer, offset, length);
        } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {
            read = readDeflated(buffer, offset, length);
        } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()
                || current.entry.getMethod() == ZipMethod.IMPLODING.getCode()
                || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode()
                || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {
            read = current.in.read(buffer, offset, length);
        } else {
            throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()),
                    current.entry);
        }

        if (read >= 0) {
            current.crc.update(buffer, offset, read);
        }

        return read;
    }"
Csv_7,/home/common/huangzhili/defects4j_buggy/Csv_7_buggy/src/main/java/org/apache/commons/csv/CSVParser.java,"private Map<String, Integer> initializeHeader() throws IOException {
        Map<String, Integer> hdrMap = null;
        final String[] formatHeader = this.format.getHeader();
        if (formatHeader != null) {
            hdrMap = new LinkedHashMap<String, Integer>();

            String[] header = null;
            if (formatHeader.length == 0) {
                // read the header from the first line of the file
                final CSVRecord nextRecord = this.nextRecord();
                if (nextRecord != null) {
                    header = nextRecord.values();
                }
            } else {
                if (this.format.getSkipHeaderRecord()) {
                    this.nextRecord();
                }
                header = formatHeader;
            }

             // build the name to index mappings
             if (header != null) {
                 for (int i = 0; i < header.length; i++) {
                     hdrMap.put(header[i], Integer.valueOf(i));
                 }
             }
        }
        return hdrMap;
    }"
Csv_8,/home/common/huangzhili/defects4j_buggy/Csv_8_buggy/src/main/java/org/apache/commons/csv/CSVFormat.java,"void validate() throws IllegalStateException {
        if (quoteChar != null && delimiter == quoteChar.charValue()) {
            throw new IllegalStateException(
                    ""The quoteChar character and the delimiter cannot be the same ('"" + quoteChar + ""')"");
        }

        if (escape != null && delimiter == escape.charValue()) {
            throw new IllegalStateException(
                    ""The escape character and the delimiter cannot be the same ('"" + escape + ""')"");
        }

        if (commentStart != null && delimiter == commentStart.charValue()) {
            throw new IllegalStateException(
                    ""The comment start character and the delimiter cannot be the same ('"" + commentStart + ""')"");
        }

        if (quoteChar != null && quoteChar.equals(commentStart)) {
            throw new IllegalStateException(
                    ""The comment start character and the quoteChar cannot be the same ('"" + commentStart + ""')"");
        }

        if (escape != null && escape.equals(commentStart)) {
            throw new IllegalStateException(
                    ""The comment start and the escape character cannot be the same ('"" + commentStart + ""')"");
        }

        if (escape == null && quotePolicy == Quote.NONE) {
             throw new IllegalStateException(""No quotes mode set but no escape character is set"");
         }
 
         if (header != null) {
             final Set<String> set = new HashSet<String>(header.length);
             set.addAll(Arrays.asList(header));
             if (set.size() != header.length) {
                 throw new IllegalStateException(""The header contains duplicate names: "" + Arrays.toString(header));
             }
         }
     }"
Csv_12,/home/common/huangzhili/defects4j_buggy/Csv_12_buggy/src/main/java/org/apache/commons/csv/CSVFormat.java,"    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);

    /**
"
Csv_13,/home/common/huangzhili/defects4j_buggy/Csv_13_buggy/src/main/java/org/apache/commons/csv/CSVPrinter.java,"private void print(final Object object, final CharSequence value, final int offset, final int len)
            throws IOException {
         if (!newRecord) {
             out.append(format.getDelimiter());
         }
         if (format.isQuoteCharacterSet()) {
             // the original object is needed so can check for Number
             printAndQuote(object, value, offset, len);
         } else if (format.isEscapeCharacterSet()) {
            printAndEscape(value, offset, len);
        } else {
            out.append(value, offset, offset + len);
        }
        newRecord = false;
    }"
Csv_16,/home/common/huangzhili/defects4j_buggy/Csv_16_buggy/src/main/java/org/apache/commons/csv/CSVParser.java,"@Override
    public Iterator<CSVRecord> iterator() {
        return new Iterator<CSVRecord>() {
        private CSVRecord current;
  
        private CSVRecord getNextRecord() {
            try {
                return CSVParser.this.nextRecord();
            } catch (final IOException e) {
                throw new IllegalStateException(
                        e.getClass().getSimpleName() + "" reading next record: "" + e.toString(), e);
            }
        }
  
        @Override
        public boolean hasNext() {
            if (CSVParser.this.isClosed()) {
                return false;
            }
            if (this.current == null) {
                this.current = this.getNextRecord();
            }
  
            return this.current != null;
        }
  
        @Override
        public CSVRecord next() {
            if (CSVParser.this.isClosed()) {
                throw new NoSuchElementException(""CSVParser has been closed"");
            }
            CSVRecord next = this.current;
            this.current = null;
  
            if (next == null) {
                // hasNext() wasn't called before
                next = this.getNextRecord();
                if (next == null) {
                    throw new NoSuchElementException(""No more CSV records available"");
                }
            }
  
            return next;
        }
  
        @Override
        public void remove() {
             throw new UnsupportedOperationException();
         }
     };
     }"
Gson_1,/home/common/huangzhili/defects4j_buggy/Gson_1_buggy/gson/src/main/java/com/google/gson/TypeInfoFactory.java,"  private static Type getActualType(
      Type typeToEvaluate, Type parentType, Class<?> rawParentClass) {
    if (typeToEvaluate instanceof Class<?>) {
      return typeToEvaluate;
    } else if (typeToEvaluate instanceof ParameterizedType) {
      ParameterizedType castedType = (ParameterizedType) typeToEvaluate;
      Type owner = castedType.getOwnerType();
      Type[] actualTypeParameters =
          extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass);
      Type rawType = castedType.getRawType();
      return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner);
    } else if (typeToEvaluate instanceof GenericArrayType) {
      GenericArrayType castedType = (GenericArrayType) typeToEvaluate;
      Type componentType = castedType.getGenericComponentType();
      Type actualType = getActualType(componentType, parentType, rawParentClass);
      if (componentType.equals(actualType)) {
        return castedType;
      }
      return actualType instanceof Class<?> ?
          TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType))
          : new GenericArrayTypeImpl(actualType);
    } else if (typeToEvaluate instanceof TypeVariable<?>) {
      if (parentType instanceof ParameterizedType) {
        // The class definition has the actual types used for the type variables.
        // Find the matching actual type for the Type Variable used for the field.
        // For example, class Foo<A> { A a; }
        // new Foo<Integer>(); defines the actual type of A to be Integer.
        // So, to find the type of the field a, we will have to look at the class'
        // actual type arguments.
        TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate;
        TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters();
        ParameterizedType objParameterizedType = (ParameterizedType) parentType;
        int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable);
        Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments();
        return actualTypeArguments[indexOfActualTypeArgument];


      }

      throw new UnsupportedOperationException(""Expecting parameterized type, got "" + parentType
          + "".\n Are you missing the use of TypeToken idiom?\n See ""
          + ""http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener"");
    } else if (typeToEvaluate instanceof WildcardType) {
      WildcardType castedType = (WildcardType) typeToEvaluate;
      return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass);
    } else {
      throw new IllegalArgumentException(""Type \'"" + typeToEvaluate + ""\' is not a Class, ""
          + ""ParameterizedType, GenericArrayType or TypeVariable. Can't extract type."");
    }
  }
"
Gson_2,/home/common/huangzhili/defects4j_buggy/Gson_2_buggy/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java,"        final Class<? super T2> requestedType = typeToken.getRawType();
        if (!clazz.isAssignableFrom(requestedType)) {
          return null;
        }
"
Gson_3,/home/common/huangzhili/defects4j_buggy/Gson_3_buggy/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java,"  private <T> ObjectConstructor<T> newDefaultImplementationConstructor(
      final Type type, Class<? super T> rawType) {
    if (Collection.class.isAssignableFrom(rawType)) {
      if (SortedSet.class.isAssignableFrom(rawType)) {
        return new ObjectConstructor<T>() {
          @Override public T construct() {
            return (T) new TreeSet<Object>();
          }
        };
      } else if (EnumSet.class.isAssignableFrom(rawType)) {
        return new ObjectConstructor<T>() {
          @SuppressWarnings(""rawtypes"")
          @Override public T construct() {
            if (type instanceof ParameterizedType) {
              Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];
              if (elementType instanceof Class) {
                return (T) EnumSet.noneOf((Class)elementType);
              } else {
                throw new JsonIOException(""Invalid EnumSet type: "" + type.toString());
              }
            } else {
              throw new JsonIOException(""Invalid EnumSet type: "" + type.toString());
            }
          }
        };
      } else if (Set.class.isAssignableFrom(rawType)) {
        return new ObjectConstructor<T>() {
          @Override public T construct() {
            return (T) new LinkedHashSet<Object>();
          }
        };
      } else if (Queue.class.isAssignableFrom(rawType)) {
        return new ObjectConstructor<T>() {
          @Override public T construct() {
            return (T) new LinkedList<Object>();
          }
        };
      } else {
        return new ObjectConstructor<T>() {
          @Override public T construct() {
            return (T) new ArrayList<Object>();
          }
        };
      }
    }

    if (Map.class.isAssignableFrom(rawType)) {
      if (SortedMap.class.isAssignableFrom(rawType)) {
        return new ObjectConstructor<T>() {
          @Override public T construct() {
            return (T) new TreeMap<Object, Object>();
          }
        };
      } else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(
          TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {
        return new ObjectConstructor<T>() {
          @Override public T construct() {
            return (T) new LinkedHashMap<Object, Object>();
          }
        };
      } else {
        return new ObjectConstructor<T>() {
          @Override public T construct() {
            return (T) new LinkedTreeMap<String, Object>();
          }
        };
      }
    }

    return null;
  }
"
Gson_4,/home/common/huangzhili/defects4j_buggy/Gson_4_buggy/gson/src/main/java/com/google/gson/stream/JsonWriter.java,"public JsonWriter value(String value) throws IOException {
    if (value == null) {
       return nullValue();
     }
     writeDeferredName();
     beforeValue(false);
     string(value);
     return this;
   }"
Gson_4,/home/common/huangzhili/defects4j_buggy/Gson_4_buggy/gson/src/main/java/com/google/gson/stream/JsonWriter.java,"public JsonWriter value(long value) throws IOException {
     writeDeferredName();
     beforeValue(false);
     out.write(Long.toString(value));
     return this;
   }"
Gson_4,/home/common/huangzhili/defects4j_buggy/Gson_4_buggy/gson/src/main/java/com/google/gson/stream/JsonWriter.java,"public JsonWriter jsonValue(String value) throws IOException {
    if (value == null) {
       return nullValue();
     }
     writeDeferredName();
     beforeValue(false);
     out.append(value);
     return this;
   }"
Gson_4,/home/common/huangzhili/defects4j_buggy/Gson_4_buggy/gson/src/main/java/com/google/gson/stream/JsonWriter.java,"public JsonWriter value(boolean value) throws IOException {
     writeDeferredName();
     beforeValue(false);
     out.write(value ? ""true"" : ""false"");
     return this;
   }"
Gson_4,/home/common/huangzhili/defects4j_buggy/Gson_4_buggy/gson/src/main/java/com/google/gson/stream/JsonWriter.java,"public JsonWriter nullValue() throws IOException {
    if (deferredName != null) {
      if (serializeNulls) {
        writeDeferredName();
      } else {
        deferredName = null;
         return this; // skip the name and the value
       }
     }
     beforeValue(false);
     out.write(""null"");
     return this;
   }"
Gson_4,/home/common/huangzhili/defects4j_buggy/Gson_4_buggy/gson/src/main/java/com/google/gson/stream/JsonWriter.java,"public JsonWriter value(double value) throws IOException {
    if (Double.isNaN(value) || Double.isInfinite(value)) {
       throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value);
     }
     writeDeferredName();
     beforeValue(false);
     out.append(Double.toString(value));
     return this;
   }"
Gson_4,/home/common/huangzhili/defects4j_buggy/Gson_4_buggy/gson/src/main/java/com/google/gson/stream/JsonReader.java,"int doPeek() throws IOException {
    int peekStack = stack[stackSize - 1];
    if (peekStack == JsonScope.EMPTY_ARRAY) {
      stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {
      // Look for a comma before the next element.
      int c = nextNonWhitespace(true);
      switch (c) {
      case ']':
        return peeked = PEEKED_END_ARRAY;
      case ';':
        checkLenient(); // fall-through
      case ',':
        break;
      default:
        throw syntaxError(""Unterminated array"");
      }
    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {
      stack[stackSize - 1] = JsonScope.DANGLING_NAME;
      // Look for a comma before the next element.
      if (peekStack == JsonScope.NONEMPTY_OBJECT) {
        int c = nextNonWhitespace(true);
        switch (c) {
        case '}':
          return peeked = PEEKED_END_OBJECT;
        case ';':
          checkLenient(); // fall-through
        case ',':
          break;
        default:
          throw syntaxError(""Unterminated object"");
        }
      }
      int c = nextNonWhitespace(true);
      switch (c) {
      case '""':
        return peeked = PEEKED_DOUBLE_QUOTED_NAME;
      case '\'':
        checkLenient();
        return peeked = PEEKED_SINGLE_QUOTED_NAME;
      case '}':
        if (peekStack != JsonScope.NONEMPTY_OBJECT) {
          return peeked = PEEKED_END_OBJECT;
        } else {
          throw syntaxError(""Expected name"");
        }
      default:
        checkLenient();
        pos--; // Don't consume the first character in an unquoted string.
        if (isLiteral((char) c)) {
          return peeked = PEEKED_UNQUOTED_NAME;
        } else {
          throw syntaxError(""Expected name"");
        }
      }
    } else if (peekStack == JsonScope.DANGLING_NAME) {
      stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;
      // Look for a colon before the value.
      int c = nextNonWhitespace(true);
      switch (c) {
      case ':':
        break;
      case '=':
        checkLenient();
        if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {
          pos++;
        }
        break;
      default:
        throw syntaxError(""Expected ':'"");
      }
    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {
      if (lenient) {
        consumeNonExecutePrefix();
      }
      stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;
    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {
      int c = nextNonWhitespace(false);
      if (c == -1) {
        return peeked = PEEKED_EOF;
      } else {
        checkLenient();
        pos--;
      }
    } else if (peekStack == JsonScope.CLOSED) {
      throw new IllegalStateException(""JsonReader is closed"");
    }

    int c = nextNonWhitespace(true);
    switch (c) {
    case ']':
      if (peekStack == JsonScope.EMPTY_ARRAY) {
        return peeked = PEEKED_END_ARRAY;
      }
      // fall-through to handle "",]""
    case ';':
    case ',':
      // In lenient mode, a 0-length literal in an array means 'null'.
      if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {
        checkLenient();
        pos--;
        return peeked = PEEKED_NULL;
      } else {
        throw syntaxError(""Unexpected value"");
      }
    case '\'':
       checkLenient();
       return peeked = PEEKED_SINGLE_QUOTED;
     case '""':
       if (stackSize == 1) {
         checkLenient();
       }
       return peeked = PEEKED_DOUBLE_QUOTED;
     case '[':
       return peeked = PEEKED_BEGIN_ARRAY;
    case '{':
      return peeked = PEEKED_BEGIN_OBJECT;
    default:
      pos--; // Don't consume the first character in a literal value.
    }
    if (stackSize == 1) {
      checkLenient();
    }

    int result = peekKeyword();
    if (result != PEEKED_NONE) {
      return result;
    }

    result = peekNumber();
    if (result != PEEKED_NONE) {
      return result;
    }

    if (!isLiteral(buffer[pos])) {
      throw syntaxError(""Expected value"");
    }

    checkLenient();
    return peeked = PEEKED_UNQUOTED;
  }"
Gson_4,/home/common/huangzhili/defects4j_buggy/Gson_4_buggy/gson/src/main/java/com/google/gson/stream/JsonWriter.java,"public JsonWriter value(Number value) throws IOException {
    if (value == null) {
      return nullValue();
    }

    writeDeferredName();
    String string = value.toString();
    if (!lenient
         && (string.equals(""-Infinity"") || string.equals(""Infinity"") || string.equals(""NaN""))) {
       throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value);
     }
     beforeValue(false);
     out.append(string);
     return this;
   }"
Gson_4,/home/common/huangzhili/defects4j_buggy/Gson_4_buggy/gson/src/main/java/com/google/gson/stream/JsonWriter.java,"@SuppressWarnings(""fallthrough"")
  private void beforeValue(boolean root) throws IOException {
    switch (peek()) {
    case NONEMPTY_DOCUMENT:
      if (!lenient) {
        throw new IllegalStateException(
            ""JSON must have only one top-level value."");
       }
       // fall-through
     case EMPTY_DOCUMENT: // first in document
       if (!lenient && !root) {
         throw new IllegalStateException(
             ""JSON must start with an array or an object."");
       }
       replaceTop(NONEMPTY_DOCUMENT);
       break;
 
    case EMPTY_ARRAY: // first in array
      replaceTop(NONEMPTY_ARRAY);
      newline();
      break;

    case NONEMPTY_ARRAY: // another in array
      out.append(',');
      newline();
      break;

    case DANGLING_NAME: // value for name
      out.append(separator);
      replaceTop(NONEMPTY_OBJECT);
      break;

    default:
      throw new IllegalStateException(""Nesting problem."");
    }
  }"
Gson_7,/home/common/huangzhili/defects4j_buggy/Gson_7_buggy/gson/src/main/java/com/google/gson/stream/JsonReader.java,"public int nextInt() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
      p = doPeek();
    }

    int result;
    if (p == PEEKED_LONG) {
      result = (int) peekedLong;
      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.
        throw new NumberFormatException(""Expected an int but was "" + peekedLong
            + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
      }
      peeked = PEEKED_NONE;
      pathIndices[stackSize - 1]++;
      return result;
    }

     if (p == PEEKED_NUMBER) {
       peekedString = new String(buffer, pos, peekedNumberLength);
       pos += peekedNumberLength;
     } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
         peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
       try {
         result = Integer.parseInt(peekedString);
         peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return result;
      } catch (NumberFormatException ignored) {
        // Fall back to parse as a double below.
      }
    } else {
      throw new IllegalStateException(""Expected an int but was "" + peek()
          + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }

    peeked = PEEKED_BUFFERED;
    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
    result = (int) asDouble;
    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.
      throw new NumberFormatException(""Expected an int but was "" + peekedString
          + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
  }"
Gson_7,/home/common/huangzhili/defects4j_buggy/Gson_7_buggy/gson/src/main/java/com/google/gson/stream/JsonReader.java,"public long nextLong() throws IOException {
    int p = peeked;
    if (p == PEEKED_NONE) {
      p = doPeek();
    }

    if (p == PEEKED_LONG) {
      peeked = PEEKED_NONE;
      pathIndices[stackSize - 1]++;
      return peekedLong;
    }

     if (p == PEEKED_NUMBER) {
       peekedString = new String(buffer, pos, peekedNumberLength);
       pos += peekedNumberLength;
     } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
         peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '""');
       try {
         long result = Long.parseLong(peekedString);
         peeked = PEEKED_NONE;
        pathIndices[stackSize - 1]++;
        return result;
      } catch (NumberFormatException ignored) {
        // Fall back to parse as a double below.
      }
    } else {
      throw new IllegalStateException(""Expected a long but was "" + peek()
          + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }

    peeked = PEEKED_BUFFERED;
    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
    long result = (long) asDouble;
    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.
      throw new NumberFormatException(""Expected a long but was "" + peekedString
          + "" at line "" + getLineNumber() + "" column "" + getColumnNumber() + "" path "" + getPath());
    }
    peekedString = null;
    peeked = PEEKED_NONE;
    pathIndices[stackSize - 1]++;
    return result;
  }"
Gson_8,/home/common/huangzhili/defects4j_buggy/Gson_8_buggy/gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java,"/*
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.gson.internal;

import java.io.ObjectInputStream;
import java.io.ObjectStreamClass;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

/**
 * Do sneaky things to allocate objects without invoking their constructors.
 *
 * @author Joel Leitch
 * @author Jesse Wilson
 */
public abstract class UnsafeAllocator {
  public abstract <T> T newInstance(Class<T> c) throws Exception;

  public static UnsafeAllocator create() {
    // try JVM
    // public class Unsafe {
    //   public Object allocateInstance(Class<?> type);
    // }
    try {
      Class<?> unsafeClass = Class.forName(""sun.misc.Unsafe"");
      Field f = unsafeClass.getDeclaredField(""theUnsafe"");
      f.setAccessible(true);
      final Object unsafe = f.get(null);
      final Method allocateInstance = unsafeClass.getMethod(""allocateInstance"", Class.class);
      return new UnsafeAllocator() {
        @Override
        @SuppressWarnings(""unchecked"")
        public <T> T newInstance(Class<T> c) throws Exception {
          return (T) allocateInstance.invoke(unsafe, c);
        }
      };
    } catch (Exception ignored) {
    }

    // try dalvikvm, post-gingerbread
    // public class ObjectStreamClass {
    //   private static native int getConstructorId(Class<?> c);
    //   private static native Object newInstance(Class<?> instantiationClass, int methodId);
    // }
    try {
      Method getConstructorId = ObjectStreamClass.class
          .getDeclaredMethod(""getConstructorId"", Class.class);
      getConstructorId.setAccessible(true);
      final int constructorId = (Integer) getConstructorId.invoke(null, Object.class);
      final Method newInstance = ObjectStreamClass.class
          .getDeclaredMethod(""newInstance"", Class.class, int.class);
      newInstance.setAccessible(true);
      return new UnsafeAllocator() {
        @Override
        @SuppressWarnings(""unchecked"")
        public <T> T newInstance(Class<T> c) throws Exception {
          return (T) newInstance.invoke(null, c, constructorId);
        }
      };
    } catch (Exception ignored) {
    }

    // try dalvikvm, pre-gingerbread
    // public class ObjectInputStream {
    //   private static native Object newInstance(
    //     Class<?> instantiationClass, Class<?> constructorClass);
    // }
    try {
      final Method newInstance = ObjectInputStream.class
          .getDeclaredMethod(""newInstance"", Class.class, Class.class);
      newInstance.setAccessible(true);
      return new UnsafeAllocator() {
        @Override
        @SuppressWarnings(""unchecked"")
        public <T> T newInstance(Class<T> c) throws Exception {
          return (T) newInstance.invoke(null, c, Object.class);
        }
      };
    } catch (Exception ignored) {
    }

    // give up
    return new UnsafeAllocator() {
      @Override
      public <T> T newInstance(Class<T> c) {
        throw new UnsupportedOperationException(""Cannot allocate "" + c);
      }
    };
  }

  /**
   * Check if the class can be instantiated by unsafe allocator. If the instance has interface or abstract modifiers
   * throw an {@link java.lang.UnsupportedOperationException}
   * @param c instance of the class to be checked
   */
}
"
Gson_9,/home/common/huangzhili/defects4j_buggy/Gson_9_buggy/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java,"    public Boolean read(JsonReader in) throws IOException {
      if (in.peek() == JsonToken.NULL) {
        in.nextNull();
        return null;
      } else if (in.peek() == JsonToken.STRING) {
        // support strings for compatibility with GSON 1.7
        return Boolean.parseBoolean(in.nextString());
      }
      return in.nextBoolean();
    }
"
Gson_9,/home/common/huangzhili/defects4j_buggy/Gson_9_buggy/gson/src/main/java/com/google/gson/stream/JsonWriter.java,"  public JsonWriter value(double value) throws IOException {
    if (Double.isNaN(value) || Double.isInfinite(value)) {
      throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value);
    }
    writeDeferredName();
    beforeValue();
    out.append(Double.toString(value));
    return this;
  }
"
Gson_9,/home/common/huangzhili/defects4j_buggy/Gson_9_buggy/gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java,"  private void put(JsonElement value) {
    if (pendingName != null) {
      if (!value.isJsonNull() || getSerializeNulls()) {
        JsonObject object = (JsonObject) peek();
        object.add(pendingName, value);
      }
      pendingName = null;
    } else if (stack.isEmpty()) {
      product = value;
    } else {
      JsonElement element = peek();
      if (element instanceof JsonArray) {
        ((JsonArray) element).add(value);
      } else {
        throw new IllegalStateException();
      }
    }
  }
"
Gson_10,/home/common/huangzhili/defects4j_buggy/Gson_10_buggy/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java,"private ReflectiveTypeAdapterFactory.BoundField createBoundField(
      final Gson context, final Field field, final String name,
      final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {
    final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());
    // special casing primitives here saves ~5% on Android...
    JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);
    TypeAdapter<?> mapped = null;
    if (annotation != null) {
      mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);
    }
    final boolean jsonAdapterPresent = mapped != null;
    if (mapped == null) mapped = context.getAdapter(fieldType);

    final TypeAdapter<?> typeAdapter = mapped;
    return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {
      @SuppressWarnings({""unchecked"", ""rawtypes""}) // the type adapter and field type always agree
       @Override void write(JsonWriter writer, Object value)
           throws IOException, IllegalAccessException {
         Object fieldValue = field.get(value);
         TypeAdapter t =
           new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());
         t.write(writer, fieldValue);
       }
       @Override void read(JsonReader reader, Object value)
          throws IOException, IllegalAccessException {
        Object fieldValue = typeAdapter.read(reader);
        if (fieldValue != null || !isPrimitive) {
          field.set(value, fieldValue);
        }
      }
      @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {
        if (!serialized) return false;
        Object fieldValue = field.get(value);
        return fieldValue != value; // avoid recursion for example for Throwable.cause
      }
    };
  }"
Gson_14,/home/common/huangzhili/defects4j_buggy/Gson_14_buggy/gson/src/main/java/com/google/gson/internal/$Gson$Types.java,"public static WildcardType supertypeOf(Type bound) {
     Type[] lowerBounds;
       lowerBounds = new Type[] { bound };
     return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);
   }"
Gson_14,/home/common/huangzhili/defects4j_buggy/Gson_14_buggy/gson/src/main/java/com/google/gson/internal/$Gson$Types.java,"public static WildcardType subtypeOf(Type bound) {
     Type[] upperBounds;
       upperBounds = new Type[] { bound };
     return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);
   }"
JacksonCore_1,/home/common/huangzhili/defects4j_buggy/JacksonCore_1_buggy/src/main/java/com/fasterxml/jackson/core/io/NumberInput.java,"    public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len)
            throws NumberFormatException
    {
            return new BigDecimal(buffer, offset, len);
    }
"
JacksonCore_1,/home/common/huangzhili/defects4j_buggy/JacksonCore_1_buggy/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java,"    public BigDecimal contentsAsDecimal()
        throws NumberFormatException
    {
        // Already got a pre-cut array?
        if (_resultArray != null) {
            return NumberInput.parseBigDecimal(_resultArray);
        }
        // Or a shared buffer?
        if (_inputStart >= 0) {
            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen);
        }
        // Or if not, just a single buffer (the usual case)
        if (_segmentSize == 0) {
            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);
        }
        // If not, let's just get it aggregated...
        return NumberInput.parseBigDecimal(contentsAsArray());
    }
"
JacksonCore_1,/home/common/huangzhili/defects4j_buggy/JacksonCore_1_buggy/src/main/java/com/fasterxml/jackson/core/io/NumberInput.java,"    public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException
    {
            return new BigDecimal(numStr);
    }
"
JacksonCore_2,/home/common/huangzhili/defects4j_buggy/JacksonCore_2_buggy/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,"protected JsonToken _parseNumber(int ch) throws IOException
    {
        /* Although we will always be complete with respect to textual
         * representation (that is, all characters will be parsed),
         * actual conversion to a number is deferred. Thus, need to
         * note that no representations are valid yet
         */
        boolean negative = (ch == INT_MINUS);
        int ptr = _inputPtr;
        int startPtr = ptr-1; // to include sign/digit already read
        final int inputLen = _inputEnd;

        dummy_loop:
        do { // dummy loop, to be able to break out
            if (negative) { // need to read the next digit
                if (ptr >= _inputEnd) {
                    break dummy_loop;
                }
                ch = _inputBuffer[ptr++];
                // First check: must have a digit to follow minus sign
                if (ch > INT_9 || ch < INT_0) {
                    _inputPtr = ptr;
                    return _handleInvalidNumberStart(ch, true);
                }
                /* (note: has been checked for non-negative already, in
                 * the dispatching code that determined it should be
                 * a numeric value)
                 */
            }
            // One special case, leading zero(es):
            if (ch == INT_0) {
                break dummy_loop;
            }
            
            /* First, let's see if the whole number is contained within
             * the input buffer unsplit. This should be the common case;
             * and to simplify processing, we will just reparse contents
             * in the alternative case (number split on buffer boundary)
             */
            
            int intLen = 1; // already got one
            
            // First let's get the obligatory integer part:
            
            int_loop:
            while (true) {
                if (ptr >= _inputEnd) {
                    break dummy_loop;
                }
                ch = (int) _inputBuffer[ptr++];
                if (ch < INT_0 || ch > INT_9) {
                    break int_loop;
                }
                ++intLen;
            }

            int fractLen = 0;
            
            // And then see if we get other parts
            if (ch == '.') { // yes, fraction
                fract_loop:
                while (true) {
                    if (ptr >= inputLen) {
                        break dummy_loop;
                    }
                    ch = (int) _inputBuffer[ptr++];
                    if (ch < INT_0 || ch > INT_9) {
                        break fract_loop;
                    }
                    ++fractLen;
                }
                // must be followed by sequence of ints, one minimum
                if (fractLen == 0) {
                    reportUnexpectedNumberChar(ch, ""Decimal point not followed by a digit"");
                }
            }

            int expLen = 0;
            if (ch == 'e' || ch == 'E') { // and/or exponent
                if (ptr >= inputLen) {
                    break dummy_loop;
                }
                // Sign indicator?
                ch = (int) _inputBuffer[ptr++];
                if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now
                    if (ptr >= inputLen) {
                        break dummy_loop;
                    }
                    ch = (int) _inputBuffer[ptr++];
                }
                while (ch <= INT_9 && ch >= INT_0) {
                    ++expLen;
                    if (ptr >= inputLen) {
                        break dummy_loop;
                    }
                    ch = (int) _inputBuffer[ptr++];
                }
                // must be followed by sequence of ints, one minimum
                if (expLen == 0) {
                    reportUnexpectedNumberChar(ch, ""Exponent indicator not followed by a digit"");
                }
            }
            // Got it all: let's add to text buffer for parsing, access
             --ptr; // need to push back following separator
             _inputPtr = ptr;
             // As per #105, need separating space between root values; check here
             int len = ptr-startPtr;
             _textBuffer.resetWithShared(_inputBuffer, startPtr, len);
             return reset(negative, intLen, fractLen, expLen);
        } while (false);

        _inputPtr = negative ? (startPtr+1) : startPtr;
        return _parseNumber2(negative);
    }"
JacksonCore_2,/home/common/huangzhili/defects4j_buggy/JacksonCore_2_buggy/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,"private JsonToken _parseNumber2(boolean negative) throws IOException
    {
        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
        int outPtr = 0;

        // Need to prepend sign?
        if (negative) {
            outBuf[outPtr++] = '-';
        }

        // This is the place to do leading-zero check(s) too:
        int intLen = 0;
        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(""No digit following minus sign"");
        if (c == '0') {
            c = _verifyNoLeadingZeroes();
        }
        boolean eof = false;

        // Ok, first the obligatory integer part:
        int_loop:
        while (c >= '0' && c <= '9') {
            ++intLen;
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = c;
            if (_inputPtr >= _inputEnd && !loadMore()) {
                // EOF is legal for main level int values
                c = CHAR_NULL;
                eof = true;
                break int_loop;
            }
            c = _inputBuffer[_inputPtr++];
        }
        // Also, integer part is not optional
        if (intLen == 0) {
            reportInvalidNumber(""Missing integer part (next char ""+_getCharDesc(c)+"")"");
        }

        int fractLen = 0;
        // And then see if we get other parts
        if (c == '.') { // yes, fraction
            outBuf[outPtr++] = c;

            fract_loop:
            while (true) {
                if (_inputPtr >= _inputEnd && !loadMore()) {
                    eof = true;
                    break fract_loop;
                }
                c = _inputBuffer[_inputPtr++];
                if (c < INT_0 || c > INT_9) {
                    break fract_loop;
                }
                ++fractLen;
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = c;
            }
            // must be followed by sequence of ints, one minimum
            if (fractLen == 0) {
                reportUnexpectedNumberChar(c, ""Decimal point not followed by a digit"");
            }
        }

        int expLen = 0;
        if (c == 'e' || c == 'E') { // exponent?
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = c;
            // Not optional, can require that we get one more char
            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]
                : getNextChar(""expected a digit for number exponent"");
            // Sign indicator?
            if (c == '-' || c == '+') {
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = c;
                // Likewise, non optional:
                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]
                    : getNextChar(""expected a digit for number exponent"");
            }

            exp_loop:
            while (c <= INT_9 && c >= INT_0) {
                ++expLen;
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = c;
                if (_inputPtr >= _inputEnd && !loadMore()) {
                    eof = true;
                    break exp_loop;
                }
                c = _inputBuffer[_inputPtr++];
            }
            // must be followed by sequence of ints, one minimum
            if (expLen == 0) {
                reportUnexpectedNumberChar(c, ""Exponent indicator not followed by a digit"");
            }
        }

         // Ok; unless we hit end-of-input, need to push last char read back
         if (!eof) {
             --_inputPtr;
         }
         _textBuffer.setCurrentLength(outPtr);
         // And there we have it!
        return reset(negative, intLen, fractLen, expLen);
    }"
JacksonCore_2,/home/common/huangzhili/defects4j_buggy/JacksonCore_2_buggy/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java,"protected JsonToken _parseNumber(int c)
        throws IOException, JsonParseException
    {
        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
        int outPtr = 0;
        boolean negative = (c == INT_MINUS);

        // Need to prepend sign?
        if (negative) {
            outBuf[outPtr++] = '-';
            // Must have something after sign too
            if (_inputPtr >= _inputEnd) {
                loadMoreGuaranteed();
            }
            c = (int) _inputBuffer[_inputPtr++] & 0xFF;
            // Note: must be followed by a digit
            if (c < INT_0 || c > INT_9) {
                return _handleInvalidNumberStart(c, true);
            }
        }

        // One special case: if first char is 0, must not be followed by a digit
        if (c == INT_0) {
            c = _verifyNoLeadingZeroes();
        }
        
        // Ok: we can first just add digit we saw first:
        outBuf[outPtr++] = (char) c;
        int intLen = 1;

        // And then figure out how far we can read without further checks:
        int end = _inputPtr + outBuf.length;
        if (end > _inputEnd) {
            end = _inputEnd;
        }

        // With this, we have a nice and tight loop:
        while (true) {
            if (_inputPtr >= end) {
                // Long enough to be split across boundary, so:
                return _parserNumber2(outBuf, outPtr, negative, intLen);
            }
            c = (int) _inputBuffer[_inputPtr++] & 0xFF;
            if (c < INT_0 || c > INT_9) {
                break;
            }
            ++intLen;
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = (char) c;
        }
        if (c == '.' || c == 'e' || c == 'E') {
            return _parseFloat(outBuf, outPtr, c, negative, intLen);
        }
        
         --_inputPtr; // to push back trailing char (comma etc)
         _textBuffer.setCurrentLength(outPtr);
         // As per #105, need separating space between root values; check here
 
         // And there we have it!
         return resetInt(negative, intLen);
    }"
JacksonCore_2,/home/common/huangzhili/defects4j_buggy/JacksonCore_2_buggy/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java,"private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative,
            int intPartLength)
        throws IOException, JsonParseException
    {
        // Ok, parse the rest
        while (true) {
            if (_inputPtr >= _inputEnd && !loadMore()) {
                _textBuffer.setCurrentLength(outPtr);
                return resetInt(negative, intPartLength);
            }
            int c = (int) _inputBuffer[_inputPtr++] & 0xFF;
            if (c > INT_9 || c < INT_0) {
                if (c == '.' || c == 'e' || c == 'E') {
                    return _parseFloat(outBuf, outPtr, c, negative, intPartLength);
                }
                break;
            }
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = (char) c;
            ++intPartLength;
        }
         --_inputPtr; // to push back trailing char (comma etc)
         _textBuffer.setCurrentLength(outPtr);
         // As per #105, need separating space between root values; check here
 
         // And there we have it!
         return resetInt(negative, intPartLength);
        
    }"
JacksonCore_2,/home/common/huangzhili/defects4j_buggy/JacksonCore_2_buggy/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java,"private JsonToken _parseFloat(char[] outBuf, int outPtr, int c,
            boolean negative, int integerPartLength)
        throws IOException, JsonParseException
    {
        int fractLen = 0;
        boolean eof = false;

        // And then see if we get other parts
        if (c == '.') { // yes, fraction
            outBuf[outPtr++] = (char) c;

            fract_loop:
            while (true) {
                if (_inputPtr >= _inputEnd && !loadMore()) {
                    eof = true;
                    break fract_loop;
                }
                c = (int) _inputBuffer[_inputPtr++] & 0xFF;
                if (c < INT_0 || c > INT_9) {
                    break fract_loop;
                }
                ++fractLen;
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = (char) c;
            }
            // must be followed by sequence of ints, one minimum
            if (fractLen == 0) {
                reportUnexpectedNumberChar(c, ""Decimal point not followed by a digit"");
            }
        }

        int expLen = 0;
        if (c == 'e' || c == 'E') { // exponent?
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = (char) c;
            // Not optional, can require that we get one more char
            if (_inputPtr >= _inputEnd) {
                loadMoreGuaranteed();
            }
            c = (int) _inputBuffer[_inputPtr++] & 0xFF;
            // Sign indicator?
            if (c == '-' || c == '+') {
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = (char) c;
                // Likewise, non optional:
                if (_inputPtr >= _inputEnd) {
                    loadMoreGuaranteed();
                }
                c = (int) _inputBuffer[_inputPtr++] & 0xFF;
            }

            exp_loop:
            while (c <= INT_9 && c >= INT_0) {
                ++expLen;
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = (char) c;
                if (_inputPtr >= _inputEnd && !loadMore()) {
                    eof = true;
                    break exp_loop;
                }
                c = (int) _inputBuffer[_inputPtr++] & 0xFF;
            }
            // must be followed by sequence of ints, one minimum
            if (expLen == 0) {
                reportUnexpectedNumberChar(c, ""Exponent indicator not followed by a digit"");
            }
        }

        // Ok; unless we hit end-of-input, need to push last char read back
         if (!eof) {
             --_inputPtr;
             // As per #105, need separating space between root values; check here
         }
         _textBuffer.setCurrentLength(outPtr);
 
        // And there we have it!
        return resetFloat(negative, integerPartLength, fractLen, expLen);
    }"
JacksonCore_2,/home/common/huangzhili/defects4j_buggy/JacksonCore_2_buggy/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java,"private int _skipWSOrEnd() throws IOException
    {
        final int[] codes = _icWS;
        while ((_inputPtr < _inputEnd) || loadMore()) {
            final int i = _inputBuffer[_inputPtr++] & 0xFF;
            switch (codes[i]) {
            case 0: // done!
                return i;
            case 1: // skip
                continue;
            case 2: // 2-byte UTF
                _skipUtf8_2(i);
                break;
            case 3: // 3-byte UTF
                _skipUtf8_3(i);
                break;
            case 4: // 4-byte UTF
                _skipUtf8_4(i);
                break;
            case INT_LF:
                ++_currInputRow;
                _currInputRowStart = _inputPtr;
                break;
            case INT_CR:
                _skipCR();
                break;
            case '/':
                _skipComment();
                break;
            case '#':
                if (!_skipYAMLComment()) {
                    return i;
                 }
                 break;
             default: // e.g. -1
                 if (i < 32) {
                     _throwInvalidSpace(i);
                 }
                 _reportInvalidChar(i);
             }
         }
        // We ran out of input...
        _handleEOF();
        return -1;
    }"
JacksonCore_9,/home/common/huangzhili/defects4j_buggy/JacksonCore_9_buggy/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java,"@Override
    public String getValueAsString() throws IOException
    {
        if (_currToken == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                return _finishAndReturnString(); // only strings can be incomplete
             }
             return _textBuffer.contentsAsString();
         }
         return super.getValueAsString(null);
     }"
JacksonCore_9,/home/common/huangzhili/defects4j_buggy/JacksonCore_9_buggy/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java,"@Override
    public String getValueAsString(String defValue) throws IOException
    {
        if (_currToken == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                return _finishAndReturnString(); // only strings can be incomplete
             }
             return _textBuffer.contentsAsString();
         }
         return super.getValueAsString(defValue);
     }"
JacksonCore_9,/home/common/huangzhili/defects4j_buggy/JacksonCore_9_buggy/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,"@Override
    public final String getValueAsString(String defValue) throws IOException {
        if (_currToken == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString(); // only strings can be incomplete
             }
             return _textBuffer.contentsAsString();
         }
         return super.getValueAsString(defValue);
     }"
JacksonCore_9,/home/common/huangzhili/defects4j_buggy/JacksonCore_9_buggy/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,"@Override
    public final String getValueAsString() throws IOException
    {
        if (_currToken == JsonToken.VALUE_STRING) {
            if (_tokenIncomplete) {
                _tokenIncomplete = false;
                _finishString(); // only strings can be incomplete
             }
             return _textBuffer.contentsAsString();
         }
         return super.getValueAsString(null);
     }"
JacksonCore_9,/home/common/huangzhili/defects4j_buggy/JacksonCore_9_buggy/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java,"@Override
    public String getValueAsString() throws IOException {
         if (_currToken == JsonToken.VALUE_STRING) {
             return getText();
         }
         return getValueAsString(null);
     }"
JacksonCore_9,/home/common/huangzhili/defects4j_buggy/JacksonCore_9_buggy/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java,"@Override
    public String getValueAsString(String defaultValue) throws IOException {
         if (_currToken == JsonToken.VALUE_STRING) {
             return getText();
         }
         if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {
             return defaultValue;
         }
        return getText();
    }"
JacksonCore_10,/home/common/huangzhili/defects4j_buggy/JacksonCore_10_buggy/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java,"private int _findOffsetForAdd(int hash)
    {
        // first, check the primary:
        int offset = _calcOffset(hash);
        final int[] hashArea = _hashArea;
        if (hashArea[offset+3] == 0) {
//System.err.printf("" PRImary slot #%d, hash %X\n"", (offset>>2), hash & 0x7F);
            return offset;
        }
        // then secondary
        int offset2 = _secondaryStart + ((offset >> 3) << 2);
        if (hashArea[offset2+3] == 0) {
//System.err.printf("" SECondary slot #%d (start x%X), hash %X\n"",(offset >> 3), _secondaryStart, (hash & 0x7F));
            return offset2;
        }
        // if not, tertiary?

        offset2 = _tertiaryStart + ((offset >> (_tertiaryShift + 2)) << _tertiaryShift);
        final int bucketSize = (1 << _tertiaryShift);
        for (int end = offset2 + bucketSize; offset2 < end; offset2 += 4) {
            if (hashArea[offset2+3] == 0) {
//System.err.printf("" TERtiary slot x%X (from x%X, start x%X), hash %X.\n"", offset2, ((offset >> (_tertiaryShift + 2)) << _tertiaryShift), _tertiaryStart, (hash & 0x7F));
                return offset2;
            }
        }

        // and if even tertiary full, append at the end of spill area
        offset = _spilloverEnd;
        _spilloverEnd += 4;

//System.err.printf("" SPIll-over at x%X; start x%X; end x%X, hash %X\n"", offset, _spilloverStart(), _hashArea.length, (hash & 0x7F));
        
        // one caveat: in the unlikely event if spill-over filling up,
        // check if that could be considered a DoS attack; handle appropriately
        // (NOTE: approximate for now; we could verify details if that becomes necessary)
         /* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array,
          *   since ""long names"" area follows. Instead, need to calculate from hash size.
          */
         if (_spilloverEnd >= hashArea.length) {
             if (_failOnDoS) {
                 _reportTooManyCollisions();
             }
            // and if we didn't fail, we'll simply force rehash for next add
            // (which, in turn, may double up or nuke contents, depending on size etc)
            _needRehash = true;
        }
        return offset;
    }"
JacksonCore_10,/home/common/huangzhili/defects4j_buggy/JacksonCore_10_buggy/src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java,"public int calcHash(int q1)
    {
        int hash = q1 ^ _seed;
        /* 29-Mar-2015, tatu: Earlier used 15 + 9 right shifts, which worked ok
         *    except for one specific problem case: numbers. So needed to make sure
         *    that all 4 least-significant bits participate in hash. Couple of ways
          *    to work it out, but this is the simplest, fast and seems to do ok.
          */
         hash += (hash >>> 16); // to xor hi- and low- 16-bits
         hash ^= (hash >>> 12);
         return hash;
     }"
JacksonCore_12,/home/common/huangzhili/defects4j_buggy/JacksonCore_12_buggy/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java,"@Override
    public JsonLocation getTokenLocation()
    {
        final Object src = _ioContext.getSourceReference();
        if (_currToken == JsonToken.FIELD_NAME) {
            return new JsonLocation(src,
                     _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);
         }
         return new JsonLocation(src,
                 getTokenCharacterOffset(), -1L, getTokenLineNr(),
                 getTokenColumnNr());
     }"
JacksonCore_12,/home/common/huangzhili/defects4j_buggy/JacksonCore_12_buggy/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,"protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException
    {
        // // // and this is back to standard nextToken()
        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
         _parsingContext.setCurrentName(name);
         _currToken = JsonToken.FIELD_NAME;
         i = _skipColon();
         if (i == INT_QUOTE) {
             _tokenIncomplete = true;
             _nextToken = JsonToken.VALUE_STRING;
            return nameToMatch.equals(name);
        }
        // Ok: we must have a value... what is it?
        JsonToken t;
        switch (i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
        }
        _nextToken = t;
        return nameToMatch.equals(name);
    }"
JacksonCore_12,/home/common/huangzhili/defects4j_buggy/JacksonCore_12_buggy/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,"private final void _isNextTokenNameYes(int i) throws IOException
     {
         _currToken = JsonToken.FIELD_NAME;
 
         switch (i) {
         case '""':
            _tokenIncomplete = true;
            _nextToken = JsonToken.VALUE_STRING;
            return;
        case '[':
            _nextToken = JsonToken.START_ARRAY;
            return;
        case '{':
            _nextToken = JsonToken.START_OBJECT;
            return;
        case 't':
            _matchToken(""true"", 1);
            _nextToken = JsonToken.VALUE_TRUE;
            return;
        case 'f':
            _matchToken(""false"", 1);
            _nextToken = JsonToken.VALUE_FALSE;
            return;
        case 'n':
            _matchToken(""null"", 1);
            _nextToken = JsonToken.VALUE_NULL;
            return;
        case '-':
            _nextToken = _parseNegNumber();
            return;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            _nextToken = _parsePosNumber(i);
            return;
        }
        _nextToken = _handleOddValue(i);
    }"
JacksonCore_12,/home/common/huangzhili/defects4j_buggy/JacksonCore_12_buggy/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,"@Override
     public JsonLocation getTokenLocation()
     {
         final Object src = _ioContext.getSourceReference();
         return new JsonLocation(src,
                 -1L, getTokenCharacterOffset(),
                 getTokenLineNr(),
                 getTokenColumnNr());
     }"
JacksonCore_12,/home/common/huangzhili/defects4j_buggy/JacksonCore_12_buggy/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,"@Override
    public boolean nextFieldName(SerializableString sstr) throws IOException
    {
        // // // Note: most of code below is copied from nextToken()

        _numTypesValid = NR_UNKNOWN;
        if (_currToken == JsonToken.FIELD_NAME) {
            _nextAfterName();
            return false;
        }
        if (_tokenIncomplete) {
            _skipString();
        }
        int i = _skipWSOrEnd();
        if (i < 0) {
            close();
            _currToken = null;
            return false;
        }
        _binaryValue = null;

        if (i == INT_RBRACKET) {
            _updateLocation();
            if (!_parsingContext.inArray()) {
                _reportMismatchedEndMarker(i, '}');
            }
            _parsingContext = _parsingContext.getParent();
            _currToken = JsonToken.END_ARRAY;
            return false;
        }
        if (i == INT_RCURLY) {
            _updateLocation();
            if (!_parsingContext.inObject()) {
                _reportMismatchedEndMarker(i, ']');
            }
            _parsingContext = _parsingContext.getParent();
            _currToken = JsonToken.END_OBJECT;
            return false;
        }
         if (_parsingContext.expectComma()) {
             i = _skipComma(i);
         }
         _updateLocation();
 
         if (!_parsingContext.inObject()) {
             _nextTokenNotInObject(i);
             return false;
         }
 
         if (i == INT_QUOTE) {
             // when doing literal match, must consider escaping:
             char[] nameChars = sstr.asQuotedChars();
            final int len = nameChars.length;

            // Require 4 more bytes for faster skipping of colon that follows name
            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...
                // first check length match by
                final int end = _inputPtr+len;
                if (_inputBuffer[end] == '""') {
                    int offset = 0;
                    int ptr = _inputPtr;
                    while (true) {
                        if (ptr == end) { // yes, match!
                            _parsingContext.setCurrentName(sstr.getValue());
                            _isNextTokenNameYes(_skipColonFast(ptr+1));
                            return true;
                        }
                        if (nameChars[offset] != _inputBuffer[ptr]) {
                            break;
                        }
                        ++offset;
                        ++ptr;
                    }
                }
            }
        }
        return _isNextTokenNameMaybe(i, sstr.getValue());
    }"
JacksonCore_12,/home/common/huangzhili/defects4j_buggy/JacksonCore_12_buggy/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,"@Override
    public final JsonToken nextToken() throws IOException
    {
        /* First: field names are special -- we will always tokenize
         * (part of) value along with field name to simplify
         * state handling. If so, can and need to use secondary token:
         */
        if (_currToken == JsonToken.FIELD_NAME) {
            return _nextAfterName();
        }
        // But if we didn't already have a name, and (partially?) decode number,
        // need to ensure no numeric information is leaked
        _numTypesValid = NR_UNKNOWN;
        if (_tokenIncomplete) {
            _skipString(); // only strings can be partial
        }
        int i = _skipWSOrEnd();
        if (i < 0) { // end-of-input
            /* 19-Feb-2009, tatu: Should actually close/release things
             *    like input source, symbol table and recyclable buffers now.
             */
            close();
            return (_currToken = null);
        }
        // clear any data retained so far
        _binaryValue = null;

        // Closing scope?
        if (i == INT_RBRACKET) {
            _updateLocation();
            if (!_parsingContext.inArray()) {
                _reportMismatchedEndMarker(i, '}');
            }
            _parsingContext = _parsingContext.getParent();
            return (_currToken = JsonToken.END_ARRAY);
        }
        if (i == INT_RCURLY) {
            _updateLocation();
            if (!_parsingContext.inObject()) {
                _reportMismatchedEndMarker(i, ']');
            }
            _parsingContext = _parsingContext.getParent();
            return (_currToken = JsonToken.END_OBJECT);
        }

        // Nope: do we then expect a comma?
        if (_parsingContext.expectComma()) {
            i = _skipComma(i);
        }
        _updateLocation();

        /* And should we now have a name? Always true for Object contexts, since
         * the intermediate 'expect-value' state is never retained.
         */
         boolean inObject = _parsingContext.inObject();
         if (inObject) {
             // First, field name itself:
             String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
             _parsingContext.setCurrentName(name);
             _currToken = JsonToken.FIELD_NAME;
             i = _skipColon();
         }
 
         // Ok: we must have a value... what is it?
 
        JsonToken t;

        switch (i) {
        case '""':
            _tokenIncomplete = true;
            t = JsonToken.VALUE_STRING;
            break;
        case '[':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            if (!inObject) {
                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);
            }
            t = JsonToken.START_OBJECT;
            break;
        case ']':
        case '}':
            // Error: neither is valid at this point; valid closers have
            // been handled earlier
            _reportUnexpectedChar(i, ""expected a value"");
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;

        case '-':
            /* Should we have separate handling for plus? Although
             * it is not allowed per se, it may be erroneously used,
             * and could be indicate by a more specific error message.
             */
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        default:
            t = _handleOddValue(i);
            break;
        }

        if (inObject) {
            _nextToken = t;
            return _currToken;
        }
        _currToken = t;
        return t;
    }"
JacksonCore_12,/home/common/huangzhili/defects4j_buggy/JacksonCore_12_buggy/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,"@Override
    public String nextFieldName() throws IOException
    {
        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)

        _numTypesValid = NR_UNKNOWN;
        if (_currToken == JsonToken.FIELD_NAME) {
            _nextAfterName();
            return null;
        }
        if (_tokenIncomplete) {
            _skipString();
        }
        int i = _skipWSOrEnd();
        if (i < 0) {
            close();
            _currToken = null;
            return null;
        }
        _binaryValue = null;
        if (i == INT_RBRACKET) {
            _updateLocation();
            if (!_parsingContext.inArray()) {
                _reportMismatchedEndMarker(i, '}');
            }
            _parsingContext = _parsingContext.getParent();
            _currToken = JsonToken.END_ARRAY;
            return null;
        }
        if (i == INT_RCURLY) {
            _updateLocation();
            if (!_parsingContext.inObject()) {
                _reportMismatchedEndMarker(i, ']');
            }
            _parsingContext = _parsingContext.getParent();
            _currToken = JsonToken.END_OBJECT;
            return null;
        }
         if (_parsingContext.expectComma()) {
             i = _skipComma(i);
         }
         _updateLocation();
         if (!_parsingContext.inObject()) {
             _nextTokenNotInObject(i);
             return null;
         }
 
         String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);
         _parsingContext.setCurrentName(name);
         _currToken = JsonToken.FIELD_NAME;
         i = _skipColon();
 
         if (i == INT_QUOTE) {
             _tokenIncomplete = true;
             _nextToken = JsonToken.VALUE_STRING;
            return name;
        }
        
        // Ok: we must have a value... what is it?

        JsonToken t;

        switch (i) {
        case '-':
            t = _parseNegNumber();
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            t = _parsePosNumber(i);
            break;
        case 'f':
            _matchFalse();
            t = JsonToken.VALUE_FALSE;
            break;
        case 'n':
            _matchNull();
            t = JsonToken.VALUE_NULL;
            break;
        case 't':
            _matchTrue();
            t = JsonToken.VALUE_TRUE;
            break;
        case '[':
            t = JsonToken.START_ARRAY;
            break;
        case '{':
            t = JsonToken.START_OBJECT;
            break;
        default:
            t = _handleOddValue(i);
            break;
        }
        _nextToken = t;
        return name;
    }"
JacksonCore_13,/home/common/huangzhili/defects4j_buggy/JacksonCore_13_buggy/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java,"    public JsonGenerator enable(Feature f) {
        super.enable(f);
        if (f == Feature.QUOTE_FIELD_NAMES) {
            _cfgUnqNames = false;
        }
        return this;
    }
"
JacksonCore_14,/home/common/huangzhili/defects4j_buggy/JacksonCore_14_buggy/src/main/java/com/fasterxml/jackson/core/io/IOContext.java,"    protected final void _verifyAlloc(Object buffer) {
        if (buffer != null) { throw new IllegalStateException(""Trying to call same allocXxx() method second time""); }
    }
"
JacksonCore_16,/home/common/huangzhili/defects4j_buggy/JacksonCore_16_buggy/src/main/java/com/fasterxml/jackson/core/util/JsonParserSequence.java,"    public void close() throws IOException {
        do { delegate.close(); } while (switchToNext());
    }
"
JacksonCore_16,/home/common/huangzhili/defects4j_buggy/JacksonCore_16_buggy/src/main/java/com/fasterxml/jackson/core/util/JsonParserSequence.java,"    protected JsonParserSequence(JsonParser[] parsers)
    {
        super(parsers[0]);
        _parsers = parsers;
        _nextParser = 1;
    }
"
JacksonCore_17,/home/common/huangzhili/defects4j_buggy/JacksonCore_17_buggy/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java,"@Override
    public void writeRaw(String text, int offset, int len) throws IOException
    {
         final char[] buf = _charBuffer;
 
         // minor optimization: see if we can just get and copy
 
         // If not, need segmented approach. For speed, let's also use input buffer
         // size that is guaranteed to fit in output buffer; each char can expand to
         // at most 3 bytes, so at most 1/3 of buffer size.
 
         while (len > 0) {
             int len2 = Math.min(buf.length, len);
             text.getChars(offset, offset+len2, buf, 0);
             writeRaw(buf, 0, len2);
             // If this is NOT the last segment and if the last character looks like
             // split surrogate second half, drop it
             offset += len2;
             len -= len2;
         }
    }"
JacksonCore_17,/home/common/huangzhili/defects4j_buggy/JacksonCore_17_buggy/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java,"private final int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputEnd)
        throws IOException
    {
        // Let's handle surrogates gracefully (as 4 byte output):
        if (ch >= SURR1_FIRST) {
            if (ch <= SURR2_LAST) { // yes, outside of BMP
                // Do we have second part?
                if (inputOffset >= inputEnd || cbuf == null) { // nope... have to note down
                    _reportError(""Split surrogate on writeRaw() input (last character)"");
                }
                _outputSurrogates(ch, cbuf[inputOffset]);
                return inputOffset+1;
            }
        }
        final byte[] bbuf = _outputBuffer;
        bbuf[_outputTail++] = (byte) (0xe0 | (ch >> 12));
        bbuf[_outputTail++] = (byte) (0x80 | ((ch >> 6) & 0x3f));
        bbuf[_outputTail++] = (byte) (0x80 | (ch & 0x3f));
        return inputOffset;
    }"
JacksonCore_18,/home/common/huangzhili/defects4j_buggy/JacksonCore_18_buggy/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java,"@Override
    public void writeNumber(BigDecimal value) throws IOException
    {
        // Don't really know max length for big decimal, no point checking
        _verifyValueWrite(WRITE_NUMBER);
         if (value == null) {
             _writeNull();
         } else  if (_cfgNumbersAsStrings) {
             String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString();
             _writeQuotedRaw(raw);
         } else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {
             writeRaw(value.toPlainString());
         } else {
             writeRaw(_asString(value));
         }
    }"
JacksonCore_18,/home/common/huangzhili/defects4j_buggy/JacksonCore_18_buggy/src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java,"@Override
    public void writeNumber(BigDecimal value) throws IOException
    {
        // Don't really know max length for big decimal, no point checking
        _verifyValueWrite(WRITE_NUMBER);
         if (value == null) {
             _writeNull();
         } else  if (_cfgNumbersAsStrings) {
             String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString();
             _writeQuotedRaw(raw);
         } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) {
             writeRaw(value.toPlainString());
         } else {
             writeRaw(_asString(value));
         }
    }"
JacksonCore_19,/home/common/huangzhili/defects4j_buggy/JacksonCore_19_buggy/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java,"private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException
    {
        _inputPtr = neg ? (startPtr+1) : startPtr;
        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();
        int outPtr = 0;

        // Need to prepend sign?
        if (neg) {
            outBuf[outPtr++] = '-';
        }

        // This is the place to do leading-zero check(s) too:
        int intLen = 0;
        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(""No digit following minus sign"");
        if (c == '0') {
            c = _verifyNoLeadingZeroes();
        }
        boolean eof = false;

        // Ok, first the obligatory integer part:
        int_loop:
        while (c >= '0' && c <= '9') {
            ++intLen;
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = c;
            if (_inputPtr >= _inputEnd && !loadMore()) {
                // EOF is legal for main level int values
                c = CHAR_NULL;
                eof = true;
                break int_loop;
            }
            c = _inputBuffer[_inputPtr++];
        }
        // Also, integer part is not optional
        if (intLen == 0) {
            return _handleInvalidNumberStart(c, neg);
        }

         int fractLen = 0;
         // And then see if we get other parts
         if (c == '.') { // yes, fraction
             outBuf[outPtr++] = c;
 
             fract_loop:
            while (true) {
                if (_inputPtr >= _inputEnd && !loadMore()) {
                    eof = true;
                    break fract_loop;
                }
                c = _inputBuffer[_inputPtr++];
                if (c < INT_0 || c > INT_9) {
                    break fract_loop;
                }
                ++fractLen;
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = c;
            }
            // must be followed by sequence of ints, one minimum
            if (fractLen == 0) {
                reportUnexpectedNumberChar(c, ""Decimal point not followed by a digit"");
            }
        }

        int expLen = 0;
        if (c == 'e' || c == 'E') { // exponent?
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = c;
            // Not optional, can require that we get one more char
            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]
                : getNextChar(""expected a digit for number exponent"");
            // Sign indicator?
            if (c == '-' || c == '+') {
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = c;
                // Likewise, non optional:
                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]
                    : getNextChar(""expected a digit for number exponent"");
            }

            exp_loop:
            while (c <= INT_9 && c >= INT_0) {
                ++expLen;
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = c;
                if (_inputPtr >= _inputEnd && !loadMore()) {
                    eof = true;
                    break exp_loop;
                }
                c = _inputBuffer[_inputPtr++];
            }
            // must be followed by sequence of ints, one minimum
            if (expLen == 0) {
                reportUnexpectedNumberChar(c, ""Exponent indicator not followed by a digit"");
            }
        }

        // Ok; unless we hit end-of-input, need to push last char read back
        if (!eof) {
            --_inputPtr;
            if (_parsingContext.inRoot()) {
                _verifyRootSpace(c);
            }
        }
        _textBuffer.setCurrentLength(outPtr);
        // And there we have it!
        return reset(neg, intLen, fractLen, expLen);
    }"
JacksonCore_19,/home/common/huangzhili/defects4j_buggy/JacksonCore_19_buggy/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java,"private final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,
            boolean negative, int integerPartLength) throws IOException
    {
        int fractLen = 0;
        boolean eof = false;
 
         // And then see if we get other parts
         if (c == INT_PERIOD) { // yes, fraction
             outBuf[outPtr++] = (char) c;
 
             fract_loop:
            while (true) {
                if (_inputPtr >= _inputEnd && !loadMore()) {
                    eof = true;
                    break fract_loop;
                }
                c = (int) _inputBuffer[_inputPtr++] & 0xFF;
                if (c < INT_0 || c > INT_9) {
                    break fract_loop;
                }
                ++fractLen;
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = (char) c;
            }
            // must be followed by sequence of ints, one minimum
            if (fractLen == 0) {
                reportUnexpectedNumberChar(c, ""Decimal point not followed by a digit"");
            }
        }

        int expLen = 0;
        if (c == INT_e || c == INT_E) { // exponent?
            if (outPtr >= outBuf.length) {
                outBuf = _textBuffer.finishCurrentSegment();
                outPtr = 0;
            }
            outBuf[outPtr++] = (char) c;
            // Not optional, can require that we get one more char
            if (_inputPtr >= _inputEnd) {
                loadMoreGuaranteed();
            }
            c = (int) _inputBuffer[_inputPtr++] & 0xFF;
            // Sign indicator?
            if (c == '-' || c == '+') {
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = (char) c;
                // Likewise, non optional:
                if (_inputPtr >= _inputEnd) {
                    loadMoreGuaranteed();
                }
                c = (int) _inputBuffer[_inputPtr++] & 0xFF;
            }

            exp_loop:
            while (c <= INT_9 && c >= INT_0) {
                ++expLen;
                if (outPtr >= outBuf.length) {
                    outBuf = _textBuffer.finishCurrentSegment();
                    outPtr = 0;
                }
                outBuf[outPtr++] = (char) c;
                if (_inputPtr >= _inputEnd && !loadMore()) {
                    eof = true;
                    break exp_loop;
                }
                c = (int) _inputBuffer[_inputPtr++] & 0xFF;
            }
            // must be followed by sequence of ints, one minimum
            if (expLen == 0) {
                reportUnexpectedNumberChar(c, ""Exponent indicator not followed by a digit"");
            }
        }

        // Ok; unless we hit end-of-input, need to push last char read back
        if (!eof) {
            --_inputPtr;
            // As per [core#105], need separating space between root values; check here
            if (_parsingContext.inRoot()) {
                _verifyRootSpace(c);
            }
        }
        _textBuffer.setCurrentLength(outPtr);

        // And there we have it!
        return resetFloat(negative, integerPartLength, fractLen, expLen);
    }"
JacksonCore_22,/home/common/huangzhili/defects4j_buggy/JacksonCore_22_buggy/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java,"@Override
    public JsonToken nextToken() throws IOException
    {
        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all
        //    conditionals; and it seems odd to return `null` but NOT considering input
        //    as closed... would love a rewrite to simplify/clear up logic here.
        
        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken
        // check for no buffered context _exposedContext - null
        // If all the conditions matches then check for scalar / non-scalar property

        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {
            // if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL
            // matched once, return null
            if (_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath
                    && (_itemFilter == TokenFilter.INCLUDE_ALL)) {
                return (_currToken = null);
            }
        }
        // Anything buffered?
        TokenFilterContext ctxt = _exposedContext;

        if (ctxt != null) {
            while (true) {
                JsonToken t = ctxt.nextTokenToRead();
                if (t != null) {
                    _currToken = t;
                    return t;
                }
                // all done with buffered stuff?
                if (ctxt == _headContext) {
                    _exposedContext = null;
                    if (ctxt.inArray()) {
                        t = delegate.getCurrentToken();
// Is this guaranteed to work without further checks?
//                        if (t != JsonToken.START_ARRAY) {
                        _currToken = t;
                        return t;
                    }

                    // Almost! Most likely still have the current token;
                    // with the sole exception of 
                    /*
                    t = delegate.getCurrentToken();
                    if (t != JsonToken.FIELD_NAME) {
                        _currToken = t;
                        return t;
                    }
                    */
                    break;
                }
                // If not, traverse down the context chain
                ctxt = _headContext.findChildOf(ctxt);
                _exposedContext = ctxt;
                if (ctxt == null) { // should never occur
                    throw _constructError(""Unexpected problem: chain of filtered context broken"");
                }
            }
        }

        // If not, need to read more. If we got any:
        JsonToken t = delegate.nextToken();
        if (t == null) {
            // no strict need to close, since we have no state here
            _currToken = t;
            return t;
        }

        // otherwise... to include or not?
        TokenFilter f;
        
        switch (t.id()) {
        case ID_START_ARRAY:
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildArrayContext(f, true);
                return (_currToken = t);
            }
            if (f == null) { // does this occur?
                delegate.skipChildren();
                break;
            }
            // Otherwise still iffy, need to check
            f = _headContext.checkValue(f);
            if (f == null) {
                delegate.skipChildren();
                break;
            }
            if (f != TokenFilter.INCLUDE_ALL) {
                f = f.filterStartArray();
            }
            _itemFilter = f;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildArrayContext(f, true);
                return (_currToken = t);
            }
            _headContext = _headContext.createChildArrayContext(f, false);
            
            // Also: only need buffering if parent path to be included
            if (_includePath) {
                t = _nextTokenWithBuffering(_headContext);
                if (t != null) {
                    _currToken = t;
                    return t;
                }
            }
            break;

        case ID_START_OBJECT:
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildObjectContext(f, true);
                return (_currToken = t);
            }
            if (f == null) { // does this occur?
                delegate.skipChildren();
                break;
            }
            // Otherwise still iffy, need to check
            f = _headContext.checkValue(f);
            if (f == null) {
                delegate.skipChildren();
                break;
            }
            if (f != TokenFilter.INCLUDE_ALL) {
                f = f.filterStartObject();
            }
            _itemFilter = f;
            if (f == TokenFilter.INCLUDE_ALL) {
                _headContext = _headContext.createChildObjectContext(f, true);
                return (_currToken = t);
            }
            _headContext = _headContext.createChildObjectContext(f, false);
            // Also: only need buffering if parent path to be included
            if (_includePath) {
                t = _nextTokenWithBuffering(_headContext);
                if (t != null) {
                    _currToken = t;
                    return t;
                }
            }
            // note: inclusion of surrounding Object handled separately via
            // FIELD_NAME
            break;

        case ID_END_ARRAY:
        case ID_END_OBJECT:
            {
                boolean returnEnd = _headContext.isStartHandled();
                f = _headContext.getFilter();
                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                    f.filterFinishArray();
                }
                _headContext = _headContext.getParent();
                _itemFilter = _headContext.getFilter();
                if (returnEnd) {
                    return (_currToken = t);
                }
            }
            break;

        case ID_FIELD_NAME:
            {
                final String name = delegate.getCurrentName();
                // note: this will also set 'needToHandleName'
                f = _headContext.setFieldName(name);
                if (f == TokenFilter.INCLUDE_ALL) {
                    _itemFilter = f;
                    if (!_includePath) {
                        // Minor twist here: if parent NOT included, may need to induce output of
                        // surrounding START_OBJECT/END_OBJECT
                        if (_includeImmediateParent && !_headContext.isStartHandled()) {
                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled
                            _exposedContext = _headContext;
                        }
                    }
                    return (_currToken = t);
                }
                if (f == null) {
                    delegate.nextToken();
                    delegate.skipChildren();
                    break;
                }
                f = f.includeProperty(name);
                if (f == null) {
                    delegate.nextToken();
                    delegate.skipChildren();
                    break;
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    if (_includePath) {
                        return (_currToken = t);
                    }
                }
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        _currToken = t;
                        return t;
                    }
                }
                break;
            }

        default: // scalar value
            f = _itemFilter;
            if (f == TokenFilter.INCLUDE_ALL) {
                return (_currToken = t);
            }
            if (f != null) {
                 f = _headContext.checkValue(f);
                 if ((f == TokenFilter.INCLUDE_ALL)
                         || ((f != null) && f.includeValue(delegate))) {
                         return (_currToken = t);
                 }
             }
             // Otherwise not included (leaves must be explicitly included)
            break;
        }

        // We get here if token was not yet found; offlined handling
        return _nextToken2();
    }"
JacksonCore_22,/home/common/huangzhili/defects4j_buggy/JacksonCore_22_buggy/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java,"protected final JsonToken _nextToken2() throws IOException
    {
        main_loop:
        while (true) {
            JsonToken t = delegate.nextToken();
            if (t == null) { // is this even legal?
                _currToken = t;
                return t;
            }
            TokenFilter f;

            switch (t.id()) {
            case ID_START_ARRAY:
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildArrayContext(f, true);
                    return (_currToken = t);
                }
                if (f == null) { // does this occur?
                    delegate.skipChildren();
                    continue main_loop;
                }
                // Otherwise still iffy, need to check
                f = _headContext.checkValue(f);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartArray();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildArrayContext(f, true);
                    return (_currToken = t);
                }
                _headContext = _headContext.createChildArrayContext(f, false);
                // but if we didn't figure it out yet, need to buffer possible events
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        _currToken = t;
                        return t;
                    }
                }
                continue main_loop;

            case ID_START_OBJECT:
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return (_currToken = t);
                }
                if (f == null) { // does this occur?
                    delegate.skipChildren();
                    continue main_loop;
                }
                // Otherwise still iffy, need to check
                f = _headContext.checkValue(f);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartObject();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return (_currToken = t);
                }
                _headContext = _headContext.createChildObjectContext(f, false);
                if (_includePath) {
                    t = _nextTokenWithBuffering(_headContext);
                    if (t != null) {
                        _currToken = t;
                        return t;
                    }
                }
                continue main_loop;

            case ID_END_ARRAY:
            case ID_END_OBJECT:
                {
                    boolean returnEnd = _headContext.isStartHandled();
                    f = _headContext.getFilter();
                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                        f.filterFinishArray();
                    }
                    _headContext = _headContext.getParent();
                    _itemFilter = _headContext.getFilter();
                    if (returnEnd) {
                        return (_currToken = t);
                    }
                }
                continue main_loop;

            case ID_FIELD_NAME:
                {
                    final String name = delegate.getCurrentName();
                    f = _headContext.setFieldName(name);
                    if (f == TokenFilter.INCLUDE_ALL) {
                        _itemFilter = f;
                        return (_currToken = t);
                    }
                    if (f == null) { // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                    }
                    f = f.includeProperty(name);
                    if (f == null) { // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                     }
                     _itemFilter = f;
                     if (f == TokenFilter.INCLUDE_ALL) {
                         if (_includePath) {
                             return (_currToken = t);
                         }
 //                        if (_includeImmediateParent) { ...
                        continue main_loop;
                    }
                    if (_includePath) {
                        t = _nextTokenWithBuffering(_headContext);
                        if (t != null) {
                            _currToken = t;
                            return t;
                        }
                    }
                }
                continue main_loop;

            default: // scalar value
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    return (_currToken = t);
                }
                if (f != null) {
                    f = _headContext.checkValue(f);
                    if ((f == TokenFilter.INCLUDE_ALL)
                            || ((f != null) && f.includeValue(delegate))) {
                            return (_currToken = t);
                    }
                }
                // Otherwise not included (leaves must be explicitly included)
                break;
            }
        }
    }"
JacksonCore_22,/home/common/huangzhili/defects4j_buggy/JacksonCore_22_buggy/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java,"protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)
        throws IOException
    {
        main_loop:
        while (true) {
            JsonToken t = delegate.nextToken();
            if (t == null) { // is this even legal?
                return t;
            }
            TokenFilter f;

            // One simplification here: we know for a fact that the item filter is
            // neither null nor 'include all', for most cases; the only exception
            // being FIELD_NAME handling

            switch (t.id()) {
            case ID_START_ARRAY:
                f = _headContext.checkValue(_itemFilter);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartArray();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildArrayContext(f, true);
                    return _nextBuffered(buffRoot);
                }
                _headContext = _headContext.createChildArrayContext(f, false);
                continue main_loop;

            case ID_START_OBJECT:
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return t;
                }
                if (f == null) { // does this occur?
                    delegate.skipChildren();
                    continue main_loop;
                }
                // Otherwise still iffy, need to check
                f = _headContext.checkValue(f);
                if (f == null) {
                    delegate.skipChildren();
                    continue main_loop;
                }
                if (f != TokenFilter.INCLUDE_ALL) {
                    f = f.filterStartObject();
                }
                _itemFilter = f;
                if (f == TokenFilter.INCLUDE_ALL) {
                    _headContext = _headContext.createChildObjectContext(f, true);
                    return _nextBuffered(buffRoot);
                }
                _headContext = _headContext.createChildObjectContext(f, false);
                continue main_loop;

            case ID_END_ARRAY:
            case ID_END_OBJECT:
                {
                    // Unlike with other loops, here we know that content was NOT
                    // included (won't get this far otherwise)
                    f = _headContext.getFilter();
                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {
                        f.filterFinishArray();
                    }
                    boolean gotEnd = (_headContext == buffRoot);
                    boolean returnEnd = gotEnd && _headContext.isStartHandled();

                    _headContext = _headContext.getParent();
                    _itemFilter = _headContext.getFilter();

                    if (returnEnd) {
                        return t;
                    }
                    // Hmmh. Do we need both checks, or should above suffice?
                    if (gotEnd || (_headContext == buffRoot)) {
                        return null;
                    }
                }
                continue main_loop;

            case ID_FIELD_NAME:
                {
                    final String name = delegate.getCurrentName();
                    f = _headContext.setFieldName(name);
                    if (f == TokenFilter.INCLUDE_ALL) {
                        _itemFilter = f;
                        return _nextBuffered(buffRoot);
                    }
                    if (f == null) { // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                        continue main_loop;
                    }
                    f = f.includeProperty(name);
                    if (f == null) { // filter out the value
                        delegate.nextToken();
                        delegate.skipChildren();
                         continue main_loop;
                     }
                     _itemFilter = f;
                     if (f == TokenFilter.INCLUDE_ALL) {
                         return _nextBuffered(buffRoot);
                     }
                 }
                continue main_loop;

            default: // scalar value
                f = _itemFilter;
                if (f == TokenFilter.INCLUDE_ALL) {
                    return _nextBuffered(buffRoot);
                }
                if (f != null) {
                    f = _headContext.checkValue(f);
                    if ((f == TokenFilter.INCLUDE_ALL)
                            || ((f != null) && f.includeValue(delegate))) {
                            return _nextBuffered(buffRoot);
                    }
                }
                // Otherwise not included (leaves must be explicitly included)
                continue main_loop;
            }
        }
    }"
JacksonCore_24,/home/common/huangzhili/defects4j_buggy/JacksonCore_24_buggy/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java,"protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException
     {
         final String numDesc = _longIntegerDesc(rawNum);
         _reportError(""Numeric value (%s) out of range of %s"", numDesc,
                 (expType == NR_LONG) ? ""long"" : ""int"");
     }"
JacksonCore_24,/home/common/huangzhili/defects4j_buggy/JacksonCore_24_buggy/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java,"protected void convertNumberToInt() throws IOException
    {
        // First, converting from long ought to be easy
        if ((_numTypesValid & NR_LONG) != 0) {
             // Let's verify it's lossless conversion by simple roundtrip
             int result = (int) _numberLong;
             if (((long) result) != _numberLong) {
                 _reportError(""Numeric value (""+getText()+"") out of range of int"");
             }
             _numberInt = result;
         } else if ((_numTypesValid & NR_BIGINT) != 0) {
            if (BI_MIN_INT.compareTo(_numberBigInt) > 0 
                    || BI_MAX_INT.compareTo(_numberBigInt) < 0) {
                reportOverflowInt();
            }
            _numberInt = _numberBigInt.intValue();
        } else if ((_numTypesValid & NR_DOUBLE) != 0) {
            // Need to check boundaries
            if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {
                reportOverflowInt();
            }
            _numberInt = (int) _numberDouble;
        } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {
            if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 
                || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {
                reportOverflowInt();
            }
            _numberInt = _numberBigDecimal.intValue();
        } else {
            _throwInternal();
        }
        _numTypesValid |= NR_INT;
    }"
JacksonDatabind_2,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_2_buggy/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java,"    @Override
    public void writeObject(Object value) throws IOException
    {
            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);
            /* 28-May-2014, tatu: Tricky choice here; if no codec, should we
             *   err out, or just embed? For now, do latter.
             */
//          throw new JsonMappingException(""No ObjectCodec configured for TokenBuffer, writeObject() called"");
    }

    @Override
    public void writeTree(TreeNode node) throws IOException
    {

            // as with 'writeObject()', is codec optional?
            _append(JsonToken.VALUE_EMBEDDED_OBJECT, node);
    }"
JacksonDatabind_3,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_3_buggy/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java,"@Override
    public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
    {
        // Ok: must point to START_ARRAY (or equivalent)
        if (!jp.isExpectedStartArrayToken()) {
            return handleNonArray(jp, ctxt);
        }
        if (_elementDeserializer != null) {
            return _deserializeCustom(jp, ctxt);
        }

        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();
        Object[] chunk = buffer.resetAndStart();
        
        int ix = 0;
        JsonToken t;
        
        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
            // Ok: no need to convert Strings, but must recognize nulls
            String value;
             if (t == JsonToken.VALUE_STRING) {
                 value = jp.getText();
             } else if (t == JsonToken.VALUE_NULL) {
                 value = _elementDeserializer.getNullValue();
             } else {
                 value = _parseString(jp, ctxt);
             }
            if (ix >= chunk.length) {
                chunk = buffer.appendCompletedChunk(chunk);
                ix = 0;
            }
            chunk[ix++] = value;
        }
        String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);
        ctxt.returnObjectBuffer(buffer);
        return result;
    }"
JacksonDatabind_3,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_3_buggy/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java,"protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException
    {
        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();
        Object[] chunk = buffer.resetAndStart();
        final JsonDeserializer<String> deser = _elementDeserializer;
        
        int ix = 0;
        JsonToken t;
         
         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
             // Ok: no need to convert Strings, but must recognize nulls
             String value = (t == JsonToken.VALUE_NULL) ? null : deser.deserialize(jp, ctxt);
             if (ix >= chunk.length) {
                 chunk = buffer.appendCompletedChunk(chunk);
                 ix = 0;
            }
            chunk[ix++] = value;
        }
        String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);
        ctxt.returnObjectBuffer(buffer);
        return result;
    }"
JacksonDatabind_4,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_4_buggy/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java,"@Override
    public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException
    {
        // Ok: must point to START_ARRAY (or equivalent)
        if (!jp.isExpectedStartArrayToken()) {
            return handleNonArray(jp, ctxt);
        }
        if (_elementDeserializer != null) {
            return _deserializeCustom(jp, ctxt);
        }

        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();
        Object[] chunk = buffer.resetAndStart();

        int ix = 0;
        JsonToken t;

            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
                // Ok: no need to convert Strings, but must recognize nulls
                String value;
                if (t == JsonToken.VALUE_STRING) {
                    value = jp.getText();
                } else if (t == JsonToken.VALUE_NULL) {
                    value = null; // since we have established that '_elementDeserializer == null' earlier
                } else {
                    value = _parseString(jp, ctxt);
                }
                if (ix >= chunk.length) {
                    chunk = buffer.appendCompletedChunk(chunk);
                    ix = 0;
                 }
                 chunk[ix++] = value;
             }
             // note: pass String.class, not String[].class, as we need element type for error info
         String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);
         ctxt.returnObjectBuffer(buffer);
         return result;
    }"
JacksonDatabind_4,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_4_buggy/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java,"/**
     * Offlined version used when we do not use the default deserialization method.
     */
    protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException
    {
        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();
        Object[] chunk = buffer.resetAndStart();
        final JsonDeserializer<String> deser = _elementDeserializer;
        
        int ix = 0;
        JsonToken t;

            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
                // Ok: no need to convert Strings, but must recognize nulls
                String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);
                if (ix >= chunk.length) {
                    chunk = buffer.appendCompletedChunk(chunk);
                    ix = 0;
                 }
                 chunk[ix++] = value;
             }
             // note: pass String.class, not String[].class, as we need element type for error info
         String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);"
JacksonDatabind_4,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_4_buggy/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java,"protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt) throws IOException
    {
        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();
        Object[] chunk = buffer.resetAndStart();
        final JsonDeserializer<String> deser = _elementDeserializer;
        
         int ix = 0;
         JsonToken t;
 
             while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {
                 // Ok: no need to convert Strings, but must recognize nulls
                 String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);
                if (ix >= chunk.length) {
                    chunk = buffer.appendCompletedChunk(chunk);
                    ix = 0;
                }
                chunk[ix++] = value;
            }
            // note: pass String.class, not String[].class, as we need element type for error info
        String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);
        ctxt.returnObjectBuffer(buffer);
        return result;
    }"
JacksonDatabind_10,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_10_buggy/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java,"public void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider)
        throws Exception
    {
        Object value = _accessor.getValue(bean);
        if (value == null) {
            return;
        }
        if (!(value instanceof Map<?,?>)) {
            throw new JsonMappingException(""Value returned by 'any-getter' (""
                    +_accessor.getName()+""()) not java.util.Map but ""+value.getClass().getName());
        }
        // 23-Feb-2015, tatu: Nasty, but has to do (for now)
        if (_mapSerializer != null) {
             _mapSerializer.serializeFields((Map<?,?>) value, gen, provider);
             return;
         }
     }"
JacksonDatabind_10,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_10_buggy/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java,"@SuppressWarnings(""unchecked"")
    protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov,
            BeanDescription beanDesc)
        throws JsonMappingException
    {
        // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object
        // 05-Jul-2012, tatu: ... but we should be able to just return ""unknown type"" serializer, right?
        if (beanDesc.getBeanClass() == Object.class) {
            return prov.getUnknownTypeSerializer(Object.class);
//            throw new IllegalArgumentException(""Can not create bean serializer for Object.class"");
        }
        final SerializationConfig config = prov.getConfig();
        BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);
        builder.setConfig(config);

        // First: any detectable (auto-detect, annotations) properties to serialize?
        List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);
        if (props == null) {
            props = new ArrayList<BeanPropertyWriter>();
        }
        // [databind#638]: Allow injection of ""virtual"" properties:
        prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);

        // [JACKSON-440] Need to allow modification bean properties to serialize:
        if (_factoryConfig.hasSerializerModifiers()) {
            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                props = mod.changeProperties(config, beanDesc, props);
            }
        }

        // Any properties to suppress?
        props = filterBeanProperties(config, beanDesc, props);

        // [JACKSON-440] Need to allow reordering of properties to serialize
        if (_factoryConfig.hasSerializerModifiers()) {
            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                props = mod.orderProperties(config, beanDesc, props);
            }
        }

        /* And if Object Id is needed, some preparation for that as well: better
         * do before view handling, mostly for the custom id case which needs
         * access to a property
         */
        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));
        
        builder.setProperties(props);
        builder.setFilterId(findFilterId(config, beanDesc));
        
        AnnotatedMember anyGetter = beanDesc.findAnyGetter();
        if (anyGetter != null) {
            if (config.canOverrideAccessModifiers()) {
                anyGetter.fixAccess();
            }
            JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());
            // copied from BasicSerializerFactory.buildMapSerializer():
            boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);
            JavaType valueType = type.getContentType();
             TypeSerializer typeSer = createTypeSerializer(config, valueType);
             // last 2 nulls; don't know key, value serializers (yet)
             // 23-Feb-2015, tatu: As per [#705], need to support custom serializers
             MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);
                 // TODO: support '@JsonIgnoreProperties' with any setter?
             // TODO: can we find full PropertyName?
             PropertyName name = new PropertyName(anyGetter.getName());
             BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null,
                    beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);
            builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));
        }
        // Next: need to gather view information, if any:
        processViews(config, builder);

        // Finally: let interested parties mess with the result bit more...
        if (_factoryConfig.hasSerializerModifiers()) {
            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                builder = mod.updateBuilder(config, beanDesc, builder);
            }
        }
        
        JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();
        
        if (ser == null) {
            // If we get this far, there were no properties found, so no regular BeanSerializer
            // would be constructed. But, couple of exceptions.
            // First: if there are known annotations, just create 'empty bean' serializer
            if (beanDesc.hasKnownClassAnnotations()) {
                return builder.createDummy();
            }
        }
        return ser;
    }"
JacksonDatabind_10,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_10_buggy/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java,"@SuppressWarnings(""unchecked"")
     public void resolve(SerializerProvider provider) throws JsonMappingException
     {
         // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...
         _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);
     }"
JacksonDatabind_10,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_10_buggy/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java,"public void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider,
            PropertyFilter filter)
                    throws Exception
    {
        Object value = _accessor.getValue(bean);
        if (value == null) {
            return;
        }
        if (!(value instanceof Map<?,?>)) {
            throw new JsonMappingException(""Value returned by 'any-getter' (""
                    +_accessor.getName()+""()) not java.util.Map but ""+value.getClass().getName());
        }
        // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?
        if (_mapSerializer != null) {
            _mapSerializer.serializeFilteredFields((Map<?,?>) value, gen, provider, filter, null);
             return;
         }
         // ... not sure how custom handler would do it
     }"
JacksonDatabind_13,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_13_buggy/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java,"@Override
    public Object deserializeSetAndReturn(JsonParser jp,
    		DeserializationContext ctxt, Object instance) throws IOException
    {
        // note: no null checks (unlike usually); deserializer should fail if one found
        Object id = _valueDeserializer.deserialize(jp, ctxt);

        /* 02-Apr-2015, tatu: Actually, as per [databind#742], let it be;
         *  missing or null id is needed for some cases, such as cases where id
          *  will be generated externally, at a later point, and is not available
          *  quite yet. Typical use case is with DB inserts.
          */
         
         ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);
         roid.bindItem(instance);
        // also: may need to set a property value as well
        SettableBeanProperty idProp = _objectIdReader.idProperty;
        if (idProp != null) {
            return idProp.setAndReturn(instance, id);
        }
        return instance;
    }"
JacksonDatabind_13,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_13_buggy/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java,"@Override
    public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType)
    {
         /* 02-Apr-2015, tatu: As per [databind#742] should allow 'null', similar to how
          *   missing id already works.
          */
 
         final ObjectIdGenerator.IdKey key = gen.key(id);
 
        if (_objectIds == null) {
            _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey,ReadableObjectId>();
        } else {
            ReadableObjectId entry = _objectIds.get(key);
            if (entry != null) {
                return entry;
            }
        }

        // Not seen yet, must create entry and configure resolver.
        ObjectIdResolver resolver = null;

        if (_objectIdResolvers == null) {
            _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);
        } else {
            for (ObjectIdResolver res : _objectIdResolvers) {
                if (res.canUseFor(resolverType)) {
                    resolver = res;
                    break;
                }
            }
        }

        if (resolver == null) {
            resolver = resolverType.newForDeserialization(this);
            // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around
            //   needed to clear state between calls.
            // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real
            //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.
            /*
            if (resolverType.getClass() == SimpleObjectIdResolver.class) {
                resolver = new SimpleObjectIdResolver();
            }
            */
            _objectIdResolvers.add(resolver);
        }

        ReadableObjectId entry = new ReadableObjectId(key);
        entry.setResolver(resolver);
        _objectIds.put(key, entry);
        return entry;
    }"
JacksonDatabind_14,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_14_buggy/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java,"protected JsonNode _bindAsTree(JsonParser jp) throws IOException
    {
        JsonNode result;
        JsonToken t = _initForReading(jp);
        if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {
             result = NullNode.instance;
         } else {
             DeserializationContext ctxt = createDeserializationContext(jp, _config);
             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, JSON_NODE_TYPE);
             if (_unwrapRoot) {
                 result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser);
             } else {
                result = (JsonNode) deser.deserialize(jp, ctxt);
            }
        }
        // Need to consume the token too
        jp.clearCurrentToken();
        return result;
    }"
JacksonDatabind_15,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_15_buggy/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java,"protected JsonSerializer<Object> findConvertingSerializer(SerializerProvider provider,
            BeanPropertyWriter prop)
        throws JsonMappingException
    {
        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();
        if (intr != null) {
            AnnotatedMember m = prop.getMember();
            if (m != null) {
                Object convDef = intr.findSerializationConverter(m);
                if (convDef != null) {
                     Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);
                     JavaType delegateType = conv.getOutputType(provider.getTypeFactory());
                     // [databind#731]: Should skip if nominally java.lang.Object
                     JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);
                     return new StdDelegatingSerializer(conv, delegateType, ser);
                 }
             }
        }
        return null;
    }"
JacksonDatabind_15,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_15_buggy/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java,"@Override
    @SuppressWarnings(""unchecked"")
    public JsonSerializer<Object> createSerializer(SerializerProvider prov,
            JavaType origType)
        throws JsonMappingException
    {
        // Very first thing, let's check if there is explicit serializer annotation:
        final SerializationConfig config = prov.getConfig();
        BeanDescription beanDesc = config.introspect(origType);
        JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());
        if (ser != null) {
            return (JsonSerializer<Object>) ser;
        }
        boolean staticTyping;
        // Next: we may have annotations that further define types to use...
        JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);
        if (type == origType) { // no changes, won't force static typing
            staticTyping = false;
        } else { // changes; assume static typing; plus, need to re-introspect if class differs
            staticTyping = true;
            if (!type.hasRawClass(origType.getRawClass())) {
                beanDesc = config.introspect(type);
            }
        }
        // Slight detour: do we have a Converter to consider?
        Converter<Object,Object> conv = beanDesc.findSerializationConverter();
        if (conv == null) { // no, simple
            return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);
        }
        JavaType delegateType = conv.getOutputType(prov.getTypeFactory());
        
        // One more twist, as per [Issue#288]; probably need to get new BeanDesc
        if (!delegateType.hasRawClass(type.getRawClass())) {
            beanDesc = config.introspect(delegateType);
            // [#359]: explicitly check (again) for @JsonSerializer...
             ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());
         }
         // [databind#731]: Should skip if nominally java.lang.Object
         if (ser == null) {
             ser = _createSerializer2(prov, delegateType, beanDesc, true);
         }
         return new StdDelegatingSerializer(conv, delegateType, ser);
    }"
JacksonDatabind_15,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_15_buggy/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java,"@Override
    public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property)
        throws JsonMappingException
    {
        JsonSerializer<?> delSer = _delegateSerializer;
        JavaType delegateType = _delegateType;

        if (delSer == null) {
            // Otherwise, need to locate serializer to delegate to. For that we need type information...
            if (delegateType == null) {
                delegateType = _converter.getOutputType(provider.getTypeFactory());
            }
             /* 02-Apr-2015, tatu: For ""dynamic case"", where type is only specified as
              *    java.lang.Object (or missing generic), [databind#731]
              */
                 delSer = provider.findValueSerializer(delegateType);
         }
         if (delSer instanceof ContextualSerializer) {
             delSer = provider.handleSecondaryContextualization(delSer, property);
         }
         return (delSer == _delegateSerializer) ? this
                 : withDelegate(_converter, delegateType, delSer);
     }"
JacksonDatabind_15,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_15_buggy/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java,"@Override
    public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException
    {
        Object delegateValue = convertValue(value);
        // should we accept nulls?
        if (delegateValue == null) {
            provider.defaultSerializeNull(gen);
             return;
         }
         // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup
         _delegateSerializer.serialize(delegateValue, gen, provider);
     }"
JacksonDatabind_15,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_15_buggy/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java,"@Override
    public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider,
            TypeSerializer typeSer) throws IOException
    {
        /* 03-Oct-2012, tatu: This is actually unlikely to work ok... but for now,
          *    let's give it a chance?
          */
         Object delegateValue = convertValue(value);
         _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);
     }"
JacksonDatabind_15,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_15_buggy/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java,"@Override
    @Deprecated // since 2.5
     public boolean isEmpty(Object value)
     {
         Object delegateValue = convertValue(value);
         return _delegateSerializer.isEmpty(delegateValue);
     }"
JacksonDatabind_15,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_15_buggy/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java,"@Override
     public boolean isEmpty(SerializerProvider prov, Object value)
     {
         Object delegateValue = convertValue(value);
         return _delegateSerializer.isEmpty(prov, delegateValue);
     }"
JacksonDatabind_15,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_15_buggy/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java,"@Override
    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)
        throws JsonMappingException
    {
        /* 03-Sep-2012, tatu: Not sure if this can be made to really work
          *    properly... but for now, try this:
          */
         // 02-Apr-2015, tatu: For dynamic case, very little we can do
         _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);
     }"
JacksonDatabind_15,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_15_buggy/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java,"protected JsonSerializer<?> findConvertingContentSerializer(SerializerProvider provider,
            BeanProperty prop, JsonSerializer<?> existingSerializer)
        throws JsonMappingException
    {
        /* 19-Oct-2014, tatu: As per [databind#357], need to avoid infinite loop
         *   when applying contextual content converter; this is not ideal way,
         *   but should work for most cases.
         */
        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();
        if (intr != null && prop != null) {
            AnnotatedMember m = prop.getMember();
            if (m != null) {
                Object convDef = intr.findSerializationContentConverter(m);
                if (convDef != null) {
                     Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);
                     JavaType delegateType = conv.getOutputType(provider.getTypeFactory());
                     // [databind#731]: Should skip if nominally java.lang.Object
                     if (existingSerializer == null) {
                         existingSerializer = provider.findValueSerializer(delegateType);
                     }
                     return new StdDelegatingSerializer(conv, delegateType, existingSerializer);
                }
            }
        }
        return existingSerializer;
    }"
JacksonDatabind_18,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_18_buggy/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java,"public boolean hasNextValue() throws IOException
     {
         if (_parser == null) {
             return false;
             // fall-through
         }
         if (!_hasNextChecked) {
             JsonToken t = _parser.getCurrentToken();
             _hasNextChecked = true;
             if (t == null) { // un-initialized or cleared; find next
                 t = _parser.nextToken();
                 // If EOF, no more, or if we hit END_ARRAY (although we don't clear the token).
                 if (t == null || t == JsonToken.END_ARRAY) {
                     JsonParser jp = _parser;
                     _parser = null;
                     if (_closeParser) {
                         jp.close();
                     }
                     return false;
                 }
             }
             // fall through
         }
         return true;
    }"
JacksonDatabind_18,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_18_buggy/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java,"public T nextValue() throws IOException
     {
         if (!_hasNextChecked) {
             if (!hasNextValue()) {
                 return _throwNoSuchElement();
             }
         }
         if (_parser == null) {
             return _throwNoSuchElement();
         }
         _hasNextChecked = false;
 
         try {
             T value;
             if (_updatedValue == null) {
                value = _deserializer.deserialize(_parser, _context);
            } else{
                _deserializer.deserialize(_parser, _context, _updatedValue);
                value = _updatedValue;
            }
            return value;
        } finally {
            /* 24-Mar-2015, tatu: As per [#733], need to mark token consumed no
             *   matter what, to avoid infinite loop for certain failure cases.
             *   For 2.6 need to improve further.
             */
            _parser.clearCurrentToken();
        }
    }"
JacksonDatabind_20,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_20_buggy/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java,"    public JsonNode setAll(Map<String,? extends JsonNode> properties)
    {
        for (Map.Entry<String,? extends JsonNode> en : properties.entrySet()) {
            JsonNode n = en.getValue();
            if (n == null) {
                n = nullNode();
            }
            _children.put(en.getKey(), n);
        }
        return this;
    }
"
JacksonDatabind_21,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_21_buggy/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java,"    public PropertyName findRootName(AnnotatedClass ac)
    {
        JsonRootName ann = _findAnnotation(ac, JsonRootName.class);
        if (ann == null) {
            return null;
        }
        String ns = ann.namespace();
        if (ns != null && ns.length() == 0) {
            ns = null;
        }
        return PropertyName.construct(ann.value(), ns);
    }
"
JacksonDatabind_22,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_22_buggy/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java,"protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov,
            JavaType type, BeanDescription beanDesc, boolean staticTyping)
        throws JsonMappingException
    {
        final SerializationConfig config = prov.getConfig();

        /* [databind#23], 15-Mar-2013, tatu: must force static handling of root value type,
         *   with just one important exception: if value type is ""untyped"", let's
         *   leave it as is; no clean way to make it work.
         */
        if (!staticTyping && type.useStaticType()) {
            if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) {
                staticTyping = true;
            }
        }
        
        // Let's see what we can learn about element/content/value type, type serializer for it:
        JavaType elementType = type.getContentType();
        TypeSerializer elementTypeSerializer = createTypeSerializer(config,
                elementType);

        // if elements have type serializer, can not force static typing:
        if (elementTypeSerializer != null) {
            staticTyping = false;
        }
        JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov,
                beanDesc.getClassInfo());
        if (type.isMapLikeType()) { // implements java.util.Map
            MapLikeType mlt = (MapLikeType) type;
            /* 29-Sep-2012, tatu: This is actually too early to (try to) find
             *  key serializer from property annotations, and can lead to caching
             *  issues (see [databind#75]). Instead, must be done from 'createContextual()' call.
             *  But we do need to check class annotations.
              */
             JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo());
             if (mlt.isTrueMapType()) {
                 return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping,
                         keySerializer, elementTypeSerializer, elementValueSerializer);
             }
             // With Map-like, just 2 options: (1) Custom, (2) Annotations
             JsonSerializer<?> ser = null;
             for (Serializers serializers : customSerializers()) { // (1) Custom
                 MapLikeType mlType = (MapLikeType) type;
                 ser = serializers.findMapLikeSerializer(config,
                         mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);
             if (ser != null) {
                 if (_factoryConfig.hasSerializerModifiers()) {
                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                         ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser);
                     }
                     }
                     return ser;
                 }
             }
             return null;
         }
         if (type.isCollectionLikeType()) {
             CollectionLikeType clt = (CollectionLikeType) type;
             if (clt.isTrueCollectionType()) {
                 return buildCollectionSerializer(config,  (CollectionType) clt, beanDesc, staticTyping,
                         elementTypeSerializer, elementValueSerializer);
             }
             // With Map-like, just 2 options: (1) Custom, (2) Annotations
            JsonSerializer<?> ser = null;
            CollectionLikeType clType = (CollectionLikeType) type;
            for (Serializers serializers : customSerializers()) { // (1) Custom
                ser = serializers.findCollectionLikeSerializer(config,
                        clType, beanDesc, elementTypeSerializer, elementValueSerializer);
            if (ser != null) {
                if (_factoryConfig.hasSerializerModifiers()) {
                    for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                        ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser);
                        }
                    }
                    return ser;
                }
            }
            return null;
        }
        if (type.isArrayType()) {
            return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping,
                    elementTypeSerializer, elementValueSerializer);
        }
        return null;
    }"
JacksonDatabind_22,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_22_buggy/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java,"protected JsonSerializer<?> buildMapSerializer(SerializationConfig config,
            MapType type, BeanDescription beanDesc,
            boolean staticTyping, JsonSerializer<Object> keySerializer,
            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)
        throws JsonMappingException
    {
        JsonSerializer<?> ser = null;

        // Order of lookups:
        // 1. Custom serializers
        // 2. Annotations (@JsonValue, @JsonDeserialize)
        // 3. Defaults
        
        for (Serializers serializers : customSerializers()) { // (1) Custom
            ser = serializers.findMapSerializer(config, type, beanDesc,
                    keySerializer, elementTypeSerializer, elementValueSerializer);
             if (ser != null) { break; }
         }
         if (ser == null) {
                 // 08-Nov-2014, tatu: As per [databind#601], better just use default Map serializer
                 /*
                 if (EnumMap.class.isAssignableFrom(type.getRawClass())
                        && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) {
                    JavaType keyType = type.getKeyType();
                    // Need to find key enum values...
                    EnumValues enums = null;
                    if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance)
                        @SuppressWarnings(""unchecked"")
                        Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass();
                        enums = EnumValues.construct(config, enumClass);
                    }
                    ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums,
                        elementTypeSerializer, elementValueSerializer);
                } else {
                */
                Object filterId = findFilterId(config, beanDesc);
                AnnotationIntrospector ai = config.getAnnotationIntrospector();
                MapSerializer mapSer = MapSerializer.construct(ai.findPropertiesToIgnore(beanDesc.getClassInfo(), true),
                        type, staticTyping, elementTypeSerializer,
                        keySerializer, elementValueSerializer, filterId);
                Object suppressableValue = findSuppressableContentValue(config,
                        type.getContentType(), beanDesc);
                if (suppressableValue != null) {
                    mapSer = mapSer.withContentInclusion(suppressableValue);
                }
                ser = mapSer;
            }
        // [databind#120]: Allow post-processing
        if (_factoryConfig.hasSerializerModifiers()) {
            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                ser = mod.modifyMapSerializer(config, type, beanDesc, ser);
            }
        }
        return ser;
    }"
JacksonDatabind_22,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_22_buggy/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java,"protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config,
            CollectionType type, BeanDescription beanDesc, boolean staticTyping,
            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) 
        throws JsonMappingException
    {
        JsonSerializer<?> ser = null;
        // Order of lookups:
        // 1. Custom serializers
        // 2. Annotations (@JsonValue, @JsonDeserialize)
        // 3. Defaults
        for (Serializers serializers : customSerializers()) { // (1) Custom
            ser = serializers.findCollectionSerializer(config,
                    type, beanDesc, elementTypeSerializer, elementValueSerializer);
            if (ser != null) {
                break;
            }
         }
 
         if (ser == null) {
                 // We may also want to use serialize Collections ""as beans"", if (and only if)
                 // this is specified with `@JsonFormat(shape=Object)`
                 JsonFormat.Value format = beanDesc.findExpectedFormat(null);
                if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {
                    return null;
                }
                Class<?> raw = type.getRawClass();
                if (EnumSet.class.isAssignableFrom(raw)) {
                    // this may or may not be available (Class doesn't; type of field/method does)
                    JavaType enumType = type.getContentType();
                    // and even if nominally there is something, only use if it really is enum
                    if (!enumType.isEnumType()) {
                        enumType = null;
                    }
                    ser = buildEnumSetSerializer(enumType);
                } else {
                    Class<?> elementRaw = type.getContentType().getRawClass();
                    if (isIndexedList(raw)) {
                        if (elementRaw == String.class) {
                            // [JACKSON-829] Must NOT use if we have custom serializer
                            if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {
                                ser = IndexedStringListSerializer.instance;
                            }
                        } else {
                            ser = buildIndexedListSerializer(type.getContentType(), staticTyping,
                                elementTypeSerializer, elementValueSerializer);
                        }
                    } else if (elementRaw == String.class) {
                        // [JACKSON-829] Must NOT use if we have custom serializer
                        if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {
                            ser = StringCollectionSerializer.instance;
                        }
                    }
                    if (ser == null) {
                        ser = buildCollectionSerializer(type.getContentType(), staticTyping,
                                elementTypeSerializer, elementValueSerializer);
                }
            }
        }
        // [databind#120]: Allow post-processing
        if (_factoryConfig.hasSerializerModifiers()) {
            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser);
            }
        }
        return ser;
    }"
JacksonDatabind_22,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_22_buggy/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java,"protected JsonSerializer<?> buildArraySerializer(SerializationConfig config,
            ArrayType type, BeanDescription beanDesc,
            boolean staticTyping,
            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)
        throws JsonMappingException
    {
        // 25-Jun-2015, tatu: Note that unlike with Collection(Like) and Map(Like) types, array
         //   types can not be annotated (in theory I guess we could have mix-ins but... ?)
         //   so we need not do primary annotation lookup here.
         //   So all we need is (1) Custom, (2) Default array serializers
         JsonSerializer<?> ser = null;
 
         for (Serializers serializers : customSerializers()) { // (1) Custom
             ser = serializers.findArraySerializer(config,
                     type, beanDesc, elementTypeSerializer, elementValueSerializer);
             if (ser != null) {
                 break;
             }
        }
        
        if (ser == null) {
             Class<?> raw = type.getRawClass();
             // Important: do NOT use standard serializers if non-standard element value serializer specified
             if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {
                 if (String[].class == raw) {
                     ser = StringArraySerializer.instance;
                 } else {
                     // other standard types?
                     ser = StdArraySerializers.findStandardImpl(raw);
                 }
             }
             if (ser == null) {
                 ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer,
                         elementValueSerializer);
             }
         }
         // [databind#120]: Allow post-processing
         if (_factoryConfig.hasSerializerModifiers()) {
             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                 ser = mod.modifyArraySerializer(config, type, beanDesc, ser);
             }
         }
         return ser;
    }"
JacksonDatabind_22,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_22_buggy/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java,"protected JsonSerializer<?> _createSerializer2(SerializerProvider prov,
             JavaType type, BeanDescription beanDesc, boolean staticTyping)
         throws JsonMappingException
     {
         JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc);
         if (ser != null) {
             return ser;
         }
         final SerializationConfig config = prov.getConfig();
         
         // Container types differ from non-container types
        // (note: called method checks for module-provided serializers)
        if (type.isContainerType()) {
            if (!staticTyping) {
                staticTyping = usesStaticTyping(config, beanDesc, null);
                // [Issue#23]: Need to figure out how to force passed parameterization
                //  to stick...
                /*
                if (property == null) {
                    JavaType t = origType.getContentType();
                    if (t != null && !t.hasRawClass(Object.class)) {
                        staticTyping = true;
                    }
                }
                */
            }
            // 03-Aug-2012, tatu: As per [Issue#40], may require POJO serializer...
            ser =  buildContainerSerializer(prov, type, beanDesc, staticTyping);
            // Will return right away, since called method does post-processing:
            if (ser != null) {
                return ser;
            }
        } else {
            // Modules may provide serializers of POJO types:
            for (Serializers serializers : customSerializers()) {
                ser = serializers.findSerializer(config, type, beanDesc);
                if (ser != null) {
                    break;
                }
            }
            // 25-Jun-2015, tatu: Then JsonSerializable, @JsonValue etc. NOTE! Prior to 2.6,
            //    this call was BEFORE custom serializer lookup, which was wrong.
        }
        
        if (ser == null) {
            // Otherwise, we will check ""primary types""; both marker types that
            // indicate specific handling (JsonSerializable), or main types that have
            // precedence over container types
            ser = findSerializerByLookup(type, config, beanDesc, staticTyping);
            if (ser == null) {
                ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);
                if (ser == null) {
                    // And this is where this class comes in: if type is not a
                    // known ""primary JDK type"", perhaps it's a bean? We can still
                    // get a null, if we can't find a single suitable bean property.
                    ser = findBeanSerializer(prov, type, beanDesc);
                    // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?
                    if (ser == null) {
                        ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);
                        // 18-Sep-2014, tatu: Actually, as per [jackson-databind#539], need to get
                        //   'unknown' serializer assigned earlier, here, so that it gets properly
                        //   post-processed
                        if (ser == null) {
                            ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());
                        }
                    }
                }
            }
        }
        if (ser != null) {
            // [databind#120]: Allow post-processing
            if (_factoryConfig.hasSerializerModifiers()) {
                for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {
                    ser = mod.modifySerializer(config, beanDesc, ser);
                }
            }
        }
        return ser;
    }"
JacksonDatabind_23,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_23_buggy/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java,"        final static DoubleSerializer instance = new DoubleSerializer();
    
        public DoubleSerializer() { super(Double.class, JsonParser.NumberType.DOUBLE, ""number""); }
"
JacksonDatabind_23,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_23_buggy/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java,"        public IntLikeSerializer() {
            super(Number.class, JsonParser.NumberType.INT, ""integer"");
        }
"
JacksonDatabind_23,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_23_buggy/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java,"        public void serialize(Number value, JsonGenerator gen, SerializerProvider provider) throws IOException {
            gen.writeNumber(value.intValue());
        }
"
JacksonDatabind_23,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_23_buggy/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java,"        protected Base(Class<?> cls, JsonParser.NumberType numberType, String schemaType) {
            super(cls, false);
            _numberType = numberType;
            _schemaType = schemaType;
            _isInt = (numberType == JsonParser.NumberType.INT)
                    || (numberType == JsonParser.NumberType.LONG)
                    || (numberType == JsonParser.NumberType.BIG_INTEGER)
                    ;
        }
"
JacksonDatabind_23,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_23_buggy/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java,"        final static ShortSerializer instance = new ShortSerializer();

        public ShortSerializer() { super(Short.class, JsonParser.NumberType.INT, ""number""); }
"
JacksonDatabind_23,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_23_buggy/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java,"        public void serializeWithType(Object value, JsonGenerator gen,
                SerializerProvider provider, TypeSerializer typeSer) throws IOException {
            // no type info, just regular serialization
            serialize(value, gen, provider);            
        }
"
JacksonDatabind_23,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_23_buggy/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java,"        public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {
            gen.writeNumber(((Long) value).longValue());
        }
"
JacksonDatabind_25,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_25_buggy/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java,"@SuppressWarnings({ ""unchecked"" })
    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,
            Annotated a, T type)
        throws JsonMappingException
    {
        // first: let's check class for the instance itself:
        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();
         Class<?> subclass = intr.findDeserializationType(a, type);
         if (subclass != null) {
             try {
                 type = (T) type.narrowBy(subclass);
             } catch (IllegalArgumentException iae) {
                 throw new JsonMappingException(""Failed to narrow type ""+type+"" with concrete-type annotation (value ""+subclass.getName()+""), method '""+a.getName()+""': ""+iae.getMessage(), null, iae);
             }
        }

        // then key class
        if (type.isContainerType()) {
            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());
            if (keyClass != null) {
                // illegal to use on non-Maps
                if (!(type instanceof MapLikeType)) {
                    throw new JsonMappingException(""Illegal key-type annotation: type ""+type+"" is not a Map(-like) type"");
                }
                try {
                    type = (T) ((MapLikeType) type).narrowKey(keyClass);
                } catch (IllegalArgumentException iae) {
                    throw new JsonMappingException(""Failed to narrow key type ""+type+"" with key-type annotation (""+keyClass.getName()+""): ""+iae.getMessage(), null, iae);
                }
            }
            JavaType keyType = type.getKeyType();
            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)
             *   (not 100% why or how, but this does seem to get called more than once, which
             *   is not good: for now, let's just avoid errors)
             */
            if (keyType != null && keyType.getValueHandler() == null) {
                Object kdDef = intr.findKeyDeserializer(a);
                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);
                if (kd != null) {
                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);
                    keyType = type.getKeyType(); // just in case it's used below
                }
            }            
           
           // and finally content class; only applicable to structured types
           Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());
           if (cc != null) {
               try {
                   type = (T) type.narrowContentsBy(cc);
               } catch (IllegalArgumentException iae) {
                   throw new JsonMappingException(""Failed to narrow content type ""+type+"" with content-type annotation (""+cc.getName()+""): ""+iae.getMessage(), null, iae);
               }
           }
           // ... as well as deserializer for contents:
           JavaType contentType = type.getContentType();
           if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)
               Object cdDef = intr.findContentDeserializer(a);
                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);
                if (cd != null) {
                    type = (T) type.withContentValueHandler(cd);
                }
            }
        }
        return type;
    }"
JacksonDatabind_25,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_25_buggy/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java,"protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,
            String typeId) throws IOException
    {
        JsonDeserializer<Object> deser = _deserializers.get(typeId);
        if (deser == null) {
            /* As per [Databind#305], need to provide contextual info. But for
             * backwards compatibility, let's start by only supporting this
             * for base class, not via interface. Later on we can add this
             * to the interface, assuming deprecation at base class helps.
             */
            JavaType type = _idResolver.typeFromId(ctxt, typeId);
            if (type == null) {
                // As per [JACKSON-614], use the default impl if no type id available:
                deser = _findDefaultImplDeserializer(ctxt);
                if (deser == null) {
                    deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);
                }
            } else {
                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,
                 *   we actually now need to explicitly narrow from base type (which may have parameterization)
                 *   using raw type.
                 *
                 *   One complication, though; can not change 'type class' (simple type to container); otherwise
                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual
                 *   type in process (getting SimpleType of Map.class which will not work as expected)
                 */
                if ((_baseType != null)
                        && _baseType.getClass() == type.getClass()) {
                    /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;
                     *   but it appears to check that JavaType impl class is the same which is
                      *   important for some reason?
                      *   Disabling the check will break 2 Enum-related tests.
                      */
                     type = _baseType.narrowBy(type.getRawClass());
                 }
                 deser = ctxt.findContextualValueDeserializer(type, _property);
             }
            _deserializers.put(typeId, deser);
        }
        return deser;
    }"
JacksonDatabind_25,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_25_buggy/src/main/java/com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java,"@Override
    public JavaType findTypeMapping(DeserializationConfig config, JavaType type)
    {
        // this is the main mapping base, so let's 
        Class<?> src = type.getRawClass();
        Class<?> dst = _mappings.get(new ClassKey(src));
        if (dst == null) {
             return null;
         }
         // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory
         return type.narrowBy(dst);
     }"
JacksonDatabind_25,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_25_buggy/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java,"private JavaType modifyTypeByAnnotation(DeserializationContext ctxt,
            Annotated a, JavaType type)
        throws JsonMappingException
    {
        // first: let's check class for the instance itself:
        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();
         Class<?> subclass = intr.findDeserializationType(a, type);
         if (subclass != null) {
             try {
                 type = type.narrowBy(subclass);
             } catch (IllegalArgumentException iae) {
                 throw new JsonMappingException(""Failed to narrow type ""+type+"" with concrete-type annotation (value ""+subclass.getName()+""), method '""+a.getName()+""': ""+iae.getMessage(), null, iae);
             }
        }

        // then key class
        if (type.isContainerType()) {
            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());
            if (keyClass != null) {
                // illegal to use on non-Maps
                if (!(type instanceof MapLikeType)) {
                    throw new JsonMappingException(""Illegal key-type annotation: type ""+type+"" is not a Map(-like) type"");
                }
                try {
                    type = ((MapLikeType) type).narrowKey(keyClass);
                } catch (IllegalArgumentException iae) {
                    throw new JsonMappingException(""Failed to narrow key type ""+type+"" with key-type annotation (""+keyClass.getName()+""): ""+iae.getMessage(), null, iae);
                }
            }
            JavaType keyType = type.getKeyType();
            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)
             *   (not 100% why or how, but this does seem to get called more than once, which
             *   is not good: for now, let's just avoid errors)
             */
            if (keyType != null && keyType.getValueHandler() == null) {
                Object kdDef = intr.findKeyDeserializer(a);
                if (kdDef != null) {
                    KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);
                    if (kd != null) {
                        type = ((MapLikeType) type).withKeyValueHandler(kd);
                        keyType = type.getKeyType(); // just in case it's used below
                    }
                }
            }            
            
            // and finally content class; only applicable to structured types
            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());
            if (cc != null) {
                try {
                    type = type.narrowContentsBy(cc);
                } catch (IllegalArgumentException iae) {
                    throw new JsonMappingException(""Failed to narrow content type ""+type+"" with content-type annotation (""+cc.getName()+""): ""+iae.getMessage(), null, iae);
                }
            }
            // ... as well as deserializer for contents:
            JavaType contentType = type.getContentType();
            if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)
                Object cdDef = intr.findContentDeserializer(a);
                if (cdDef != null) {
                    JsonDeserializer<?> cd = null;
                    if (cdDef instanceof JsonDeserializer<?>) {
                        cdDef = (JsonDeserializer<?>) cdDef;
                    } else {
                        Class<?> cdClass = _verifyAsClass(cdDef, ""findContentDeserializer"", JsonDeserializer.None.class);
                        if (cdClass != null) {
                            cd = ctxt.deserializerInstance(a, cdClass);
                        }
                    }
                    if (cd != null) {
                        type = type.withContentValueHandler(cd);
                    }
                }
            }
        }
        return type;
    }"
JacksonDatabind_26,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_26_buggy/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java,"public class BeanPropertyWriter extends PropertyWriter
    implements BeanProperty
{
    // as of 2.6.2

    /**
     * Marker object used to indicate ""do not serialize if empty""
     */
    public final static Object MARKER_FOR_EMPTY = JsonInclude.Include.NON_EMPTY;

    /**
     * Marker we use to indicate case where we have done format lookup,
     * but found nothing; marker used to avoid having to repeat such lookups.
     *
     * @since 2.6
     */
    protected final static JsonFormat.Value NO_FORMAT = new JsonFormat.Value();
"
JacksonDatabind_29,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_29_buggy/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java,"@SuppressWarnings(""resource"")
    protected final Object _deserialize(JsonParser p, DeserializationContext ctxt,
            int index, String typeId) throws IOException
    {
         JsonParser p2 = _tokens[index].asParser(p);
         JsonToken t = p2.nextToken();
         // 29-Sep-2015, tatu: As per [databind#942], nulls need special support
 
         TokenBuffer merged = new TokenBuffer(p);
         merged.writeStartArray();
        merged.writeString(typeId);
        merged.copyCurrentStructure(p2);
        merged.writeEndArray();

        // needs to point to START_OBJECT (or whatever first token is)
        JsonParser mp = merged.asParser(p);
        mp.nextToken();
        return _properties[index].getProperty().deserialize(mp, ctxt);
    }"
JacksonDatabind_29,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_29_buggy/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java,"@SuppressWarnings(""resource"")
    protected final void _deserializeAndSet(JsonParser p, DeserializationContext ctxt,
            Object bean, int index, String typeId) throws IOException
    {
        /* Ok: time to mix type id, value; and we will actually use ""wrapper-array""
         * style to ensure we can handle all kinds of JSON constructs.
         */
         JsonParser p2 = _tokens[index].asParser(p);
         JsonToken t = p2.nextToken();
         // 29-Sep-2015, tatu: As per [databind#942], nulls need special support
         TokenBuffer merged = new TokenBuffer(p);
         merged.writeStartArray();
         merged.writeString(typeId);
        
        merged.copyCurrentStructure(p2);
        merged.writeEndArray();
        // needs to point to START_OBJECT (or whatever first token is)
        JsonParser mp = merged.asParser(p);
        mp.nextToken();
        _properties[index].getProperty().deserializeAndSet(mp, ctxt, bean);
    }"
JacksonDatabind_30,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_30_buggy/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"@SuppressWarnings(""resource"")
    protected Object _convert(Object fromValue, JavaType toValueType)
        throws IllegalArgumentException
    {        
        // also, as per [Issue-11], consider case for simple cast
        /* But with caveats: one is that while everything is Object.class, we don't
         * want to ""optimize"" that out; and the other is that we also do not want
         * to lose conversions of generic types.
         */
        Class<?> targetType = toValueType.getRawClass();
        if (targetType != Object.class
                && !toValueType.hasGenericTypes()
                && targetType.isAssignableFrom(fromValue.getClass())) {
            return fromValue;
        }
         
         // Then use TokenBuffer, which is a JsonGenerator:
         TokenBuffer buf = new TokenBuffer(this, false);
         try {
             // inlined 'writeValue' with minor changes:
             // first: disable wrapping when writing
            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);
            // no need to check for closing of TokenBuffer
            _serializerProvider(config).serializeValue(buf, fromValue);

            // then matching read, inlined 'readValue' with minor mods:
            final JsonParser jp = buf.asParser();
            Object result;
            // ok to pass in existing feature flags; unwrapping handled by mapper
            final DeserializationConfig deserConfig = getDeserializationConfig();
            JsonToken t = _initForReading(jp);
            if (t == JsonToken.VALUE_NULL) {
                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);
                result = _findRootDeserializer(ctxt, toValueType).getNullValue(ctxt);
            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {
                result = null;
            } else { // pointing to event other than null
                DeserializationContext ctxt = createDeserializationContext(jp, deserConfig);
                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, toValueType);
                // note: no handling of unwarpping
                result = deser.deserialize(jp, ctxt);
            }
            jp.close();
            return result;
        } catch (IOException e) { // should not occur, no real i/o...
            throw new IllegalArgumentException(e.getMessage(), e);
        }
    }"
JacksonDatabind_30,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_30_buggy/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"@SuppressWarnings({ ""unchecked"", ""resource"" })
    public <T extends JsonNode> T valueToTree(Object fromValue)
        throws IllegalArgumentException
     {
         if (fromValue == null) return null;
         TokenBuffer buf = new TokenBuffer(this, false);
         JsonNode result;
         try {
             writeValue(buf, fromValue);
            JsonParser jp = buf.asParser();
            result = readTree(jp);
            jp.close();
        } catch (IOException e) { // should not occur, no real i/o...
            throw new IllegalArgumentException(e.getMessage(), e);
        }
        return (T) result;
    }"
JacksonDatabind_30,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_30_buggy/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java,"@Override
    public void copyCurrentEvent(JsonParser p) throws IOException
    {
        if (_mayHaveNativeIds) {
            _checkNativeIds(p);
        }
        switch (p.getCurrentToken()) {
        case START_OBJECT:
            writeStartObject();
            break;
        case END_OBJECT:
            writeEndObject();
            break;
        case START_ARRAY:
            writeStartArray();
            break;
        case END_ARRAY:
            writeEndArray();
            break;
        case FIELD_NAME:
            writeFieldName(p.getCurrentName());
            break;
        case VALUE_STRING:
            if (p.hasTextCharacters()) {
                writeString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());
            } else {
                writeString(p.getText());
            }
            break;
        case VALUE_NUMBER_INT:
            switch (p.getNumberType()) {
            case INT:
                writeNumber(p.getIntValue());
                break;
            case BIG_INTEGER:
                writeNumber(p.getBigIntegerValue());
                break;
            default:
                writeNumber(p.getLongValue());
             }
             break;
         case VALUE_NUMBER_FLOAT:
                 /* 10-Oct-2015, tatu: Ideally we would first determine whether underlying
                  *   number is already decoded into a number (in which case might as well
                  *   access as number); or is still retained as text (in which case we
                  *   should further defer decoding that may not need BigDecimal):
                  */
                 switch (p.getNumberType()) {
                 case BIG_DECIMAL:
                     writeNumber(p.getDecimalValue());
                    break;
                case FLOAT:
                    writeNumber(p.getFloatValue());
                    break;
                default:
                    writeNumber(p.getDoubleValue());
            }
            break;
        case VALUE_TRUE:
            writeBoolean(true);
            break;
        case VALUE_FALSE:
            writeBoolean(false);
            break;
        case VALUE_NULL:
            writeNull();
            break;
        case VALUE_EMBEDDED_OBJECT:
            writeObject(p.getEmbeddedObject());
            break;
        default:
            throw new RuntimeException(""Internal error: should never end up through this code path"");
        }
    }"
JacksonDatabind_31,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_31_buggy/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java,"@Override
    public void writeString(SerializableString text) throws IOException {
         if (text == null) {
             writeNull();
         } else {
             _append(JsonToken.VALUE_STRING, text);
         }
     }"
JacksonDatabind_31,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_31_buggy/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java,"@Override
    public void writeObject(Object value) throws IOException
    {
        if (value == null) {
            writeNull();
            return;
        }
        Class<?> raw = value.getClass();
        if (raw == byte[].class || (value instanceof RawValue)) {
            _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);
            return;
        }
        if (_objectCodec == null) {
            /* 28-May-2014, tatu: Tricky choice here; if no codec, should we
              *   err out, or just embed? For now, do latter.
              */
 //          throw new JsonMappingException(""No ObjectCodec configured for TokenBuffer, writeObject() called"");
             _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);
         } else {
             _objectCodec.writeValue(this, value);
         }
    }"
JacksonDatabind_31,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_31_buggy/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java,"@Override
    public void writeTree(TreeNode node) throws IOException
    {
        if (node == null) {
            writeNull();
            return;
        }
 
         if (_objectCodec == null) {
             // as with 'writeObject()', is codec optional?
             _append(JsonToken.VALUE_EMBEDDED_OBJECT, node);
         } else {
             _objectCodec.writeTree(this, node);
         }
    }"
JacksonDatabind_31,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_31_buggy/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java,"@Override
    public void writeString(String text) throws IOException {
         if (text == null) {
             writeNull();
         } else {
             _append(JsonToken.VALUE_STRING, text);
         }
     }"
JacksonDatabind_31,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_31_buggy/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java,"@Override
    public void writeNumber(BigDecimal dec) throws IOException {
         if (dec == null) {
             writeNull();
         } else {
             _append(JsonToken.VALUE_NUMBER_FLOAT, dec);
         }
     }"
JacksonDatabind_31,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_31_buggy/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java,"@Override
    public void writeNumber(BigInteger v) throws IOException {
         if (v == null) {
             writeNull();
         } else {
             _append(JsonToken.VALUE_NUMBER_INT, v);
         }
     }"
JacksonDatabind_32,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_32_buggy/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java,"@Override
        public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
        {
            switch (p.getCurrentTokenId()) {
            case JsonTokenId.ID_START_OBJECT:
                {
                    JsonToken t = p.nextToken();
                    if (t == JsonToken.END_OBJECT) {
                        return new LinkedHashMap<String,Object>(2);
                    }
                }
            case JsonTokenId.ID_FIELD_NAME:
                return mapObject(p, ctxt);
            case JsonTokenId.ID_START_ARRAY:
                {
                    JsonToken t = p.nextToken();
                    if (t == JsonToken.END_ARRAY) { // and empty one too
                        if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {
                            return NO_OBJECTS;
                        }
                        return new ArrayList<Object>(2);
                    }
                }
                if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {
                    return mapArrayToArray(p, ctxt);
                }
                return mapArray(p, ctxt);
            case JsonTokenId.ID_EMBEDDED_OBJECT:
                return p.getEmbeddedObject();
            case JsonTokenId.ID_STRING:
                return p.getText();

            case JsonTokenId.ID_NUMBER_INT:
                if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {
                    return _coerceIntegral(p, ctxt);
                }
                return p.getNumberValue(); // should be optimal, whatever it is

            case JsonTokenId.ID_NUMBER_FLOAT:
                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
                    return p.getDecimalValue();
                }
                return Double.valueOf(p.getDoubleValue());

            case JsonTokenId.ID_TRUE:
                return Boolean.TRUE;
            case JsonTokenId.ID_FALSE:
                return Boolean.FALSE;

             case JsonTokenId.ID_NULL: // should not get this but...
                 return null;
 
                 // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),
                 //    if caller has advanced to the first token of Object, but for empty Object
 
             //case JsonTokenId.ID_END_ARRAY: // invalid
             default:
                throw ctxt.mappingException(Object.class);
            }
        }"
JacksonDatabind_32,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_32_buggy/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java,"@Override
    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
    {
        switch (p.getCurrentTokenId()) {
        case JsonTokenId.ID_START_OBJECT:
         case JsonTokenId.ID_FIELD_NAME:
             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),
             //    if caller has advanced to the first token of Object, but for empty Object
             if (_mapDeserializer != null) {
                 return _mapDeserializer.deserialize(p, ctxt);
             }
            return mapObject(p, ctxt);
        case JsonTokenId.ID_START_ARRAY:
            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {
                return mapArrayToArray(p, ctxt);
            }
            if (_listDeserializer != null) {
                return _listDeserializer.deserialize(p, ctxt);
            }
            return mapArray(p, ctxt);
        case JsonTokenId.ID_EMBEDDED_OBJECT:
            return p.getEmbeddedObject();
        case JsonTokenId.ID_STRING:
            if (_stringDeserializer != null) {
                return _stringDeserializer.deserialize(p, ctxt);
            }
            return p.getText();

        case JsonTokenId.ID_NUMBER_INT:
            if (_numberDeserializer != null) {
                return _numberDeserializer.deserialize(p, ctxt);
            }
            /* Caller may want to get all integral values returned as {@link java.math.BigInteger},
             * or {@link java.lang.Long} for consistency
             */
            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {
                return _coerceIntegral(p, ctxt);
            }
            return p.getNumberValue(); // should be optimal, whatever it is

        case JsonTokenId.ID_NUMBER_FLOAT:
            if (_numberDeserializer != null) {
                return _numberDeserializer.deserialize(p, ctxt);
            }
            /* [JACKSON-72]: need to allow overriding the behavior regarding
             *   which type to use
             */
            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {
                return p.getDecimalValue();
            }
            return p.getDoubleValue();

        case JsonTokenId.ID_TRUE:
            return Boolean.TRUE;
        case JsonTokenId.ID_FALSE:
            return Boolean.FALSE;

        case JsonTokenId.ID_NULL: // should not get this but...
            return null;

//        case JsonTokenId.ID_END_ARRAY: // invalid
        default:
        }
        throw ctxt.mappingException(Object.class);
    }"
JacksonDatabind_36,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_36_buggy/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java,"private final static DateFormat _cloneFormat(DateFormat df, String format,
            TimeZone tz, Locale loc, Boolean lenient)
    {
        if (!loc.equals(DEFAULT_LOCALE)) {
            df = new SimpleDateFormat(format, loc);
            df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);
        } else {
            df = (DateFormat) df.clone();
            if (tz != null) {
                 df.setTimeZone(tz);
             }
         }
         return df;
     }"
JacksonDatabind_38,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_38_buggy/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java,"@Deprecated
    public static SimpleType construct(Class<?> cls)
    {
        /* Let's add sanity checks, just to ensure no
         * Map/Collection entries are constructed
         */
        if (Map.class.isAssignableFrom(cls)) {
            throw new IllegalArgumentException(""Can not construct SimpleType for a Map (class: ""+cls.getName()+"")"");
        }
        if (Collection.class.isAssignableFrom(cls)) {
            throw new IllegalArgumentException(""Can not construct SimpleType for a Collection (class: ""+cls.getName()+"")"");
        }
        // ... and while we are at it, not array types either
         if (cls.isArray()) {
             throw new IllegalArgumentException(""Can not construct SimpleType for an array (class: ""+cls.getName()+"")"");
         }
         return new SimpleType(cls, TypeBindings.emptyBindings(),
                 _bogusSuperClass(cls), null, null, null, false);
     }"
JacksonDatabind_38,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_38_buggy/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java,"@Deprecated // since 2.7
     public static CollectionType construct(Class<?> rawType, JavaType elemT) {
         // First: may need to fabricate TypeBindings (needed for refining into
         // concrete collection types, as per [databind#1102])
         return new CollectionType(rawType, null,
                 // !!! TODO: Wrong, does have supertypes, but:
                 _bogusSuperClass(rawType), null, elemT,
                 null, null, false);
    }"
JacksonDatabind_38,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_38_buggy/src/main/java/com/fasterxml/jackson/databind/type/MapType.java,"@Deprecated // since 2.7
    public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT)
     {
         // First: may need to fabricate TypeBindings (needed for refining into
         // concrete collection types, as per [databind#1102])
         // !!! TODO: Wrong, does have supertypes
         return new MapType(rawType, null, _bogusSuperClass(rawType), null,
                 keyT, valueT, null, null, false);
     }"
JacksonDatabind_40,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_40_buggy/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java,"        public final T getNullValue() {
            return _nullValue;
        }
"
JacksonDatabind_41,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_41_buggy/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java,"    public JavaType constructType(Type type, Class<?> contextClass) {
        return constructType(type, constructType(contextClass));
    }
"
JacksonDatabind_41,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_41_buggy/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java,"    public JavaType constructType(Type type, JavaType contextType) {
        return _fromAny(null, type, contextType.getBindings());
    }
"
JacksonDatabind_43,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_43_buggy/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java,"@Override
     public Object deserializeSetAndReturn(JsonParser p,
     		DeserializationContext ctxt, Object instance) throws IOException
     {
         Object id = _valueDeserializer.deserialize(p, ctxt);
         /* 02-Apr-2015, tatu: Actually, as per [databind#742], let it be;
          *  missing or null id is needed for some cases, such as cases where id
          *  will be generated externally, at a later point, and is not available
          *  quite yet. Typical use case is with DB inserts.
          */
         // note: no null checks (unlike usually); deserializer should fail if one found
         if (id == null) {
             return null;
         }
         ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);
         roid.bindItem(instance);
         // also: may need to set a property value as well
        SettableBeanProperty idProp = _objectIdReader.idProperty;
        if (idProp != null) {
            return idProp.setAndReturn(instance, id);
        }
        return instance;
    }"
JacksonDatabind_48,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_48_buggy/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java,"@Override
    public VisibilityChecker<?> getDefaultVisibilityChecker()
     {
         VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();
         // then global overrides (disabling)
         if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) {
             vchecker = vchecker.withGetterVisibility(Visibility.NONE);
         }
        if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) {
            vchecker = vchecker.withIsGetterVisibility(Visibility.NONE);
        }
        if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) {
            vchecker = vchecker.withFieldVisibility(Visibility.NONE);
        }
        return vchecker;
    }"
JacksonDatabind_48,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_48_buggy/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java,"@Override
    public VisibilityChecker<?> getDefaultVisibilityChecker()
    {
        VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();
        if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) {
            vchecker = vchecker.withSetterVisibility(Visibility.NONE);
        }
         if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) {
             vchecker = vchecker.withCreatorVisibility(Visibility.NONE);
         }
         if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) {
             vchecker = vchecker.withFieldVisibility(Visibility.NONE);
         }
        return vchecker;
    }"
JacksonDatabind_50,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_50_buggy/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java,"@Override
    @SuppressWarnings(""resource"")
    protected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)
        throws IOException
    {
        final PropertyBasedCreator creator = _propertyBasedCreator;
        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);

        TokenBuffer unknown = null;

        JsonToken t = p.getCurrentToken();
        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {
            String propName = p.getCurrentName();
            p.nextToken(); // to point to value
            // creator property?
            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);
            if (creatorProp != null) {
                // Last creator property to set?
                if (buffer.assignParameter(creatorProp,
                        _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {
                    p.nextToken(); // to move to following FIELD_NAME/END_OBJECT
                    Object bean;
                    try {
                        bean = creator.build(ctxt, buffer);
                    } catch (Exception e) {
                        bean = wrapInstantiationProblem(e, ctxt);
                    }
                    if (bean == null) {
                        return ctxt.handleInstantiationProblem(handledType(), null,
                                _creatorReturnedNullException());
                    }
                    // [databind#631]: Assign current value, to be accessible by custom serializers
                    p.setCurrentValue(bean);

                    //  polymorphic?
                    if (bean.getClass() != _beanType.getRawClass()) {
                        return handlePolymorphic(p, ctxt, bean, unknown);
                    }
                    if (unknown != null) { // nope, just extra unknown stuff...
                        bean = handleUnknownProperties(ctxt, bean, unknown);
                    }
                    // or just clean?
                    return deserialize(p, ctxt, bean);
                }
                continue;
            }
            // Object Id property?
            if (buffer.readIdProperty(propName)) {
                continue;
            }
            // regular property? needs buffering
            SettableBeanProperty prop = _beanProperties.find(propName);
            if (prop != null) {
                    buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));
                    // 14-Jun-2016, tatu: As per [databind#1261], looks like we need additional
                    //    handling of forward references here. Not exactly sure why existing
                    //    facilities did not cover, but this does appear to solve the problem
                continue;
            }
            // Things marked as ignorable should not be passed to any setter
            if (_ignorableProps != null && _ignorableProps.contains(propName)) {
                handleIgnoredProperty(p, ctxt, handledType(), propName);
                continue;
            }
            // ""any property""?
            if (_anySetter != null) {
                try {
                    buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));
                } catch (Exception e) {
                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);
                }
                continue;
            }
            // Ok then, let's collect the whole field; name and value
            if (unknown == null) {
                unknown = new TokenBuffer(p, ctxt);
            }
            unknown.writeFieldName(propName);
            unknown.copyCurrentStructure(p);
        }

        // We hit END_OBJECT, so:
        Object bean;
        try {
            bean =  creator.build(ctxt, buffer);
        } catch (Exception e) {
             wrapInstantiationProblem(e, ctxt);
             bean = null; // never gets here
         }
         if (unknown != null) {
             // polymorphic?
             if (bean.getClass() != _beanType.getRawClass()) {
                return handlePolymorphic(null, ctxt, bean, unknown);
            }
            // no, just some extra unknown properties
            return handleUnknownProperties(ctxt, bean, unknown);
        }
        return bean;
    }"
JacksonDatabind_52,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_52_buggy/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java,"@Override
    public void resolve(DeserializationContext ctxt)
        throws JsonMappingException
    {
        ExternalTypeHandler.Builder extTypes = null;
        // if ValueInstantiator can use ""creator"" approach, need to resolve it here...
        SettableBeanProperty[] creatorProps;

        if (_valueInstantiator.canCreateFromObjectWith()) {
            creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());

            // 21-Jun-2015, tatu: This resolution was duplicated later on and seems like
            //    it really should be only done at a later point. So commented out in 2.8.
            //   However, just in case there was a reason for it, leaving commented out
            //   here instead of immediately removing.

            /*
            // also: need to try to resolve 'external' type ids...
            for (SettableBeanProperty prop : creatorProps) {
                if (prop.hasValueTypeDeserializer()) {
                    TypeDeserializer typeDeser = prop.getValueTypeDeserializer();
                    if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) {
                        if (extTypes == null) {
                            extTypes = new ExternalTypeHandler.Builder();
                        }
                        extTypes.addExternal(prop, typeDeser);
                    }
                }
            }
            */
        } else {
            creatorProps = null;
        }

        UnwrappedPropertyHandler unwrapped = null;

        for (SettableBeanProperty origProp : _beanProperties) {
            SettableBeanProperty prop = origProp;

            // May already have deserializer from annotations, if so, skip:
            if (!prop.hasValueDeserializer()) {
                // [databind#125]: allow use of converters
                JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop);
                if (deser == null) {
                    deser = findDeserializer(ctxt, prop.getType(), prop);
                }
                prop = prop.withValueDeserializer(deser);
            } else { // may need contextual version
                JsonDeserializer<Object> deser = prop.getValueDeserializer();
                /* Important! This is the only place where actually handle ""primary""
                 * property deserializers -- call is different from other places.
                 */
                JsonDeserializer<?> cd = ctxt.handlePrimaryContextualization(deser, prop,
                        prop.getType());
                if (cd != deser) {
                    prop = prop.withValueDeserializer(cd);
                }
            }

            // Need to link managed references with matching back references
            prop = _resolveManagedReferenceProperty(ctxt, prop);

            // [databind#351[: need to wrap properties that require object id resolution.
            if (!(prop instanceof ManagedReferenceProperty)) {
                prop = _resolvedObjectIdProperty(ctxt, prop);
            }
            // Support unwrapped values (via @JsonUnwrapped)
            SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop);
            if (u != null) {
                prop = u;
                if (unwrapped == null) {
                    unwrapped = new UnwrappedPropertyHandler();
                }
                unwrapped.addProperty(prop);
                /* 12-Dec-2014, tatu: As per [databind#647], we will have problems if
                 *    the original property is left in place. So let's remove it now.
                 */
                _beanProperties.remove(prop);
                continue;
            }
            // non-static inner classes too:
            prop = _resolveInnerClassValuedProperty(ctxt, prop);
            if (prop != origProp) {
                _beanProperties.replace(prop);
                // [databind#795]: Make sure PropertyBasedCreator's properties stay in sync
                if (creatorProps != null) {
                    // 18-May-2015, tatu: _Should_ start with consistent set. But can we really
                    //   fully count on this? May need to revisit in future; seems to hold for now.
                    for (int i = 0, len = creatorProps.length; i < len; ++i) {
                        if (creatorProps[i] == origProp) {
                            creatorProps[i] = prop;
                            break;
                        }
                        // ... as per above, it is possible we'd need to add this as fallback
                        // if (but only if) identity check fails?
                        /*
                        if (creatorProps[i].getName().equals(prop.getName())) {
                            creatorProps[i] = prop;
                            break;
                        }
                        */
                    }
                }
            }
            // one more thing: if this property uses ""external property"" type inclusion,
            // it needs different handling altogether
            if (prop.hasValueTypeDeserializer()) {
                TypeDeserializer typeDeser = prop.getValueTypeDeserializer();
                if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) {
                    if (extTypes == null) {
                        extTypes = new ExternalTypeHandler.Builder();
                    }
                    extTypes.addExternal(prop, typeDeser);
                    // In fact, remove from list of known properties to simplify later handling
                    _beanProperties.remove(prop);
                    continue;
                }
            }
        }
        // ""any setter"" may also need to be resolved now
        if (_anySetter != null && !_anySetter.hasValueDeserializer()) {
            _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt,
                    _anySetter.getType(), _anySetter.getProperty()));
        }
        // as well as delegate-based constructor:
        if (_valueInstantiator.canCreateUsingDelegate()) {
            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());
            if (delegateType == null) {
                throw new IllegalArgumentException(""Invalid delegate-creator definition for ""+_beanType
                        +"": value instantiator (""+_valueInstantiator.getClass().getName()
                        +"") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"");
            }
            _delegateDeserializer = _findDelegateDeserializer(ctxt, delegateType,
                    _valueInstantiator.getDelegateCreator());
        }

        // and array-delegate-based constructor:
        if (_valueInstantiator.canCreateUsingArrayDelegate()) {
            JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());
            if (delegateType == null) {
                throw new IllegalArgumentException(""Invalid array-delegate-creator definition for ""+_beanType
                        +"": value instantiator (""+_valueInstantiator.getClass().getName()
                        +"") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'"");
            }
            _arrayDelegateDeserializer = _findDelegateDeserializer(ctxt, delegateType,
                    _valueInstantiator.getArrayDelegateCreator());
        }

        // And now that we know CreatorProperty instances are also resolved can finally create the creator:
        if (creatorProps != null) {
            _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps);
        }

         if (extTypes != null) {
             // 21-Jun-2016, tatu: related to [databind#999], may need to link type ids too,
             //    so need to pass collected properties
             _externalTypeIdHandler = extTypes.build();
             // we consider this non-standard, to offline handling
             _nonStandardCreation = true;
         }
        
        _unwrappedPropertyHandler = unwrapped;
        if (unwrapped != null) { // we consider this non-standard, to offline handling
            _nonStandardCreation = true;
        }

        // may need to disable vanilla processing, if unwrapped handling was enabled...
        _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation;
    }"
JacksonDatabind_53,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_53_buggy/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java,"public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)
    {
        // simple optimization to avoid costly introspection if type-erased type does NOT differ
        final Class<?> rawBase = baseType.getRawClass();
        if (rawBase == subclass) {
            return baseType;
        }

        JavaType newType;

        // also: if we start from untyped, not much to save
        do { // bogus loop to be able to break
            if (rawBase == Object.class) {
                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
                break;
            }
            if (!rawBase.isAssignableFrom(subclass)) {
                throw new IllegalArgumentException(String.format(
                        ""Class %s not subtype of %s"", subclass.getName(), baseType));
            }
            // A few special cases where we can simplify handling:

            // (1) Original target type has no generics -- just resolve subtype
            if (baseType.getBindings().isEmpty()) {
                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     
                break;
            }
            // (2) A small set of ""well-known"" List/Map subtypes where can take a short-cut
            if (baseType.isContainerType()) {
                if (baseType.isMapLikeType()) {
                    if ((subclass == HashMap.class)
                            || (subclass == LinkedHashMap.class)
                            || (subclass == EnumMap.class)
                            || (subclass == TreeMap.class)) {
                        newType = _fromClass(null, subclass,
                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));
                        break;
                    }
                } else if (baseType.isCollectionLikeType()) {
                    if ((subclass == ArrayList.class)
                            || (subclass == LinkedList.class)
                            || (subclass == HashSet.class)
                            || (subclass == TreeSet.class)) {
                        newType = _fromClass(null, subclass,
                                TypeBindings.create(subclass, baseType.getContentType()));
                        break;
                    }
                    // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,
                    //    but they are impl details and we basically do not care...
                    if (rawBase == EnumSet.class) {
                        return baseType;
                    }
                }
            }
            // (3) Sub-class does not take type parameters -- just resolve subtype
            int typeParamCount = subclass.getTypeParameters().length;
            if (typeParamCount == 0) {
                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     
                break;
            }
            
            // If not, we'll need to do more thorough forward+backwards resolution. Sigh.
            // !!! TODO (as of 28-Jan-2016, at least)
            
            // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is
            //    a way to fully resolve and merge hierarchies; but that gets expensive
            //    so let's, for now, try to create close-enough approximation that
            //    is not 100% same, structurally, but has equivalent information for
            //    our specific neeeds.
            // 29-Mar-2016, tatu: See [databind#1173]  (and test `TypeResolverTest`)
             //  for a case where this code does get invoked: not ideal
             // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but
             //  not certain it would reliably work... but let's hope for best for now
             if (baseType.isInterface()) {
                 newType = baseType.refine(subclass, TypeBindings.emptyBindings(), null, new JavaType[] { baseType });
             } else {
                 newType = baseType.refine(subclass, TypeBindings.emptyBindings(), baseType, NO_TYPES);
             }
             // Only SimpleType returns null, but if so just resolve regularly
             if (newType == null) {
                 TypeBindings tb = null;
                 if (baseType.containedTypeCount() == typeParamCount) {
                     if (typeParamCount == 1) {
                         tb = TypeBindings.create(subclass, baseType.containedType(0));
                     } else if (typeParamCount == 2) {
                         tb = TypeBindings.create(subclass, baseType.containedType(0),
                                 baseType.containedType(1));
                     }
                 }
                 newType = _fromClass(null, subclass,
                         (tb == null) ? TypeBindings.emptyBindings() : tb);
             }
         } while (false);
 
        // except possibly handlers
//      newType = newType.withHandlersFrom(baseType);
        return newType;

        // 20-Oct-2015, tatu: Old simplistic approach
        
        /*
        // Currently mostly SimpleType instances can become something else
        if (baseType instanceof SimpleType) {
            // and only if subclass is an array, Collection or Map
            if (subclass.isArray()
                || Map.class.isAssignableFrom(subclass)
                || Collection.class.isAssignableFrom(subclass)) {
                // need to assert type compatibility...
                if (!baseType.getRawClass().isAssignableFrom(subclass)) {
                    throw new IllegalArgumentException(""Class ""+subclass.getClass().getName()+"" not subtype of ""+baseType);
                }
                // this _should_ work, right?
                JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());
                // one more thing: handlers to copy?
                Object h = baseType.getValueHandler();
                if (h != null) {
                    subtype = subtype.withValueHandler(h);
                }
                h = baseType.getTypeHandler();
                if (h != null) {
                    subtype = subtype.withTypeHandler(h);
                }
                return subtype;
            }
        }
        // But there is the need for special case for arrays too, it seems
        if (baseType instanceof ArrayType) {
            if (subclass.isArray()) {
                // actually see if it might be a no-op first:
                ArrayType at = (ArrayType) baseType;
                Class<?> rawComp = subclass.getComponentType();
                if (at.getContentType().getRawClass() == rawComp) {
                    return baseType;
                }
                JavaType componentType = _fromAny(null, rawComp, null);
                return ((ArrayType) baseType).withComponentType(componentType);
            }
        }

        // otherwise regular narrowing should work just fine
        return baseType.narrowBy(subclass);
        */
    }"
JacksonDatabind_53,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_53_buggy/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java,"protected JavaType _fromClass(ClassStack context, Class<?> rawType, TypeBindings bindings)
    {
        // Very first thing: small set of core types we know well:
        JavaType result = _findWellKnownSimple(rawType);
        if (result != null) {
            return result;
        }
        // Barring that, we may have recently constructed an instance
        boolean cachable = (bindings == null) || bindings.isEmpty();
        if (cachable) {
            result = _typeCache.get(rawType);
        if (result != null) {
            return result;
            }
        }

        // 15-Oct-2015, tatu: recursive reference?
        if (context == null) {
            context = new ClassStack(rawType);
        } else {
            ClassStack prev = context.find(rawType);
            if (prev != null) {
                // Self-reference: needs special handling, then...
                ResolvedRecursiveType selfRef = new ResolvedRecursiveType(rawType, EMPTY_BINDINGS);
                prev.addSelfReference(selfRef);
                return selfRef;
            }
            // no, but need to update context to allow for proper cycle resolution
            context = context.child(rawType);
        }

        // First: do we have an array type?
        if (rawType.isArray()) {
            result = ArrayType.construct(_fromAny(context, rawType.getComponentType(), bindings),
                    bindings);
        } else {
            // If not, need to proceed by first resolving parent type hierarchy
            
            JavaType superClass;
            JavaType[] superInterfaces;

            if (rawType.isInterface()) {
                superClass = null;
                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);
            } else {
                // Note: even Enums can implement interfaces, so can not drop those
                superClass = _resolveSuperClass(context, rawType, bindings);
                superInterfaces = _resolveSuperInterfaces(context, rawType, bindings);
            }

            // 19-Oct-2015, tatu: Bit messy, but we need to 'fix' java.util.Properties here...
            if (rawType == Properties.class) {
                result = MapType.construct(rawType, bindings, superClass, superInterfaces,
                        CORE_TYPE_STRING, CORE_TYPE_STRING);
            }
            // And then check what flavor of type we got. Start by asking resolved
            // super-type if refinement is all that is needed?
            else if (superClass != null) {
                result = superClass.refine(rawType, bindings, superClass, superInterfaces);
            }
            // if not, perhaps we are now resolving a well-known class or interface?
            if (result == null) {
                result = _fromWellKnownClass(context, rawType, bindings, superClass, superInterfaces); 
                if (result == null) {
                    result = _fromWellKnownInterface(context, rawType, bindings, superClass, superInterfaces);
                    if (result == null) {
                        // but if nothing else, ""simple"" class for now:
                        result = _newSimpleType(rawType, bindings, superClass, superInterfaces);
                    }
                }
             }
         }
         context.resolveSelfReferences(result);
         if (cachable) {
             _typeCache.putIfAbsent(rawType, result);
         }
         return result;
     }"
JacksonDatabind_55,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_55_buggy/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java,"@SuppressWarnings(""unchecked"")
    public static JsonSerializer<Object> getFallbackKeySerializer(SerializationConfig config,
            Class<?> rawKeyType)
    {
        if (rawKeyType != null) {
            // 29-Sep-2015, tatu: Odd case here, of `Enum`, which we may get for `EnumMap`; not sure
            //   if that is a bug or feature. Regardless, it seems to require dynamic handling
            //   (compared to getting actual fully typed Enum).
            //  Note that this might even work from the earlier point, but let's play it safe for now
            // 11-Aug-2016, tatu: Turns out we get this if `EnumMap` is the root value because
            //    then there is no static type
            if (rawKeyType == Enum.class) {
                 return new Dynamic();
             }
             if (rawKeyType.isEnum()) {
                 return new Default(Default.TYPE_ENUM, rawKeyType);
             }
         }
         return DEFAULT_KEY_SERIALIZER;
    }"
JacksonDatabind_56,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_56_buggy/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java,"@Override
        protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException
        {
            switch (_kind) {
            case STD_FILE:
                return new File(value);
            case STD_URL:
                return new URL(value);
            case STD_URI:
                return URI.create(value);
            case STD_CLASS:
                try {
                    return ctxt.findClass(value);
                } catch (Exception e) {
                    throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));
                }
            case STD_JAVA_TYPE:
                return ctxt.getTypeFactory().constructFromCanonical(value);
            case STD_CURRENCY:
                // will throw IAE if unknown:
                return Currency.getInstance(value);
            case STD_PATTERN:
                // will throw IAE (or its subclass) if malformed
                 return Pattern.compile(value);
             case STD_LOCALE:
                 {
                     int ix = value.indexOf('_');
                     if (ix < 0) { // single argument
                         return new Locale(value);
                     }
                     String first = value.substring(0, ix);
                     value = value.substring(ix+1);
                     ix = value.indexOf('_');
                     if (ix < 0) { // two pieces
                         return new Locale(first, value);
                     }
                    String second = value.substring(0, ix);
                    return new Locale(first, second, value.substring(ix+1));
                }
            case STD_CHARSET:
                return Charset.forName(value);
            case STD_TIME_ZONE:
                return TimeZone.getTimeZone(value);
            case STD_INET_ADDRESS:
                return InetAddress.getByName(value);
            case STD_INET_SOCKET_ADDRESS:
                if (value.startsWith(""["")) {
                    // bracketed IPv6 (with port number)

                    int i = value.lastIndexOf(']');
                    if (i == -1) {
                        throw new InvalidFormatException(ctxt.getParser(),
                                ""Bracketed IPv6 address must contain closing bracket"",
                                value, InetSocketAddress.class);
                    }

                    int j = value.indexOf(':', i);
                    int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;
                    return new InetSocketAddress(value.substring(0, i + 1), port);
                } else {
                    int ix = value.indexOf(':');
                    if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {
                        // host:port
                        int port = Integer.parseInt(value.substring(ix+1));
                        return new InetSocketAddress(value.substring(0, ix), port);
                    }
                    // host or unbracketed IPv6, without port number
                    return new InetSocketAddress(value, 0);
                }
            }
            throw new IllegalArgumentException();
        }"
JacksonDatabind_59,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_59_buggy/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java,"public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)
    {
        // simple optimization to avoid costly introspection if type-erased type does NOT differ
        final Class<?> rawBase = baseType.getRawClass();
        if (rawBase == subclass) {
            return baseType;
        }

        JavaType newType;

        // also: if we start from untyped, not much to save
        do { // bogus loop to be able to break
            if (rawBase == Object.class) {
                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());
                break;
            }
            if (!rawBase.isAssignableFrom(subclass)) {
                throw new IllegalArgumentException(String.format(
                        ""Class %s not subtype of %s"", subclass.getName(), baseType));
            }
            // A few special cases where we can simplify handling:

            // (1) Original target type has no generics -- just resolve subtype
            if (baseType.getBindings().isEmpty()) {
                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     
                break;
            }
            // (2) A small set of ""well-known"" List/Map subtypes where can take a short-cut
            if (baseType.isContainerType()) {
                if (baseType.isMapLikeType()) {
                    if ((subclass == HashMap.class)
                            || (subclass == LinkedHashMap.class)
                            || (subclass == EnumMap.class)
                            || (subclass == TreeMap.class)) {
                        newType = _fromClass(null, subclass,
                                TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));
                        break;
                    }
                } else if (baseType.isCollectionLikeType()) {
                    if ((subclass == ArrayList.class)
                            || (subclass == LinkedList.class)
                            || (subclass == HashSet.class)
                            || (subclass == TreeSet.class)) {
                        newType = _fromClass(null, subclass,
                                TypeBindings.create(subclass, baseType.getContentType()));
                        break;
                    }
                    // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,
                    //    but they are impl details and we basically do not care...
                    if (rawBase == EnumSet.class) {
                        return baseType;
                    }
                }
            }
            // (3) Sub-class does not take type parameters -- just resolve subtype
            int typeParamCount = subclass.getTypeParameters().length;
            if (typeParamCount == 0) {
                newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     
                break;
            }
            
            // If not, we'll need to do more thorough forward+backwards resolution. Sigh.

            // 20-Oct-2015, tatu: Container, Map-types somewhat special. There is
            //    a way to fully resolve and merge hierarchies; but that gets expensive
            //    so let's, for now, try to create close-enough approximation that
            //    is not 100% same, structurally, but has equivalent information for
            //    our specific neeeds.
            // 29-Mar-2016, tatu: See [databind#1173]  (and test `TypeResolverTest`)
            //  for a case where this code does get invoked: not ideal
            // 29-Jun-2016, tatu: As to bindings, this works for [databind#1215], but
            //  not certain it would reliably work... but let's hope for best for now
            TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);
            if (baseType.isInterface()) {
                newType = baseType.refine(subclass, tb, null, new JavaType[] { baseType });
            } else {
                newType = baseType.refine(subclass, tb, baseType, NO_TYPES);
            }
            // Only SimpleType returns null, but if so just resolve regularly
            if (newType == null) {
                newType = _fromClass(null, subclass, tb);
            }
        } while (false);
 
         // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get
         //   copied as well
         return newType;
 
         // 20-Oct-2015, tatu: Old simplistic approach
        
        /*
        // Currently mostly SimpleType instances can become something else
        if (baseType instanceof SimpleType) {
            // and only if subclass is an array, Collection or Map
            if (subclass.isArray()
                || Map.class.isAssignableFrom(subclass)
                || Collection.class.isAssignableFrom(subclass)) {
                // need to assert type compatibility...
                if (!baseType.getRawClass().isAssignableFrom(subclass)) {
                    throw new IllegalArgumentException(""Class ""+subclass.getClass().getName()+"" not subtype of ""+baseType);
                }
                // this _should_ work, right?
                JavaType subtype = _fromClass(null, subclass, TypeBindings.emptyBindings());
                // one more thing: handlers to copy?
                Object h = baseType.getValueHandler();
                if (h != null) {
                    subtype = subtype.withValueHandler(h);
                }
                h = baseType.getTypeHandler();
                if (h != null) {
                    subtype = subtype.withTypeHandler(h);
                }
                return subtype;
            }
        }
        // But there is the need for special case for arrays too, it seems
        if (baseType instanceof ArrayType) {
            if (subclass.isArray()) {
                // actually see if it might be a no-op first:
                ArrayType at = (ArrayType) baseType;
                Class<?> rawComp = subclass.getComponentType();
                if (at.getContentType().getRawClass() == rawComp) {
                    return baseType;
                }
                JavaType componentType = _fromAny(null, rawComp, null);
                return ((ArrayType) baseType).withComponentType(componentType);
            }
        }

        // otherwise regular narrowing should work just fine
        return baseType.narrowBy(subclass);
        */
    }"
JacksonDatabind_60,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_60_buggy/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java,"@Override
    public void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,
            TypeSerializer typeSer0) throws IOException
    {
        // Regardless of other parts, first need to find value to serialize:
        Object value = null;
        try {
            value = _accessorMethod.getValue(bean);
            // and if we got null, can also just write it directly
            if (value == null) {
                provider.defaultSerializeNull(gen);
                return;
            }
            JsonSerializer<Object> ser = _valueSerializer;
            if (ser == null) { // no serializer yet? Need to fetch
//                ser = provider.findTypedValueSerializer(value.getClass(), true, _property);
                ser = provider.findValueSerializer(value.getClass(), _property);
            } else {
                /* 09-Dec-2010, tatu: To work around natural type's refusal to add type info, we do
                 *    this (note: type is for the wrapper type, not enclosed value!)
                 */
                if (_forceTypeInformation) {
                    typeSer0.writeTypePrefixForScalar(bean, gen);
                    ser.serialize(value, gen, provider);
                    typeSer0.writeTypeSuffixForScalar(bean, gen);
                    return;
                }
            }
             // 28-Sep-2016, tatu: As per [databind#1385], we do need to do some juggling
             //    to use different Object for type id (logical type) and actual serialization
             //    (delegat type).
             ser.serializeWithType(value, gen, provider, typeSer0);
         } catch (IOException ioe) {
             throw ioe;
         } catch (Exception e) {
            Throwable t = e;
            // Need to unwrap this specific type, to see infinite recursion...
            while (t instanceof InvocationTargetException && t.getCause() != null) {
                t = t.getCause();
            }
            // Errors shouldn't be wrapped (and often can't, as well)
            if (t instanceof Error) {
                throw (Error) t;
            }
            // let's try to indicate the path best we can...
            throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + ""()"");
        }
    }"
JacksonDatabind_61,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_61_buggy/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java,"        public boolean useForType(JavaType t)
        {
            // 03-Oct-2016, tatu: As per [databind#1395], need to skip
            //  primitive types too, regardless

            switch (_appliesFor) {
            case NON_CONCRETE_AND_ARRAYS:
                while (t.isArrayType()) {
                    t = t.getContentType();
                }
                // fall through
            case OBJECT_AND_NON_CONCRETE:
                // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:
                while (t.isReferenceType()) {
                    t = t.getReferencedType();
                }
                return t.isJavaLangObject()
                        || (!t.isConcrete()
                                // [databind#88] Should not apply to JSON tree models:
                                && !TreeNode.class.isAssignableFrom(t.getRawClass()));

            case NON_FINAL:
                while (t.isArrayType()) {
                    t = t.getContentType();
                }
                // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:
                while (t.isReferenceType()) {
                    t = t.getReferencedType();
                }
                // [databind#88] Should not apply to JSON tree models:
                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());
            default:
            //case JAVA_LANG_OBJECT:
                return t.isJavaLangObject();
            }
        }
"
JacksonDatabind_61,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_61_buggy/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java,"    public TypeSerializer buildTypeSerializer(SerializationConfig config,
            JavaType baseType, Collection<NamedType> subtypes)
    {
        if (_idType == JsonTypeInfo.Id.NONE) { return null; }
        // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
        //    regardless of setting
        TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);
        switch (_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeSerializer(idRes, null);
        case PROPERTY:
            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeSerializer(idRes, null);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeSerializer(idRes, null, _typeProperty);
        case EXISTING_PROPERTY:
        	// as per [#528]
        	return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);
        }
        throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: ""+_includeAs);
    }
"
JacksonDatabind_61,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_61_buggy/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java,"    public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,
            JavaType baseType, Collection<NamedType> subtypes)
    {
        if (_idType == JsonTypeInfo.Id.NONE) { return null; }
        // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,
        //    regardless of setting

        TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);

        JavaType defaultImpl;

        if (_defaultImpl == null) {
            defaultImpl = null;
        } else {
            // 20-Mar-2016, tatu: It is important to do specialization go through
            //   TypeFactory to ensure proper resolution; with 2.7 and before, direct
            //   call to JavaType was used, but that can not work reliably with 2.7
            // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT
            //   if so, need to add explicit checks for marker types. Not ideal, but
            //   seems like a reasonable compromise.
            if ((_defaultImpl == Void.class)
                     || (_defaultImpl == NoClass.class)) {
                defaultImpl = config.getTypeFactory().constructType(_defaultImpl);
            } else {
                defaultImpl = config.getTypeFactory()
                    .constructSpecializedType(baseType, _defaultImpl);
            }
        }

        // First, method for converting type info to type id:
        switch (_includeAs) {
        case WRAPPER_ARRAY:
            return new AsArrayTypeDeserializer(baseType, idRes,
                    _typeProperty, _typeIdVisible, defaultImpl);
        case PROPERTY:
        case EXISTING_PROPERTY: // as per [#528] same class as PROPERTY
            return new AsPropertyTypeDeserializer(baseType, idRes,
                    _typeProperty, _typeIdVisible, defaultImpl, _includeAs);
        case WRAPPER_OBJECT:
            return new AsWrapperTypeDeserializer(baseType, idRes,
                    _typeProperty, _typeIdVisible, defaultImpl);
        case EXTERNAL_PROPERTY:
            return new AsExternalTypeDeserializer(baseType, idRes,
                    _typeProperty, _typeIdVisible, defaultImpl);
        }
        throw new IllegalStateException(""Do not know how to construct standard type serializer for inclusion type: ""+_includeAs);
    }
"
JacksonDatabind_63,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_63_buggy/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java,"public String getDescription() {
            if (_desc == null) {
                StringBuilder sb = new StringBuilder();

                if (_from == null) { // can this ever occur?
                    sb.append(""UNKNOWN"");
                } else {
                    Class<?> cls = (_from instanceof Class<?>) ? (Class<?>)_from : _from.getClass();
                    // Hmmh. Although Class.getName() is mostly ok, it does look
                     // butt-ugly for arrays.
                     // 06-Oct-2016, tatu: as per [databind#1403], `getSimpleName()` not so good
                     //   as it drops enclosing class. So let's try bit different approach
                     String pkgName = ClassUtil.getPackageName(cls);
                     if (pkgName != null) {
                         sb.append(pkgName);
                         sb.append('.');
                     }
                     sb.append(cls.getSimpleName());
                 }
                 sb.append('[');
                 if (_fieldName != null) {
                    sb.append('""');
                    sb.append(_fieldName);
                    sb.append('""');
                } else if (_index >= 0) {
                    sb.append(_index);
                } else {
                    sb.append('?');
                }
                sb.append(']');
                _desc = sb.toString();
            }
            return _desc;
        }"
JacksonDatabind_66,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_66_buggy/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java,"        public final Object deserializeKey(String key, DeserializationContext ctxt)
            throws IOException
        {
            if (key == null) { // is this even legal call?
                return null;
            }
            try {
                // Ugh... should not have to give parser which may or may not be correct one...
                Object result = _delegate.deserialize(ctxt.getParser(), ctxt);
                if (result != null) {
                    return result;
                }
                return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
            } catch (Exception re) {
                return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation: %s"", re.getMessage());
            }
        }
"
JacksonDatabind_68,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_68_buggy/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java,"public Object deserializeFromString(JsonParser p, DeserializationContext ctxt) throws IOException
    {
        // First things first: id Object Id is used, most likely that's it
        if (_objectIdReader != null) {
            return deserializeFromObjectId(p, ctxt);
        }
         /* Bit complicated if we have delegating creator; may need to use it,
          * or might not...
          */
         if (_delegateDeserializer != null) {
             if (!_valueInstantiator.canCreateFromString()) {
                 Object bean = _valueInstantiator.createUsingDelegate(ctxt,
                         _delegateDeserializer.deserialize(p, ctxt));
                 if (_injectables != null) {
                     injectValues(ctxt, bean);
                 }
                return bean;
            }
        }
        return _valueInstantiator.createFromString(ctxt, p.getText());
    }"
JacksonDatabind_68,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_68_buggy/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java,"public Object deserializeFromBoolean(JsonParser p, DeserializationContext ctxt) throws IOException
     {
         if (_delegateDeserializer != null) {
             if (!_valueInstantiator.canCreateFromBoolean()) {
                 Object bean = _valueInstantiator.createUsingDelegate(ctxt,
                         _delegateDeserializer.deserialize(p, ctxt));
                 if (_injectables != null) {
                     injectValues(ctxt, bean);
                 }
                return bean;
            }
        }
        boolean value = (p.getCurrentToken() == JsonToken.VALUE_TRUE);
        return _valueInstantiator.createFromBoolean(ctxt, value);
    }"
JacksonDatabind_68,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_68_buggy/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java,"public Object deserializeFromDouble(JsonParser p, DeserializationContext ctxt) throws IOException
    {
         NumberType t = p.getNumberType();
         // no separate methods for taking float...
         if ((t == NumberType.DOUBLE) || (t == NumberType.FLOAT)) {
             if (_delegateDeserializer != null) {
                 if (!_valueInstantiator.canCreateFromDouble()) {
                     Object bean = _valueInstantiator.createUsingDelegate(ctxt,
                             _delegateDeserializer.deserialize(p, ctxt));
                     if (_injectables != null) {
                         injectValues(ctxt, bean);
                     }
                    return bean;
                }
            }
            return _valueInstantiator.createFromDouble(ctxt, p.getDoubleValue());
        }
        // actually, could also be BigDecimal, so:
        if (_delegateDeserializer != null) {
            return _valueInstantiator.createUsingDelegate(ctxt,
                    _delegateDeserializer.deserialize(p, ctxt));
        }
        return ctxt.handleMissingInstantiator(handledType(), p,
                ""no suitable creator method found to deserialize from Number value (%s)"",
                p.getNumberValue());
    }"
JacksonDatabind_68,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_68_buggy/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java,"public Object deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException
     {
         // note: can not call `_delegateDeserializer()` since order reversed here:
         if (_arrayDelegateDeserializer != null) {
             try {
                 Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt, _arrayDelegateDeserializer.deserialize(p, ctxt));
                 if (_injectables != null) {
                     injectValues(ctxt, bean);
                 }
                 return bean;
             } catch (Exception e) {
                 return wrapInstantiationProblem(e, ctxt);
             }
         }
         // fallback to non-array delegate
         if (_delegateDeserializer != null) {
             try {
             Object bean = _valueInstantiator.createUsingArrayDelegate(ctxt,
                     _delegateDeserializer.deserialize(p, ctxt));
             if (_injectables != null) {
                 injectValues(ctxt, bean);
             }
             return bean;
             } catch (Exception e) {
                 wrapInstantiationProblem(e, ctxt);
                 return null;
             }
         }
         if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {
             JsonToken t = p.nextToken();
            if (t == JsonToken.END_ARRAY && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {
                return null;
            }
            final Object value = deserialize(p, ctxt);
            if (p.nextToken() != JsonToken.END_ARRAY) {
                handleMissingEndArrayForSingle(p, ctxt);
            }
            return value;
        }
        if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {
            JsonToken t = p.nextToken();
            if (t == JsonToken.END_ARRAY) {
                return null;
            }
            return ctxt.handleUnexpectedToken(handledType(),
                    JsonToken.START_ARRAY, p, null);
        }
        return ctxt.handleUnexpectedToken(handledType(), p);
    }"
JacksonDatabind_68,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_68_buggy/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java,"protected Object deserializeFromObjectUsingNonDefault(JsonParser p,
             DeserializationContext ctxt) throws IOException
     {
         if (_delegateDeserializer != null) {
             return _valueInstantiator.createUsingDelegate(ctxt,
                     _delegateDeserializer.deserialize(p, ctxt));
         }
         if (_propertyBasedCreator != null) {
             return _deserializeUsingPropertyBased(p, ctxt);
        }
        // should only occur for abstract types...
        if (_beanType.isAbstract()) {
            return ctxt.handleMissingInstantiator(handledType(), p,
                    ""abstract type (need to add/enable type information?)"");
        }
        return ctxt.handleMissingInstantiator(_beanType.getRawClass(), p,
                ""no suitable constructor found, can not deserialize from Object value (missing default constructor or creator, or perhaps need to add/enable type information?)"");
    }"
JacksonDatabind_68,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_68_buggy/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java,"@SuppressWarnings(""incomplete-switch"")
    public Object deserializeFromNumber(JsonParser p, DeserializationContext ctxt)
        throws IOException
    {
        // First things first: id Object Id is used, most likely that's it
        if (_objectIdReader != null) {
            return deserializeFromObjectId(p, ctxt);
        }
        switch (p.getNumberType()) {
        case INT:
            if (_delegateDeserializer != null) {
                if (!_valueInstantiator.canCreateFromInt()) {
                    Object bean = _valueInstantiator.createUsingDelegate(ctxt,
                            _delegateDeserializer.deserialize(p, ctxt));
                    if (_injectables != null) {
                        injectValues(ctxt, bean);
                    }
                    return bean;
                }
             }
             return _valueInstantiator.createFromInt(ctxt, p.getIntValue());
         case LONG:
             if (_delegateDeserializer != null) {
                 if (!_valueInstantiator.canCreateFromInt()) {
                     Object bean = _valueInstantiator.createUsingDelegate(ctxt,
                             _delegateDeserializer.deserialize(p, ctxt));
                     if (_injectables != null) {
                         injectValues(ctxt, bean);
                     }
                    return bean;
                }
            }
            return _valueInstantiator.createFromLong(ctxt, p.getLongValue());
        }
        // actually, could also be BigInteger, so:
        if (_delegateDeserializer != null) {
            Object bean = _valueInstantiator.createUsingDelegate(ctxt,
                    _delegateDeserializer.deserialize(p, ctxt));
            if (_injectables != null) {
                injectValues(ctxt, bean);
            }
            return bean;
        }
        return ctxt.handleMissingInstantiator(handledType(), p,
                ""no suitable creator method found to deserialize from Number value (%s)"",
                p.getNumberValue());
    }"
JacksonDatabind_69,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_69_buggy/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java,"public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit,
            SettableBeanProperty[] properties)
    {
        verifyNonDup(creator, C_PROPS, explicit);
            // Better ensure we have no duplicate names either...
            if (properties.length > 1) {
                HashMap<String,Integer> names = new HashMap<String,Integer>();
                for (int i = 0, len = properties.length; i < len; ++i) {
                    String name = properties[i].getName();
                    /* [Issue-13]: Need to consider Injectables, which may not have
                     *   a name at all, and need to be skipped
                     */
                    if (name.length() == 0 && properties[i].getInjectableValueId() != null) {
                        continue;
                    }
                    Integer old = names.put(name, Integer.valueOf(i));
                    if (old != null) {
                        throw new IllegalArgumentException(""Duplicate creator property \""""+name+""\"" (index ""+old+"" vs ""+i+"")"");
                    }
                 }
             }
             _propertyBasedArgs = properties;
     }"
JacksonDatabind_69,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_69_buggy/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java,"protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)
    {
        final int mask = (1 << typeIndex);
        _hasNonDefaultCreator = true;
        AnnotatedWithParams oldOne = _creators[typeIndex];
        // already had an explicitly marked one?
        if (oldOne != null) {
            boolean verify;
             if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is
                 // but skip, if new one not annotated
                 if (!explicit) {
                     return;
                 }
                 // both explicit: verify
                 verify = true;
            } else {
                // otherwise only verify if neither explicitly annotated.
                verify = !explicit;
            }

            // one more thing: ok to override in sub-class
            if (verify && (oldOne.getClass() == newOne.getClass())) {
                // [databind#667]: avoid one particular class of bogus problems
                Class<?> oldType = oldOne.getRawParameterType(0);
                Class<?> newType = newOne.getRawParameterType(0);

                if (oldType == newType) {
                    throw new IllegalArgumentException(""Conflicting ""+TYPE_DESCS[typeIndex]
                            +"" creators: already had explicitly marked ""+oldOne+"", encountered ""+newOne);
                }
                // otherwise, which one to choose?
                if (newType.isAssignableFrom(oldType)) {
                    // new type more generic, use old
                    return;
                }
                // new type more specific, use it
            }
        }
        if (explicit) {
            _explicitCreators |= mask;
        }
        _creators[typeIndex] = _fixAccess(newOne);
    }"
JacksonDatabind_72,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_72_buggy/src/main/java/com/fasterxml/jackson/databind/deser/impl/InnerClassProperty.java,"package com.fasterxml.jackson.databind.deser.impl;

import java.io.IOException;
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;

import com.fasterxml.jackson.core.*;
import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.deser.SettableBeanProperty;
import com.fasterxml.jackson.databind.introspect.*;
import com.fasterxml.jackson.databind.util.ClassUtil;

/**
 * This sub-class is used to handle special case of value being a
 * non-static inner class. If so, we will have to use a special
 * alternative for default constructor; but otherwise can delegate
 * to regular implementation.
 */
public final class InnerClassProperty
    extends SettableBeanProperty
{
    private static final long serialVersionUID = 1L;

    /**
     * Actual property that we use after value construction.
     */
    protected final SettableBeanProperty _delegate;

    /**
     * Constructor used when deserializing this property.
     * Transient since there is no need to persist; only needed during
     * construction of objects.
     */
    final protected transient Constructor<?> _creator;
    
    /**
     * Serializable version of single-arg constructor we use for value instantiation.
     */
    protected AnnotatedConstructor _annotated;

    public InnerClassProperty(SettableBeanProperty delegate,
            Constructor<?> ctor)
    {
        super(delegate);
        _delegate = delegate;
        _creator = ctor;
    }

    /**
     * Constructor used with JDK Serialization; needed to handle transient
     * Constructor, wrap/unwrap in/out-of Annotated variant.
     */
    protected InnerClassProperty(InnerClassProperty src, AnnotatedConstructor ann)
    {
        super(src);
        _delegate = src._delegate;
        _annotated = ann;
        _creator = (_annotated == null) ? null : _annotated.getAnnotated();
        if (_creator == null) {
            throw new IllegalArgumentException(""Missing constructor (broken JDK (de)serialization?)"");
        }
    }
    
    protected InnerClassProperty(InnerClassProperty src, JsonDeserializer<?> deser)
    {
        super(src, deser);
        _delegate = src._delegate.withValueDeserializer(deser);
        _creator = src._creator;
    }

    protected InnerClassProperty(InnerClassProperty src, PropertyName newName) {
        super(src, newName);
        _delegate = src._delegate.withName(newName);
        _creator = src._creator;
    }

    @Override
    public InnerClassProperty withName(PropertyName newName) {
        return new InnerClassProperty(this, newName);
    }

    @Override
    public InnerClassProperty withValueDeserializer(JsonDeserializer<?> deser) {
        return new InnerClassProperty(this, deser);
    }

    @Override
    public void assignIndex(int index) { _delegate.assignIndex(index); }

    @Override
    public int getPropertyIndex() { return _delegate.getPropertyIndex(); }

    
    // // // BeanProperty impl
    
    @Override
    public <A extends Annotation> A getAnnotation(Class<A> acls) {
        return _delegate.getAnnotation(acls);
    }

    @Override public AnnotatedMember getMember() {  return _delegate.getMember(); }

    /*
    /**********************************************************
    /* Deserialization methods
    /**********************************************************
     */

    @Override
    public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object bean)
        throws IOException
    {
        JsonToken t = jp.getCurrentToken();
        Object value;
        if (t == JsonToken.VALUE_NULL) {
            value = _valueDeserializer.getNullValue(ctxt);
        } else if (_valueTypeDeserializer != null) {
            value = _valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer);
        } else  { // the usual case
            try {
                value = _creator.newInstance(bean);
            } catch (Exception e) {
                ClassUtil.unwrapAndThrowAsIAE(e, ""Failed to instantiate class ""+_creator.getDeclaringClass().getName()+"", problem: ""+e.getMessage());
                value = null;
            }
            _valueDeserializer.deserialize(jp, ctxt, value);
        }
        set(bean, value);
    }

    @Override
    public Object deserializeSetAndReturn(JsonParser jp,
      DeserializationContext ctxt, Object instance)
        throws IOException
    {
        return setAndReturn(instance, deserialize(jp, ctxt));
    }
    
    @Override
    public final void set(Object instance, Object value) throws IOException {
        _delegate.set(instance, value);
    }

    @Override
    public Object setAndReturn(Object instance, Object value) throws IOException {
        return _delegate.setAndReturn(instance, value);
    }

    /*
    /**********************************************************
    /* JDK serialization handling
    /**********************************************************
     */

    // When reading things back, 
    Object readResolve() {
        return new InnerClassProperty(this, _annotated);
    }

    Object writeReplace() {
        // need to construct a fake instance to support serialization
        if (_annotated != null) {
            return this;
        }
        return new InnerClassProperty(this, new AnnotatedConstructor(null, _creator, null, null));
    }
}
"
JacksonDatabind_73,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_73_buggy/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java,"    protected void _removeUnwantedAccessor(Map<String, POJOPropertyBuilder> props)
    {
        final boolean inferMutators = _config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS);
        Iterator<POJOPropertyBuilder> it = props.values().iterator();

        while (it.hasNext()) {
            POJOPropertyBuilder prop = it.next();
            // 26-Jan-2017, tatu: [databind#935]: need to denote removal of
            prop.removeNonVisible(inferMutators);
        }
    }"
JacksonDatabind_73,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_73_buggy/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java,"    public void removeNonVisible(boolean inferMutators)
    {
        /* 07-Jun-2015, tatu: With 2.6, we will allow optional definition
         *  of explicit access type for property; if not ""AUTO"", it will
         *  dictate how visibility checks are applied.
         */
        JsonProperty.Access acc = findAccess();
        if (acc == null) {
            acc = JsonProperty.Access.AUTO;
        }
        switch (acc) {
        case READ_ONLY:
            // Remove setters, creators for sure, but fields too if deserializing
            _setters = null;
            _ctorParameters = null;
            if (!_forSerialization) {
                _fields = null;
            }
            break;
        case READ_WRITE:
            // no trimming whatsoever?
            break;
        case WRITE_ONLY:
            // remove getters, definitely, but also fields if serializing
            _getters = null;
            if (_forSerialization) {
                _fields = null;
            }
            break;
        default:
        case AUTO: // the default case: base it on visibility
            _getters = _removeNonVisible(_getters);
            _ctorParameters = _removeNonVisible(_ctorParameters);
    
            if (!inferMutators || (_getters == null)) {
                _fields = _removeNonVisible(_fields);
                _setters = _removeNonVisible(_setters);
            }
        }
    }"
JacksonDatabind_75,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_75_buggy/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java,"@Override
    public JsonSerializer<?> createContextual(SerializerProvider serializers,
            BeanProperty property) throws JsonMappingException
    {
        if (property != null) {
            JsonFormat.Value format = findFormatOverrides(serializers,
                     property, handledType());
             if (format != null) {
                 Boolean serializeAsIndex = _isShapeWrittenUsingIndex(property.getType().getRawClass(),
                         format, false);
                 if (serializeAsIndex != _serializeAsIndex) {
                     return new EnumSerializer(_values, serializeAsIndex);
                 }
            }
        }
        return this;
    }"
JacksonDatabind_75,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_75_buggy/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java,"@SuppressWarnings(""unchecked"")
    public static EnumSerializer construct(Class<?> enumClass, SerializationConfig config,
            BeanDescription beanDesc, JsonFormat.Value format)
    {
        /* 08-Apr-2015, tatu: As per [databind#749], we can not statically determine
         *   between name() and toString(), need to construct `EnumValues` with names,
          *   handle toString() case dynamically (for example)
          */
         EnumValues v = EnumValues.constructFromName(config, (Class<Enum<?>>) enumClass);
         Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true);
         return new EnumSerializer(v, serializeAsIndex);
     }"
JacksonDatabind_77,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_77_buggy/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java,"@Override
    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,
            JavaType type, BeanDescription beanDesc)
        throws JsonMappingException
    {
        final DeserializationConfig config = ctxt.getConfig();
        // We may also have custom overrides:
        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);
        if (custom != null) {
            return custom;
        }
        /* One more thing to check: do we have an exception type
         * (Throwable or its sub-classes)? If so, need slightly
         * different handling.
         */
        if (type.isThrowable()) {
            return buildThrowableDeserializer(ctxt, type, beanDesc);
        }
        /* Or, for abstract types, may have alternate means for resolution
         * (defaulting, materialization)
         */
        // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are
        //    not something we could materialize anything for
        if (type.isAbstract() && !type.isPrimitive()) {
            // Let's make it possible to materialize abstract types.
            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);
            if (concreteType != null) {
                /* important: introspect actual implementation (abstract class or
                 * interface doesn't have constructors, for one)
                 */
                beanDesc = config.introspect(concreteType);
                return buildBeanDeserializer(ctxt, concreteType, beanDesc);
            }
        }

        // Otherwise, may want to check handlers for standard types, from superclass:
        @SuppressWarnings(""unchecked"")
        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);
        if (deser != null) {
            return deser;
        }

        // Otherwise: could the class be a Bean class? If not, bail out
        if (!isPotentialBeanType(type.getRawClass())) {
             return null;
         }
         // For checks like [databind#1599]
         // Use generic bean introspection to build deserializer
         return buildBeanDeserializer(ctxt, type, beanDesc);
     }"
JacksonDatabind_78,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_78_buggy/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java,"    protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc,
            Class<?> type, Map<Class<?>,Boolean> ignoredTypes)
    {
        Boolean status = ignoredTypes.get(type);
        if (status != null) {
            return status.booleanValue();
        }
        // 21-Apr-2016, tatu: For 2.8, can specify config overrides
        ConfigOverride override = config.findConfigOverride(type);
        if (override != null) {
            status = override.getIsIgnoredType();
        }
        if (status == null) {
            BeanDescription desc = config.introspectClassAnnotations(type);
            status = config.getAnnotationIntrospector().isIgnorableType(desc.getClassInfo());
            // We default to 'false', i.e. not ignorable
            if (status == null) {
                status = Boolean.FALSE;
            }
        }
        ignoredTypes.put(type, status);
        return status.booleanValue();
    }
"
JacksonDatabind_78,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_78_buggy/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java,"    public JsonDeserializer<Object> createBuilderBasedDeserializer(
    		DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc,
    		Class<?> builderClass)
        throws JsonMappingException
    {
        // First: need a BeanDescription for builder class
        JavaType builderType = ctxt.constructType(builderClass);
        BeanDescription builderDesc = ctxt.getConfig().introspectForBuilder(builderType);
        return buildBuilderBasedDeserializer(ctxt, valueType, builderDesc);
    }
"
JacksonDatabind_78,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_78_buggy/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java,"    public final static BeanDeserializerFactory instance = new BeanDeserializerFactory(
            new DeserializerFactoryConfig());

    public BeanDeserializerFactory(DeserializerFactoryConfig config) {
        super(config);
    }
"
JacksonDatabind_79,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_79_buggy/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java,"@SuppressWarnings(""incomplete-switch"")
    @Override
    public JsonSerializer<?> createContextual(SerializerProvider provider,
            BeanProperty property)
        throws JsonMappingException
    {
        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();
        final AnnotatedMember accessor = (property == null || intr == null)
                ? null : property.getMember();
        final SerializationConfig config = provider.getConfig();
        
        // Let's start with one big transmutation: Enums that are annotated
        // to serialize as Objects may want to revert
        JsonFormat.Shape shape = null;
        if (accessor != null) {
            JsonFormat.Value format = intr.findFormat((Annotated) accessor);

            if (format != null) {
                shape = format.getShape();
                // or, alternatively, asked to revert ""back to"" other representations...
                if (shape != _serializationShape) {
                    if (_handledType.isEnum()) {
                        switch (shape) {
                        case STRING:
                        case NUMBER:
                        case NUMBER_INT:
                            // 12-Oct-2014, tatu: May need to introspect full annotations... but
                            //   for now, just do class ones
                            BeanDescription desc = config.introspectClassAnnotations(_handledType);
                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType,
                                    provider.getConfig(), desc, format);
                            return provider.handlePrimaryContextualization(ser, property);
                        }
                    }
                }
            }
        }

        ObjectIdWriter oiw = _objectIdWriter;
        String[] ignorals = null;
        Object newFilterId = null;
        
        // Then we may have an override for Object Id
        if (accessor != null) {
            ignorals = intr.findPropertiesToIgnore(accessor, true);
            ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);
             if (objectIdInfo == null) {
                 // no ObjectId override, but maybe ObjectIdRef?
                 if (oiw != null) {
                     objectIdInfo = intr.findObjectReferenceInfo(accessor,
                             new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));
                         oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());
                 }
             } else {
                 // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it
                // to be able to move to SerializerProvider (where it really belongs)
                
                // 2.1: allow modifications by ""id ref"" annotations as well:
                objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);
                ObjectIdGenerator<?> gen;
                Class<?> implClass = objectIdInfo.getGeneratorType();
                JavaType type = provider.constructType(implClass);
                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];
                // Property-based generator is trickier
                if (implClass == ObjectIdGenerators.PropertyGenerator.class) { // most special one, needs extra work
                    String propName = objectIdInfo.getPropertyName().getSimpleName();
                    BeanPropertyWriter idProp = null;

                    for (int i = 0, len = _props.length ;; ++i) {
                        if (i == len) {
                            throw new IllegalArgumentException(""Invalid Object Id definition for ""+_handledType.getName()
                                    +"": can not find property with name '""+propName+""'"");
                        }
                        BeanPropertyWriter prop = _props[i];
                        if (propName.equals(prop.getName())) {
                            idProp = prop;
                            /* Let's force it to be the first property to output
                             * (although it may still get rearranged etc)
                             */
                            if (i > 0) { // note: must shuffle both regular properties and filtered
                                System.arraycopy(_props, 0, _props, 1, i);
                                _props[0] = idProp;
                                if (_filteredProps != null) {
                                    BeanPropertyWriter fp = _filteredProps[i];
                                    System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);
                                    _filteredProps[0] = fp;
                                }
                            }
                            break;
                        }
                    }
                    idType = idProp.getType();
                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);
                    oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());
                } else { // other types need to be simpler
                    gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);
                    oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen,
                            objectIdInfo.getAlwaysAsId());
                }
            }
            
            // Or change Filter Id in use?
            Object filterId = intr.findFilterId(accessor);
            if (filterId != null) {
                // but only consider case of adding a new filter id (no removal via annotation)
                if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {
                    newFilterId = filterId;
                }
            }
        }
        // either way, need to resolve serializer:
        BeanSerializerBase contextual = this;
        if (oiw != null) {
            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);
            oiw = oiw.withSerializer(ser);
            if (oiw != _objectIdWriter) {
                contextual = contextual.withObjectIdWriter(oiw);
            }
        }
        // And possibly add more properties to ignore
        if (ignorals != null && ignorals.length != 0) {
            contextual = contextual.withIgnorals(ignorals);
        }
        if (newFilterId != null) {
            contextual = contextual.withFilterId(newFilterId);
        }
        if (shape == null) {
            shape = _serializationShape;
        }
        if (shape == JsonFormat.Shape.ARRAY) {
            return contextual.asArraySerializer();
        }
        return contextual;
    }"
JacksonDatabind_79,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_79_buggy/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java,"@Override
     public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {
         JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);
         if (ref != null) {
             objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());
         }
         return objectIdInfo;
     }"
JacksonDatabind_80,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_80_buggy/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java,"        final AnnotationIntrospector ai = config.getAnnotationIntrospector();
        // for backwards compatibility, must allow null here:
        Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();
        
        HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();
        // start with registered subtypes (which have precedence)
        if (_registeredSubtypes != null) {
            for (NamedType subtype : _registeredSubtypes) {
                // is it a subtype of root type?
                if (rawBase.isAssignableFrom(subtype.getType())) { // yes
                    AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config,
                            subtype.getType());
                    _collectAndResolve(curr, subtype, config, ai, collected);
                }
            }
        }
"
JacksonDatabind_80,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_80_buggy/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java,"        final AnnotationIntrospector ai = config.getAnnotationIntrospector();
        Class<?> rawBase = baseType.getRawClass();

        // Need to keep track of classes that have been handled already 
        Set<Class<?>> typesHandled = new HashSet<Class<?>>();
        Map<String,NamedType> byName = new LinkedHashMap<String,NamedType>();

        // start with lowest-precedence, which is from type hierarchy
        NamedType rootType = new NamedType(rawBase, null);
        AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config,
                rawBase);
        _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);
        
        // then with definitions from property
            Collection<NamedType> st = ai.findSubtypes(property);
            if (st != null) {
                for (NamedType nt : st) {
                    ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());
                    _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);
                }            
        }
"
JacksonDatabind_81,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_81_buggy/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java,"        final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());
        if (serClass != null) {
            if (type.hasRawClass(serClass)) {
                // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of
                //    static typing this way
                type = type.withStaticTyping();
            } else {
                Class<?> currRaw = type.getRawClass();
                try {
                    // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,
                    //   may be needed here too in future?
                    if (serClass.isAssignableFrom(currRaw)) { // common case
                        type = tf.constructGeneralizedType(type, serClass);
                    } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well
                        type = tf.constructSpecializedType(type, serClass);
                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements
                    } else {
                        throw new JsonMappingException(null,
                                String.format(""Can not refine serialization type %s into %s; types not related"",
                                        type, serClass.getName()));
                    }
                } catch (IllegalArgumentException iae) {
                    throw new JsonMappingException(null,
                            String.format(""Failed to widen type %s with annotation (value %s), from '%s': %s"",
                                    type, serClass.getName(), a.getName(), iae.getMessage()),
                                    iae);
                }
            }
        }
"
JacksonDatabind_81,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_81_buggy/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java,"            final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());
            if (keyClass != null) {
                try {
                    keyType = tf.constructSpecializedType(keyType, keyClass);
                    type = ((MapLikeType) type).withKeyType(keyType);
                } catch (IllegalArgumentException iae) {
                    throw new JsonMappingException(null,
                            String.format(""Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s"",
                                    type, keyClass.getName(), a.getName(), iae.getMessage()),
                                    iae);
                }
            }
"
JacksonDatabind_81,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_81_buggy/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java,"            final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());
            if (keyClass != null) {
                if (keyType.hasRawClass(keyClass)) {
                    keyType = keyType.withStaticTyping();
                } else {
                    Class<?> currRaw = keyType.getRawClass();
                    try {
                        // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually
                        //   specialize (narrow) type sometimes, even if more commonly opposite
                        //   is needed.
                        if (keyClass.isAssignableFrom(currRaw)) { // common case
                            keyType = tf.constructGeneralizedType(keyType, keyClass);
                        } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well
                            keyType = tf.constructSpecializedType(keyType, keyClass);
                            // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements
                        } else {
                            throw new JsonMappingException(null,
                                    String.format(""Can not refine serialization key type %s into %s; types not related"",
                                            keyType, keyClass.getName()));
                        }
                    } catch (IllegalArgumentException iae) {
                        throw new JsonMappingException(null,
                                String.format(""Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s"",
                                        type, keyClass.getName(), a.getName(), iae.getMessage()),
                                        iae);
                    }
                }
                type = ((MapLikeType) type).withKeyType(keyType);
            }
"
JacksonDatabind_81,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_81_buggy/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java,"    protected StdTypeResolverBuilder _constructNoTypeResolverBuilder() {
        return StdTypeResolverBuilder.noTypeInfoBuilder();
    }
"
JacksonDatabind_81,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_81_buggy/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java,"        final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);
        
        // Ok: start by refining the main type itself; common to all types
        final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());
        if ((valueClass != null) && !type.hasRawClass(valueClass)) {
            try {
                type = tf.constructSpecializedType(type, valueClass);
            } catch (IllegalArgumentException iae) {
                throw new JsonMappingException(null,
                        String.format(""Failed to narrow type %s with annotation (value %s), from '%s': %s"",
                                type, valueClass.getName(), a.getName(), iae.getMessage()),
                                iae);
            }
        }
"
JacksonDatabind_81,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_81_buggy/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java,"        final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());
        if ((valueClass != null) && !type.hasRawClass(valueClass)) {
            try {
                type = tf.constructSpecializedType(type, valueClass);
            } catch (IllegalArgumentException iae) {
                throw new JsonMappingException(null,
                        String.format(""Failed to narrow type %s with annotation (value %s), from '%s': %s"",
                                type, valueClass.getName(), a.getName(), iae.getMessage()),
                                iae);
            }
        }
"
JacksonDatabind_81,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_81_buggy/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java,"           final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());
           if (contentClass != null) {
               if (contentType.hasRawClass(contentClass)) {
                   contentType = contentType.withStaticTyping();
               } else {
                   // 03-Apr-2016, tatu: As per [databind#1178], may need to actually
                   //   specialize (narrow) type sometimes, even if more commonly opposite
                   //   is needed.
                   Class<?> currRaw = contentType.getRawClass();
                   try {
                       if (contentClass.isAssignableFrom(currRaw)) { // common case
                           contentType = tf.constructGeneralizedType(contentType, contentClass);
                       } else if (currRaw.isAssignableFrom(contentClass)) { // specialization, ok as well
                           contentType = tf.constructSpecializedType(contentType, contentClass);
                           // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements
                       } else {
                           throw new JsonMappingException(null,
                                   String.format(""Can not refine serialization content type %s into %s; types not related"",
                                           contentType, contentClass.getName()));
                       }
                   } catch (IllegalArgumentException iae) { // shouldn't really happen
                       throw new JsonMappingException(null,
                               String.format(""Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s"",
                                       type, contentClass.getName(), a.getName(), iae.getMessage()),
                                       iae);
                   }
               }
               type = type.withContentType(contentType);
           }
"
JacksonDatabind_84,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_84_buggy/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java,"    public void setReference(JavaType ref)
    {
        // sanity check; should not be called multiple times
        if (_referencedType != null) {
            throw new IllegalStateException(""Trying to re-set self reference; old value = ""+_referencedType+"", new = ""+ref);
        }
        _referencedType = ref;
    }
"
JacksonDatabind_86,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_86_buggy/src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java,"    public void setReference(JavaType ref)
    {
        // sanity check; should not be called multiple times
        if (_referencedType != null) {
            throw new IllegalStateException(""Trying to re-set self reference; old value = ""+_referencedType+"", new = ""+ref);
        }
        _referencedType = ref;
    }
"
JacksonDatabind_87,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_87_buggy/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java,"package com.fasterxml.jackson.databind.util;

import java.text.DateFormat;
import java.text.FieldPosition;
import java.text.ParseException;
import java.text.ParsePosition;
import java.text.SimpleDateFormat;
import java.util.*;

import com.fasterxml.jackson.core.io.NumberInput;

/**
 * Default {@link DateFormat} implementation used by standard Date
 * serializers and deserializers. For serialization defaults to using
 * an ISO-8601 compliant format (format String ""yyyy-MM-dd'T'HH:mm:ss.SSSZ"")
 * and for deserialization, both ISO-8601 and RFC-1123.
 */
@SuppressWarnings(""serial"")
public class StdDateFormat
    extends DateFormat
{
    /* TODO !!! 24-Nov-2009, tatu: Should rewrite this class:
     * JDK date parsing is awfully brittle, and ISO-8601 is quite
     * permissive. The two don't mix, need to write a better one.
     */
    // 02-Oct-2014, tatu: Alas. While spit'n'polished a few times, still
    //   not really robust. But still in use.

    /**
     * Defines a commonly used date format that conforms
     * to ISO-8601 date formatting standard, when it includes basic undecorated
     * timezone definition
     */
    public final static String DATE_FORMAT_STR_ISO8601 = ""yyyy-MM-dd'T'HH:mm:ss.SSSZ"";

    /**
     * Same as 'regular' 8601, but handles 'Z' as an alias for ""+0000""
     * (or ""UTC"")
     */
    protected final static String DATE_FORMAT_STR_ISO8601_Z = ""yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"";

    /**
     * Same as 'regular' 8601 except misses timezone altogether
     *
     * @since 2.8.10
     */

    /**
     * ISO-8601 with just the Date part, no time
     */
    protected final static String DATE_FORMAT_STR_PLAIN = ""yyyy-MM-dd"";

    /**
     * This constant defines the date format specified by
     * RFC 1123 / RFC 822.
     */
    protected final static String DATE_FORMAT_STR_RFC1123 = ""EEE, dd MMM yyyy HH:mm:ss zzz"";

    /**
     * For error messages we'll also need a list of all formats.
     */
    protected final static String[] ALL_FORMATS = new String[] {
        DATE_FORMAT_STR_ISO8601,
        DATE_FORMAT_STR_ISO8601_Z,
        DATE_FORMAT_STR_RFC1123,
        DATE_FORMAT_STR_PLAIN
    };

    /**
     * By default we use UTC for everything, with Jackson 2.7 and later
     * (2.6 and earlier relied on GMT)
     */
    private final static TimeZone DEFAULT_TIMEZONE;
    static {
        DEFAULT_TIMEZONE = TimeZone.getTimeZone(""UTC""); // since 2.7
    }

    private final static Locale DEFAULT_LOCALE = Locale.US;

    protected final static DateFormat DATE_FORMAT_RFC1123;

    protected final static DateFormat DATE_FORMAT_ISO8601;
    protected final static DateFormat DATE_FORMAT_ISO8601_Z;

    protected final static DateFormat DATE_FORMAT_PLAIN;

    /* Let's construct ""blueprint"" date format instances: can not be used
     * as is, due to thread-safety issues, but can be used for constructing
     * actual instances more cheaply (avoids re-parsing).
     */
    static {
        /* Another important thing: let's force use of default timezone for
         * baseline DataFormat objects
         */

        DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123, DEFAULT_LOCALE);
        DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE);
        DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601, DEFAULT_LOCALE);
        DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);
        DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z, DEFAULT_LOCALE);
        DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE);
        DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN, DEFAULT_LOCALE);
        DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE);
    }
    
    /**
     * A singleton instance can be used for cloning purposes, as a blueprint of sorts.
     */
    public final static StdDateFormat instance = new StdDateFormat();
    
    /**
     * Caller may want to explicitly override timezone to use; if so,
     * we will have non-null value here.
     */
    protected transient TimeZone _timezone;

    protected final Locale _locale;

    /**
     * Explicit override for leniency, if specified.
     *<p>
     * Can not be `final` because {@link #setLenient(boolean)} returns
     * `void`.
     *
     * @since 2.7
     */
    protected Boolean _lenient;
    
    protected transient DateFormat _formatRFC1123;
    protected transient DateFormat _formatISO8601;
    protected transient DateFormat _formatISO8601_z;
    protected transient DateFormat _formatPlain;

    /*
    /**********************************************************
    /* Life cycle, accessing singleton ""standard"" formats
    /**********************************************************
     */

    public StdDateFormat() {
        _locale = DEFAULT_LOCALE;
    }

    @Deprecated // since 2.7
    public StdDateFormat(TimeZone tz, Locale loc) {
        _timezone = tz;
        _locale = loc;
    }

    protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient) {
        _timezone = tz;
        _locale = loc;
        _lenient = lenient;
    }
    
    public static TimeZone getDefaultTimeZone() {
        return DEFAULT_TIMEZONE;
    }
    
    /**
     * Method used for creating a new instance with specified timezone;
     * if no timezone specified, defaults to the default timezone (UTC).
     */
    public StdDateFormat withTimeZone(TimeZone tz) {
        if (tz == null) {
            tz = DEFAULT_TIMEZONE;
        }
        if ((tz == _timezone) || tz.equals(_timezone)) {
            return this;
        }
        return new StdDateFormat(tz, _locale, _lenient);
    }

    public StdDateFormat withLocale(Locale loc) {
        if (loc.equals(_locale)) {
            return this;
        }
        return new StdDateFormat(_timezone, loc, _lenient);
    }
    
    @Override
    public StdDateFormat clone() {
        /* Although there is that much state to share, we do need to
         * orchestrate a bit, mostly since timezones may be changed
         */
        return new StdDateFormat(_timezone, _locale, _lenient);
    }

    /**
     * @deprecated Since 2.4; use variant that takes Locale
     */
    @Deprecated
    public static DateFormat getISO8601Format(TimeZone tz) {
        return getISO8601Format(tz, DEFAULT_LOCALE);
    }

    /**
     * Method for getting a non-shared DateFormat instance
     * that uses specified timezone and can handle simple ISO-8601
     * compliant date format.
     * 
     * @since 2.4
     */
    public static DateFormat getISO8601Format(TimeZone tz, Locale loc) {
        return _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, tz, loc, null);
    }

    /**
     * Method for getting a non-shared DateFormat instance
     * that uses specific timezone and can handle RFC-1123
     * compliant date format.
     * 
     * @since 2.4
     */
    public static DateFormat getRFC1123Format(TimeZone tz, Locale loc) {
        return _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,
                tz, loc, null);
    }

    /**
     * @deprecated Since 2.4; use variant that takes Locale
     */
    @Deprecated
    public static DateFormat getRFC1123Format(TimeZone tz) {
        return getRFC1123Format(tz, DEFAULT_LOCALE);
    }

    /*
    /**********************************************************
    /* Public API, configuration
    /**********************************************************
     */

    @Override // since 2.6
    public TimeZone getTimeZone() {
        return _timezone;
    }

    @Override
    public void setTimeZone(TimeZone tz)
    {
        /* DateFormats are timezone-specific (via Calendar contained),
         * so need to reset instances if timezone changes:
         */
        if (!tz.equals(_timezone)) {
            _clearFormats();
            _timezone = tz;
        }
    }

    /**
     * Need to override since we need to keep track of leniency locally,
     * and not via underlying {@link Calendar} instance like base class
     * does.
     */
    @Override // since 2.7
    public void setLenient(boolean enabled) {
        Boolean newValue = enabled;
        if (_lenient != newValue) {
            _lenient = newValue;
            // and since leniency settings may have been used:
            _clearFormats();
        }
    }

    @Override // since 2.7
    public boolean isLenient() {
        if (_lenient == null) {
            // default is, I believe, true
            return true;
        }
        return _lenient.booleanValue();
    }

    /*
    /**********************************************************
    /* Public API, parsing
    /**********************************************************
     */

    @Override
    public Date parse(String dateStr) throws ParseException
    {
        dateStr = dateStr.trim();
        ParsePosition pos = new ParsePosition(0);

        Date dt;

        if (looksLikeISO8601(dateStr)) { // also includes ""plain""
            dt = parseAsISO8601(dateStr, pos, true);
        } else {
            // Also consider ""stringified"" simple time stamp
            int i = dateStr.length();
            while (--i >= 0) {
                char ch = dateStr.charAt(i);
                if (ch < '0' || ch > '9') {
                    // 07-Aug-2013, tatu: And [databind#267] points out that negative numbers should also work
                    if (i > 0 || ch != '-') {
                        break;
                    }
                }
            }
            if ((i < 0)
                // let's just assume negative numbers are fine (can't be RFC-1123 anyway); check length for positive
                    && (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false))) {
                dt = new Date(Long.parseLong(dateStr));
            } else {
                // Otherwise, fall back to using RFC 1123
                dt = parseAsRFC1123(dateStr, pos);
            }
        }
        if (dt != null) {
            return dt;
        }

        StringBuilder sb = new StringBuilder();
        for (String f : ALL_FORMATS) {
            if (sb.length() > 0) {
                sb.append(""\"", \"""");
            } else {
                sb.append('""');
            }
            sb.append(f);
        }
        sb.append('""');
        throw new ParseException
            (String.format(""Can not parse date \""%s\"": not compatible with any of standard forms (%s)"",
                           dateStr, sb.toString()), pos.getErrorIndex());
    }

    @Override
    public Date parse(String dateStr, ParsePosition pos)
    {
        if (looksLikeISO8601(dateStr)) { // also includes ""plain""
            try {
                return parseAsISO8601(dateStr, pos, false);
            } catch (ParseException e) { // will NOT be thrown due to false but is declared...
                return null;
            }
        }
        // Also consider ""stringified"" simple time stamp
        int i = dateStr.length();
        while (--i >= 0) {
            char ch = dateStr.charAt(i);
            if (ch < '0' || ch > '9') {
                // 07-Aug-2013, tatu: And [databind#267] points out that negative numbers should also work
                if (i > 0 || ch != '-') {
                    break;
                }
            }
        }
        if (i < 0) { // all digits
            // let's just assume negative numbers are fine (can't be RFC-1123 anyway); check length for positive
            if (dateStr.charAt(0) == '-' || NumberInput.inLongRange(dateStr, false)) {
                return new Date(Long.parseLong(dateStr));
            }
        }
        // Otherwise, fall back to using RFC 1123
        return parseAsRFC1123(dateStr, pos);
    }

    /*
    /**********************************************************
    /* Public API, writing
    /**********************************************************
     */
    
    @Override
    public StringBuffer format(Date date, StringBuffer toAppendTo,
            FieldPosition fieldPosition)
    {
        if (_formatISO8601 == null) {
            _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601,
                    _timezone, _locale, _lenient);
        }
        return _formatISO8601.format(date, toAppendTo, fieldPosition);
    }

    /*
    /**********************************************************
    /* Std overrides
    /**********************************************************
     */
    
    @Override
    public String toString() {
        String str = ""DateFormat ""+getClass().getName();
        TimeZone tz = _timezone;
        if (tz != null) {
            str += "" (timezone: ""+tz+"")"";
        }
        str += ""(locale: ""+_locale+"")"";
        return str;
    }

    @Override // since 2.7[.2], as per [databind#1130]
    public boolean equals(Object o) {
        return (o == this);
    }

    @Override // since 2.7[.2], as per [databind#1130]
    public int hashCode() {
        return System.identityHashCode(this);
    }

    /*
    /**********************************************************
    /* Helper methods
    /**********************************************************
     */

    /**
     * Overridable helper method used to figure out which of supported
     * formats is the likeliest match.
     */
    protected boolean looksLikeISO8601(String dateStr)
    {
        if (dateStr.length() >= 5
            && Character.isDigit(dateStr.charAt(0))
            && Character.isDigit(dateStr.charAt(3))
            && dateStr.charAt(4) == '-'
            ) {
            return true;
        }
        return false;
    }

    protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors)
            throws ParseException
    {
        /* 21-May-2009, tatu: DateFormat has very strict handling of
         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.
         */

        /* First: do we have ""zulu"" format ('Z' == ""UTC"")? If yes, that's
         * quite simple because we already set date format timezone to be
         * UTC, and hence can just strip out 'Z' altogether
         */
        int len = dateStr.length();
        char c = dateStr.charAt(len-1);
        DateFormat df;
        String formatStr;

        // Need to support ""plain"" date...
        if (len <= 10 && Character.isDigit(c)) {
            df = _formatPlain;
            formatStr = DATE_FORMAT_STR_PLAIN;
            if (df == null) {
                df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr,
                        _timezone, _locale, _lenient);
            }
        } else if (c == 'Z') {
            df = _formatISO8601_z;
            formatStr = DATE_FORMAT_STR_ISO8601_Z;
            if (df == null) {
                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
                //    must use UTC, not whatever is configured as default timezone
                //    (because we know `Z` identifier is used)
                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,
                        DEFAULT_TIMEZONE, _locale, _lenient);
            }
            // may be missing milliseconds... if so, add
            if (dateStr.charAt(len-4) == ':') {
                StringBuilder sb = new StringBuilder(dateStr);
                sb.insert(len-1, "".000"");
                dateStr = sb.toString();
            }
        } else {
            // Let's see if we have timezone indicator or not...
            if (hasTimeZone(dateStr)) {
                c = dateStr.charAt(len-3);
                if (c == ':') { // remove optional colon
                    // remove colon
                    StringBuilder sb = new StringBuilder(dateStr);
                    sb.delete(len-3, len-2);
                    dateStr = sb.toString();
                } else if (c == '+' || c == '-') { // missing minutes
                    // let's just append '00'
                    dateStr += ""00"";
                }
                // Milliseconds partial or missing; and even seconds are optional
                len = dateStr.length();
                // remove 'T', '+'/'-' and 4-digit timezone-offset
                int timeLen = len - dateStr.lastIndexOf('T') - 6;
                if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss
                    int offset = len - 5; // insertion offset, before tz-offset
                    StringBuilder sb = new StringBuilder(dateStr);
                    switch (timeLen) {
                    case 11:
                        sb.insert(offset, '0'); break;
                    case 10:
                        sb.insert(offset, ""00""); break;
                    case 9: // is this legal? (just second fraction marker)
                        sb.insert(offset, ""000""); break;
                    case 8:
                        sb.insert(offset, "".000""); break;
                    case 7: // not legal to have single-digit second
                        break;
                    case 6: // probably not legal, but let's allow
                        sb.insert(offset, ""00.000"");
                    case 5: // is legal to omit seconds
                        sb.insert(offset, "":00.000"");
                    }
                    dateStr = sb.toString();
                }
                df = _formatISO8601;
                formatStr = DATE_FORMAT_STR_ISO8601;
                if (_formatISO8601 == null) {
                    df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr,
                            _timezone, _locale, _lenient);
                }
            } else {
                // If not, plain date, no timezone
                StringBuilder sb = new StringBuilder(dateStr);
                int timeLen = len - dateStr.lastIndexOf('T') - 1;
                // And possible also millisecond part if missing
                if (timeLen < 12) { // missing, or partial
                    switch (timeLen) {
                    case 11: sb.append('0');
                    case 10: sb.append('0');
                    case 9: sb.append('0');
                        break;
                    default:
                        sb.append("".000"");
                    }
                }
                sb.append('Z');
                dateStr = sb.toString();
                df = _formatISO8601_z;
                formatStr = DATE_FORMAT_STR_ISO8601_Z;
                if (df == null) {
                    // 10-Jun-2017, tatu: As per [databind#1651], when using this format,
                    //    must use UTC, not whatever is configured as default timezone
                    //    (because we know `Z` identifier is used)
                    df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,
                            DEFAULT_TIMEZONE, _locale, _lenient);
                }
            }
        }
        Date dt = df.parse(dateStr, pos);
        // 22-Dec-2015, tatu: With non-lenient, may get null
        if (dt == null) {
            throw new ParseException
            (String.format(""Can not parse date \""%s\"": while it seems to fit format '%s', parsing fails (leniency? %s)"",
                           dateStr, formatStr, _lenient),
               pos.getErrorIndex());
        }
        return dt;
    }

    protected Date parseAsRFC1123(String dateStr, ParsePosition pos)
    {
        if (_formatRFC1123 == null) {
            _formatRFC1123 = _cloneFormat(DATE_FORMAT_RFC1123, DATE_FORMAT_STR_RFC1123,
                    _timezone, _locale, _lenient);
        }
        return _formatRFC1123.parse(dateStr, pos);
    }

    private final static boolean hasTimeZone(String str)
    {
        // Only accept ""+hh"", ""+hhmm"" and ""+hh:mm"" (and with minus), so
        int len = str.length();
        if (len >= 6) {
            char c = str.charAt(len-6);
            if (c == '+' || c == '-') return true;
            c = str.charAt(len-5);
            if (c == '+' || c == '-') return true;
            c = str.charAt(len-3);
            if (c == '+' || c == '-') return true;
        }
        return false;
    }

    private final static DateFormat _cloneFormat(DateFormat df, String format,
            TimeZone tz, Locale loc, Boolean lenient)
    {
        if (!loc.equals(DEFAULT_LOCALE)) {
            df = new SimpleDateFormat(format, loc);
            df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);
        } else {
            df = (DateFormat) df.clone();
            if (tz != null) {
                df.setTimeZone(tz);
            }
        }
        if (lenient != null) {
            df.setLenient(lenient.booleanValue());
        }
        return df;
    }

    protected void _clearFormats() {
        _formatRFC1123 = null;
        _formatISO8601 = null;
        _formatISO8601_z = null;

        _formatPlain = null;
    }
}

"
JacksonDatabind_90,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_90_buggy/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java,"    public boolean canInstantiate() {
        return canCreateUsingDefault()
                || canCreateUsingDelegate() 
                || canCreateFromObjectWith() || canCreateFromString()
                || canCreateFromInt() || canCreateFromLong()
                || canCreateFromDouble() || canCreateFromBoolean();
    }
"
JacksonDatabind_90,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_90_buggy/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java,"    public boolean canCreateFromObjectWith() {
        return (_withArgsCreator != null);
    }
"
JacksonDatabind_92,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_92_buggy/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java,"    public final static BeanDeserializerFactory instance = new BeanDeserializerFactory(
            new DeserializerFactoryConfig());

    public BeanDeserializerFactory(DeserializerFactoryConfig config) {
        super(config);
    }
"
JacksonDatabind_94,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_94_buggy/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java,"public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException
    {
        // There are certain nasty classes that could cause problems, mostly
        // via default typing -- catch them here.
        final Class<?> raw = type.getRawClass();
        String full = raw.getName();

        main_check:
        do {
            if (_cfgIllegalClassNames.contains(full)) {
                break;
            }

            // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling
            //    for some Spring framework types
            // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces
            if (raw.isInterface()) {
                ;
            } else if (full.startsWith(PREFIX_SPRING)) {
                for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){
                    String name = cls.getSimpleName();
                    // looking for ""AbstractBeanFactoryPointcutAdvisor"" but no point to allow any is there?
                    if (""AbstractPointcutAdvisor"".equals(name)
                            // ditto  for ""FileSystemXmlApplicationContext"": block all ApplicationContexts
                             || ""AbstractApplicationContext"".equals(name)) {
                         break main_check;
                     }
                 // [databind#1737]; more 3rd party
                 // s.add(""com.mchange.v2.c3p0.JndiRefForwardingDataSource"");
                 // s.add(""com.mchange.v2.c3p0.WrapperConnectionPoolDataSource"");
                 // [databind#1931]; more 3rd party
                 // com.mchange.v2.c3p0.ComboPooledDataSource
                 // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource 
                 }
             }
             return;
        } while (false);

        throw JsonMappingException.from(ctxt,
                String.format(""Illegal type (%s) to deserialize: prevented for security reasons"", full));
    }"
JacksonDatabind_95,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_95_buggy/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java,"        final Class<?> rawBase = baseType.getRawClass();
        if (rawBase == subclass) {
            return baseType;
        }
"
JacksonDatabind_95,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_95_buggy/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java,"    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {
        int len = parameterClasses.length;
        JavaType[] pt = new JavaType[len];
        for (int i = 0; i < len; ++i) {
            pt[i] = _fromClass(null, parameterClasses[i], null);
        }
        return constructParametricType(parametrized, pt);
    }
"
JacksonDatabind_95,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_95_buggy/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java,"    protected JavaType parseType(MyTokenizer tokens)
        throws IllegalArgumentException
    {
        if (!tokens.hasMoreTokens()) {
            throw _problem(tokens, ""Unexpected end-of-string"");
        }
        Class<?> base = findClass(tokens.nextToken(), tokens);

        // either end (ok, non generic type), or generics
        if (tokens.hasMoreTokens()) {
            String token = tokens.nextToken();
            if (""<"".equals(token)) {
                List<JavaType> parameterTypes = parseTypes(tokens);
                TypeBindings b = TypeBindings.create(base, parameterTypes);
                return _factory._fromClass(null, base, b);
            }
            // can be comma that separates types, or closing '>'
            tokens.pushBack(token);
        }
        return _factory._fromClass(null, base, null);
    }
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java,"    protected IOException _throwAsIOE(JsonParser p, Exception e) throws IOException
    {
        ClassUtil.throwIfIOE(e);
        ClassUtil.throwIfRTE(e);
        // let's wrap the innermost problem
        Throwable th = ClassUtil.getRootCause(e);
        throw JsonMappingException.from(p, th.getMessage(), th);
    }
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java,"    protected java.util.Date _parseDate(String value, DeserializationContext ctxt)
        throws IOException
    {
        try {
            // Take empty Strings to mean 'empty' Value, usually 'null':
            if (_isEmptyOrTextualNull(value)) {
                return (java.util.Date) getNullValue(ctxt);
            }
            return ctxt.parseDate(value);
        } catch (IllegalArgumentException iae) {
            return (java.util.Date) ctxt.handleWeirdStringValue(_valueClass, value,
                    ""not a valid representation (error: %s)"",
                    iae.getMessage());
        }
    }
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java,"    public Object deserializeKey(String key, DeserializationContext ctxt)
        throws IOException
    {
        if (key == null) { // is this even legal call?
            return null;
        }
        try {
            Object result = _parse(key, ctxt);
            if (result != null) {
                return result;
            }
        } catch (Exception re) {
            return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation, problem: (%s) %s"",
                    re.getClass().getName(),
                    re.getMessage());
        }
        if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {
            return null;
        }
        return ctxt.handleWeirdKey(_keyClass, key, ""not a valid representation"");
    }
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java,"    protected JsonMappingException wrapException(Throwable t)
    {
        // 05-Nov-2015, tatu: This used to always unwrap the whole exception, but now only
        //   does so if and until `JsonMappingException` is found.
        for (Throwable curr = t; curr != null; curr = curr.getCause()) {
            if (curr instanceof JsonMappingException) {
                return (JsonMappingException) curr;
            }
        }
        return new JsonMappingException(null,
                ""Instantiation of ""+getValueTypeDesc()+"" value failed: ""+t.getMessage(), t);
    }
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java,"    public static Object defaultValue(Class<?> cls)
    {
        if (cls == Integer.TYPE) {
            return Integer.valueOf(0);
        }
        if (cls == Long.TYPE) {
            return Long.valueOf(0L);
        }
        if (cls == Boolean.TYPE) {
            return Boolean.FALSE;
        }
        if (cls == Double.TYPE) {
            return Double.valueOf(0.0);
        }
        if (cls == Float.TYPE) {
            return Float.valueOf(0.0f);
        }
        if (cls == Byte.TYPE) {
            return Byte.valueOf((byte) 0);
        }
        if (cls == Short.TYPE) {
            return Short.valueOf((short) 0);
        }
        if (cls == Character.TYPE) {
            return '\0';
        }
        throw new IllegalArgumentException(""Class ""+cls.getName()+"" is not a primitive type"");
    }
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java,"    public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException
    {
        if (filter == null) {
            return true;
        }
        // should let filter decide what to do with nulls:
        // But just case, let's handle unexpected (from our perspective) problems explicitly
        try {
            return filter.equals(null);
        } catch (Throwable t) {
            String msg = String.format(
""Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s"",
filter.getClass().getName(), t.getClass().getName(), t.getMessage());
            reportBadDefinition(filter.getClass(), msg, t);
            return false; // never gets here
        }
    }
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java,"    private IOException _wrapAsIOE(JsonGenerator g, Exception e) {
        if (e instanceof IOException) {
            return (IOException) e;
        }
        String msg = e.getMessage();
        if (msg == null) {
            msg = ""[no message for ""+e.getClass().getName()+""]"";
        }
        return new JsonMappingException(g, msg, e);
    }
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java,"    protected BeanPropertyWriter buildWriter(SerializerProvider prov,
            BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,
            TypeSerializer typeSer, TypeSerializer contentTypeSer,
            AnnotatedMember am, boolean defaultUseStaticTyping)
        throws JsonMappingException
    {
        // do we have annotation that forces type to use (to declared type or its super type)?
        JavaType serializationType;
        try {
            serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);
        } catch (JsonMappingException e) {
            if (propDef == null) {
                return prov.reportBadDefinition(declaredType, e.getMessage());
            }
            return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());
        }

        // Container types can have separate type serializers for content (value / element) type
        if (contentTypeSer != null) {
            // 04-Feb-2010, tatu: Let's force static typing for collection, if there is
            //    type information for contents. Should work well (for JAXB case); can be
            //    revisited if this causes problems.
            if (serializationType == null) {
//                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());
                serializationType = declaredType;
            }
            JavaType ct = serializationType.getContentType();
            // Not exactly sure why, but this used to occur; better check explicitly:
            if (ct == null) {
                prov.reportBadPropertyDefinition(_beanDesc, propDef,
                        ""serialization type ""+serializationType+"" has no content"");
            }
            serializationType = serializationType.withContentTypeHandler(contentTypeSer);
            ct = serializationType.getContentType();
        }

        Object valueToSuppress = null;
        boolean suppressNulls = false;

        // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement
        JavaType actualType = (serializationType == null) ? declaredType : serializationType;
        
        // 17-Mar-2017: [databind#1522] Allow config override per property type
        AnnotatedMember accessor = propDef.getAccessor();
        if (accessor == null) {
            // neither Setter nor ConstructorParameter are expected here
            return prov.reportBadPropertyDefinition(_beanDesc, propDef,
                    ""could not determine property type"");
        }
        Class<?> rawPropertyType = accessor.getRawType();

        // 17-Aug-2016, tatu: Default inclusion covers global default (for all types), as well
        //   as type-default for enclosing POJO. What we need, then, is per-type default (if any)
        //   for declared property type... and finally property annotation overrides
        JsonInclude.Value inclV = _config.getDefaultInclusion(actualType.getRawClass(),
                rawPropertyType, _defaultInclusion);

        // property annotation override
        
        inclV = inclV.withOverrides(propDef.findInclusion());

        JsonInclude.Include inclusion = inclV.getValueInclusion();
        if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...
            inclusion = JsonInclude.Include.ALWAYS;
        }
        switch (inclusion) {
        case NON_DEFAULT:
            // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,
            //    so that if enclosing class has this, we may need to access values of property,
            //    whereas for global defaults OR per-property overrides, we have more
            //    static definition. Sigh.
            // First: case of class/type specifying it; try to find POJO property defaults
            Object defaultBean;

            // 16-Oct-2016, tatu: Note: if we cannot for some reason create ""default instance"",
            //    revert logic to the case of general/per-property handling, so both
            //    type-default AND null are to be excluded.
            //    (as per [databind#1417]
            if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) {
                // 07-Sep-2016, tatu: may also need to front-load access forcing now
                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {
                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
                }
                try {
                    valueToSuppress = am.getValue(defaultBean);
                } catch (Exception e) {
                    _throwWrapped(e, propDef.getName(), defaultBean);
                }
            } else {
                valueToSuppress = BeanUtil.getDefaultValue(actualType);
                suppressNulls = true;
            }
            if (valueToSuppress == null) {
                suppressNulls = true;
            } else {
                if (valueToSuppress.getClass().isArray()) {
                    valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);
                }
            }
            break;
        case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals
            // always suppress nulls
            suppressNulls = true;
            // and for referential types, also ""empty"", which in their case means ""absent""
            if (actualType.isReferenceType()) {
                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;
            }
            break;
        case NON_EMPTY:
            // always suppress nulls
            suppressNulls = true;
            // but possibly also 'empty' values:
            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;
            break;
        case CUSTOM: // new with 2.9
            valueToSuppress = prov.includeFilterInstance(propDef, inclV.getValueFilter());
            if (valueToSuppress == null) { // is this legal?
                suppressNulls = true;
            } else {
                suppressNulls = prov.includeFilterSuppressNulls(valueToSuppress);
            }
            break;
        case NON_NULL:
            suppressNulls = true;
            // fall through
        case ALWAYS: // default
        default:
            // we may still want to suppress empty collections
            if (actualType.isContainerType()
                    && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {
                valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;
            }
            break;
        }
        Class<?>[] views = propDef.findViews();
        if (views == null) {
            views = _beanDesc.findDefaultViews();
        }
        BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,
                am, _beanDesc.getClassAnnotations(), declaredType,
                ser, typeSer, serializationType, suppressNulls, valueToSuppress, views);

        // How about custom null serializer?
        Object serDef = _annotationIntrospector.findNullSerializer(am);
        if (serDef != null) {
            bpw.assignNullSerializer(prov.serializerInstance(am, serDef));
        }
        // And then, handling of unwrapping
        NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);
        if (unwrapper != null) {
            bpw = bpw.unwrappingWriter(unwrapper);
        }
        return bpw;
    }
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java,"    protected void _throwAsIOE(JsonParser p, Exception e, Object value) throws IOException
    {
        if (e instanceof IllegalArgumentException) {
            String actType = ClassUtil.classNameOf(value);
            StringBuilder msg = new StringBuilder(""Problem deserializing property '"")
                    .append(getName())
                    .append(""' (expected type: "")
                    .append(getType())
                    .append(""; actual type: "")
                    .append(actType).append("")"");
            String origMsg = e.getMessage();
            if (origMsg != null) {
                msg.append("", problem: "")
                    .append(origMsg);
            } else {
                msg.append("" (no error message provided)"");
            }
            throw JsonMappingException.from(p, msg.toString(), e);
        }
        _throwAsIOE(p, e);
    }
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java,"    public Object instantiateBean(boolean fixAccess) {
        AnnotatedConstructor ac = _classInfo.getDefaultConstructor();
        if (ac == null) {
            return null;
        }
        if (fixAccess) {
            ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
        }
        try {
            return ac.getAnnotated().newInstance();
        } catch (Exception e) {
            Throwable t = e;
            while (t.getCause() != null) {
                t = t.getCause();
            }
            ClassUtil.throwIfError(t);
            ClassUtil.throwIfRTE(t);
            throw new IllegalArgumentException(""Failed to instantiate bean of type ""
                    +_classInfo.getAnnotated().getName()+"": (""+t.getClass().getName()+"") ""
                    +t.getMessage(), t);
        }
    }
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java,"    protected void _throwAsIOE(Exception e, Object propName, Object value)
        throws IOException
    {
        if (e instanceof IllegalArgumentException) {
            String actType = ClassUtil.classNameOf(value);
            StringBuilder msg = new StringBuilder(""Problem deserializing \""any\"" property '"").append(propName);
            msg.append(""' of class ""+getClassName()+"" (expected type: "").append(_type);
            msg.append(""; actual type: "").append(actType).append("")"");
            String origMsg = e.getMessage();
            if (origMsg != null) {
                msg.append("", problem: "").append(origMsg);
            } else {
                msg.append("" (no error message provided)"");
            }
            throw new JsonMappingException(null, msg.toString(), e);
        }
        ClassUtil.throwIfIOE(e);
        ClassUtil.throwIfRTE(e);
        // let's wrap the innermost problem
        Throwable t = ClassUtil.getRootCause(e);
        throw new JsonMappingException(null, t.getMessage(), t);
    }
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java,"    protected double _parseDouble(String key) throws IllegalArgumentException {
        return NumberInput.parseDouble(key);
    }
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java,"    protected JsonDeserializer<Object> buildBuilderBasedDeserializer(
    		DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc)
        throws JsonMappingException
    {
        // Creators, anyone? (to create builder itself)
        ValueInstantiator valueInstantiator;
        try {
            valueInstantiator = findValueInstantiator(ctxt, builderDesc);
        } catch (NoClassDefFoundError error) {
            return new ErrorThrowingDeserializer(error);
        } catch (IllegalArgumentException e) {
            // 05-Apr-2017, tatu: Although it might appear cleaner to require collector
            //   to throw proper exception, it doesn't actually have reference to this
            //   instance so...
            throw InvalidDefinitionException.from(ctxt.getParser(),
                    e.getMessage(),
                    builderDesc, null);
        }
        final DeserializationConfig config = ctxt.getConfig();
        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);
        builder.setValueInstantiator(valueInstantiator);
         // And then ""with methods"" for deserializing from JSON Object
        addBeanProps(ctxt, builderDesc, builder);
        addObjectIdReader(ctxt, builderDesc, builder);
        
        // managed/back reference fields/setters need special handling... first part
        addBackReferenceProperties(ctxt, builderDesc, builder);
        addInjectables(ctxt, builderDesc, builder);

        JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();
        final String buildMethodName = (builderConfig == null) ?
                JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;
        
        // and lastly, find build method to use:
        AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);
        if (buildMethod != null) { // note: can't yet throw error; may be given build method
            if (config.canOverrideAccessModifiers()) {
            	ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
            }
        }
        builder.setPOJOBuilder(buildMethod, builderConfig);
        // this may give us more information...
        if (_factoryConfig.hasDeserializerModifiers()) {
            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {
                builder = mod.updateBuilder(config, builderDesc, builder);
            }
        }
        JsonDeserializer<?> deserializer = builder.buildBuilderBased(
        		valueType, buildMethodName);

        // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:
        if (_factoryConfig.hasDeserializerModifiers()) {
            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {
                deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);
            }
        }
        return (JsonDeserializer<Object>) deserializer;
    }
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java,"        final DeserializationConfig config = ctxt.getConfig();
        if (_factoryConfig.hasDeserializerModifiers()) {
            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {
                builder = mod.updateBuilder(config, beanDesc, builder);
            }
        }
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java,"    public TypeDeserializer findTypeDeserializer(DeserializationConfig config,
            JavaType baseType)
        throws JsonMappingException
    {
        BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());
        AnnotatedClass ac = bean.getClassInfo();
        AnnotationIntrospector ai = config.getAnnotationIntrospector();
        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);

        // Ok: if there is no explicit type info handler, we may want to
        // use a default. If so, config object knows what to use.
        Collection<NamedType> subtypes = null;
        if (b == null) {
            b = config.getDefaultTyper(baseType);
            if (b == null) {
                return null;
            }
        } else {
            subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);
        }
        // May need to figure out default implementation, if none found yet
        // (note: check for abstract type is not 100% mandatory, more of an optimization)
        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {
            JavaType defaultType = mapAbstractType(config, baseType);
            if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {
                b = b.defaultImpl(defaultType.getRawClass());
            }
        }
        // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,
        //    map to better type here
        try {
            return b.buildTypeDeserializer(config, baseType, subtypes);
        } catch (IllegalArgumentException e0) {
            InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null,
                    e0.getMessage(), baseType);
            e.initCause(e0);
            throw e;
        }
    }
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java,"    protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type)
        throws JsonMappingException
    {        
        JsonSerializer<Object> ser;
        try {
            ser = _createUntypedSerializer(type);
        } catch (IllegalArgumentException iae) {
            // We better only expose checked exceptions, since those
            // are what caller is expected to handle
            ser = null;
            reportMappingProblem(iae, iae.getMessage());
        }
    
        if (ser != null) {
            // 21-Dec-2015, tatu: Should we also cache using raw key?
            _serializerCache.addAndResolveNonTypedSerializer(type, ser, this);
        }
        return ser;
    }
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java,"    protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt,
            DeserializerFactory factory, JavaType type)
        throws JsonMappingException
    {
        JsonDeserializer<Object> deser;
        try {
            deser = _createDeserializer(ctxt, factory, type);
        } catch (IllegalArgumentException iae) {
            // We better only expose checked exceptions, since those
            // are what caller is expected to handle
            throw JsonMappingException.from(ctxt, iae.getMessage(), iae);
        }
        if (deser == null) {
            return null;
        }
        /* cache resulting deserializer? always true for ""plain"" BeanDeserializer
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java,"    protected JsonSerializer<Object> _createAndCacheUntypedSerializer(Class<?> rawType)
        throws JsonMappingException
    {
        JavaType fullType = _config.constructType(rawType);
        JsonSerializer<Object> ser;
        try {
            ser = _createUntypedSerializer(fullType);
        } catch (IllegalArgumentException iae) {
            // We better only expose checked exceptions, since those
            // are what caller is expected to handle
            ser = null; // doesn't matter but compiler whines otherwise
            reportMappingProblem(iae, iae.getMessage());
        }

        if (ser != null) {
            // 21-Dec-2015, tatu: Best to cache for both raw and full-type key
            _serializerCache.addAndResolveNonTypedSerializer(rawType, fullType, ser, this);
        }
        return ser;
    }
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java,"    public static JsonMappingException wrapWithPath(Throwable src, Reference ref)
    {
        JsonMappingException jme;
        if (src instanceof JsonMappingException) {
            jme = (JsonMappingException) src;
        } else {
            // [databind#2128]: try to avoid duplication
            String msg = src.getMessage();
            // Let's use a more meaningful placeholder if all we have is null
            if (msg == null || msg.length() == 0) {
                msg = ""(was ""+src.getClass().getName()+"")"";
            }
            // 17-Aug-2015, tatu: Let's also pass the processor (parser/generator) along
            Closeable proc = null;
            if (src instanceof JsonProcessingException) {
                Object proc0 = ((JsonProcessingException) src).getProcessor();
                if (proc0 instanceof Closeable) {
                    proc = (Closeable) proc0;
                }
            }
            jme = new JsonMappingException(proc, msg, src);
        }
        jme.prependPath(ref);
        return jme;
    }
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java,"    public static JsonMappingException fromUnexpectedIOE(IOException src) {
        return new JsonMappingException(null,
                String.format(""Unexpected IOException (of type %s): %s"",
                        src.getClass().getName(),
                        src.getMessage()));
    }
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java,"        final JavaType type = constructType(instClass);
        String excMsg;
        if (cause == null) {
            excMsg = ""N/A"";
        } else if ((excMsg = cause.getMessage()) == null) {
            excMsg = ClassUtil.nameOf(cause.getClass());
        }
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java,"    public Date parseDate(String dateStr) throws IllegalArgumentException
    {
        try {
            DateFormat df = getDateFormat();
            return df.parse(dateStr);
        } catch (ParseException e) {
            throw new IllegalArgumentException(String.format(
                    ""Failed to parse Date value '%s': %s"", dateStr,
                    e.getMessage()));
        }
    }
"
JacksonDatabind_103,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_103_buggy/src/main/java/com/fasterxml/jackson/databind/DatabindContext.java,"    public JavaType resolveSubType(JavaType baseType, String subClass)
        throws JsonMappingException
    {
        // 30-Jan-2010, tatu: Most ids are basic class names; so let's first
        //    check if any generics info is added; and only then ask factory
        //    to do translation when necessary
        if (subClass.indexOf('<') > 0) {
            // note: may want to try combining with specialization (esp for EnumMap)?
            // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment
            //    compatibility -- needed later anyway, and not doing so may open
            //    security issues.
            JavaType t = getTypeFactory().constructFromCanonical(subClass);
            if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {
                return t;
            }
        } else {
            Class<?> cls;
            try {
                cls =  getTypeFactory().findClass(subClass);
            } catch (ClassNotFoundException e) { // let caller handle this problem
                return null;
            } catch (Exception e) {
                throw invalidTypeIdException(baseType, subClass, String.format(
                        ""problem: (%s) %s"",
                        e.getClass().getName(),
                        e.getMessage()));
            }
            if (baseType.isTypeOrSuperTypeOf(cls)) {
                return getTypeFactory().constructSpecializedType(baseType, cls);
            }
        }
        throw invalidTypeIdException(baseType, subClass, ""Not a subtype"");
    }
"
JacksonDatabind_104,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_104_buggy/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java,"        final int year = cal.get(Calendar.YEAR);

        // Assuming GregorianCalendar, special handling needed for BCE (aka BC)
                // 22-Nov-2018, tatu: Handling beyond 4-digits is not well specified wrt ISO-8601, but
                //   it seems that plus prefix IS mandated. Padding is an open question, but since agreeement
                //   for max length would be needed, we ewould need to limit to arbitrary length
                //   like five digits (erroring out if beyond or padding to that as minimum).
                //   Instead, let's just print number out as is and let decoder try to make sense of it.
            pad4(buffer, year);
        buffer.append('-');
        pad2(buffer, cal.get(Calendar.MONTH) + 1);
        buffer.append('-');
        pad2(buffer, cal.get(Calendar.DAY_OF_MONTH));
        buffer.append('T');
        pad2(buffer, cal.get(Calendar.HOUR_OF_DAY));
        buffer.append(':');
        pad2(buffer, cal.get(Calendar.MINUTE));
        buffer.append(':');
        pad2(buffer, cal.get(Calendar.SECOND));
        buffer.append('.');
        pad3(buffer, cal.get(Calendar.MILLISECOND));

        int offset = tz.getOffset(cal.getTimeInMillis());
        if (offset != 0) {
            int hours = Math.abs((offset / (60 * 1000)) / 60);
            int minutes = Math.abs((offset / (60 * 1000)) % 60);
            buffer.append(offset < 0 ? '-' : '+');
            pad2(buffer, hours);
            if( _tzSerializedWithColon ) {
            		buffer.append(':');
            }
            pad2(buffer, minutes);
        } else {
            // 24-Jun-2017, tatu: While `Z` would be conveniently short, older specs
            //   mandate use of full `+0000`
//            formatted.append('Z');
	        	if( _tzSerializedWithColon ) {
	            buffer.append(""+00:00"");
	        	}
	        	else {
	        		buffer.append(""+0000"");
	        	}
        }
"
JacksonDatabind_104,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_104_buggy/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java,"    private static void pad4(StringBuffer buffer, int value) {
        int h = value / 100;
        if (h == 0) {
            buffer.append('0').append('0');
        } else {
                pad2(buffer, h);
            value -= (100 * h);
        }
        pad2(buffer, value);
    }
"
JacksonDatabind_105,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_105_buggy/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java,"    public static JsonDeserializer<?> find(Class<?> rawType, String clsName)
    {
        if (_classNames.contains(clsName)) {
            JsonDeserializer<?> d = FromStringDeserializer.findDeserializer(rawType);
            if (d != null) {
                return d;
            }
            if (rawType == UUID.class) {
                return new UUIDDeserializer();
            }
            if (rawType == StackTraceElement.class) {
                return new StackTraceElementDeserializer();
            }
            if (rawType == AtomicBoolean.class) {
                // (note: AtomicInteger/Long work due to single-arg constructor. For now?
                return new AtomicBooleanDeserializer();
            }
            if (rawType == ByteBuffer.class) {
                return new ByteBufferDeserializer();
            }
        }
        return null;
    }
"
JacksonDatabind_105,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_105_buggy/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java,"    private final static HashSet<String> _classNames = new HashSet<String>();
    static {
        // note: can skip primitive types; other ways to check them:
        Class<?>[] types = new Class<?>[] {
                UUID.class,
                AtomicBoolean.class,
                StackTraceElement.class,
                ByteBuffer.class
        };
        for (Class<?> cls : types) { _classNames.add(cls.getName()); }
        for (Class<?> cls : FromStringDeserializer.types()) { _classNames.add(cls.getName()); }
    }
"
JacksonDatabind_106,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_106_buggy/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java,"    public float getFloatValue() throws IOException {
        return (float) currentNumericNode().doubleValue();
    }
"
JacksonDatabind_108,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_108_buggy/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java,"    public <T extends TreeNode> T readTree(JsonParser p) throws IOException {
        return (T) _bindAsTree(p);
    }
"
JacksonDatabind_108,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_108_buggy/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java,"    protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p) throws IOException
    {
        DeserializationContext ctxt = createDeserializationContext(p);
        _initForMultiRead(ctxt, p);
        p.nextToken();
        return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);
    }
"
JacksonDatabind_109,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_109_buggy/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java,"package com.fasterxml.jackson.databind.ser.std;

import java.io.IOException;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.math.BigInteger;

import com.fasterxml.jackson.annotation.JsonFormat;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;

import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;
import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
import com.fasterxml.jackson.databind.ser.ContextualSerializer;

/**
 * As a fallback, we may need to use this serializer for other
 * types of {@link Number}s: both custom types and ""big"" numbers
 * like {@link BigInteger} and {@link BigDecimal}.
 */
@JacksonStdImpl
@SuppressWarnings(""serial"")
public class NumberSerializer
    extends StdScalarSerializer<Number>
    implements ContextualSerializer
{
    /**
     * Static instance that is only to be used for {@link java.lang.Number}.
     */
    public final static NumberSerializer instance = new NumberSerializer(Number.class);

    /**
     * Copied from `jackson-core` class `GeneratorBase`
     */
    
    protected final boolean _isInt;

    /**
     * @since 2.5
     */
    public NumberSerializer(Class<? extends Number> rawType) {
        super(rawType, false);
        // since this will NOT be constructed for Integer or Long, only case is:
        _isInt = (rawType == BigInteger.class);
    }

    @Override
    public JsonSerializer<?> createContextual(SerializerProvider prov,
            BeanProperty property) throws JsonMappingException
    {
        JsonFormat.Value format = findFormatOverrides(prov, property, handledType());
        if (format != null) {
            switch (format.getShape()) {
            case STRING:
                // [databind#2264]: Need special handling for `BigDecimal`
                return ToStringSerializer.instance;
            default:
            }
        }
        return this;
    }

    @Override
    public void serialize(Number value, JsonGenerator g, SerializerProvider provider) throws IOException
    {
        // should mostly come in as one of these two:
        if (value instanceof BigDecimal) {
            g.writeNumber((BigDecimal) value);
        } else if (value instanceof BigInteger) {
            g.writeNumber((BigInteger) value);
            
        // These should not occur, as more specific methods should have been called; but
        // just in case let's cover all bases:
        } else if (value instanceof Long) {
            g.writeNumber(value.longValue());
        } else if (value instanceof Double) {
            g.writeNumber(value.doubleValue());
        } else if (value instanceof Float) {
            g.writeNumber(value.floatValue());
        } else if (value instanceof Integer || value instanceof Byte || value instanceof Short) {
            g.writeNumber(value.intValue()); // doesn't need to be cast to smaller numbers
        } else {
            // We'll have to use fallback ""untyped"" number write method
            g.writeNumber(value.toString());
        }
    }

    @Override
    public JsonNode getSchema(SerializerProvider provider, Type typeHint) {
        return createSchemaNode(_isInt ? ""integer"" : ""number"", true);
    }

    @Override
    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException
    {
        if (_isInt) {
            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);
        } else {
            if (((Class<?>) handledType()) == BigDecimal.class) {
                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);
            } else {
                // otherwise bit unclear what to call... but let's try:
                /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);
            }
        }
    }

    /**
     * @since 2.10
     */
    


                // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector, so we need this
                    // ... but wouldn't it be nice to trigger error via generator? Alas,
                    // no method to do that. So we'll do...

            // should never be called

        // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector, so we need this
}
"
JacksonDatabind_109,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_109_buggy/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java,"        public JsonSerializer<?> createContextual(SerializerProvider prov,
                BeanProperty property) throws JsonMappingException
        {
            JsonFormat.Value format = findFormatOverrides(prov, property, handledType());
            if (format != null) {
                switch (format.getShape()) {
                case STRING:
                    return ToStringSerializer.instance;
                default:
                }
            }
            return this;
        }
"
JacksonDatabind_110,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_110_buggy/src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java,"    // 10-Jan-2018, tatu: There are a few ""well-known"" special containers in JDK too:

    private final static Class<?> CLASS_AS_ARRAYS_LIST = Arrays.asList(null, null).getClass();

    private final static Class<?> CLASS_SINGLETON_SET;
    private final static Class<?> CLASS_SINGLETON_LIST;
    private final static Class<?> CLASS_SINGLETON_MAP;

    private final static Class<?> CLASS_UNMODIFIABLE_SET;
    private final static Class<?> CLASS_UNMODIFIABLE_LIST;"
JacksonDatabind_110,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_110_buggy/src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java,"    static {
        Set<?> set = Collections.singleton(Boolean.TRUE);
        CLASS_SINGLETON_SET = set.getClass();
        CLASS_UNMODIFIABLE_SET = Collections.unmodifiableSet(set).getClass();

        List<?> list = Collections.singletonList(Boolean.TRUE);
        CLASS_SINGLETON_LIST = list.getClass();
        CLASS_UNMODIFIABLE_LIST = Collections.unmodifiableList(list).getClass();
        // for [databind#2265]
        
        Map<?,?> map = Collections.singletonMap(""a"", ""b"");
        CLASS_SINGLETON_MAP = map.getClass();
        CLASS_UNMODIFIABLE_MAP = Collections.unmodifiableMap(map).getClass();
    }"
JacksonDatabind_110,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_110_buggy/src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java,"    public static JsonDeserializer<?> findForCollection(DeserializationContext ctxt,
            JavaType type)
        throws JsonMappingException
    {
        JavaUtilCollectionsConverter conv;

        // 10-Jan-2017, tatu: Some types from `java.util.Collections`/`java.util.Arrays` need bit of help...
        if (type.hasRawClass(CLASS_AS_ARRAYS_LIST)) {
            conv = converter(TYPE_AS_LIST, type, List.class);
        } else if (type.hasRawClass(CLASS_SINGLETON_LIST)) {
            conv = converter(TYPE_SINGLETON_LIST, type, List.class);
        } else if (type.hasRawClass(CLASS_SINGLETON_SET)) {
            conv = converter(TYPE_SINGLETON_SET, type, Set.class);
        // [databind#2265]: we may have another impl type for unmodifiable Lists, check both
        } else if (type.hasRawClass(CLASS_UNMODIFIABLE_LIST)) {
            conv = converter(TYPE_UNMODIFIABLE_LIST, type, List.class);
        } else if (type.hasRawClass(CLASS_UNMODIFIABLE_SET)) {
            conv = converter(TYPE_UNMODIFIABLE_SET, type, Set.class);
        } else {
            return null;
        }
        return new StdDelegatingDeserializer<Object>(conv);
    }
"
JacksonDatabind_111,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_111_buggy/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java,"package com.fasterxml.jackson.databind.deser.impl;

import java.io.IOException;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;

import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.deser.NullValueProvider;
import com.fasterxml.jackson.databind.deser.SettableBeanProperty;
import com.fasterxml.jackson.databind.introspect.AnnotatedMember;
import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;
import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;
import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
import com.fasterxml.jackson.databind.util.Annotations;

/**
 * This concrete sub-class implements Collection or Map property that is
 * indirectly by getting the property value and directly modifying it.
 */
public final class SetterlessProperty
    extends SettableBeanProperty
{
    private static final long serialVersionUID = 1L;

    protected final AnnotatedMethod _annotated;

    /**
     * Get method for accessing property value used to access property
     * (of Collection or Map type) to modify.
     */
    protected final Method _getter;

    public SetterlessProperty(BeanPropertyDefinition propDef, JavaType type,
            TypeDeserializer typeDeser, Annotations contextAnnotations, AnnotatedMethod method)
    {
        super(propDef, type, typeDeser, contextAnnotations);
        _annotated = method;
        _getter = method.getAnnotated();
    }

    protected SetterlessProperty(SetterlessProperty src, JsonDeserializer<?> deser,
            NullValueProvider nva) {
        super(src, deser, nva);
        _annotated = src._annotated;
        _getter = src._getter;
    }

    protected SetterlessProperty(SetterlessProperty src, PropertyName newName) {
        super(src, newName);
        _annotated = src._annotated;
        _getter = src._getter;
    }

    @Override
    public SettableBeanProperty withName(PropertyName newName) {
        return new SetterlessProperty(this, newName);
    }

    @Override
    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were
        return new SetterlessProperty(this, deser, _nullProvider);
    }

    @Override
    public SettableBeanProperty withNullProvider(NullValueProvider nva) {
        return new SetterlessProperty(this, _valueDeserializer, nva);
    }

    @Override
    public void fixAccess(DeserializationConfig config) {
        _annotated.fixAccess(
                config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
    }

    /*
    /**********************************************************
    /* BeanProperty impl
    /**********************************************************
     */
    
    @Override
    public <A extends Annotation> A getAnnotation(Class<A> acls) {
        return _annotated.getAnnotation(acls);
    }

    @Override public AnnotatedMember getMember() {  return _annotated; }

    /*
    /**********************************************************
    /* Overridden methods
    /**********************************************************
     */
    
    @Override
    public final void deserializeAndSet(JsonParser p, DeserializationContext ctxt,
            Object instance) throws IOException
    {
        JsonToken t = p.getCurrentToken();
        if (t == JsonToken.VALUE_NULL) {
            // Hmmh. Is this a problem? We won't be setting anything, so it's
            // equivalent of empty Collection/Map in this case
            return;
        }
        // For [databind#501] fix we need to implement this but:
        if (_valueTypeDeserializer != null) {
            ctxt.reportBadDefinition(getType(), String.format(
                    ""Problem deserializing 'setterless' property (\""%s\""): no way to handle typed deser with setterless yet"",
                    getName()));
//            return _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);
        }
        // Ok: then, need to fetch Collection/Map to modify:
        Object toModify;
        try {
            toModify = _getter.invoke(instance, (Object[]) null);
        } catch (Exception e) {
            _throwAsIOE(p, e);
            return; // never gets here
        }
        // Note: null won't work, since we can't then inject anything in. At least
        // that's not good in common case. However, theoretically the case where
        // we get JSON null might be compatible. If so, implementation could be changed.
        if (toModify == null) {
            ctxt.reportBadDefinition(getType(), String.format(
                    ""Problem deserializing 'setterless' property '%s': get method returned null"",
                    getName()));
        }
        _valueDeserializer.deserialize(p, ctxt, toModify);
    }

    @Override
    public Object deserializeSetAndReturn(JsonParser p,
      DeserializationContext ctxt, Object instance) throws IOException
    {
        deserializeAndSet(p, ctxt, instance);
        return instance;
    }

    @Override
    public final void set(Object instance, Object value) throws IOException {
        throw new UnsupportedOperationException(""Should never call `set()` on setterless property ('""+getName()+""')"");
    }

    @Override
    public Object setAndReturn(Object instance, Object value) throws IOException
    {
        set(instance, value);
        return instance;
    }
}
"
JacksonDatabind_111,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_111_buggy/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReferenceProperty.java,"    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were
        return new ObjectIdReferenceProperty(this, deser, _nullProvider);
    }
"
JacksonDatabind_111,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_111_buggy/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java,"    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were
        return new MethodProperty(this, deser, _nullProvider);
    }
"
JacksonDatabind_111,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_111_buggy/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java,"package com.fasterxml.jackson.databind.deser.impl;

import java.io.IOException;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;

import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;

import com.fasterxml.jackson.databind.*;
import com.fasterxml.jackson.databind.deser.NullValueProvider;
import com.fasterxml.jackson.databind.deser.SettableBeanProperty;
import com.fasterxml.jackson.databind.introspect.AnnotatedField;
import com.fasterxml.jackson.databind.introspect.AnnotatedMember;
import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;
import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
import com.fasterxml.jackson.databind.util.Annotations;
import com.fasterxml.jackson.databind.util.ClassUtil;

/**
 * This concrete sub-class implements property that is set
 * directly assigning to a Field.
 */
public final class FieldProperty
    extends SettableBeanProperty
{
    private static final long serialVersionUID = 1L;

    final protected AnnotatedField _annotated;

    /**
     * Actual field to set when deserializing this property.
     * Transient since there is no need to persist; only needed during
     * construction of objects.
     */
    final protected transient Field _field;

    /**
     * @since 2.9
     */
    final protected boolean _skipNulls;

    public FieldProperty(BeanPropertyDefinition propDef, JavaType type,
            TypeDeserializer typeDeser, Annotations contextAnnotations, AnnotatedField field)
    {
        super(propDef, type, typeDeser, contextAnnotations);
        _annotated = field;
        _field = field.getAnnotated();
        _skipNulls = NullsConstantProvider.isSkipper(_nullProvider);
    }

    protected FieldProperty(FieldProperty src, JsonDeserializer<?> deser,
            NullValueProvider nva) {
        super(src, deser, nva);
        _annotated = src._annotated;
        _field = src._field;
        _skipNulls = NullsConstantProvider.isSkipper(nva);
    }

    protected FieldProperty(FieldProperty src, PropertyName newName) {
        super(src, newName);
        _annotated = src._annotated;
        _field = src._field;
        _skipNulls = src._skipNulls;
    }

    /**
     * Constructor used for JDK Serialization when reading persisted object
     */
    protected FieldProperty(FieldProperty src)
    {
        super(src);
        _annotated = src._annotated;
        Field f = _annotated.getAnnotated();
        if (f == null) {
            throw new IllegalArgumentException(""Missing field (broken JDK (de)serialization?)"");
        }
        _field = f;
        _skipNulls = src._skipNulls;
    }

    @Override
    public SettableBeanProperty withName(PropertyName newName) {
        return new FieldProperty(this, newName);
    }

    @Override
    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were
        return new FieldProperty(this, deser, _nullProvider);
    }

    @Override
    public SettableBeanProperty withNullProvider(NullValueProvider nva) {
        return new FieldProperty(this, _valueDeserializer, nva);
    }

    @Override
    public void fixAccess(DeserializationConfig config) {
        ClassUtil.checkAndFixAccess(_field,
                config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
    }

    /*
    /**********************************************************
    /* BeanProperty impl
    /**********************************************************
     */
    
    @Override
    public <A extends Annotation> A getAnnotation(Class<A> acls) {
        return (_annotated == null) ? null : _annotated.getAnnotation(acls);
    }

    @Override public AnnotatedMember getMember() {  return _annotated; }

    /*
    /**********************************************************
    /* Overridden methods
    /**********************************************************
     */

    @Override
    public void deserializeAndSet(JsonParser p,
      DeserializationContext ctxt, Object instance) throws IOException
    {
        Object value;
        if (p.hasToken(JsonToken.VALUE_NULL)) {
            if (_skipNulls) {
                return;
            }
            value = _nullProvider.getNullValue(ctxt);
        } else if (_valueTypeDeserializer == null) {
            value = _valueDeserializer.deserialize(p, ctxt);
            // 04-May-2018, tatu: [databind#2023] Coercion from String (mostly) can give null
            if (value == null) {
                if (_skipNulls) {
                    return;
                }
                value = _nullProvider.getNullValue(ctxt);
            }
        } else {
            value = _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);
        }
        try {
            _field.set(instance, value);
        } catch (Exception e) {
            _throwAsIOE(p, e, value);
        }
    }

    @Override
    public Object deserializeSetAndReturn(JsonParser p,
      DeserializationContext ctxt, Object instance) throws IOException
    {
        Object value;
        if (p.hasToken(JsonToken.VALUE_NULL)) {
            if (_skipNulls) {
                return instance;
            }
            value = _nullProvider.getNullValue(ctxt);
        } else if (_valueTypeDeserializer == null) {
            value = _valueDeserializer.deserialize(p, ctxt);
            // 04-May-2018, tatu: [databind#2023] Coercion from String (mostly) can give null
            if (value == null) {
                if (_skipNulls) {
                    return instance;
                }
                value = _nullProvider.getNullValue(ctxt);
            }
        } else {
            value = _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);
        }
        try {
            _field.set(instance, value);
        } catch (Exception e) {
            _throwAsIOE(p, e, value);
        }
        return instance;
    }

    @Override
    public void set(Object instance, Object value) throws IOException
    {
        try {
            _field.set(instance, value);
        } catch (Exception e) {
            // 15-Sep-2015, tatu: How could we get a ref to JsonParser?
            _throwAsIOE(e, value);
        }
    }

    @Override
    public Object setAndReturn(Object instance, Object value) throws IOException
    {
        try {
            _field.set(instance, value);
        } catch (Exception e) {
            // 15-Sep-2015, tatu: How could we get a ref to JsonParser?
            _throwAsIOE(e, value);
        }
        return instance;
    }

    /*
    /**********************************************************
    /* JDK serialization handling
    /**********************************************************
     */

    Object readResolve() {
        return new FieldProperty(this);
    }
}
"
JacksonDatabind_111,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_111_buggy/src/main/java/com/fasterxml/jackson/databind/deser/CreatorProperty.java,"    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were
        return new CreatorProperty(this, deser, _nullProvider);
    }
"
JacksonDatabind_111,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_111_buggy/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java,"    public AtomicReferenceDeserializer withResolved(TypeDeserializer typeDeser, JsonDeserializer<?> valueDeser) {
        return new AtomicReferenceDeserializer(_fullType, _valueInstantiator,
                typeDeser, valueDeser);
    }
"
JacksonDatabind_111,/home/common/huangzhili/defects4j_buggy/JacksonDatabind_111_buggy/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java,"    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {
        if (_valueDeserializer == deser) {
            return this;
        }
        // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were
        return new ObjectIdValueProperty(this, deser, _nullProvider);
    }
"
JacksonXml_2,/home/common/huangzhili/defects4j_buggy/JacksonXml_2_buggy/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java,"private final int _next() throws XMLStreamException
    {
        switch (_currentState) {
        case XML_ATTRIBUTE_VALUE:
            ++_nextAttributeIndex;
            // fall through
        case XML_START_ELEMENT: // attributes to return?
            if (_nextAttributeIndex < _attributeCount) {
                _localName = _xmlReader.getAttributeLocalName(_nextAttributeIndex);
                _namespaceURI = _xmlReader.getAttributeNamespace(_nextAttributeIndex);
                _textValue = _xmlReader.getAttributeValue(_nextAttributeIndex);
                return (_currentState = XML_ATTRIBUTE_NAME);
            }
            // otherwise need to find START/END_ELEMENT or text
            String text = _collectUntilTag();
            // If we have no/all-whitespace text followed by START_ELEMENT, ignore text
            if (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) {
                    return _initStartElement();
            }
            // For END_ELEMENT we will return text, if any
            if (text != null) {
                _textValue = text;
                return (_currentState = XML_TEXT);
            }
            return _handleEndElement();

        case XML_ATTRIBUTE_NAME:
            // if we just returned name, will need to just send value next
             return (_currentState = XML_ATTRIBUTE_VALUE);
         case XML_TEXT:
             // mixed text with other elements
             // text followed by END_ELEMENT
             return _handleEndElement();
         case XML_END:
            return XML_END;
//            throw new IllegalStateException(""No more XML tokens available (end of input)"");
        }

        // Ok: must be END_ELEMENT; see what tag we get (or end)
        switch (_skipUntilTag()) {
        case XMLStreamConstants.END_DOCUMENT:
            return (_currentState = XML_END);
        case XMLStreamConstants.END_ELEMENT:
            return _handleEndElement();
        }
        // START_ELEMENT...
        return _initStartElement();
    }"
JacksonXml_6,/home/common/huangzhili/defects4j_buggy/JacksonXml_6_buggy/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java,"    public void writeBinary(Base64Variant b64variant,
    		byte[] data, int offset, int len) throws IOException
    {
        if (data == null) {
            writeNull();
            return;
        }
        _verifyValueWrite(""write Binary value"");
        if (_nextName == null) {
            handleMissingName();
        }
        try {
            if (_nextIsAttribute) {
                // Stax2 API only has 'full buffer' write method:
                byte[] fullBuffer = toFullBuffer(data, offset, len);
                _xmlWriter.writeBinaryAttribute("""", _nextName.getNamespaceURI(), _nextName.getLocalPart(), fullBuffer);
            } else if (checkNextIsUnwrapped()) {
            	// should we consider pretty-printing or not?
                _xmlWriter.writeBinary(data, offset, len);
            } else {
                if (_xmlPrettyPrinter != null) {
                    _xmlPrettyPrinter.writeLeafElement(_xmlWriter,
                            _nextName.getNamespaceURI(), _nextName.getLocalPart(),
                            data, offset, len);
                } else {
                    _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());
                    _xmlWriter.writeBinary(data, offset, len);
                    _xmlWriter.writeEndElement();
                }
            }
        } catch (XMLStreamException e) {
            StaxUtil.throwAsGenerationException(e, this);
        }
    }
"
JacksonXml_6,/home/common/huangzhili/defects4j_buggy/JacksonXml_6_buggy/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java,"    private byte[] toFullBuffer(byte[] data, int offset, int len)
    {
        // might already be ok:
        if (offset == 0 && len == data.length) {
            return data;
        }
        byte[] result = new byte[len];
        if (len > 0) {
            System.arraycopy(data, offset, result, 0, len);
        }
        return result;
    }
"
Jsoup_3,/home/common/huangzhili/defects4j_buggy/Jsoup_3_buggy/src/main/java/org/jsoup/nodes/Element.java,"public Element wrap(String html) {
         Validate.notEmpty(html);
 
         Element wrapBody = Parser.parseBodyFragment(html, baseUri).body();
         Elements wrapChildren = wrapBody.children();
         Element wrap = wrapChildren.first();
         if (wrap == null) // nothing to wrap with; noop
            return null;

        Element deepest = getDeepChild(wrap);
        parentNode.replaceChild(this, wrap);
        deepest.addChild(this);

        // remainder (unbalananced wrap, like <div></div><p></p> -- The <p> is remainder
        if (wrapChildren.size() > 1) {
            for (int i = 1; i < wrapChildren.size(); i++) { // skip first
                Element remainder = wrapChildren.get(i);
                remainder.parentNode.removeChild(remainder);
                wrap.appendChild(remainder);
            }
        }
        return this;
    }"
Jsoup_3,/home/common/huangzhili/defects4j_buggy/Jsoup_3_buggy/src/main/java/org/jsoup/nodes/Element.java,"public Element append(String html) {
         Validate.notNull(html);
         
         Element fragment = Parser.parseBodyFragment(html, baseUri).body();
         for (Node node : fragment.childNodes()) {
             node.parentNode = null;
             appendChild(node);
        }
        return this;
    }"
Jsoup_3,/home/common/huangzhili/defects4j_buggy/Jsoup_3_buggy/src/main/java/org/jsoup/nodes/Element.java,"public Element prepend(String html) {
         Validate.notNull(html);
         
         Element fragment = Parser.parseBodyFragment(html, baseUri).body();
         List<Node> nodes = fragment.childNodes();
         for (int i = nodes.size() - 1; i >= 0; i--) {
             Node node = nodes.get(i);
            node.parentNode = null;
            prependChild(node);
        }
        return this;
    }"
Jsoup_3,/home/common/huangzhili/defects4j_buggy/Jsoup_3_buggy/src/main/java/org/jsoup/parser/Parser.java,"private boolean stackHasValidParent(Tag childTag) {
         if (stack.size() == 1 && childTag.equals(htmlTag))
             return true; // root is valid for html node
 
 
         // otherwise, look up the stack for valid ancestors
         for (int i = stack.size() -1; i >= 0; i--) {
             Element el = stack.get(i);
             Tag parent2 = el.tag();
             if (parent2.isValidParent(childTag)) {
                 return true;
             }
         }
        return false;
    }"
Jsoup_3,/home/common/huangzhili/defects4j_buggy/Jsoup_3_buggy/src/main/java/org/jsoup/parser/Parser.java,"private Element addChildToParent(Element child, boolean isEmptyElement) {
        Element parent = popStackToSuitableContainer(child.tag());
         Tag childTag = child.tag();
         boolean validAncestor = stackHasValidParent(childTag);
 
         if (!validAncestor) {
             // create implicit parent around this child
             Tag parentTag = childTag.getImplicitParent();
             Element implicit = new Element(parentTag, baseUri);
            // special case: make sure there's a head before putting in body
            if (child.tag().equals(bodyTag)) {
                Element head = new Element(headTag, baseUri);
                implicit.appendChild(head);
            }
            implicit.appendChild(child);

            // recurse to ensure somewhere to put parent
            Element root = addChildToParent(implicit, false);
            if (!isEmptyElement)
                stack.addLast(child);
            return root;
        }

        parent.appendChild(child);

        if (!isEmptyElement)
            stack.addLast(child);
        return parent;
    }"
Jsoup_3,/home/common/huangzhili/defects4j_buggy/Jsoup_3_buggy/src/main/java/org/jsoup/parser/Tag.java,"boolean canContain(Tag child) {
        Validate.notNull(child);

        if (child.isBlock && !this.canContainBlock)
            return false;

        if (!child.isBlock && !this.canContainInline) // not block == inline
            return false;

        if (this.optionalClosing && this.equals(child))
            return false;

        if (this.empty || this.isData())
            return false;

        // head can only contain a few. if more than head in here, modify to have a list of valids
        // TODO: (could solve this with walk for ancestor)
        if (this.tagName.equals(""head"")) {
            if (child.tagName.equals(""base"") || child.tagName.equals(""script"") || child.tagName.equals(""noscript"") || child.tagName.equals(""link"") ||
                    child.tagName.equals(""meta"") || child.tagName.equals(""title"") || child.tagName.equals(""style"") || child.tagName.equals(""object"")) {
                return true;
            }
            return false;
        }
        
        // dt and dd (in dl)
        if (this.tagName.equals(""dt"") && child.tagName.equals(""dd""))
            return false;
        if (this.tagName.equals(""dd"") && child.tagName.equals(""dt""))
             return false;
 
         // don't allow children to contain their parent (directly)
         
         return true;
     }"
Jsoup_4,/home/common/huangzhili/defects4j_buggy/Jsoup_4_buggy/src/main/java/org/jsoup/nodes/Entities.java,"static String unescape(String string) {
        if (!string.contains(""&""))
            return string;

        Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?
        StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs

        while (m.find()) {
            int charval = -1;
            String num = m.group(3);
            if (num != null) {
                try {
                    int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator
                    charval = Integer.valueOf(num, base);
                 } catch (NumberFormatException e) {
                 } // skip
             } else {
                 String name = m.group(1).toLowerCase();
                 if (full.containsKey(name))
                     charval = full.get(name);
             }

            if (charval != -1 || charval > 0xFFFF) { // out of range
                String c = Character.toString((char) charval);
                m.appendReplacement(accum, c);
            } else {
                m.appendReplacement(accum, m.group(0)); // replace with original string
            }
        }
        m.appendTail(accum);
        return accum.toString();
    }"
Jsoup_7,/home/common/huangzhili/defects4j_buggy/Jsoup_7_buggy/src/main/java/org/jsoup/nodes/Document.java,"public Document normalise() {
        Element htmlEl = findFirstElementByTagName(""html"", this);
        if (htmlEl == null)
            htmlEl = appendElement(""html"");
        if (head() == null)
            htmlEl.prependElement(""head"");
        if (body() == null)
            htmlEl.appendElement(""body"");

        // pull text nodes out of root, html, and head els, and push into body. non-text nodes are already taken care
        // of. do in inverse order to maintain text order.
        normaliseTextNodes(head());
         normaliseTextNodes(htmlEl);
         normaliseTextNodes(this);
 
         
         return this;
     }"
Jsoup_8,/home/common/huangzhili/defects4j_buggy/Jsoup_8_buggy/src/main/java/org/jsoup/nodes/Node.java,"    public String outerHtml() {
        StringBuilder accum = new StringBuilder(32*1024);
        outerHtml(accum);
        return accum.toString();
    }
"
Jsoup_9,/home/common/huangzhili/defects4j_buggy/Jsoup_9_buggy/src/main/java/org/jsoup/nodes/Entities.java,"        public Map<Character, String> getMap() {
            return map;
        }
"
Jsoup_11,/home/common/huangzhili/defects4j_buggy/Jsoup_11_buggy/src/main/java/org/jsoup/select/Selector.java,"private Elements select() {
        tq.consumeWhitespace();
        
         if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements
             elements.add(root);
             combinator(tq.consume().toString());
         } else {
             addElements(findElements()); // chomp first element matcher off queue 
         }            
               
        while (!tq.isEmpty()) {
            // hierarchy and extras
            boolean seenWhite = tq.consumeWhitespace();
            
            if (tq.matchChomp("","")) { // group or
                while (!tq.isEmpty()) {
                    String subQuery = tq.chompTo("","");
                    elements.addAll(select(subQuery, root));
                }
            } else if (tq.matchesAny(combinators)) {
                combinator(tq.consume().toString());
            } else if (seenWhite) {
                combinator("" "");
            } else { // E.class, E#id, E[attr] etc. AND
                Elements candidates = findElements(); // take next el, #. etc off queue
                intersectElements(filterForSelf(elements, candidates));
            }
        }
        return new Elements(elements);
    }"
Jsoup_11,/home/common/huangzhili/defects4j_buggy/Jsoup_11_buggy/src/main/java/org/jsoup/select/Selector.java,"private Elements findElements() {
        if (tq.matchChomp(""#"")) {
            return byId();
        } else if (tq.matchChomp(""."")) {
            return byClass();
        } else if (tq.matchesWord()) {
            return byTag();
        } else if (tq.matches(""["")) {
            return byAttribute();
        } else if (tq.matchChomp(""*"")) {
            return allElements();
        } else if (tq.matchChomp("":lt("")) {
            return indexLessThan();
        } else if (tq.matchChomp("":gt("")) {
            return indexGreaterThan();
        } else if (tq.matchChomp("":eq("")) {
            return indexEquals();
        } else if (tq.matches("":has("")) {
            return has();
        } else if (tq.matches("":contains("")) {
            return contains(false);
        } else if (tq.matches("":containsOwn("")) {
            return contains(true);
        } else if (tq.matches("":matches("")) {
             return matches(false);
         } else if (tq.matches("":matchesOwn("")) {
             return matches(true);
         } else { // unhandled
             throw new SelectorParseException(""Could not parse query '%s': unexpected token at '%s'"", query, tq.remainder());
         }
    }"
Jsoup_12,/home/common/huangzhili/defects4j_buggy/Jsoup_12_buggy/src/main/java/org/jsoup/select/Selector.java,"private void combinator(char combinator) {
         tq.consumeWhitespace();
         String subQuery = tq.consumeToAny(combinators);
         
         Elements output;
         if (combinator == '>')
            output = filterForChildren(elements, select(subQuery, elements));
        else if (combinator == ' ')
            output = filterForDescendants(elements, select(subQuery, elements));
        else if (combinator == '+')
            output = filterForAdjacentSiblings(elements, select(subQuery, root));
        else if (combinator == '~')
            output = filterForGeneralSiblings(elements, select(subQuery, root));
        else
            throw new IllegalStateException(""Unknown combinator: "" + combinator);
        
        elements.clear(); elements.addAll(output);
    }"
Jsoup_14,/home/common/huangzhili/defects4j_buggy/Jsoup_14_buggy/src/main/java/org/jsoup/parser/TokeniserState.java,"void read(Tokeniser t, CharacterReader r) {
             if (r.matches('/')) {
                 t.createTempBuffer();
                 t.advanceTransition(RCDATAEndTagOpen);
                 // diverge from spec: got a start tag, but there's no appropriate end tag (</title>), so rather than
                 // consuming to EOF; break out here
             } else {
                 t.emit(""<"");
                 t.transition(Rcdata);
            }
        }"
Jsoup_16,/home/common/huangzhili/defects4j_buggy/Jsoup_16_buggy/src/main/java/org/jsoup/nodes/DocumentType.java,"    public DocumentType(String name, String publicId, String systemId, String baseUri) {
        super(baseUri);

        attr(""name"", name);
        attr(""publicId"", publicId);
        attr(""systemId"", systemId);
    }
"
Jsoup_16,/home/common/huangzhili/defects4j_buggy/Jsoup_16_buggy/src/main/java/org/jsoup/nodes/DocumentType.java,"    public String nodeName() {
        return ""#doctype"";
    }
"
Jsoup_17,/home/common/huangzhili/defects4j_buggy/Jsoup_17_buggy/src/main/java/org/jsoup/parser/TreeBuilderState.java,"        private boolean anythingElse(Token t, TreeBuilder tb) {
            tb.error(this);
            return false;
        }
"
Jsoup_18,/home/common/huangzhili/defects4j_buggy/Jsoup_18_buggy/src/main/java/org/jsoup/parser/CharacterReader.java,"String consumeToEnd() {
         String data = input.substring(pos, input.length() - 1);
         pos = input.length();
         return data;
     }"
Jsoup_21,/home/common/huangzhili/defects4j_buggy/Jsoup_21_buggy/src/main/java/org/jsoup/select/QueryParser.java,"Evaluator parse() {
        tq.consumeWhitespace();

        if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements
            evals.add(new StructuralEvaluator.Root());
            combinator(tq.consume());
        } else {
            findElements();
        }

        while (!tq.isEmpty()) {
             // hierarchy and extras
             boolean seenWhite = tq.consumeWhitespace();
 
             if (tq.matchChomp("","")) {
                 CombiningEvaluator.Or or = new CombiningEvaluator.Or(evals);
                 evals.clear();
                 evals.add(or);
                 while (!tq.isEmpty()) {
                     String subQuery = tq.chompTo("","");
                     or.add(parse(subQuery));
                 }
             } else if (tq.matchesAny(combinators)) {
                 combinator(tq.consume());
             } else if (seenWhite) {
                 combinator(' ');
            } else { // E.class, E#id, E[attr] etc. AND
                findElements(); // take next el, #. etc off queue
            }
        }

        if (evals.size() == 1)
            return evals.get(0);

        return new CombiningEvaluator.And(evals);
    }"
Jsoup_21,/home/common/huangzhili/defects4j_buggy/Jsoup_21_buggy/src/main/java/org/jsoup/select/QueryParser.java,"private void combinator(char combinator) {
        tq.consumeWhitespace();
        String subQuery = consumeSubQuery(); // support multi > childs
        Evaluator e;

        if (evals.size() == 1)
            e = evals.get(0);
        else
            e = new CombiningEvaluator.And(evals);
        evals.clear();
        Evaluator f = parse(subQuery);

        if (combinator == '>')
            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediateParent(e)));
        else if (combinator == ' ')
            evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.Parent(e)));
        else if (combinator == '+')
             evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediatePreviousSibling(e)));
         else if (combinator == '~')
             evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.PreviousSibling(e)));
         else
             throw new Selector.SelectorParseException(""Unknown combinator: "" + combinator);
     }"
Jsoup_22,/home/common/huangzhili/defects4j_buggy/Jsoup_22_buggy/src/main/java/org/jsoup/nodes/Element.java,"    public Element nextElementSibling() {
        List<Element> siblings = parent().children();
        Integer index = indexInList(this, siblings);
        Validate.notNull(index);
        if (siblings.size() > index+1)
            return siblings.get(index+1);
        else
            return null;
    }
"
Jsoup_22,/home/common/huangzhili/defects4j_buggy/Jsoup_22_buggy/src/main/java/org/jsoup/nodes/Node.java,"    private void reindexChildren() {
        for (int i = 0; i < childNodes.size(); i++) {
            childNodes.get(i).setSiblingIndex(i);
        }
    }
"
Jsoup_22,/home/common/huangzhili/defects4j_buggy/Jsoup_22_buggy/src/main/java/org/jsoup/nodes/Node.java,"    public Node nextSibling() {
        if (parentNode == null)
            return null; // root
        
        List<Node> siblings = parentNode.childNodes;
        Integer index = siblingIndex();
        Validate.notNull(index);
        if (siblings.size() > index+1)
            return siblings.get(index+1);
        else
            return null;
    }
"
Jsoup_22,/home/common/huangzhili/defects4j_buggy/Jsoup_22_buggy/src/main/java/org/jsoup/select/Elements.java,"    public Elements() {
        contents = new ArrayList<Element>();
    }
"
Jsoup_22,/home/common/huangzhili/defects4j_buggy/Jsoup_22_buggy/src/main/java/org/jsoup/nodes/Element.java,"    public Element previousElementSibling() {
        List<Element> siblings = parent().children();
        Integer index = indexInList(this, siblings);
        Validate.notNull(index);
        if (index > 0)
            return siblings.get(index-1);
        else
            return null;
    }
"
Jsoup_22,/home/common/huangzhili/defects4j_buggy/Jsoup_22_buggy/src/main/java/org/jsoup/nodes/Element.java,"    public Elements siblingElements() {

        return parent().children();
    }
"
Jsoup_23,/home/common/huangzhili/defects4j_buggy/Jsoup_23_buggy/src/main/java/org/jsoup/parser/Tokeniser.java,"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
        if (reader.isEmpty())
            return null;
        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
            return null;
        if (reader.matchesAny('\t', '\n', '\f', ' ', '<', '&'))
            return null;

        reader.mark();
        if (reader.matchConsume(""#"")) { // numbered
            boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
            if (numRef.length() == 0) { // didn't match anything
                characterReferenceError(""numeric reference with no numerals"");
                reader.rewindToMark();
                return null;
            }
            if (!reader.matchConsume("";""))
                characterReferenceError(""missing semicolon""); // missing semi
            int charval = -1;
            try {
                int base = isHexMode ? 16 : 10;
                charval = Integer.valueOf(numRef, base);
            } catch (NumberFormatException e) {
            } // skip
            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
                characterReferenceError(""character outside of valid range"");
                return replacementChar;
            } else {
                // todo: implement number replacement table
                // todo: check for extra illegal unicode points as parse errors
                return (char) charval;
             }
         } else { // named
             // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found
             String nameRef = reader.consumeLetterSequence();
             String origNameRef = new String(nameRef); // for error reporting. nameRef gets chomped looking for matches
             boolean looksLegit = reader.matches(';');
             boolean found = false;
            while (nameRef.length() > 0 && !found) {
                if (Entities.isNamedEntity(nameRef))
                    found = true;
                else {
                    nameRef = nameRef.substring(0, nameRef.length()-1);
                    reader.unconsume();
                }
            }
            if (!found) {
                if (looksLegit) // named with semicolon
                    characterReferenceError(String.format(""invalid named referenece '%s'"", origNameRef));
                reader.rewindToMark();
                return null;
            }
            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
                // don't want that to match
                reader.rewindToMark();
                return null;
            }
            if (!reader.matchConsume("";""))
                characterReferenceError(""missing semicolon""); // missing semi
            return Entities.getCharacterByName(nameRef);
        }
    }"
Jsoup_25,/home/common/huangzhili/defects4j_buggy/Jsoup_25_buggy/src/main/java/org/jsoup/parser/Tag.java,"    public String toString() {
        return tagName;
    }
"
Jsoup_28,/home/common/huangzhili/defects4j_buggy/Jsoup_28_buggy/src/main/java/org/jsoup/nodes/Entities.java,"static String unescape(String string, boolean strict) {
         if (!string.contains(""&""))
             return string;
         Matcher m = strict? strictUnescapePattern.matcher(string) : unescapePattern.matcher(string);
         StringBuffer accum = new StringBuffer(string.length());
         while (m.find()) {
             int charval = -1;
             String num = m.group(3);
             if (num != null) {
                 try {
                     int base = m.group(2) != null ? 16 : 10;
                     charval = Integer.valueOf(num, base);
                 } catch (NumberFormatException e) {
                 }
             } else {
                 String name = m.group(1);
                 if (full.containsKey(name))
                     charval = full.get(name);
             }
             if (charval != -1 || charval > 0xFFFF) {
                 String c = Character.toString((char) charval);
                 m.appendReplacement(accum, Matcher.quoteReplacement(c));
             } else {
                 m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));
             }
         }
         m.appendTail(accum);
         return accum.toString();
     }"
Jsoup_28,/home/common/huangzhili/defects4j_buggy/Jsoup_28_buggy/src/main/java/org/jsoup/parser/Tokeniser.java,"Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {
        if (reader.isEmpty())
            return null;
        if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())
            return null;
        if (reader.matchesAny('\t', '\n', '\r', '\f', ' ', '<', '&'))
            return null;

        reader.mark();
        if (reader.matchConsume(""#"")) { // numbered
            boolean isHexMode = reader.matchConsumeIgnoreCase(""X"");
            String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();
            if (numRef.length() == 0) { // didn't match anything
                characterReferenceError(""numeric reference with no numerals"");
                reader.rewindToMark();
                return null;
            }
            if (!reader.matchConsume("";""))
                characterReferenceError(""missing semicolon""); // missing semi
            int charval = -1;
            try {
                int base = isHexMode ? 16 : 10;
                charval = Integer.valueOf(numRef, base);
            } catch (NumberFormatException e) {
            } // skip
            if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {
                characterReferenceError(""character outside of valid range"");
                return replacementChar;
            } else {
                // todo: implement number replacement table
                // todo: check for extra illegal unicode points as parse errors
                return (char) charval;
            }
         } else { // named
             // get as many letters as possible, and look for matching entities.
             String nameRef = reader.consumeLetterThenDigitSequence();
             String origNameRef = new String(nameRef);
             boolean looksLegit = reader.matches(';');
             // found if a base named entity without a ;, or an extended entity with the ;.
             boolean found = false;
             while (nameRef.length() > 0 && !found) {
                 if (Entities.isNamedEntity(nameRef))
                     found = true;
                 else {
                     nameRef = nameRef.substring(0, nameRef.length()-1);
                     reader.unconsume();
                 }
             }
 
             if (!found) {
                 reader.rewindToMark();
                 if (looksLegit) // named with semicolon
                     characterReferenceError(String.format(""invalid named referenece '%s'"", origNameRef));
                 return null;
             }
             if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {
                // don't want that to match
                reader.rewindToMark();
                return null;
            }
            if (!reader.matchConsume("";""))
                characterReferenceError(""missing semicolon""); // missing semi
            return Entities.getCharacterByName(nameRef);
        }
    }"
Jsoup_29,/home/common/huangzhili/defects4j_buggy/Jsoup_29_buggy/src/main/java/org/jsoup/nodes/Document.java,"public String title() {
         // title is a preserve whitespace tag (for document output), but normalised here
         Element titleEl = getElementsByTag(""title"").first();
         return titleEl != null ? titleEl.text().trim() : """";
     }"
Jsoup_30,/home/common/huangzhili/defects4j_buggy/Jsoup_30_buggy/src/main/java/org/jsoup/safety/Cleaner.java,"    private int copySafeNodes(Element root, Element destination) {
        List<Node> sourceChildren = root.childNodes();
        int numDiscarded = 0;

        for (Node source : sourceChildren) {
            if (source instanceof Element) {
                Element sourceEl = (Element) source;

                if (whitelist.isSafeTag(sourceEl.tagName())) { // safe, clone and copy safe attrs
                    ElementMeta meta = createSafeElement(sourceEl);
                    Element destChild = meta.el;
                    destination.appendChild(destChild);

                    numDiscarded += meta.numAttribsDiscarded;
                    numDiscarded += copySafeNodes(sourceEl, destChild);
                } else {
                    numDiscarded++;
                    numDiscarded += copySafeNodes(sourceEl, destination);
                }
            } else if (source instanceof TextNode) {
                TextNode sourceText = (TextNode) source;
                TextNode destText = new TextNode(sourceText.getWholeText(), source.baseUri());
                destination.appendChild(destText);
            }
        }
        return numDiscarded;


    }
"
Jsoup_30,/home/common/huangzhili/defects4j_buggy/Jsoup_30_buggy/src/main/java/org/jsoup/safety/Cleaner.java,"    public boolean isValid(Document dirtyDocument) {
        Validate.notNull(dirtyDocument);

        Document clean = Document.createShell(dirtyDocument.baseUri());
        int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());
        return numDiscarded == 0;
    }
"
Jsoup_31,/home/common/huangzhili/defects4j_buggy/Jsoup_31_buggy/src/main/java/org/jsoup/parser/XmlTreeBuilder.java,"void insert(Token.Comment commentToken) {
         Comment comment = new Comment(commentToken.getData(), baseUri);
         Node insert = comment;
         insertNode(insert);
     }"
Jsoup_31,/home/common/huangzhili/defects4j_buggy/Jsoup_31_buggy/src/main/java/org/jsoup/parser/TokeniserState.java,"void read(Tokeniser t, CharacterReader r) {
            // todo: handle bogus comment starting from eof. when does that trigger?
             // rewind to capture character that lead us here
             r.unconsume();
             Token.Comment comment = new Token.Comment();
             comment.data.append(r.consumeTo('>'));
             // todo: replace nullChar with replaceChar
             t.emit(comment);
            t.advanceTransition(Data);
        }"
Jsoup_36,/home/common/huangzhili/defects4j_buggy/Jsoup_36_buggy/src/main/java/org/jsoup/helper/DataUtil.java,"static String getCharsetFromContentType(String contentType) {
        if (contentType == null) return null;
         Matcher m = charsetPattern.matcher(contentType);
         if (m.find()) {
             String charset = m.group(1).trim();
                 if (Charset.isSupported(charset)) return charset;
                 charset = charset.toUpperCase(Locale.ENGLISH);
                 if (Charset.isSupported(charset)) return charset;
                 // if our advanced charset matching fails.... we just take the default
         }
         return null;
     }"
Jsoup_36,/home/common/huangzhili/defects4j_buggy/Jsoup_36_buggy/src/main/java/org/jsoup/helper/DataUtil.java,"static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {
        String docData;
        Document doc = null;
        if (charsetName == null) { // determine from meta. safe parse as UTF-8
            // look for <meta http-equiv=""Content-Type"" content=""text/html;charset=gb2312""> or HTML5 <meta charset=""gb2312"">
            docData = Charset.forName(defaultCharset).decode(byteData).toString();
            doc = parser.parseInput(docData, baseUri);
            Element meta = doc.select(""meta[http-equiv=content-type], meta[charset]"").first();
            if (meta != null) { // if not found, will keep utf-8 as best attempt

                 String foundCharset;
                 if (meta.hasAttr(""http-equiv"")) {
                     foundCharset = getCharsetFromContentType(meta.attr(""content""));
                 } else {
                     foundCharset = meta.attr(""charset"");
                 }
 
                 if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode
                     charsetName = foundCharset;
                     byteData.rewind();
                     docData = Charset.forName(foundCharset).decode(byteData).toString();
                    doc = null;
                }
            }
        } else { // specified by content type header (or by user on file load)
            Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
            docData = Charset.forName(charsetName).decode(byteData).toString();
        }
        if (doc == null) {
            // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present
            // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight
            // into head mode
            if (docData.length() > 0 && docData.charAt(0) == 65279)
                docData = docData.substring(1);

            doc = parser.parseInput(docData, baseUri);
            doc.outputSettings().charset(charsetName);
        }
        return doc;
    }"
Jsoup_44,/home/common/huangzhili/defects4j_buggy/Jsoup_44_buggy/src/main/java/org/jsoup/parser/TreeBuilder.java,"    protected abstract boolean process(Token token);

    protected boolean processStartTag(String name) {
        return process(start.reset().name(name));
    }
"
Jsoup_52,/home/common/huangzhili/defects4j_buggy/Jsoup_52_buggy/src/main/java/org/jsoup/parser/XmlTreeBuilder.java,"void insert(Token.Comment commentToken) {
        Comment comment = new Comment(commentToken.getData(), baseUri);
        Node insert = comment;
        if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)
             // so we do a bit of a hack and parse the data as an element to pull the attributes out
             String data = comment.getData();
             if (data.length() > 1 && (data.startsWith(""!"") || data.startsWith(""?""))) {
                 String declaration = data.substring(1);
                 insert = new XmlDeclaration(declaration, comment.baseUri(), data.startsWith(""!""));
             }
         }
         insertNode(insert);
    }"
Jsoup_52,/home/common/huangzhili/defects4j_buggy/Jsoup_52_buggy/src/main/java/org/jsoup/helper/DataUtil.java,"static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {
        String docData;
        Document doc = null;

        // look for BOM - overrides any other header or input
        charsetName = detectCharsetFromBom(byteData, charsetName);

        if (charsetName == null) { // determine from meta. safe first parse as UTF-8
            // look for <meta http-equiv=""Content-Type"" content=""text/html;charset=gb2312""> or HTML5 <meta charset=""gb2312"">
            docData = Charset.forName(defaultCharset).decode(byteData).toString();
            doc = parser.parseInput(docData, baseUri);
            Element meta = doc.select(""meta[http-equiv=content-type], meta[charset]"").first();
            String foundCharset = null; // if not found, will keep utf-8 as best attempt
            if (meta != null) {
                if (meta.hasAttr(""http-equiv"")) {
                     foundCharset = getCharsetFromContentType(meta.attr(""content""));
                 }
                 if (foundCharset == null && meta.hasAttr(""charset"")) {
                     try {
                         if (Charset.isSupported(meta.attr(""charset""))) {
                     foundCharset = meta.attr(""charset"");
                         }
                     } catch (IllegalCharsetNameException e) {
                         foundCharset = null;
                     }
                 }
             }
             // look for <?xml encoding='ISO-8859-1'?>
            if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {
                XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);
                if (prolog.name().equals(""xml"")) {
                    foundCharset = prolog.attr(""encoding"");
                }
            }
            foundCharset = validateCharset(foundCharset);

            if (foundCharset != null && !foundCharset.equals(defaultCharset)) { // need to re-decode
                foundCharset = foundCharset.trim().replaceAll(""[\""']"", """");
                charsetName = foundCharset;
                byteData.rewind();
                docData = Charset.forName(foundCharset).decode(byteData).toString();
                doc = null;
            }
        } else { // specified by content type header (or by user on file load)
            Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
            docData = Charset.forName(charsetName).decode(byteData).toString();
        }
        if (doc == null) {
            doc = parser.parseInput(docData, baseUri);
            doc.outputSettings().charset(charsetName);
        }
        return doc;
    }"
Jsoup_56,/home/common/huangzhili/defects4j_buggy/Jsoup_56_buggy/src/main/java/org/jsoup/nodes/DocumentType.java,"@Override
    void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {
        if (out.syntax() == Syntax.html && !has(PUBLIC_ID) && !has(SYSTEM_ID)) {
            // looks like a html5 doctype, go lowercase for aesthetics
            accum.append(""<!doctype"");
        } else {
            accum.append(""<!DOCTYPE"");
         }
         if (has(NAME))
             accum.append("" "").append(attr(NAME));
         if (has(PUBLIC_ID))
             accum.append("" PUBLIC \"""").append(attr(PUBLIC_ID)).append('""');
         if (has(SYSTEM_ID))
             accum.append("" \"""").append(attr(SYSTEM_ID)).append('""');
         accum.append('>');
    }"
Jsoup_56,/home/common/huangzhili/defects4j_buggy/Jsoup_56_buggy/src/main/java/org/jsoup/parser/Token.java,"@Override
         Token reset() {
             reset(name);
             reset(publicIdentifier);
             reset(systemIdentifier);
             forceQuirks = false;
            return this;
        }"
Jsoup_56,/home/common/huangzhili/defects4j_buggy/Jsoup_56_buggy/src/main/java/org/jsoup/parser/TokeniserState.java,"void read(Tokeniser t, CharacterReader r) {
            if (r.isEmpty()) {
                t.eofError(this);
                t.doctypePending.forceQuirks = true;
                t.emitDoctypePending();
                t.transition(Data);
                return;
            }
            if (r.matchesAny('\t', '\n', '\r', '\f', ' '))
                r.advance(); // ignore whitespace
            else if (r.matches('>')) {
                 t.emitDoctypePending();
                 t.advanceTransition(Data);
             } else if (r.matchConsumeIgnoreCase(DocumentType.PUBLIC_KEY)) {
                 t.transition(AfterDoctypePublicKeyword);
             } else if (r.matchConsumeIgnoreCase(DocumentType.SYSTEM_KEY)) {
                 t.transition(AfterDoctypeSystemKeyword);
             } else {
                 t.error(this);
                t.doctypePending.forceQuirks = true;
                t.advanceTransition(BogusDoctype);
            }

        }"
Jsoup_56,/home/common/huangzhili/defects4j_buggy/Jsoup_56_buggy/src/main/java/org/jsoup/parser/XmlTreeBuilder.java,"void insert(Token.Doctype d) {
         DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);
         insertNode(doctypeNode);
     }"
Jsoup_56,/home/common/huangzhili/defects4j_buggy/Jsoup_56_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                return true; // ignore whitespace
            } else if (t.isComment()) {
                tb.insert(t.asComment());
            } else if (t.isDoctype()) {
                // todo: parse error check on expected doctypes
                 // todo: quirk state check on doctype ids
                 Token.Doctype d = t.asDoctype();
                 DocumentType doctype = new DocumentType(
                     tb.settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());
                 tb.getDocument().appendChild(doctype);
                 if (d.isForceQuirks())
                     tb.getDocument().quirksMode(Document.QuirksMode.quirks);
                tb.transition(BeforeHtml);
            } else {
                // todo: check not iframe srcdoc
                tb.transition(BeforeHtml);
                return tb.process(t); // re-process token
            }
            return true;
        }"
Jsoup_58,/home/common/huangzhili/defects4j_buggy/Jsoup_58_buggy/src/main/java/org/jsoup/safety/Cleaner.java,"    public boolean isValid(Document dirtyDocument) {
        Validate.notNull(dirtyDocument);

        Document clean = Document.createShell(dirtyDocument.baseUri());
        int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());
        return numDiscarded == 0;
    }
"
Jsoup_58,/home/common/huangzhili/defects4j_buggy/Jsoup_58_buggy/src/main/java/org/jsoup/parser/Parser.java,"    public static List<Node> parseXmlFragment(String fragmentXml, String baseUri) {
        XmlTreeBuilder treeBuilder = new XmlTreeBuilder();
        return treeBuilder.parseFragment(fragmentXml, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());
    }
"
Jsoup_58,/home/common/huangzhili/defects4j_buggy/Jsoup_58_buggy/src/main/java/org/jsoup/Jsoup.java,"    public static String clean(String bodyHtml, String baseUri, Whitelist whitelist, Document.OutputSettings outputSettings) {
        Document dirty = parseBodyFragment(bodyHtml, baseUri);
        Cleaner cleaner = new Cleaner(whitelist);
        Document clean = cleaner.clean(dirty);
        clean.outputSettings(outputSettings);
        return clean.body().html();
    }
"
Jsoup_60,/home/common/huangzhili/defects4j_buggy/Jsoup_60_buggy/src/main/java/org/jsoup/parser/TokenQueue.java,"public String chompBalanced(char open, char close) {
        int start = -1;
        int end = -1;
        int depth = 0;
        char last = 0;
        boolean inQuote = false;

        do {
            if (isEmpty()) break;
            Character c = consume();
            if (last == 0 || last != ESC) {
                if ((c.equals('\'') || c.equals('""')) && c != open)
                    inQuote = !inQuote;
                if (inQuote)
                    continue;
                if (c.equals(open)) {
                    depth++;
                    if (start == -1)
                        start = pos;
                }
                else if (c.equals(close))
                    depth--;
            }

            if (depth > 0 && last != 0)
                end = pos; // don't include the outer match pair in the return
             last = c;
         } while (depth > 0);
         final String out = (end >= 0) ? queue.substring(start, end) : """";
         return out;
     }"
Jsoup_63,/home/common/huangzhili/defects4j_buggy/Jsoup_63_buggy/src/main/java/org/jsoup/parser/Tokeniser.java,"void emit(Token token) {
        Validate.isFalse(isEmitPending, ""There is an unread token pending!"");

        emitPending = token;
        isEmitPending = true;

         if (token.type == Token.TokenType.StartTag) {
             Token.StartTag startTag = (Token.StartTag) token;
             lastStartTag = startTag.tagName;
             if (startTag.selfClosing)
                 selfClosingFlagAcknowledged = false;
         } else if (token.type == Token.TokenType.EndTag) {
             Token.EndTag endTag = (Token.EndTag) token;
             if (endTag.attributes != null)
                error(""Attributes incorrectly present on end tag"");
        }
    }"
Jsoup_63,/home/common/huangzhili/defects4j_buggy/Jsoup_63_buggy/src/main/java/org/jsoup/parser/Tokeniser.java,"Token read() {
         if (!selfClosingFlagAcknowledged) {
             error(""Self closing flag not acknowledged"");
             selfClosingFlagAcknowledged = true;
         }
         while (!isEmitPending)
             state.read(this, reader);
 
        // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:
        if (charsBuilder.length() > 0) {
            String str = charsBuilder.toString();
            charsBuilder.delete(0, charsBuilder.length());
            charsString = null;
            return charPending.data(str);
        } else if (charsString != null) {
            Token token = charPending.data(charsString);
            charsString = null;
            return token;
        } else {
            isEmitPending = false;
            return emitPending;
        }
    }"
Jsoup_63,/home/common/huangzhili/defects4j_buggy/Jsoup_63_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java,"Element insertEmpty(Token.StartTag startTag) {
        Tag tag = Tag.valueOf(startTag.name(), settings);
        Element el = new Element(tag, baseUri, startTag.attributes);
         insertNode(el);
         if (startTag.isSelfClosing()) {
             if (tag.isKnownTag()) {
                 if (tag.isSelfClosing()) tokeniser.acknowledgeSelfClosingFlag();
             }
             else {
                 tag.setSelfClosing();
                 tokeniser.acknowledgeSelfClosingFlag();
             }
         }
         return el;
     }"
Jsoup_65,/home/common/huangzhili/defects4j_buggy/Jsoup_65_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"boolean process(Token t, HtmlTreeBuilder tb) {
            switch (t.type) {
                 case StartTag:
                     Token.StartTag startTag = t.asStartTag();
                     String name = startTag.normalName();
                     if (name.equals(""tr"")) {
                         tb.clearStackToTableBodyContext();
                         tb.insert(startTag);
                         tb.transition(InRow);
                    } else if (StringUtil.in(name, ""th"", ""td"")) {
                        tb.error(this);
                        tb.processStartTag(""tr"");
                        return tb.process(startTag);
                    } else if (StringUtil.in(name, ""caption"", ""col"", ""colgroup"", ""tbody"", ""tfoot"", ""thead"")) {
                        return exitTableBody(t, tb);
                    } else
                        return anythingElse(t, tb);
                    break;
                case EndTag:
                    Token.EndTag endTag = t.asEndTag();
                    name = endTag.normalName();
                    if (StringUtil.in(name, ""tbody"", ""tfoot"", ""thead"")) {
                        if (!tb.inTableScope(name)) {
                            tb.error(this);
                            return false;
                        } else {
                            tb.clearStackToTableBodyContext();
                            tb.pop();
                            tb.transition(InTable);
                        }
                    } else if (name.equals(""table"")) {
                        return exitTableBody(t, tb);
                    } else if (StringUtil.in(name, ""body"", ""caption"", ""col"", ""colgroup"", ""html"", ""td"", ""th"", ""tr"")) {
                        tb.error(this);
                        return false;
                    } else
                        return anythingElse(t, tb);
                    break;
                default:
                    return anythingElse(t, tb);
            }
            return true;
        }"
Jsoup_65,/home/common/huangzhili/defects4j_buggy/Jsoup_65_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java,"void clearStackToTableBodyContext() {
         clearStackToContext(""tbody"", ""tfoot"", ""thead"");
     }"
Jsoup_65,/home/common/huangzhili/defects4j_buggy/Jsoup_65_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"boolean process(Token t, HtmlTreeBuilder tb) {
            if (t.isStartTag()) {
                 Token.StartTag startTag = t.asStartTag();
                 String name = startTag.normalName();
 
                 if (StringUtil.in(name, ""th"", ""td"")) {
                     tb.clearStackToTableRowContext();
                     tb.insert(startTag);
                     tb.transition(InCell);
                    tb.insertMarkerToFormattingElements();
                } else if (StringUtil.in(name, ""caption"", ""col"", ""colgroup"", ""tbody"", ""tfoot"", ""thead"", ""tr"")) {
                    return handleMissingTr(t, tb);
                } else {
                    return anythingElse(t, tb);
                }
            } else if (t.isEndTag()) {
                Token.EndTag endTag = t.asEndTag();
                String name = endTag.normalName();

                if (name.equals(""tr"")) {
                    if (!tb.inTableScope(name)) {
                        tb.error(this); // frag
                        return false;
                    }
                    tb.clearStackToTableRowContext();
                    tb.pop(); // tr
                    tb.transition(InTableBody);
                } else if (name.equals(""table"")) {
                    return handleMissingTr(t, tb);
                } else if (StringUtil.in(name, ""tbody"", ""tfoot"", ""thead"")) {
                    if (!tb.inTableScope(name)) {
                        tb.error(this);
                        return false;
                    }
                    tb.processEndTag(""tr"");
                    return tb.process(t);
                } else if (StringUtil.in(name, ""body"", ""caption"", ""col"", ""colgroup"", ""html"", ""td"", ""th"")) {
                    tb.error(this);
                    return false;
                } else {
                    return anythingElse(t, tb);
                }
            } else {
                return anythingElse(t, tb);
            }
            return true;
        }"
Jsoup_66,/home/common/huangzhili/defects4j_buggy/Jsoup_66_buggy/src/main/java/org/jsoup/nodes/Element.java,"protected List<Node> ensureChildNodes() {
         if (childNodes == EMPTY_NODES) {
             childNodes = new NodeList(4);
         }
         return childNodes;
     }"
Jsoup_67,/home/common/huangzhili/defects4j_buggy/Jsoup_67_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java,"    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {
        specificScopeTarget[0] = targetName;
        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);
    }
"
Jsoup_67,/home/common/huangzhili/defects4j_buggy/Jsoup_67_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java,"    private static final String[] TagSearchSpecial = sort(new String[]{""address"", ""applet"", ""area"", ""article"", ""aside"", ""base"", ""basefont"", ""bgsound"",
        ""blockquote"", ""body"", ""br"", ""button"", ""caption"", ""center"", ""col"", ""colgroup"", ""command"", ""dd"",
        ""details"", ""dir"", ""div"", ""dl"", ""dt"", ""embed"", ""fieldset"", ""figcaption"", ""figure"", ""footer"", ""form"",
        ""frame"", ""frameset"", ""h1"", ""h2"", ""h3"", ""h4"", ""h5"", ""h6"", ""head"", ""header"", ""hgroup"", ""hr"", ""html"",
        ""iframe"", ""img"", ""input"", ""isindex"", ""li"", ""link"", ""listing"", ""marquee"", ""menu"", ""meta"", ""nav"",
        ""noembed"", ""noframes"", ""noscript"", ""object"", ""ol"", ""p"", ""param"", ""plaintext"", ""pre"", ""script"",
        ""section"", ""select"", ""style"", ""summary"", ""table"", ""tbody"", ""td"", ""textarea"", ""tfoot"", ""th"", ""thead"",
        ""title"", ""tr"", ""ul"", ""wbr"", ""xmp""});
"
Jsoup_69,/home/common/huangzhili/defects4j_buggy/Jsoup_69_buggy/src/main/java/org/jsoup/nodes/FormElement.java,"    public FormElement addElement(Element element) {
        elements.add(element);
        return this;
    }
"
Jsoup_71,/home/common/huangzhili/defects4j_buggy/Jsoup_71_buggy/src/main/java/org/jsoup/select/QueryParser.java,"private void findElements() {
        if (tq.matchChomp(""#""))
            byId();
        else if (tq.matchChomp("".""))
            byClass();
        else if (tq.matchesWord() || tq.matches(""*|""))
            byTag();
        else if (tq.matches(""[""))
            byAttribute();
        else if (tq.matchChomp(""*""))
            allElements();
        else if (tq.matchChomp("":lt(""))
            indexLessThan();
        else if (tq.matchChomp("":gt(""))
            indexGreaterThan();
        else if (tq.matchChomp("":eq(""))
            indexEquals();
        else if (tq.matches("":has(""))
            has();
        else if (tq.matches("":contains(""))
            contains(false);
        else if (tq.matches("":containsOwn(""))
            contains(true);
        else if (tq.matches("":containsData(""))
            containsData();
        else if (tq.matches("":matches(""))
            matches(false);
        else if (tq.matches("":matchesOwn(""))
            matches(true);
        else if (tq.matches("":not(""))
            not();
		else if (tq.matchChomp("":nth-child(""))
        	cssNthChild(false, false);
        else if (tq.matchChomp("":nth-last-child(""))
        	cssNthChild(true, false);
        else if (tq.matchChomp("":nth-of-type(""))
        	cssNthChild(false, true);
        else if (tq.matchChomp("":nth-last-of-type(""))
        	cssNthChild(true, true);
        else if (tq.matchChomp("":first-child""))
        	evals.add(new Evaluator.IsFirstChild());
        else if (tq.matchChomp("":last-child""))
        	evals.add(new Evaluator.IsLastChild());
        else if (tq.matchChomp("":first-of-type""))
        	evals.add(new Evaluator.IsFirstOfType());
        else if (tq.matchChomp("":last-of-type""))
        	evals.add(new Evaluator.IsLastOfType());
        else if (tq.matchChomp("":only-child""))
        	evals.add(new Evaluator.IsOnlyChild());
        else if (tq.matchChomp("":only-of-type""))
        	evals.add(new Evaluator.IsOnlyOfType());
        else if (tq.matchChomp("":empty""))
         	evals.add(new Evaluator.IsEmpty());
         else if (tq.matchChomp("":root""))
         	evals.add(new Evaluator.IsRoot());
 		else // unhandled
             throw new Selector.SelectorParseException(""Could not parse query '%s': unexpected token at '%s'"", query, tq.remainder());
 
    }"
Jsoup_73,/home/common/huangzhili/defects4j_buggy/Jsoup_73_buggy/src/main/java/org/jsoup/helper/W3CDom.java,"public void tail(org.jsoup.nodes.Node source, int depth) {
             if (source instanceof org.jsoup.nodes.Element && dest.getParentNode() instanceof Element) {
                 dest = (Element) dest.getParentNode(); // undescend. cromulent.
             }
         }"
Jsoup_73,/home/common/huangzhili/defects4j_buggy/Jsoup_73_buggy/src/main/java/org/jsoup/helper/W3CDom.java,"private String updateNamespaces(org.jsoup.nodes.Element el) {
            // scan the element for namespace declarations
            // like: xmlns=""blah"" or xmlns:prefix=""blah""
            Attributes attributes = el.attributes();
            for (Attribute attr : attributes) {
                String key = attr.getKey();
                String prefix;
                if (key.equals(xmlnsKey)) {
                    prefix = """";
                } else if (key.startsWith(xmlnsPrefix)) {
                    prefix = key.substring(xmlnsPrefix.length());
                 } else {
                     continue;
                 }
                 namespaces.put(prefix, attr.getValue());
             }
 
             // get the element prefix if any
            int pos = el.tagName().indexOf("":"");
            return pos > 0 ? el.tagName().substring(0, pos) : """";
        }"
Jsoup_74,/home/common/huangzhili/defects4j_buggy/Jsoup_74_buggy/src/main/java/org/jsoup/helper/StringUtil.java,"public static void appendNormalisedWhitespace(StringBuilder accum, String string, boolean stripLeading) {
        boolean lastWasWhite = false;
        boolean reachedNonWhite = false;

        int len = string.length();
        int c;
        for (int i = 0; i < len; i+= Character.charCount(c)) {
            c = string.codePointAt(i);
            if (isActuallyWhitespace(c)) {
                if ((stripLeading && !reachedNonWhite) || lastWasWhite)
                    continue;
                 accum.append(' ');
                 lastWasWhite = true;
             }
             else {
                 accum.appendCodePoint(c);
                 lastWasWhite = false;
                 reachedNonWhite = true;
            }
        }
    }"
Jsoup_78,/home/common/huangzhili/defects4j_buggy/Jsoup_78_buggy/src/main/java/org/jsoup/helper/DataUtil.java,"static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {
        if (input == null) // empty body
            return new Document(baseUri);
        input = ConstrainableInputStream.wrap(input, bufferSize, 0);

        Document doc = null;
        boolean fullyRead = false;

        // read the start of the stream and look for a BOM or meta charset
        input.mark(bufferSize);
        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.
        fullyRead = input.read() == -1;
        input.reset();

        // look for BOM - overrides any other header or input
        BomCharset bomCharset = detectCharsetFromBom(firstBytes);
        if (bomCharset != null) {
            charsetName = bomCharset.charset;
            input.skip(bomCharset.offset);
        }

        if (charsetName == null) { // determine from meta. safe first parse as UTF-8
            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();
            doc = parser.parseInput(docData, baseUri);

            // look for <meta http-equiv=""Content-Type"" content=""text/html;charset=gb2312""> or HTML5 <meta charset=""gb2312"">
            Elements metaElements = doc.select(""meta[http-equiv=content-type], meta[charset]"");
            String foundCharset = null; // if not found, will keep utf-8 as best attempt
            for (Element meta : metaElements) {
                if (meta.hasAttr(""http-equiv""))
                    foundCharset = getCharsetFromContentType(meta.attr(""content""));
                if (foundCharset == null && meta.hasAttr(""charset""))
                    foundCharset = meta.attr(""charset"");
                if (foundCharset != null)
                    break;
            }

            // look for <?xml encoding='ISO-8859-1'?>
            if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {
                XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);
                if (prolog.name().equals(""xml""))
                    foundCharset = prolog.attr(""encoding"");
            }
            foundCharset = validateCharset(foundCharset);
            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)
                foundCharset = foundCharset.trim().replaceAll(""[\""']"", """");
                charsetName = foundCharset;
                doc = null;
            } else if (!fullyRead) {
                doc = null;
            }
        } else { // specified by content type header (or by user on file load)
            Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
        }
        if (doc == null) {
             if (charsetName == null)
                 charsetName = defaultCharset;
             BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);
                 doc = parser.parseInput(reader, baseUri);
                 // io exception when parsing (not seen before because reading the stream as we go)
             doc.outputSettings().charset(charsetName);
         }
         input.close();
        return doc;
    }"
Jsoup_79,/home/common/huangzhili/defects4j_buggy/Jsoup_79_buggy/src/main/java/org/jsoup/nodes/LeafNode.java,"
import org.jsoup.helper.Validate;

import java.util.List;

abstract class LeafNode extends Node {

    Object value; // either a string value, or an attribute map (in the rare case multiple attributes are set)

"
Jsoup_79,/home/common/huangzhili/defects4j_buggy/Jsoup_79_buggy/src/main/java/org/jsoup/nodes/LeafNode.java,"    public int childNodeSize() {
        return 0;
    }
"
Jsoup_81,/home/common/huangzhili/defects4j_buggy/Jsoup_81_buggy/src/main/java/org/jsoup/helper/DataUtil.java,"static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {
        if (input == null) // empty body
            return new Document(baseUri);
        input = ConstrainableInputStream.wrap(input, bufferSize, 0);

        Document doc = null;
        boolean fullyRead = false;

        // read the start of the stream and look for a BOM or meta charset
        input.mark(bufferSize);
        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.
        fullyRead = input.read() == -1;
        input.reset();

        // look for BOM - overrides any other header or input
        BomCharset bomCharset = detectCharsetFromBom(firstBytes);
        if (bomCharset != null)
            charsetName = bomCharset.charset;

        if (charsetName == null) { // determine from meta. safe first parse as UTF-8
            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();
            doc = parser.parseInput(docData, baseUri);

            // look for <meta http-equiv=""Content-Type"" content=""text/html;charset=gb2312""> or HTML5 <meta charset=""gb2312"">
            Elements metaElements = doc.select(""meta[http-equiv=content-type], meta[charset]"");
            String foundCharset = null; // if not found, will keep utf-8 as best attempt
            for (Element meta : metaElements) {
                if (meta.hasAttr(""http-equiv""))
                    foundCharset = getCharsetFromContentType(meta.attr(""content""));
                if (foundCharset == null && meta.hasAttr(""charset""))
                    foundCharset = meta.attr(""charset"");
                if (foundCharset != null)
                    break;
            }

            // look for <?xml encoding='ISO-8859-1'?>
            if (foundCharset == null && doc.childNodeSize() > 0) {
                Node first = doc.childNode(0);
                 XmlDeclaration decl = null;
                 if (first instanceof XmlDeclaration)
                     decl = (XmlDeclaration) first;
                 if (decl != null) {
                     if (decl.name().equalsIgnoreCase(""xml""))
                         foundCharset = decl.attr(""encoding"");
                }
            }
            foundCharset = validateCharset(foundCharset);
            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)
                foundCharset = foundCharset.trim().replaceAll(""[\""']"", """");
                charsetName = foundCharset;
                doc = null;
            } else if (!fullyRead) {
                doc = null;
            }
        } else { // specified by content type header (or by user on file load)
            Validate.notEmpty(charsetName, ""Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML"");
        }
        if (doc == null) {
            if (charsetName == null)
                charsetName = defaultCharset;
            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);
            if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here
                reader.skip(1);
            try {
                doc = parser.parseInput(reader, baseUri);
            } catch (UncheckedIOException e) {
                // io exception when parsing (not seen before because reading the stream as we go)
                throw e.ioException();
            }
            doc.outputSettings().charset(charsetName);
        }
        input.close();
        return doc;
    }"
Jsoup_83,/home/common/huangzhili/defects4j_buggy/Jsoup_83_buggy/src/main/java/org/jsoup/parser/CharacterReader.java,"String consumeTagName() {
        // '\t', '\n', '\r', '\f', ' ', '/', '>', nullChar
        // NOTE: out of spec, added '<' to fix common author bugs
        bufferUp();
        final int start = bufPos;
        final int remaining = bufLength;
        final char[] val = charBuf;
 
         while (bufPos < remaining) {
             final char c = val[bufPos];
             if (c == '\t'|| c ==  '\n'|| c ==  '\r'|| c ==  '\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)
                 break;
             bufPos++;
         }

        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : """";
    }"
Jsoup_83,/home/common/huangzhili/defects4j_buggy/Jsoup_83_buggy/src/main/java/org/jsoup/parser/TokeniserState.java,"void read(Tokeniser t, CharacterReader r) {
            char c = r.consume();
            switch (c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    break; // ignore whitespace
                case '/':
                    t.transition(SelfClosingStartTag);
                    break;
                    // intended fall through as if >
                case '>':
                    t.emitTagPending();
                    t.transition(Data);
                    break;
                case nullChar:
                    t.error(this);
                    t.tagPending.newAttribute();
                    r.unconsume();
                    t.transition(AttributeName);
                    break;
                case eof:
                    t.eofError(this);
                    t.transition(Data);
                     break;
                 case '""':
                 case '\'':
                 case '<':
                 case '=':
                     t.error(this);
                     t.tagPending.newAttribute();
                    t.tagPending.appendAttributeName(c);
                    t.transition(AttributeName);
                    break;
                default: // A-Z, anything else
                    t.tagPending.newAttribute();
                    r.unconsume();
                    t.transition(AttributeName);
            }
        }"
Jsoup_83,/home/common/huangzhili/defects4j_buggy/Jsoup_83_buggy/src/main/java/org/jsoup/parser/TokeniserState.java,"void read(Tokeniser t, CharacterReader r) {
            // previous TagOpen state did NOT consume, will have a letter char in current
            //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();
            String tagName = r.consumeTagName();
            t.tagPending.appendTagName(tagName);

            char c = r.consume();
            switch (c) {
                case '\t':
                case '\n':
                case '\r':
                case '\f':
                case ' ':
                    t.transition(BeforeAttributeName);
                    break;
                 case '/':
                     t.transition(SelfClosingStartTag);
                     break;
                     // intended fall through to next >
                 case '>':
                     t.emitTagPending();
                    t.transition(Data);
                    break;
                case nullChar: // replacement
                    t.tagPending.appendTagName(replacementStr);
                    break;
                case eof: // should emit pending tag?
                    t.eofError(this);
                    t.transition(Data);
                    break;
                default: // buffer underrun
                    t.tagPending.appendTagName(c);
            }
        }"
Jsoup_87,/home/common/huangzhili/defects4j_buggy/Jsoup_87_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java,"    void reconstructFormattingElements() {
        Element last = lastFormattingElement();
        if (last == null || onStack(last))
            return;

        Element entry = last;
        int size = formattingElements.size();
        int pos = size - 1;
        boolean skip = false;
        while (true) {
            if (pos == 0) { // step 4. if none before, skip to 8
                skip = true;
                break;
            }
            entry = formattingElements.get(--pos); // step 5. one earlier than entry
            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack
                break; // jump to 8, else continue back to 4
        }
        while(true) {
            if (!skip) // step 7: on later than entry
                entry = formattingElements.get(++pos);
            Validate.notNull(entry); // should not occur, as we break at last element

            // 8. create new element from element, 9 insert into current node, onto stack
            skip = false; // can only skip increment from 4.
            Element newEl = insertStartTag(entry.nodeName());
            // newEl.namespace(entry.namespace()); // todo: namespaces
            newEl.attributes().addAll(entry.attributes());

            // 10. replace entry with new entry
            formattingElements.set(pos, newEl);

            // 11
            if (pos == size-1) // if not last entry in list, jump to 7
                break;
        }
    }
"
Jsoup_87,/home/common/huangzhili/defects4j_buggy/Jsoup_87_buggy/src/main/java/org/jsoup/parser/Tag.java,"    public static Tag valueOf(String tagName, ParseSettings settings) {
        Validate.notNull(tagName);
        Tag tag = tags.get(tagName);

        if (tag == null) {
            tagName = settings.normalizeTag(tagName);
            Validate.notEmpty(tagName);
            tag = tags.get(tagName);

            if (tag == null) {
                // not defined: create default; go anywhere, do anything! (incl be inside a <p>)
                tag = new Tag(tagName);
                tag.isBlock = false;
            }
        }
        return tag;
    }
"
Jsoup_87,/home/common/huangzhili/defects4j_buggy/Jsoup_87_buggy/src/main/java/org/jsoup/parser/Tag.java,"    private boolean selfClosing = false; // can self close (<foo />). used for unknown tags that self close, without forcing them as empty.
    private boolean preserveWhitespace = false; // for pre, textarea, script etc
    private boolean formList = false; // a control that appears in forms: input, textarea, output etc
    private boolean formSubmit = false; // a control that can be submitted in a form: input etc

    private Tag(String tagName) {
        this.tagName = tagName;
    }
"
Jsoup_87,/home/common/huangzhili/defects4j_buggy/Jsoup_87_buggy/src/main/java/org/jsoup/parser/Tag.java,"    private static final Map<String, Tag> tags = new HashMap<>(); // map of known tags

    private String tagName;
    private boolean isBlock = true; // block or inline
    private boolean formatAsBlock = true; // should be formatted as a block
    private boolean canContainInline = true; // only pcdata if not
    private boolean empty = false; // can hold nothing; e.g. img
    private boolean selfClosing = false; // can self close (<foo />). used for unknown tags that self close, without forcing them as empty.
    private boolean preserveWhitespace = false; // for pre, textarea, script etc
    private boolean formList = false; // a control that appears in forms: input, textarea, output etc
    private boolean formSubmit = false; // a control that can be submitted in a form: input etc

    private Tag(String tagName) {
        this.tagName = tagName;
    }
"
Jsoup_87,/home/common/huangzhili/defects4j_buggy/Jsoup_87_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {
            tb.error(this);
            return false;
        }
"
Jsoup_87,/home/common/huangzhili/defects4j_buggy/Jsoup_87_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"        private void closeCell(HtmlTreeBuilder tb) {
            if (tb.inTableScope(""td""))
                tb.processEndTag(""td"");
            else
                tb.processEndTag(""th""); // only here if th or td in scope
        }
"
Jsoup_87,/home/common/huangzhili/defects4j_buggy/Jsoup_87_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"        private boolean exitTableBody(Token t, HtmlTreeBuilder tb) {
            if (!(tb.inTableScope(""tbody"") || tb.inTableScope(""thead"") || tb.inScope(""tfoot""))) {
                // frag case
                tb.error(this);
                return false;
            }
            tb.clearStackToTableBodyContext();
            tb.processEndTag(tb.currentElement().nodeName());
            return tb.process(t);
        }
"
Jsoup_87,/home/common/huangzhili/defects4j_buggy/Jsoup_87_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"                            final int stackSize = stack.size();
                            for (int si = 0; si < stackSize && si < 64; si++) {
                                Element el = stack.get(si);
                                if (el == formatEl) {
                                    commonAncestor = stack.get(si - 1);
                                    seenFormattingElement = true;
                                } else if (seenFormattingElement && tb.isSpecial(el)) {
                                    furthestBlock = el;
                                    break;
                                }
                            }
"
Jsoup_87,/home/common/huangzhili/defects4j_buggy/Jsoup_87_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {
            tb.processStartTag(""body"");
            tb.framesetOk(true);
            return tb.process(t);
        }
"
Jsoup_87,/home/common/huangzhili/defects4j_buggy/Jsoup_87_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java,"    void removeFromActiveFormattingElements(Element el) {
        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {
            Element next = formattingElements.get(pos);
            if (next == el) {
                formattingElements.remove(pos);
                break;
            }
        }
    }
"
Jsoup_87,/home/common/huangzhili/defects4j_buggy/Jsoup_87_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java,"    void pushActiveFormattingElements(Element in) {
        int numSeen = 0;
        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {
            Element el = formattingElements.get(pos);
            if (el == null) // marker
                break;

            if (isSameFormattingElement(in, el))
                numSeen++;

            if (numSeen == 3) {
                formattingElements.remove(pos);
                break;
            }
        }
        formattingElements.add(in);
    }
"
Jsoup_87,/home/common/huangzhili/defects4j_buggy/Jsoup_87_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java,"    void resetInsertionMode() {
        boolean last = false;
        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element node = stack.get(pos);
            if (pos == 0) {
                last = true;
                node = contextElement;
            }
            String name = node.nodeName();
            if (""select"".equals(name)) {
                transition(HtmlTreeBuilderState.InSelect);
                break; // frag
            } else if ((""td"".equals(name) || ""th"".equals(name) && !last)) {
                transition(HtmlTreeBuilderState.InCell);
                break;
            } else if (""tr"".equals(name)) {
                transition(HtmlTreeBuilderState.InRow);
                break;
            } else if (""tbody"".equals(name) || ""thead"".equals(name) || ""tfoot"".equals(name)) {
                transition(HtmlTreeBuilderState.InTableBody);
                break;
            } else if (""caption"".equals(name)) {
                transition(HtmlTreeBuilderState.InCaption);
                break;
            } else if (""colgroup"".equals(name)) {
                transition(HtmlTreeBuilderState.InColumnGroup);
                break; // frag
            } else if (""table"".equals(name)) {
                transition(HtmlTreeBuilderState.InTable);
                break;
            } else if (""head"".equals(name)) {
                transition(HtmlTreeBuilderState.InBody);
                break; // frag
            } else if (""body"".equals(name)) {
                transition(HtmlTreeBuilderState.InBody);
                break;
            } else if (""frameset"".equals(name)) {
                transition(HtmlTreeBuilderState.InFrameset);
                break; // frag
            } else if (""html"".equals(name)) {
                transition(HtmlTreeBuilderState.BeforeHead);
                break; // frag
            } else if (last) {
                transition(HtmlTreeBuilderState.InBody);
                break; // frag
            }
        }
    }
"
Jsoup_87,/home/common/huangzhili/defects4j_buggy/Jsoup_87_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java,"    void newPendingTableCharacters() {
        pendingTableCharacters = new ArrayList<>();
    }
"
Jsoup_87,/home/common/huangzhili/defects4j_buggy/Jsoup_87_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java,"            final String elName = stack.get(pos).nodeName();
            if (inSorted(elName, targetNames))
                return true;
            if (inSorted(elName, baseTypes))
                return false;
            if (extraTypes != null && inSorted(elName, extraTypes))
                return false;
        }
        //Validate.fail(""Should not be reachable""); // would end up false because hitting 'html' at root (basetypes)
        return false;
    }

    boolean inScope(String[] targetNames) {
        return inSpecificScope(targetNames, TagsSearchInScope, null);
    }

    boolean inScope(String targetName) {
        return inScope(targetName, null);
    }

    boolean inScope(String targetName, String[] extras) {
        return inSpecificScope(targetName, TagsSearchInScope, extras);
        // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml
        // todo: in svg namespace: forignOjbect, desc, title
    }

    boolean inListItemScope(String targetName) {
        return inScope(targetName, TagSearchList);
    }

    boolean inButtonScope(String targetName) {
        return inScope(targetName, TagSearchButton);
    }

    boolean inTableScope(String targetName) {
        return inSpecificScope(targetName, TagSearchTableScope, null);
    }

    boolean inSelectScope(String targetName) {
        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element el = stack.get(pos);
            String elName = el.nodeName();
            if (elName.equals(targetName))
                return true;
            if (!inSorted(elName, TagSearchSelectScope)) // all elements except
                return false;
        }
        Validate.fail(""Should not be reachable"");
        return false;
    }

    void setHeadElement(Element headElement) {
        this.headElement = headElement;
    }

    Element getHeadElement() {
        return headElement;
    }

    boolean isFosterInserts() {
        return fosterInserts;
    }

    void setFosterInserts(boolean fosterInserts) {
        this.fosterInserts = fosterInserts;
    }

    FormElement getFormElement() {
        return formElement;
    }

    void setFormElement(FormElement formElement) {
        this.formElement = formElement;
    }

    void newPendingTableCharacters() {
        pendingTableCharacters = new ArrayList<>();
    }

    List<String> getPendingTableCharacters() {
        return pendingTableCharacters;
    }

    /**
     11.2.5.2 Closing elements that have implied end tags<p/>
     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a
     dt element, an li element, an option element, an optgroup element, a p element, an rp element, or an rt element,
     the UA must pop the current node off the stack of open elements.

     @param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the
     process, then the UA must perform the above steps as if that element was not in the above list.
"
Jsoup_87,/home/common/huangzhili/defects4j_buggy/Jsoup_87_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java,"        final int bottom = stack.size() -1;
        final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;
        // don't walk too far up the tree

        for (int pos = bottom; pos >= top; pos--) {
            final String elName = stack.get(pos).nodeName();
            if (inSorted(elName, targetNames))
                return true;
            if (inSorted(elName, baseTypes))
                return false;
            if (extraTypes != null && inSorted(elName, extraTypes))
                return false;
        }
"
Jsoup_87,/home/common/huangzhili/defects4j_buggy/Jsoup_87_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java,"    private void clearStackToContext(String... nodeNames) {
        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element next = stack.get(pos);
            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(""html""))
                break;
            else
                stack.remove(pos);
        }
    }
"
Jsoup_87,/home/common/huangzhili/defects4j_buggy/Jsoup_87_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java,"    void popStackToBefore(String elName) {
        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element next = stack.get(pos);
            if (next.nodeName().equals(elName)) {
                break;
            } else {
                stack.remove(pos);
            }
        }
    }
"
Jsoup_87,/home/common/huangzhili/defects4j_buggy/Jsoup_87_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java,"    void popStackToClose(String... elNames) {
        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element next = stack.get(pos);
            stack.remove(pos);
            if (inSorted(next.nodeName(), elNames))
                break;
        }
    }
"
Jsoup_87,/home/common/huangzhili/defects4j_buggy/Jsoup_87_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java,"    void popStackToClose(String elName) {
        for (int pos = stack.size() -1; pos >= 0; pos--) {
            Element next = stack.get(pos);
            stack.remove(pos);
            if (next.nodeName().equals(elName))
                break;
        }
    }
"
Jsoup_87,/home/common/huangzhili/defects4j_buggy/Jsoup_87_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java,"    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {
        for (int pos = queue.size() -1; pos >= 0; pos--) {
            Element next = queue.get(pos);
            if (next == element) {
                return true;
            }
        }
        return false;
    }
"
Jsoup_87,/home/common/huangzhili/defects4j_buggy/Jsoup_87_buggy/src/main/java/org/jsoup/nodes/Element.java,"    public Element tagName(String tagName) {
        Validate.notEmpty(tagName, ""Tag name must not be empty."");
        tag = Tag.valueOf(tagName, NodeUtils.parser(this).settings()); // maintains the case option of the original parse
        return this;
    }
"
Jsoup_87,/home/common/huangzhili/defects4j_buggy/Jsoup_87_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java,"    void generateImpliedEndTags() {
        generateImpliedEndTags(null);
    }
"
Jsoup_91,/home/common/huangzhili/defects4j_buggy/Jsoup_91_buggy/src/main/java/org/jsoup/UncheckedIOException.java,"    public UncheckedIOException(IOException cause) {
        super(cause);
    }
"
Jsoup_91,/home/common/huangzhili/defects4j_buggy/Jsoup_91_buggy/src/main/java/org/jsoup/parser/CharacterReader.java,"    public String consumeToAny(final char... chars) {
        bufferUp();
        int pos = bufPos;
        final int start = pos;
        final int remaining = bufLength;
        final char[] val = charBuf;
        final int charLen = chars.length;
        int i;

        OUTER: while (pos < remaining) {
            for (i = 0; i < charLen; i++) {
                if (val[pos] == chars[i])
                    break OUTER;
            }
            pos++;
        }

        bufPos = pos;
        return pos > start ? cacheString(charBuf, stringCache, start, pos -start) : """";
    }
"
Jsoup_91,/home/common/huangzhili/defects4j_buggy/Jsoup_91_buggy/src/main/java/org/jsoup/parser/CharacterReader.java,"    public CharacterReader(Reader input, int sz) {
        Validate.notNull(input);
        Validate.isTrue(input.markSupported());
        reader = input;
        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];
        bufferUp();

    }
"
Jsoup_92,/home/common/huangzhili/defects4j_buggy/Jsoup_92_buggy/src/main/java/org/jsoup/parser/XmlTreeBuilder.java,"Element insert(Token.StartTag startTag) {
         Tag tag = Tag.valueOf(startTag.name(), settings);
         // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.
 
         Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));
         insertNode(el);
        if (startTag.isSelfClosing()) {
            if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output. see above.
                tag.setSelfClosing();
        } else {
            stack.add(el);
        }
        return el;
    }"
Jsoup_92,/home/common/huangzhili/defects4j_buggy/Jsoup_92_buggy/src/main/java/org/jsoup/parser/Token.java,"final void newAttribute() {
            if (attributes == null)
                attributes = new Attributes();

            if (pendingAttributeName != null) {
                // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here
                pendingAttributeName = pendingAttributeName.trim();
                if (pendingAttributeName.length() > 0) {
                    String value;
                    if (hasPendingAttributeValue)
                        value = pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS;
                    else if (hasEmptyAttributeValue)
                        value = """";
                     else
                         value = null;
                     // note that we add, not put. So that the first is kept, and rest are deduped, once in a context where case sensitivity is known (the appropriate tree builder).
                     attributes.put(pendingAttributeName, value);
                 }
             }
             pendingAttributeName = null;
            hasEmptyAttributeValue = false;
            hasPendingAttributeValue = false;
            reset(pendingAttributeValue);
            pendingAttributeValueS = null;
        }"
Jsoup_92,/home/common/huangzhili/defects4j_buggy/Jsoup_92_buggy/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java,"Element insert(final Token.StartTag startTag) {
         // cleanup duplicate attributes:
 
         // handle empty unknown tags
         // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.
        if (startTag.isSelfClosing()) {
            Element el = insertEmpty(startTag);
            stack.add(el);
            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data
            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing
            return el;
        }

        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));
        insert(el);
        return el;
    }"
JxPath_1,/home/common/huangzhili/defects4j_buggy/JxPath_1_buggy/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,"    public static boolean testNode(Node node, NodeTest test) {
        if (test == null) {
            return true;
        }
        else if (test instanceof NodeNameTest) {
            if (node.getNodeType() != Node.ELEMENT_NODE) {
                return false;
            }

            NodeNameTest nodeNameTest = (NodeNameTest) test;
            QName testName = nodeNameTest.getNodeName();
            String namespaceURI = nodeNameTest.getNamespaceURI();
            boolean wildcard = nodeNameTest.isWildcard();
            String testPrefix = testName.getPrefix();
            if (wildcard && testPrefix == null) {
                return true;
            }

            if (wildcard
                || testName.getName()
                        .equals(DOMNodePointer.getLocalName(node))) {
                String nodeNS = DOMNodePointer.getNamespaceURI(node);
                return equalStrings(namespaceURI, nodeNS);
            }
        }
        else if (test instanceof NodeTypeTest) {
            int nodeType = node.getNodeType();
            switch (((NodeTypeTest) test).getNodeType()) {
                case Compiler.NODE_TYPE_NODE :
                    return nodeType == Node.ELEMENT_NODE;
                case Compiler.NODE_TYPE_TEXT :
                    return nodeType == Node.CDATA_SECTION_NODE
                        || nodeType == Node.TEXT_NODE;
                case Compiler.NODE_TYPE_COMMENT :
                    return nodeType == Node.COMMENT_NODE;
                case Compiler.NODE_TYPE_PI :
                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;
            }
            return false;
        }
        else if (test instanceof ProcessingInstructionTest) {
            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {
                String testPI = ((ProcessingInstructionTest) test).getTarget();
                String nodePI = ((ProcessingInstruction) node).getTarget();
                return testPI.equals(nodePI);
            }
        }
        return false;
    }
"
JxPath_1,/home/common/huangzhili/defects4j_buggy/JxPath_1_buggy/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java,"    public static boolean testNode(
        NodePointer pointer,
        Object node,
        NodeTest test) 
    {
        if (test == null) {
            return true;
        }
        else if (test instanceof NodeNameTest) {
            if (!(node instanceof Element)) {
                return false;
            }

            NodeNameTest nodeNameTest = (NodeNameTest) test;
            QName testName = nodeNameTest.getNodeName();
            String namespaceURI = nodeNameTest.getNamespaceURI();
            boolean wildcard = nodeNameTest.isWildcard();
            String testPrefix = testName.getPrefix();
            if (wildcard && testPrefix == null) {
                return true;
            }

            if (wildcard
                || testName.getName()
                        .equals(JDOMNodePointer.getLocalName(node))) {
                String nodeNS = JDOMNodePointer.getNamespaceURI(node);
                return equalStrings(namespaceURI, nodeNS);
            }

        }
        else if (test instanceof NodeTypeTest) {
            switch (((NodeTypeTest) test).getNodeType()) {
                case Compiler.NODE_TYPE_NODE :
                    return node instanceof Element;
                case Compiler.NODE_TYPE_TEXT :
                    return (node instanceof Text) || (node instanceof CDATA);
                case Compiler.NODE_TYPE_COMMENT :
                    return node instanceof Comment;
                case Compiler.NODE_TYPE_PI :
                    return node instanceof ProcessingInstruction;
            }
            return false;
        }
        else if (test instanceof ProcessingInstructionTest) {
            if (node instanceof ProcessingInstruction) {
                String testPI = ((ProcessingInstructionTest) test).getTarget();
                String nodePI = ((ProcessingInstruction) node).getTarget();
                return testPI.equals(nodePI);
            }
        }

        return false;
    }
"
JxPath_2,/home/common/huangzhili/defects4j_buggy/JxPath_2_buggy/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java,"public Iterator iteratePointers(EvalContext context) {
        Object result = compute(context);
        if (result == null) {
            return Collections.EMPTY_LIST.iterator();
        }
         if (result instanceof EvalContext) {
             return (EvalContext) result;
         }
         return new PointerIterator(ValueUtils.iterate(result),
                 new QName(null, ""value""),
                 context.getRootContext().getCurrentNodePointer().getLocale());
    }"
JxPath_2,/home/common/huangzhili/defects4j_buggy/JxPath_2_buggy/src/java/org/apache/commons/jxpath/ri/compiler/Expression.java,"public Iterator iterate(EvalContext context) {
        Object result = compute(context);
         if (result instanceof EvalContext) {
             return new ValueIterator((EvalContext) result);
         }
         return ValueUtils.iterate(result);
     }"
JxPath_3,/home/common/huangzhili/defects4j_buggy/JxPath_3_buggy/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java,"public NodePointer createPath(JXPathContext context, Object value) {
        NodePointer newParent = parent.createPath(context);
        if (isAttribute()) {
            NodePointer pointer = newParent.createAttribute(context, getName());
            pointer.setValue(value);
             return pointer;
         }
         else {
             if (newParent instanceof PropertyOwnerPointer) {
                 PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;
                 newParent = pop.getPropertyPointer();
            }
            return newParent.createChild(context, getName(), index, value);
        }
    }"
JxPath_3,/home/common/huangzhili/defects4j_buggy/JxPath_3_buggy/src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java,"public NodePointer createPath(JXPathContext context) {
        NodePointer newParent = parent.createPath(context);
        if (isAttribute()) {
             return newParent.createAttribute(context, getName());
         }
         else {
             // Consider these two use cases:
             // 1. The parent pointer of NullPropertyPointer is 
             //    a PropertyOwnerPointer other than NullPointer. When we call 
            //    createPath on it, it most likely returns itself. We then
            //    take a PropertyPointer from it and get the PropertyPointer
            //    to expand the collection for the corresponding property.
            //
            // 2. The parent pointer of NullPropertyPointer is a NullPointer.
            //    When we call createPath, it may return a PropertyOwnerPointer
            //    or it may return anything else, like a DOMNodePointer.
            //    In the former case we need to do exactly what we did in use 
            //    case 1.  In the latter case, we simply request that the 
            //    non-property pointer expand the collection by itself.
            if (newParent instanceof PropertyOwnerPointer) {
                PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;
                newParent = pop.getPropertyPointer();
            }
            return newParent.createChild(context, getName(), getIndex());
        }
    }"
JxPath_4,/home/common/huangzhili/defects4j_buggy/JxPath_4_buggy/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java,"public Object getValue() {
         if (node instanceof Element) {
             return ((Element) node).getTextTrim();
         }
         if (node instanceof Comment) {
             String text = ((Comment) node).getText();
            if (text != null) {
                text = text.trim();
            }
            return text;
        }
        if (node instanceof Text) {
            return ((Text) node).getTextTrim();
        }
        if (node instanceof CDATA) {
            return ((CDATA) node).getTextTrim();
        }
        if (node instanceof ProcessingInstruction) {
            String text = ((ProcessingInstruction) node).getData();
            if (text != null) {
                text = text.trim();
            }
            return text;
        }
        return null;
    }"
JxPath_7,/home/common/huangzhili/defects4j_buggy/JxPath_7_buggy/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThanOrEqual.java,"    public CoreOperationGreaterThanOrEqual(Expression arg1, Expression arg2) {
        super(new Expression[] { arg1, arg2 });
    }
"
JxPath_7,/home/common/huangzhili/defects4j_buggy/JxPath_7_buggy/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThan.java,"    public CoreOperationLessThan(Expression arg1, Expression arg2) {
        super(new Expression[] { arg1, arg2 });
    }
"
JxPath_7,/home/common/huangzhili/defects4j_buggy/JxPath_7_buggy/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThanOrEqual.java,"    public CoreOperationLessThanOrEqual(Expression arg1, Expression arg2) {
        super(new Expression[] { arg1, arg2 });
    }
"
JxPath_7,/home/common/huangzhili/defects4j_buggy/JxPath_7_buggy/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java,"    protected CoreOperationRelationalExpression(Expression[] args) {
        super(args);
    }
"
JxPath_7,/home/common/huangzhili/defects4j_buggy/JxPath_7_buggy/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java,"    protected final boolean isSymmetric() {
        return false;
    }
"
JxPath_7,/home/common/huangzhili/defects4j_buggy/JxPath_7_buggy/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThan.java,"    public CoreOperationGreaterThan(Expression arg1, Expression arg2) {
        super(new Expression[] { arg1, arg2 });
    }
"
JxPath_9,/home/common/huangzhili/defects4j_buggy/JxPath_9_buggy/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java,"protected boolean equal(Object l, Object r) {
        if (l instanceof Pointer && r instanceof Pointer) {
            if (l.equals(r)) {
                return true;
            }
        }
        if (l instanceof Pointer) {
            l = ((Pointer) l).getValue();
        }

        if (r instanceof Pointer) {
             r = ((Pointer) r).getValue();
         }
 
         if (l == r) {
             return true;
         }
         if (l instanceof Boolean || r instanceof Boolean) {
             return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));
             }
             //if either side is NaN, no comparison returns true:
         if (l instanceof Number || r instanceof Number) {
             return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));
             }
             if (l instanceof String || r instanceof String) {
             return (
                 InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));
         }
         return l != null && l.equals(r);
     }"
JxPath_11,/home/common/huangzhili/defects4j_buggy/JxPath_11_buggy/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java,"public boolean setPosition(int position) {
        if (attributes == null) {
            return false;
        }
        this.position = position;
        return position >= 1 && position <= attributes.size();
    }"
JxPath_11,/home/common/huangzhili/defects4j_buggy/JxPath_11_buggy/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java,"private Attr getAttribute(Element element, QName name) {
        String testPrefix = name.getPrefix();
         String testNS = null;
 
         if (testPrefix != null) {
             testNS = parent.getNamespaceURI(testPrefix);
         }
 
         if (testNS != null) {
            Attr attr = element.getAttributeNodeNS(testNS, name.getName());
            if (attr != null) {
                return attr;
            }

            // This may mean that the parser does not support NS for
            // attributes, example - the version of Crimson bundled
            // with JDK 1.4.0
            NamedNodeMap nnm = element.getAttributes();
            for (int i = 0; i < nnm.getLength(); i++) {
                attr = (Attr) nnm.item(i);
                if (testAttr(attr, name)) {
                    return attr;
                }
            }
            return null;
        }
        return element.getAttributeNode(name.getName());
    }"
JxPath_13,/home/common/huangzhili/defects4j_buggy/JxPath_13_buggy/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,"public NodePointer createAttribute(JXPathContext context, QName name) {
        if (!(node instanceof Element)) {
            return super.createAttribute(context, name);
        }
         Element element = (Element) node;
         String prefix = name.getPrefix();
         if (prefix != null) {
             String ns = getNamespaceURI(prefix);
             if (ns == null) {
                 throw new JXPathException(
                     ""Unknown namespace prefix: "" + prefix);
            }
            element.setAttributeNS(ns, name.toString(), """");
        }
        else {
            if (!element.hasAttribute(name.getName())) {
                element.setAttribute(name.getName(), """");
            }
        }
        NodeIterator it = attributeIterator(name);
        it.setPosition(1);
        return it.getNodePointer();
    }"
JxPath_13,/home/common/huangzhili/defects4j_buggy/JxPath_13_buggy/src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java,"public synchronized String getPrefix(String namespaceURI) {

    /**
     * Get the nearest prefix found that matches an externally-registered namespace. 
     * @param namespaceURI
     * @return String prefix if found.
     * @since JXPath 1.3
     */
        if (reverseMap == null) {
            reverseMap = new HashMap();
            NodeIterator ni = pointer.namespaceIterator();
            if (ni != null) {
                for (int position = 1; ni.setPosition(position); position++) {
                    NodePointer nsPointer = ni.getNodePointer();
                    String uri = nsPointer.getNamespaceURI();                    
                    String prefix = nsPointer.getName().getName();
                    if (!"""".equals(prefix)) {
                        reverseMap.put(uri, prefix);
                    }
                }
            }
            Iterator it = namespaceMap.entrySet().iterator();
            while (it.hasNext()) {
                Map.Entry entry = (Map.Entry) it.next();
                reverseMap.put(entry.getValue(), entry.getKey());
             }
         }
         String prefix = (String) reverseMap.get(namespaceURI);
         if (prefix == null && parent != null) {
             return parent.getPrefix(namespaceURI);
         }
         return prefix;
     }"
JxPath_14,/home/common/huangzhili/defects4j_buggy/JxPath_14_buggy/src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java,"    protected Object functionFloor(EvalContext context) {
        assertArgCount(1);
        double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));
        return new Double(Math.floor(v));
    }
"
JxPath_15,/home/common/huangzhili/defects4j_buggy/JxPath_15_buggy/src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java,"public boolean setPosition(int position) {
        if (!prepared) {
            prepared = true;
            BasicNodeSet nodeSet = (BasicNodeSet) getNodeSet();
            ArrayList pointers = new ArrayList();
            for (int i = 0; i < contexts.length; i++) {
                EvalContext ctx = (EvalContext) contexts[i];
                while (ctx.nextSet()) {
                    while (ctx.nextNode()) {
                        NodePointer ptr = ctx.getCurrentNodePointer();
                        if (!pointers.contains(ptr)) {
                            nodeSet.add(ptr);
                            pointers.add(ptr);
                        }
                    }
                }
            }
        }
        return super.setPosition(position);
    }
}"
JxPath_16,/home/common/huangzhili/defects4j_buggy/JxPath_16_buggy/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java,"public static boolean testNode(
        NodePointer pointer,
        Object node,
        NodeTest test)
    {
        if (test == null) {
            return true;
        }
        if (test instanceof NodeNameTest) {
            if (!(node instanceof Element)) {
                return false;
            }

            NodeNameTest nodeNameTest = (NodeNameTest) test;
            QName testName = nodeNameTest.getNodeName();
            String namespaceURI = nodeNameTest.getNamespaceURI();
            boolean wildcard = nodeNameTest.isWildcard();
            String testPrefix = testName.getPrefix();
            if (wildcard && testPrefix == null) {
                return true;
            }
            if (wildcard
                || testName.getName()
                        .equals(JDOMNodePointer.getLocalName(node))) {
                String nodeNS = JDOMNodePointer.getNamespaceURI(node);
                return equalStrings(namespaceURI, nodeNS) || nodeNS == null
                        && equalStrings(testPrefix, getPrefix(node));
            }
            return false;
        }
         if (test instanceof NodeTypeTest) {
             switch (((NodeTypeTest) test).getNodeType()) {
                 case Compiler.NODE_TYPE_NODE :
                     return (node instanceof Element) || (node instanceof Document);
                 case Compiler.NODE_TYPE_TEXT :
                     return (node instanceof Text) || (node instanceof CDATA);
                 case Compiler.NODE_TYPE_COMMENT :
                    return node instanceof Comment;
                case Compiler.NODE_TYPE_PI :
                    return node instanceof ProcessingInstruction;
            }
            return false;
        }
        if (test instanceof ProcessingInstructionTest && node instanceof ProcessingInstruction) {
            String testPI = ((ProcessingInstructionTest) test).getTarget();
            String nodePI = ((ProcessingInstruction) node).getTarget();
            return testPI.equals(nodePI);
        }
        return false;
    }"
JxPath_16,/home/common/huangzhili/defects4j_buggy/JxPath_16_buggy/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java,"public static boolean testNode(Node node, NodeTest test) {
        if (test == null) {
            return true;
        }
        if (test instanceof NodeNameTest) {
            if (node.getNodeType() != Node.ELEMENT_NODE) {
                return false;
            }

            NodeNameTest nodeNameTest = (NodeNameTest) test;
            QName testName = nodeNameTest.getNodeName();
            String namespaceURI = nodeNameTest.getNamespaceURI();
            boolean wildcard = nodeNameTest.isWildcard();
            String testPrefix = testName.getPrefix();
            if (wildcard && testPrefix == null) {
                return true;
            }
            if (wildcard
                || testName.getName()
                        .equals(DOMNodePointer.getLocalName(node))) {
                String nodeNS = DOMNodePointer.getNamespaceURI(node);
                return equalStrings(namespaceURI, nodeNS) || nodeNS == null
                        && equalStrings(testPrefix, getPrefix(node));
            }
            return false;
        }
        if (test instanceof NodeTypeTest) {
             int nodeType = node.getNodeType();
             switch (((NodeTypeTest) test).getNodeType()) {
                 case Compiler.NODE_TYPE_NODE :
                     return nodeType == Node.ELEMENT_NODE
                             || nodeType == Node.DOCUMENT_NODE;
                 case Compiler.NODE_TYPE_TEXT :
                     return nodeType == Node.CDATA_SECTION_NODE
                         || nodeType == Node.TEXT_NODE;
                case Compiler.NODE_TYPE_COMMENT :
                    return nodeType == Node.COMMENT_NODE;
                case Compiler.NODE_TYPE_PI :
                    return nodeType == Node.PROCESSING_INSTRUCTION_NODE;
            }
            return false;
        }
        if (test instanceof ProcessingInstructionTest) {
            if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {
                String testPI = ((ProcessingInstructionTest) test).getTarget();
                String nodePI = ((ProcessingInstruction) node).getTarget();
                return testPI.equals(nodePI);
            }
        }
        return false;
    }"
JxPath_17,/home/common/huangzhili/defects4j_buggy/JxPath_17_buggy/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java,"public boolean setPosition(int position) {
        this.position = position;
        return position >= 1 && position <= attributes.size();
    }"
JxPath_17,/home/common/huangzhili/defects4j_buggy/JxPath_17_buggy/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java,"public boolean setPosition(int position) {
        if (attributes == null) {
            return false;
        }
        this.position = position;
        return position >= 1 && position <= attributes.size();
    }"
JxPath_17,/home/common/huangzhili/defects4j_buggy/JxPath_17_buggy/src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java,"private boolean testAttr(Attr attr) {
        String nodePrefix = DOMNodePointer.getPrefix(attr);
        String nodeLocalName = DOMNodePointer.getLocalName(attr);

        if (nodePrefix != null && nodePrefix.equals(""xmlns"")) {
            return false;
        }

        if (nodePrefix == null && nodeLocalName.equals(""xmlns"")) {
            return false;
        }

        String testLocalName = name.getName();
         if (testLocalName.equals(""*"") || testLocalName.equals(nodeLocalName)) {
             String testPrefix = name.getPrefix();
 
             if (equalStrings(testPrefix, nodePrefix)) {
                 return true;
             }
             String testNS = null;
             if (testPrefix != null) {
                 testNS = parent.getNamespaceURI(testPrefix);
             }
             String nodeNS = null;
             if (nodePrefix != null) {
                 nodeNS = parent.getNamespaceURI(nodePrefix);
             }
             return equalStrings(testNS, nodeNS);
         }
         return false;
     }"
JxPath_18,/home/common/huangzhili/defects4j_buggy/JxPath_18_buggy/src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java,"public boolean nextNode() {
        super.setPosition(getCurrentPosition() + 1);
        if (!setStarted) {
            setStarted = true;
            if (!(nodeTest instanceof NodeNameTest)) {
                return false;
            }
            QName name = ((NodeNameTest) nodeTest).getNodeName();
            iterator =
                parentContext.getCurrentNodePointer().attributeIterator(name);
        }
        if (iterator == null) {
            return false;
        }
        if (!iterator.setPosition(iterator.getPosition() + 1)) {
            return false;
        }
        currentNodePointer = iterator.getNodePointer();
        return true;
    }"
JxPath_19,/home/common/huangzhili/defects4j_buggy/JxPath_19_buggy/src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java,"private int getRelativePositionByQName() {
        if (node instanceof Element) {
            Object parent = ((Element) node).getParent();
            if (!(parent instanceof Element)) {
                return 1;
            }

            List children = ((Element) parent).getContent();
            int count = 0;
             String name = ((Element) node).getQualifiedName();
             for (int i = 0; i < children.size(); i++) {
                 Object child = children.get(i);
                 if ((child instanceof Element)
                     && ((Element) child).getQualifiedName().equals(name)) {
                     count++;
                 }
                 if (child == node) {
                    break;
                }
            }
            return count;
        }
        return 1;
    }"
JxPath_20,/home/common/huangzhili/defects4j_buggy/JxPath_20_buggy/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java,"private boolean compute(Object left, Object right) {
        left = reduce(left);
        right = reduce(right);

        if (left instanceof InitialContext) {
            ((InitialContext) left).reset();
        }
        if (right instanceof InitialContext) {
            ((InitialContext) right).reset();
        }
        if (left instanceof Iterator && right instanceof Iterator) {
            return findMatch((Iterator) left, (Iterator) right);
        }
        if (left instanceof Iterator) {
             return containsMatch((Iterator) left, right);
         }
         if (right instanceof Iterator) {
             return containsMatch((Iterator) right, left);
         }
         double ld = InfoSetUtil.doubleValue(left);
         if (Double.isNaN(ld)) {
            return false;
        }
        double rd = InfoSetUtil.doubleValue(right);
        if (Double.isNaN(rd)) {
            return false;
        }
        return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);
    }"
Lang_4,/home/common/huangzhili/defects4j_buggy/Lang_4_buggy/src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java,"@Override
    public int translate(final CharSequence input, final int index, final Writer out) throws IOException {
        int max = longest;
        if (index + longest > input.length()) {
            max = input.length() - index;
        }
         // descend so as to get a greedy algorithm
         for (int i = max; i >= shortest; i--) {
             final CharSequence subSeq = input.subSequence(index, index + i);
             final CharSequence result = lookupMap.get(subSeq);
             if (result != null) {
                 out.write(result.toString());
                 return i;
            }
        }
        return 0;
    }"
Lang_7,/home/common/huangzhili/defects4j_buggy/Lang_7_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static BigDecimal createBigDecimal(String str) {
        if (str == null) {
            return null;
        }
        // handle JDK1.3.1 bug where """" throws IndexOutOfBoundsException
         if (StringUtils.isBlank(str)) {
             throw new NumberFormatException(""A blank string is not a valid number"");
         }
             // this is protection for poorness in java.lang.BigDecimal.
             // it accepts this as a legal value, but it does not appear 
             // to be in specification of class. OS X Java parses it to 
             // a wrong value.
         return new BigDecimal(str);
     }"
Lang_7,/home/common/huangzhili/defects4j_buggy/Lang_7_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
         if (StringUtils.isBlank(str)) {
             throw new NumberFormatException(""A blank string is not a valid number"");
         }  
         if (str.startsWith(""--"")) {
             return null;
         }
         if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
             int hexDigits = str.length() - 2; // drop 0x
             if (str.startsWith(""-"")) { // drop -
                hexDigits--;
            }
            if (hexDigits > 8) { // too many for an int
                return createLong(str);
            }
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos || expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                if (expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                mant = str.substring(0, expPos);
            } else {
                mant = str;
            }
            dec = null;
        }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length() - 1);
            } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) { // NOPMD
                            // Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) { // NOPMD
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) { // NOPMD
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) { // NOPMD
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }"
Lang_8,/home/common/huangzhili/defects4j_buggy/Lang_8_buggy/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java,"        public void appendTo(StringBuffer buffer, Calendar calendar) {
            if (zone.useDaylightTime()
                    && calendar.get(Calendar.DST_OFFSET) != 0) {
                buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));
            } else {
                buffer.append(getTimeZoneDisplay(zone, false, mStyle, mLocale));
            }
        }
"
Lang_8,/home/common/huangzhili/defects4j_buggy/Lang_8_buggy/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java,"        public int estimateLength() {
            // We have no access to the Calendar object that will be passed to
            // appendTo so base estimate on the TimeZone passed to the
            // constructor
            return Math.max(mStandard.length(), mDaylight.length());
        }
"
Lang_13,/home/common/huangzhili/defects4j_buggy/Lang_13_buggy/src/main/java/org/apache/commons/lang3/SerializationUtils.java,"@Override
        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
            String name = desc.getName();
             try {
                 return Class.forName(name, false, classLoader);
             } catch (ClassNotFoundException ex) {
                     return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
             }
         }"
Lang_15,/home/common/huangzhili/defects4j_buggy/Lang_15_buggy/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java,"private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, Class<?> toClass,
            Map<TypeVariable<?>, Type> subtypeVarAssigns) {
        // make sure they're assignable
        if (!isAssignable(cls, toClass)) {
            return null;
        }

        // can't work with primitives
        if (cls.isPrimitive()) {
            // both classes are primitives?
            if (toClass.isPrimitive()) {
                // dealing with widening here. No type arguments to be
                // harvested with these two types.
                return new HashMap<TypeVariable<?>, Type>();
            }

            // work with wrapper the wrapper class instead of the primitive
            cls = ClassUtils.primitiveToWrapper(cls);
        }

        // create a copy of the incoming map, or an empty one if it's null
        HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>()
                 : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);
 
         // has target class been reached?
         if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {
             return typeVarAssigns;
         }
 
        // walk the inheritance hierarchy until the target class is reached
        return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);
    }"
Lang_15,/home/common/huangzhili/defects4j_buggy/Lang_15_buggy/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java,"private static boolean isAssignable(Type type, ParameterizedType toParameterizedType,
            Map<TypeVariable<?>, Type> typeVarAssigns) {
        if (type == null) {
            return true;
        }

        // only a null type can be assigned to null type which
        // would have cause the previous to return true
        if (toParameterizedType == null) {
            return false;
        }

        // all types are assignable to themselves
        if (toParameterizedType.equals(type)) {
            return true;
        }

        // get the target type's raw type
        Class<?> toClass = getRawType(toParameterizedType);
        // get the subject type's type arguments including owner type arguments
        // and supertype arguments up to and including the target class.
        Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null);

        // null means the two types are not compatible
        if (fromTypeVarAssigns == null) {
            return false;
        }

        // compatible types, but there's no type arguments. this is equivalent
        // to comparing Map< ?, ? > to Map, and raw types are always assignable
        // to parameterized types.
        if (fromTypeVarAssigns.isEmpty()) {
            return true;
        }

        // get the target type's type arguments including owner type arguments
        Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType,
                 toClass, typeVarAssigns);
 
         // now to check each type argument
         for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {
             Type toTypeArg = entry.getValue();
             Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());
 
             // parameters must either be absent from the subject type, within
             // the bounds of the wildcard type, or be an exact match to the
            // parameters of the target type.
            if (fromTypeArg != null
                    && !toTypeArg.equals(fromTypeArg)
                    && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,
                            typeVarAssigns))) {
                return false;
            }
        }

        return true;
    }"
Lang_20,/home/common/huangzhili/defects4j_buggy/Lang_20_buggy/src/main/java/org/apache/commons/lang3/StringUtils.java,"public static String join(Object[] array, String separator, int startIndex, int endIndex) {
        if (array == null) {
            return null;
        }
        if (separator == null) {
            separator = EMPTY;
        }

        // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))
        //           (Assuming that all Strings are roughly equally long)
        int noOfItems = (endIndex - startIndex);
        if (noOfItems <= 0) {
             return EMPTY;
         }
 
         StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());
 
         for (int i = startIndex; i < endIndex; i++) {
             if (i > startIndex) {
                buf.append(separator);
            }
            if (array[i] != null) {
                buf.append(array[i]);
            }
        }
        return buf.toString();
    }"
Lang_20,/home/common/huangzhili/defects4j_buggy/Lang_20_buggy/src/main/java/org/apache/commons/lang3/StringUtils.java,"public static String join(Object[] array, char separator, int startIndex, int endIndex) {
        if (array == null) {
            return null;
        }
        int noOfItems = (endIndex - startIndex);
        if (noOfItems <= 0) {
             return EMPTY;
         }
         
         StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);
 
         for (int i = startIndex; i < endIndex; i++) {
             if (i > startIndex) {
                buf.append(separator);
            }
            if (array[i] != null) {
                buf.append(array[i]);
            }
        }
        return buf.toString();
    }"
Lang_23,/home/common/huangzhili/defects4j_buggy/Lang_23_buggy/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java,"    public ExtendedMessageFormat(String pattern) {
        this(pattern, Locale.getDefault());
    }
"
Lang_23,/home/common/huangzhili/defects4j_buggy/Lang_23_buggy/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java,"    private Format getFormat(String desc) {
        if (registry != null) {
            String name = desc;
            String args = null;
            int i = desc.indexOf(START_FMT);
            if (i > 0) {
                name = desc.substring(0, i).trim();
                args = desc.substring(i + 1).trim();
            }
            FormatFactory factory = registry.get(name);
            if (factory != null) {
                return factory.getFormat(name, args, getLocale());
            }
        }
        return null;
    }
"
Lang_30,/home/common/huangzhili/defects4j_buggy/Lang_30_buggy/src/main/java/org/apache/commons/lang3/StringUtils.java,"public static boolean containsNone(CharSequence cs, char[] searchChars) {
        if (cs == null || searchChars == null) {
             return true;
         }
         int csLen = cs.length();
         int searchLen = searchChars.length;
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
                             // missing low surrogate, fine, like String.indexOf(String)
                         // ch is in the Basic Multilingual Plane
                         return false;
                 }
             }
         }
        return true;
    }"
Lang_30,/home/common/huangzhili/defects4j_buggy/Lang_30_buggy/src/main/java/org/apache/commons/lang3/StringUtils.java,"public static int indexOfAnyBut(String str, String searchChars) {
        if (isEmpty(str) || isEmpty(searchChars)) {
            return INDEX_NOT_FOUND;
        }
         int strLen = str.length();
         for (int i = 0; i < strLen; i++) {
             char ch = str.charAt(i);
             if (searchChars.indexOf(ch) < 0) {
                     return i;
             }
         }
         return INDEX_NOT_FOUND;
    }"
Lang_30,/home/common/huangzhili/defects4j_buggy/Lang_30_buggy/src/main/java/org/apache/commons/lang3/StringUtils.java,"public static int indexOfAny(CharSequence cs, char[] searchChars) {
        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
             return INDEX_NOT_FOUND;
         }
         int csLen = cs.length();
         int searchLen = searchChars.length;
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
                         // ch is a supplementary character
                         return i;
                 }
             }
         }
        return INDEX_NOT_FOUND;
    }"
Lang_30,/home/common/huangzhili/defects4j_buggy/Lang_30_buggy/src/main/java/org/apache/commons/lang3/StringUtils.java,"public static boolean containsAny(CharSequence cs, char[] searchChars) {
        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
            return false;
        }
        int csLength = cs.length();
        int searchLength = searchChars.length;
        int csLast = csLength - 1;
        int searchLast = searchLength - 1;
        for (int i = 0; i < csLength; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLength; j++) {
                 if (searchChars[j] == ch) {
                     if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
                             // missing low surrogate, fine, like String.indexOf(String)
                         if (searchChars[j + 1] == cs.charAt(i + 1)) {
                             return true;
                         }
                     } else {
                        // ch is in the Basic Multilingual Plane
                        return true;
                    }
                }
            }
        }
        return false;
    }"
Lang_30,/home/common/huangzhili/defects4j_buggy/Lang_30_buggy/src/main/java/org/apache/commons/lang3/StringUtils.java,"public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {
        if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
             return INDEX_NOT_FOUND;
         }
         int csLen = cs.length();
         int searchLen = searchChars.length;
         outer:
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
                         continue outer;
                 }
             }
             return i;
        }
        return INDEX_NOT_FOUND;
    }"
Lang_32,/home/common/huangzhili/defects4j_buggy/Lang_32_buggy/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java,"static void register(Object value) {
         getRegistry().add(new IDKey(value));
     }"
Lang_32,/home/common/huangzhili/defects4j_buggy/Lang_32_buggy/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java,"static boolean isRegistered(Object value) {
         return getRegistry().contains(new IDKey(value));
     }"
Lang_32,/home/common/huangzhili/defects4j_buggy/Lang_32_buggy/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java,"static void unregister(Object value) {
         getRegistry().remove(new IDKey(value));
     }"
Lang_34,/home/common/huangzhili/defects4j_buggy/Lang_34_buggy/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java,"static Map<Object, Object> getRegistry() {
         return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();
     }"
Lang_34,/home/common/huangzhili/defects4j_buggy/Lang_34_buggy/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java,"static boolean isRegistered(Object value) {
         Map<Object, Object> m = getRegistry();
         return m.containsKey(value);
     }"
Lang_35,/home/common/huangzhili/defects4j_buggy/Lang_35_buggy/src/main/java/org/apache/commons/lang3/ArrayUtils.java,"public static <T> T[] add(T[] array, int index, T element) {
        Class<?> clss = null;
        if (array != null) {
            clss = array.getClass().getComponentType();
         } else if (element != null) {
             clss = element.getClass();
         } else {
             return (T[]) new Object[] { null };
         }
         @SuppressWarnings(""unchecked"") // the add method creates an array of type clss, which is type T
         final T[] newArray = (T[]) add(array, index, element, clss);
        return newArray;
    }"
Lang_35,/home/common/huangzhili/defects4j_buggy/Lang_35_buggy/src/main/java/org/apache/commons/lang3/ArrayUtils.java,"public static <T> T[] add(T[] array, T element) {
        Class<?> type;
        if (array != null){
            type = array.getClass();
         } else if (element != null) {
             type = element.getClass();
         } else {
             type = Object.class;
         }
         @SuppressWarnings(""unchecked"") // type must be T
         T[] newArray = (T[]) copyArrayGrow1(array, type);
        newArray[newArray.length - 1] = element;
        return newArray;
    }"
Lang_36,/home/common/huangzhili/defects4j_buggy/Lang_36_buggy/src/java/org/apache/commons/lang3/math/NumberUtils.java,"public static Number createNumber(String str) throws NumberFormatException {
        if (str == null) {
            return null;
        }
        if (StringUtils.isBlank(str)) {
            throw new NumberFormatException(""A blank string is not a valid number"");
        }  
        if (str.startsWith(""--"")) {
            // this is protection for poorness in java.lang.BigDecimal.
            // it accepts this as a legal value, but it does not appear 
            // to be in specification of class. OS X Java parses it to 
            // a wrong value.
            return null;
        }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
            return createInteger(str);
        }   
        char lastChar = str.charAt(str.length() - 1);
        String mant;
        String dec;
        String exp;
        int decPos = str.indexOf('.');
        int expPos = str.indexOf('e') + str.indexOf('E') + 1;

        if (decPos > -1) {

            if (expPos > -1) {
                if (expPos < decPos) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                dec = str.substring(decPos + 1, expPos);
            } else {
                dec = str.substring(decPos + 1);
            }
            mant = str.substring(0, decPos);
        } else {
            if (expPos > -1) {
                mant = str.substring(0, expPos);
            } else {
                mant = str;
             }
             dec = null;
         }
         if (!Character.isDigit(lastChar)) {
             if (expPos > -1 && expPos < str.length() - 1) {
                 exp = str.substring(expPos + 1, str.length() - 1);
             } else {
                exp = null;
            }
            //Requesting a specific type..
            String numeric = str.substring(0, str.length() - 1);
            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
            switch (lastChar) {
                case 'l' :
                case 'L' :
                    if (dec == null
                        && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                        try {
                            return createLong(numeric);
                        } catch (NumberFormatException nfe) {
                            //Too big for a long
                        }
                        return createBigInteger(numeric);

                    }
                    throw new NumberFormatException(str + "" is not a valid number."");
                case 'f' :
                case 'F' :
                    try {
                        Float f = NumberUtils.createFloat(numeric);
                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                            //If it's too big for a float or the float value = 0 and the string
                            //has non-zeros in it, then float does not have the precision we want
                            return f;
                        }

                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                case 'd' :
                case 'D' :
                    try {
                        Double d = NumberUtils.createDouble(numeric);
                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
                            return d;
                        }
                    } catch (NumberFormatException nfe) {
                        // ignore the bad number
                    }
                    try {
                        return createBigDecimal(numeric);
                    } catch (NumberFormatException e) {
                        // ignore the bad number
                    }
                    //$FALL-THROUGH$
                default :
                    throw new NumberFormatException(str + "" is not a valid number."");

            }
        } else {
            //User doesn't have a preference on the return type, so let's start
            //small and go from there...
            if (expPos > -1 && expPos < str.length() - 1) {
                exp = str.substring(expPos + 1, str.length());
            } else {
                exp = null;
            }
            if (dec == null && exp == null) {
                //Must be an int,long,bigint
                try {
                    return createInteger(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    return createLong(str);
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                return createBigInteger(str);

            } else {
                //Must be a float,double,BigDec
                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
                try {
                    Float f = createFloat(str);
                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                        return f;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }
                try {
                    Double d = createDouble(str);
                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                        return d;
                    }
                } catch (NumberFormatException nfe) {
                    // ignore the bad number
                }

                return createBigDecimal(str);

            }
        }
    }"
Lang_36,/home/common/huangzhili/defects4j_buggy/Lang_36_buggy/src/java/org/apache/commons/lang3/math/NumberUtils.java,"public static boolean isNumber(String str) {
        if (StringUtils.isEmpty(str)) {
            return false;
        }
        char[] chars = str.toCharArray();
        int sz = chars.length;
        boolean hasExp = false;
        boolean hasDecPoint = false;
        boolean allowSigns = false;
        boolean foundDigit = false;
        // deal with any possible sign up front
        int start = (chars[0] == '-') ? 1 : 0;
        if (sz > start + 1) {
            if (chars[start] == '0' && chars[start + 1] == 'x') {
                int i = start + 2;
                if (i == sz) {
                    return false; // str == ""0x""
                }
                // checking hex (it can't be anything else)
                for (; i < chars.length; i++) {
                    if ((chars[i] < '0' || chars[i] > '9')
                        && (chars[i] < 'a' || chars[i] > 'f')
                        && (chars[i] < 'A' || chars[i] > 'F')) {
                        return false;
                    }
                }
                return true;
            }
        }
        sz--; // don't want to loop to the last char, check it afterwords
              // for type qualifiers
        int i = start;
        // loop to the next to last char or to the last char if we need another digit to
        // make a valid number (e.g. chars[0..5] = ""1234E"")
        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {
            if (chars[i] >= '0' && chars[i] <= '9') {
                foundDigit = true;
                allowSigns = false;

            } else if (chars[i] == '.') {
                if (hasDecPoint || hasExp) {
                    // two decimal points or dec in exponent   
                    return false;
                }
                hasDecPoint = true;
            } else if (chars[i] == 'e' || chars[i] == 'E') {
                // we've already taken care of hex.
                if (hasExp) {
                    // two E's
                    return false;
                }
                if (!foundDigit) {
                    return false;
                }
                hasExp = true;
                allowSigns = true;
            } else if (chars[i] == '+' || chars[i] == '-') {
                if (!allowSigns) {
                    return false;
                }
                allowSigns = false;
                foundDigit = false; // we need a digit after the E
            } else {
                return false;
            }
            i++;
        }
        if (i < chars.length) {
            if (chars[i] >= '0' && chars[i] <= '9') {
                // no type qualifier, OK
                return true;
            }
            if (chars[i] == 'e' || chars[i] == 'E') {
                 // can't have an E at the last byte
                 return false;
             }
             if (!allowSigns
                 && (chars[i] == 'd'
                     || chars[i] == 'D'
                    || chars[i] == 'f'
                    || chars[i] == 'F')) {
                return foundDigit;
            }
            if (chars[i] == 'l'
                || chars[i] == 'L') {
                // not allowing L with an exponent
                return foundDigit && !hasExp;
            }
            // last character is illegal
            return false;
        }
        // allowSigns is true iff the val ends in 'E'
        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass
        return !allowSigns && foundDigit;
    }"
Lang_41,/home/common/huangzhili/defects4j_buggy/Lang_41_buggy/src/java/org/apache/commons/lang/ClassUtils.java,"public static String getShortClassName(String className) {
        if (className == null) {
            return StringUtils.EMPTY;
        }
        if (className.length() == 0) {
            return StringUtils.EMPTY;
        }


        // Handle array encoding
            // Strip Object type encoding


        int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
        int innerIdx = className.indexOf(
                INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);
        String out = className.substring(lastDotIdx + 1);
         if (innerIdx != -1) {
             out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
         }
         return out;
     }"
Lang_46,/home/common/huangzhili/defects4j_buggy/Lang_46_buggy/src/java/org/apache/commons/lang/StringEscapeUtils.java,"private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {
        if (out == null) {
            throw new IllegalArgumentException(""The Writer must not be null"");
        }
        if (str == null) {
            return;
        }
        int sz;
        sz = str.length();
        for (int i = 0; i < sz; i++) {
            char ch = str.charAt(i);

            // handle unicode
            if (ch > 0xfff) {
                out.write(""\\u"" + hex(ch));
            } else if (ch > 0xff) {
                out.write(""\\u0"" + hex(ch));
            } else if (ch > 0x7f) {
                out.write(""\\u00"" + hex(ch));
            } else if (ch < 32) {
                switch (ch) {
                    case '\b' :
                        out.write('\\');
                        out.write('b');
                        break;
                    case '\n' :
                        out.write('\\');
                        out.write('n');
                        break;
                    case '\t' :
                        out.write('\\');
                        out.write('t');
                        break;
                    case '\f' :
                        out.write('\\');
                        out.write('f');
                        break;
                    case '\r' :
                        out.write('\\');
                        out.write('r');
                        break;
                    default :
                        if (ch > 0xf) {
                            out.write(""\\u00"" + hex(ch));
                        } else {
                            out.write(""\\u000"" + hex(ch));
                        }
                        break;
                }
            } else {
                switch (ch) {
                    case '\'' :
                        if (escapeSingleQuote) {
                            out.write('\\');
                        }
                        out.write('\'');
                        break;
                    case '""' :
                        out.write('\\');
                        out.write('""');
                        break;
                    case '\\' :
                        out.write('\\');
                         out.write('\\');
                         break;
                     case '/' :
                             out.write('\\');
                         out.write('/');
                         break;
                     default :
                        out.write(ch);
                        break;
                }
            }
        }
    }"
Lang_47,/home/common/huangzhili/defects4j_buggy/Lang_47_buggy/src/java/org/apache/commons/lang/text/StrBuilder.java,"public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {
         if (width > 0) {
             ensureCapacity(size + width);
             String str = (obj == null ? getNullText() : obj.toString());
             int strLen = str.length();
             if (strLen >= width) {
                 str.getChars(0, width, buffer, size);
            } else {
                int padLen = width - strLen;
                str.getChars(0, strLen, buffer, size);
                for (int i = 0; i < padLen; i++) {
                    buffer[size + strLen + i] = padChar;
                }
            }
            size += width;
        }
        return this;
    }"
Lang_47,/home/common/huangzhili/defects4j_buggy/Lang_47_buggy/src/java/org/apache/commons/lang/text/StrBuilder.java,"public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {
         if (width > 0) {
             ensureCapacity(size + width);
             String str = (obj == null ? getNullText() : obj.toString());
             int strLen = str.length();
             if (strLen >= width) {
                 str.getChars(strLen - width, strLen, buffer, size);
            } else {
                int padLen = width - strLen;
                for (int i = 0; i < padLen; i++) {
                    buffer[size + i] = padChar;
                }
                str.getChars(0, strLen, buffer, size + padLen);
            }
            size += width;
        }
        return this;
    }"
Lang_50,/home/common/huangzhili/defects4j_buggy/Lang_50_buggy/src/java/org/apache/commons/lang/time/FastDateFormat.java,"public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone,
            Locale locale) {

        Object key = new Pair(new Integer(dateStyle), new Integer(timeStyle));
         if (timeZone != null) {
             key = new Pair(key, timeZone);
         }
         if (locale != null) {
             key = new Pair(key, locale);
         }
 
         FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);
         if (format == null) {
             if (locale == null) {
                 locale = Locale.getDefault();
             }
             try {
                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,
                         locale);
                String pattern = formatter.toPattern();
                format = getInstance(pattern, timeZone, locale);
                cDateTimeInstanceCache.put(key, format);

            } catch (ClassCastException ex) {
                throw new IllegalArgumentException(""No date time pattern for locale: "" + locale);
            }
        }
        return format;
    }"
Lang_50,/home/common/huangzhili/defects4j_buggy/Lang_50_buggy/src/java/org/apache/commons/lang/time/FastDateFormat.java,"public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {
        Object key = new Integer(style);
        if (timeZone != null) {
             key = new Pair(key, timeZone);
         }
 
         if (locale != null) {
             key = new Pair(key, locale);
         }
 
 
         FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);
         if (format == null) {
             if (locale == null) {
                 locale = Locale.getDefault();
             }
             try {
                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
                 String pattern = formatter.toPattern();
                format = getInstance(pattern, timeZone, locale);
                cDateInstanceCache.put(key, format);
                
            } catch (ClassCastException ex) {
                throw new IllegalArgumentException(""No date pattern for locale: "" + locale);
            }
        }
        return format;
    }"
Lang_56,/home/common/huangzhili/defects4j_buggy/Lang_56_buggy/src/java/org/apache/commons/lang/time/FastDateFormat.java,"    public String toString() {
        return ""FastDateFormat["" + mPattern + ""]"";
    }
"
Lang_56,/home/common/huangzhili/defects4j_buggy/Lang_56_buggy/src/java/org/apache/commons/lang/time/FastDateFormat.java,"    public static FastDateFormat getInstance() {
        return getInstance(getDefaultPattern(), null, null);
    }
"
Lang_60,/home/common/huangzhili/defects4j_buggy/Lang_60_buggy/src/java/org/apache/commons/lang/text/StrBuilder.java,"public int indexOf(char ch, int startIndex) {
        startIndex = (startIndex < 0 ? 0 : startIndex);
        if (startIndex >= size) {
             return -1;
         }
         char[] thisBuf = buffer;
         for (int i = startIndex; i < thisBuf.length; i++) {
             if (thisBuf[i] == ch) {
                 return i;
             }
        }
        return -1;
    }"
Lang_60,/home/common/huangzhili/defects4j_buggy/Lang_60_buggy/src/java/org/apache/commons/lang/text/StrBuilder.java,"public boolean contains(char ch) {
         char[] thisBuf = buffer;
         for (int i = 0; i < thisBuf.length; i++) {
             if (thisBuf[i] == ch) {
                 return true;
             }
        }
        return false;
    }"
Lang_62,/home/common/huangzhili/defects4j_buggy/Lang_62_buggy/src/java/org/apache/commons/lang/Entities.java,"public String unescape(String str) {
        int firstAmp = str.indexOf('&');
        if (firstAmp < 0) {
            return str;
        }

        StringBuffer buf = new StringBuffer(str.length());
        buf.append(str.substring(0, firstAmp));
        for (int i = firstAmp; i < str.length(); ++i) {
            char ch = str.charAt(i);
            if (ch == '&') {
                int semi = str.indexOf(';', i + 1);
                if (semi == -1) {
                    buf.append(ch);
                    continue;
                }
                int amph = str.indexOf('&', i + 1);
                if( amph != -1 && amph < semi ) {
                    // Then the text looks like &...&...;
                    buf.append(ch);
                    continue;
                }
                String entityName = str.substring(i + 1, semi);
                int entityValue;
                if (entityName.length() == 0) {
                    entityValue = -1;
                } else if (entityName.charAt(0) == '#') {
                    if (entityName.length() == 1) {
                        entityValue = -1;
                    } else {
                        char charAt1 = entityName.charAt(1);
                        try {
                            if (charAt1 == 'x' || charAt1=='X') {
                                entityValue = Integer.valueOf(entityName.substring(2), 16).intValue();
                             } else {
                                 entityValue = Integer.parseInt(entityName.substring(1));
                             }
                         } catch (NumberFormatException ex) {
                             entityValue = -1;
                         }
                    }
                } else {
                    entityValue = this.entityValue(entityName);
                }
                if (entityValue == -1) {
                    buf.append('&');
                    buf.append(entityName);
                    buf.append(';');
                } else {
                    buf.append((char) (entityValue));
                }
                i = semi;
            } else {
                buf.append(ch);
            }
        }
        return buf.toString();
    }"
Lang_62,/home/common/huangzhili/defects4j_buggy/Lang_62_buggy/src/java/org/apache/commons/lang/Entities.java,"public void unescape(Writer writer, String string) throws IOException {
        int firstAmp = string.indexOf('&');
        if (firstAmp < 0) {
            writer.write(string);
            return;
        }

        writer.write(string, 0, firstAmp);
        int len = string.length();
        for (int i = firstAmp; i < len; i++) {
            char c = string.charAt(i);
            if (c == '&') {
                int nextIdx = i+1;
                int semiColonIdx = string.indexOf(';', nextIdx);
                if (semiColonIdx == -1) {
                    writer.write(c);
                    continue;
                }
                int amphersandIdx = string.indexOf('&', i + 1);
                if( amphersandIdx != -1 && amphersandIdx < semiColonIdx ) {
                    // Then the text looks like &...&...;
                    writer.write(c);
                    continue;
                }
                String entityContent = string.substring(nextIdx, semiColonIdx);
                int entityValue = -1;
                int entityContentLen = entityContent.length();
                if (entityContentLen > 0) {
                    if (entityContent.charAt(0) == '#') { //escaped value content is an integer (decimal or hexidecimal)
                        if (entityContentLen > 1) {  
                            char isHexChar = entityContent.charAt(1);
                            try {
                                switch (isHexChar) {
                                     case 'X' :
                                     case 'x' : {
                                         entityValue = Integer.parseInt(entityContent.substring(2), 16);
                                     }
                                     default : {
                                         entityValue = Integer.parseInt(entityContent.substring(1), 10);
                                     }
                                 }
                             } catch (NumberFormatException e) {
                             }
                         }
                     } else { //escaped value content is an entity name
                        entityValue = this.entityValue(entityContent);
                    }
                }
                
                if (entityValue == -1) {
                    writer.write('&');
                    writer.write(entityContent);
                    writer.write(';');
                } else {
                    writer.write(entityValue);
                }
                i = semiColonIdx; //move index up to the semi-colon                
            } else {
                writer.write(c);
            }
        }
    }"
Lang_63,/home/common/huangzhili/defects4j_buggy/Lang_63_buggy/src/java/org/apache/commons/lang/time/DurationFormatUtils.java,"public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, 
            TimeZone timezone) {

        long millis = endMillis - startMillis;
        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {
            return formatDuration(millis, format, padWithZeros);
        }

        Token[] tokens = lexx(format);

        // timezones get funky around 0, so normalizing everything to GMT 
        // stops the hours being off
        Calendar start = Calendar.getInstance(timezone);
        start.setTime(new Date(startMillis));
        Calendar end = Calendar.getInstance(timezone);
        end.setTime(new Date(endMillis));

        // initial estimates
        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);
        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);
        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);
        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);
        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);
        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);
        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);

        // each initial estimate is adjusted in case it is under 0
        while (milliseconds < 0) {
            milliseconds += 1000;
            seconds -= 1;
        }
        while (seconds < 0) {
            seconds += 60;
            minutes -= 1;
        }
        while (minutes < 0) {
            minutes += 60;
            hours -= 1;
        }
        while (hours < 0) {
            hours += 24;
             days -= 1;
         }
         while (days < 0) {
             days += 31;
 //days += 31; // TODO: Need tests to show this is bad and the new code is good.
 // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is 
 // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.
 // Also it's contextual - if asked for no M in the format then I should probably 
 // be doing no calculating here.
             months -= 1;
         }
         while (months < 0) {
             months += 12;
             years -= 1;
         }
         milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);
         seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);
         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);
         hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);
         days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);
         months -= reduceAndCorrect(start, end, Calendar.MONTH, months);
         years -= reduceAndCorrect(start, end, Calendar.YEAR, years);
 
         // This next block of code adds in values that 
         // aren't requested. This allows the user to ask for the 
        // number of months and get the real count and not just 0->11.
        if (!Token.containsTokenWithValue(tokens, y)) {
            if (Token.containsTokenWithValue(tokens, M)) {
                months += 12 * years;
                years = 0;
            } else {
                // TODO: this is a bit weak, needs work to know about leap years
                days += 365 * years;
                years = 0;
            }
        }
        if (!Token.containsTokenWithValue(tokens, M)) {
            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);
            months = 0;
        }
        if (!Token.containsTokenWithValue(tokens, d)) {
            hours += 24 * days;
            days = 0;
        }
        if (!Token.containsTokenWithValue(tokens, H)) {
            minutes += 60 * hours;
            hours = 0;
        }
        if (!Token.containsTokenWithValue(tokens, m)) {
            seconds += 60 * minutes;
            minutes = 0;
        }
        if (!Token.containsTokenWithValue(tokens, s)) {
            milliseconds += 1000 * seconds;
            seconds = 0;
        }

        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);
    }"
Lang_63,/home/common/huangzhili/defects4j_buggy/Lang_63_buggy/src/java/org/apache/commons/lang/time/DurationFormatUtils.java,"static String format(Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds,
            int milliseconds, boolean padWithZeros) {
        StringBuffer buffer = new StringBuffer();
        boolean lastOutputSeconds = false;
        int sz = tokens.length;
        for (int i = 0; i < sz; i++) {
            Token token = tokens[i];
            Object value = token.getValue();
            int count = token.getCount();
            if (value instanceof StringBuffer) {
                buffer.append(value.toString());
            } else {
                if (value == y) {
                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(years), count, '0') : Integer
                            .toString(years));
                    lastOutputSeconds = false;
                } else if (value == M) {
                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(months), count, '0') : Integer
                            .toString(months));
                    lastOutputSeconds = false;
                } else if (value == d) {
                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(days), count, '0') : Integer
                            .toString(days));
                    lastOutputSeconds = false;
                } else if (value == H) {
                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(hours), count, '0') : Integer
                            .toString(hours));
                    lastOutputSeconds = false;
                } else if (value == m) {
                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(minutes), count, '0') : Integer
                            .toString(minutes));
                    lastOutputSeconds = false;
                } else if (value == s) {
                    buffer.append(padWithZeros ? StringUtils.leftPad(Integer.toString(seconds), count, '0') : Integer
                            .toString(seconds));
                    lastOutputSeconds = true;
                } else if (value == S) {
                    if (lastOutputSeconds) {
                        milliseconds += 1000;
                        String str = padWithZeros
                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')
                                : Integer.toString(milliseconds);
                        buffer.append(str.substring(1));
                    } else {
                        buffer.append(padWithZeros
                                ? StringUtils.leftPad(Integer.toString(milliseconds), count, '0')
                                : Integer.toString(milliseconds));
                    }
                    lastOutputSeconds = false;
                }
            }
         }
         return buffer.toString();
     }"
Lang_64,/home/common/huangzhili/defects4j_buggy/Lang_64_buggy/src/java/org/apache/commons/lang/enums/ValuedEnum.java,"    public String toString() {
        if (iToString == null) {
            String shortName = ClassUtils.getShortClassName(getEnumClass());
            iToString = shortName + ""["" + getName() + ""="" + getValue() + ""]"";
        }
        return iToString;
    }
"
Lang_64,/home/common/huangzhili/defects4j_buggy/Lang_64_buggy/src/java/org/apache/commons/lang/enums/ValuedEnum.java,"    public int compareTo(Object other) {
        return iValue - ((ValuedEnum) other).iValue;
    }
"
Math_1,/home/common/huangzhili/defects4j_buggy/Math_1_buggy/src/main/java/org/apache/commons/math3/fraction/BigFraction.java,"            final long a1 = (long) FastMath.floor(r1);
            p2 = (a1 * p1) + p0;
            q2 = (a1 * q1) + q0;
            if ((p2 > overflow) || (q2 > overflow)) {
                // in maxDenominator mode, if the last fraction was very close to the actual value
                // q2 may overflow in the next iteration; in this case return the last one.
                throw new FractionConversionException(value, p2, q2);
            }
"
Math_1,/home/common/huangzhili/defects4j_buggy/Math_1_buggy/src/main/java/org/apache/commons/math3/fraction/Fraction.java,"    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)
        throws FractionConversionException
    {
        long overflow = Integer.MAX_VALUE;
        double r0 = value;
        long a0 = (long)FastMath.floor(r0);
        if (FastMath.abs(a0) > overflow) {
            throw new FractionConversionException(value, a0, 1l);
        }

        // check for (almost) integer arguments, which should not go to iterations.
        if (FastMath.abs(a0 - value) < epsilon) {
            this.numerator = (int) a0;
            this.denominator = 1;
            return;
        }

        long p0 = 1;
        long q0 = 0;
        long p1 = a0;
        long q1 = 1;

        long p2 = 0;
        long q2 = 1;

        int n = 0;
        boolean stop = false;
        do {
            ++n;
            double r1 = 1.0 / (r0 - a0);
            long a1 = (long)FastMath.floor(r1);
            p2 = (a1 * p1) + p0;
            q2 = (a1 * q1) + q0;

            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {
                // in maxDenominator mode, if the last fraction was very close to the actual value
                // q2 may overflow in the next iteration; in this case return the last one.
                throw new FractionConversionException(value, p2, q2);
            }

            double convergent = (double)p2 / (double)q2;
            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {
                p0 = p1;
                p1 = p2;
                q0 = q1;
                q1 = q2;
                a0 = a1;
                r0 = r1;
            } else {
                stop = true;
            }
        } while (!stop);

        if (n >= maxIterations) {
            throw new FractionConversionException(value, maxIterations);
        }

        if (q2 < maxDenominator) {
            this.numerator = (int) p2;
            this.denominator = (int) q2;
        } else {
            this.numerator = (int) p1;
            this.denominator = (int) q1;
        }

    }
"
Math_4,/home/common/huangzhili/defects4j_buggy/Math_4_buggy/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java,"public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {
 
         // compute the intersection on infinite line
         Vector3D v1D = line.intersection(subLine.line);
 
         // check location of point with respect to first sub-line
         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));

        // check location of point with respect to second sub-line
        Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));

        if (includeEndPoints) {
            return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;
        } else {
            return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;
        }

    }"
Math_4,/home/common/huangzhili/defects4j_buggy/Math_4_buggy/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java,"public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {

        // retrieve the underlying lines
        Line line1 = (Line) getHyperplane();
        Line line2 = (Line) subLine.getHyperplane();
 
         // compute the intersection on infinite line
         Vector2D v2D = line1.intersection(line2);
 
         // check location of point with respect to first sub-line
         Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));

        // check location of point with respect to second sub-line
        Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));

        if (includeEndPoints) {
            return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;
        } else {
            return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;
        }

    }"
Math_6,/home/common/huangzhili/defects4j_buggy/Math_6_buggy/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java,"@Override
    protected PointValuePair doOptimize() {
        checkParameters();

        final GoalType goal = getGoalType();
        final double[] guess = getStartPoint();
        final int n = guess.length;

        final double[][] direc = new double[n][n];
        for (int i = 0; i < n; i++) {
            direc[i][i] = 1;
        }

        final ConvergenceChecker<PointValuePair> checker
            = getConvergenceChecker();

         double[] x = guess;
         double fVal = computeObjectiveValue(x);
         double[] x1 = x.clone();
         int iter = 0;
         while (true) {
             ++iter;
 
             double fX = fVal;
             double fX2 = 0;
            double delta = 0;
            int bigInd = 0;
            double alphaMin = 0;

            for (int i = 0; i < n; i++) {
                final double[] d = MathArrays.copyOf(direc[i]);

                fX2 = fVal;

                final UnivariatePointValuePair optimum = line.search(x, d);
                fVal = optimum.getValue();
                alphaMin = optimum.getPoint();
                final double[][] result = newPointAndDirection(x, d, alphaMin);
                x = result[0];

                if ((fX2 - fVal) > delta) {
                    delta = fX2 - fVal;
                    bigInd = i;
                }
            }

            // Default convergence check.
            boolean stop = 2 * (fX - fVal) <=
                (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) +
                 absoluteThreshold);

            final PointValuePair previous = new PointValuePair(x1, fX);
            final PointValuePair current = new PointValuePair(x, fVal);
            if (!stop) { // User-defined stopping criteria.
                if (checker != null) {
                    stop = checker.converged(iter, previous, current);
                }
            }
            if (stop) {
                if (goal == GoalType.MINIMIZE) {
                    return (fVal < fX) ? current : previous;
                } else {
                    return (fVal > fX) ? current : previous;
                }
            }

            final double[] d = new double[n];
            final double[] x2 = new double[n];
            for (int i = 0; i < n; i++) {
                d[i] = x[i] - x1[i];
                x2[i] = 2 * x[i] - x1[i];
            }

            x1 = x.clone();
            fX2 = computeObjectiveValue(x2);

            if (fX > fX2) {
                double t = 2 * (fX + fX2 - 2 * fVal);
                double temp = fX - fVal - delta;
                t *= temp * temp;
                temp = fX - fX2;
                t -= delta * temp * temp;

                if (t < 0.0) {
                    final UnivariatePointValuePair optimum = line.search(x, d);
                    fVal = optimum.getValue();
                    alphaMin = optimum.getPoint();
                    final double[][] result = newPointAndDirection(x, d, alphaMin);
                    x = result[0];

                    final int lastInd = n - 1;
                    direc[bigInd] = direc[lastInd];
                    direc[lastInd] = result[1];
                }
            }
        }
    }"
Math_6,/home/common/huangzhili/defects4j_buggy/Math_6_buggy/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java,"@Override
    protected PointValuePair doOptimize() {
        checkParameters();

        // Indirect call to ""computeObjectiveValue"" in order to update the
        // evaluations counter.
        final MultivariateFunction evalFunc
            = new MultivariateFunction() {
                public double value(double[] point) {
                    return computeObjectiveValue(point);
                }
            };

        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final Comparator<PointValuePair> comparator
            = new Comparator<PointValuePair>() {
            public int compare(final PointValuePair o1,
                               final PointValuePair o2) {
                final double v1 = o1.getValue();
                final double v2 = o2.getValue();
                return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);
            }
        };

        // Initialize search.
        simplex.build(getStartPoint());
        simplex.evaluate(evalFunc, comparator);

        PointValuePair[] previous = null;
        int iteration = 0;
        final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
        while (true) {
            if (iteration > 0) {
                boolean converged = true;
                for (int i = 0; i < simplex.getSize(); i++) {
                    PointValuePair prev = previous[i];
                    converged = converged &&
                        checker.converged(iteration, prev, simplex.getPoint(i));
                }
                if (converged) {
                    // We have found an optimum.
                    return simplex.getPoint(0);
                }
            }

            // We still need to search.
             previous = simplex.getPoints();
             simplex.iterate(evalFunc, comparator);
 
+			++iteration;
         }
     }"
Math_6,/home/common/huangzhili/defects4j_buggy/Math_6_buggy/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java,"@Override
    protected PointVectorValuePair doOptimize() {
        checkParameters();

        final int nR = getTarget().length; // Number of observed data.
        final double[] currentPoint = getStartPoint();
        final int nC = currentPoint.length; // Number of parameters.

        // arrays shared with the other private methods
        solvedCols  = FastMath.min(nR, nC);
        diagR       = new double[nC];
        jacNorm     = new double[nC];
        beta        = new double[nC];
        permutation = new int[nC];
        lmDir       = new double[nC];

        // local point
        double   delta   = 0;
        double   xNorm   = 0;
        double[] diag    = new double[nC];
        double[] oldX    = new double[nC];
        double[] oldRes  = new double[nR];
        double[] oldObj  = new double[nR];
        double[] qtf     = new double[nR];
        double[] work1   = new double[nC];
        double[] work2   = new double[nC];
        double[] work3   = new double[nC];

        final RealMatrix weightMatrixSqrt = getWeightSquareRoot();

        // Evaluate the function at the starting point and calculate its norm.
        double[] currentObjective = computeObjectiveValue(currentPoint);
        double[] currentResiduals = computeResiduals(currentObjective);
        PointVectorValuePair current = new PointVectorValuePair(currentPoint, currentObjective);
        double currentCost = computeCost(currentResiduals);

        // Outer loop.
        lmPar = 0;
        boolean firstIteration = true;
        int iter = 0;
        final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();
        while (true) {
            ++iter;
            final PointVectorValuePair previous = current;

            // QR decomposition of the jacobian matrix
            qrDecomposition(computeWeightedJacobian(currentPoint));

            weightedResidual = weightMatrixSqrt.operate(currentResiduals);
            for (int i = 0; i < nR; i++) {
                qtf[i] = weightedResidual[i];
            }

            // compute Qt.res
            qTy(qtf);

            // now we don't need Q anymore,
            // so let jacobian contain the R matrix with its diagonal elements
            for (int k = 0; k < solvedCols; ++k) {
                int pk = permutation[k];
                weightedJacobian[k][pk] = diagR[pk];
            }

            if (firstIteration) {
                // scale the point according to the norms of the columns
                // of the initial jacobian
                xNorm = 0;
                for (int k = 0; k < nC; ++k) {
                    double dk = jacNorm[k];
                    if (dk == 0) {
                        dk = 1.0;
                    }
                    double xk = dk * currentPoint[k];
                    xNorm  += xk * xk;
                    diag[k] = dk;
                }
                xNorm = FastMath.sqrt(xNorm);

                // initialize the step bound delta
                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);
            }

            // check orthogonality between function vector and jacobian columns
            double maxCosine = 0;
            if (currentCost != 0) {
                for (int j = 0; j < solvedCols; ++j) {
                    int    pj = permutation[j];
                    double s  = jacNorm[pj];
                    if (s != 0) {
                        double sum = 0;
                        for (int i = 0; i <= j; ++i) {
                            sum += weightedJacobian[i][pj] * qtf[i];
                        }
                        maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));
                    }
                }
            }
            if (maxCosine <= orthoTolerance) {
                // Convergence has been reached.
                setCost(currentCost);
                return current;
            }

            // rescale if necessary
            for (int j = 0; j < nC; ++j) {
                diag[j] = FastMath.max(diag[j], jacNorm[j]);
            }

            // Inner loop.
            for (double ratio = 0; ratio < 1.0e-4;) {

                // save the state
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    oldX[pj] = currentPoint[pj];
                }
                final double previousCost = currentCost;
                double[] tmpVec = weightedResidual;
                weightedResidual = oldRes;
                oldRes    = tmpVec;
                tmpVec    = currentObjective;
                currentObjective = oldObj;
                oldObj    = tmpVec;

                // determine the Levenberg-Marquardt parameter
                determineLMParameter(qtf, delta, diag, work1, work2, work3);

                // compute the new point and the norm of the evolution direction
                double lmNorm = 0;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    lmDir[pj] = -lmDir[pj];
                    currentPoint[pj] = oldX[pj] + lmDir[pj];
                    double s = diag[pj] * lmDir[pj];
                    lmNorm  += s * s;
                }
                lmNorm = FastMath.sqrt(lmNorm);
                // on the first iteration, adjust the initial step bound.
                if (firstIteration) {
                    delta = FastMath.min(delta, lmNorm);
                }

                // Evaluate the function at x + p and calculate its norm.
                currentObjective = computeObjectiveValue(currentPoint);
                currentResiduals = computeResiduals(currentObjective);
                current = new PointVectorValuePair(currentPoint, currentObjective);
                currentCost = computeCost(currentResiduals);

                // compute the scaled actual reduction
                double actRed = -1.0;
                if (0.1 * currentCost < previousCost) {
                    double r = currentCost / previousCost;
                    actRed = 1.0 - r * r;
                }

                // compute the scaled predicted reduction
                // and the scaled directional derivative
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    double dirJ = lmDir[pj];
                    work1[j] = 0;
                    for (int i = 0; i <= j; ++i) {
                        work1[i] += weightedJacobian[i][pj] * dirJ;
                    }
                }
                double coeff1 = 0;
                for (int j = 0; j < solvedCols; ++j) {
                    coeff1 += work1[j] * work1[j];
                }
                double pc2 = previousCost * previousCost;
                coeff1 = coeff1 / pc2;
                double coeff2 = lmPar * lmNorm * lmNorm / pc2;
                double preRed = coeff1 + 2 * coeff2;
                double dirDer = -(coeff1 + coeff2);

                // ratio of the actual to the predicted reduction
                ratio = (preRed == 0) ? 0 : (actRed / preRed);

                // update the step bound
                if (ratio <= 0.25) {
                    double tmp =
                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                        if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {
                            tmp = 0.1;
                        }
                        delta = tmp * FastMath.min(delta, 10.0 * lmNorm);
                        lmPar /= tmp;
                } else if ((lmPar == 0) || (ratio >= 0.75)) {
                    delta = 2 * lmNorm;
                    lmPar *= 0.5;
                }

                // test for successful iteration.
                if (ratio >= 1.0e-4) {
                    // successful iteration, update the norm
                    firstIteration = false;
                    xNorm = 0;
                    for (int k = 0; k < nC; ++k) {
                        double xK = diag[k] * currentPoint[k];
                        xNorm += xK * xK;
                    }
                    xNorm = FastMath.sqrt(xNorm);

                     // tests for convergence.
                     if (checker != null) {
                         // we use the vectorial convergence checker
                         if (checker.converged(iter, previous, current)) {
                             setCost(currentCost);
                             return current;
                         }
                    }
                } else {
                    // failed iteration, reset the previous values
                    currentCost = previousCost;
                    for (int j = 0; j < solvedCols; ++j) {
                        int pj = permutation[j];
                        currentPoint[pj] = oldX[pj];
                    }
                    tmpVec    = weightedResidual;
                    weightedResidual = oldRes;
                    oldRes    = tmpVec;
                    tmpVec    = currentObjective;
                    currentObjective = oldObj;
                    oldObj    = tmpVec;
                    // Reset ""current"" to previous values.
                    current = new PointVectorValuePair(currentPoint, currentObjective);
                }

                // Default convergence criteria.
                if ((FastMath.abs(actRed) <= costRelativeTolerance &&
                     preRed <= costRelativeTolerance &&
                     ratio <= 2.0) ||
                    delta <= parRelativeTolerance * xNorm) {
                    setCost(currentCost);
                    return current;
                }

                // tests for termination and stringent tolerances
                // (2.2204e-16 is the machine epsilon for IEEE754)
                if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,
                                                   costRelativeTolerance);
                } else if (delta <= 2.2204e-16 * xNorm) {
                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,
                                                   parRelativeTolerance);
                } else if (maxCosine <= 2.2204e-16)  {
                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,
                                                   orthoTolerance);
                }
            }
        }
    }"
Math_6,/home/common/huangzhili/defects4j_buggy/Math_6_buggy/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java,"@Override
    public PointVectorValuePair doOptimize() {
        checkParameters();

        final ConvergenceChecker<PointVectorValuePair> checker
            = getConvergenceChecker();

        // Computation will be useless without a checker (see ""for-loop"").
        if (checker == null) {
            throw new NullArgumentException();
        }

        final double[] targetValues = getTarget();
        final int nR = targetValues.length; // Number of observed data.

        final RealMatrix weightMatrix = getWeight();
        // Diagonal of the weight matrix.
        final double[] residualsWeights = new double[nR];
        for (int i = 0; i < nR; i++) {
            residualsWeights[i] = weightMatrix.getEntry(i, i);
        }

        final double[] currentPoint = getStartPoint();
        final int nC = currentPoint.length;

        // iterate until convergence is reached
        PointVectorValuePair current = null;
        int iter = 0;
        for (boolean converged = false; !converged;) {
            ++iter;

            // evaluate the objective function and its jacobian
            PointVectorValuePair previous = current;
            // Value of the objective function at ""currentPoint"".
            final double[] currentObjective = computeObjectiveValue(currentPoint);
            final double[] currentResiduals = computeResiduals(currentObjective);
            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);
            current = new PointVectorValuePair(currentPoint, currentObjective);

            // build the linear problem
            final double[]   b = new double[nC];
            final double[][] a = new double[nC][nC];
            for (int i = 0; i < nR; ++i) {

                final double[] grad   = weightedJacobian.getRow(i);
                final double weight   = residualsWeights[i];
                final double residual = currentResiduals[i];

                // compute the normal equation
                final double wr = weight * residual;
                for (int j = 0; j < nC; ++j) {
                    b[j] += wr * grad[j];
                }

                // build the contribution matrix for measurement i
                for (int k = 0; k < nC; ++k) {
                    double[] ak = a[k];
                    double wgk = weight * grad[k];
                    for (int l = 0; l < nC; ++l) {
                        ak[l] += wgk * grad[l];
                    }
                }
            }

            try {
                // solve the linearized least squares problem
                RealMatrix mA = new BlockRealMatrix(a);
                DecompositionSolver solver = useLU ?
                        new LUDecomposition(mA).getSolver() :
                        new QRDecomposition(mA).getSolver();
                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();
                // update the estimated parameters
                for (int i = 0; i < nC; ++i) {
                    currentPoint[i] += dX[i];
                }
            } catch (SingularMatrixException e) {
                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);
            }
 
             // Check convergence.
             if (previous != null) {
                 converged = checker.converged(iter, previous, current);
                 if (converged) {
                     setCost(computeCost(currentResiduals));
                     return current;
                }
            }
        }
        // Must never happen.
        throw new MathInternalError();
    }"
Math_6,/home/common/huangzhili/defects4j_buggy/Math_6_buggy/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java,"@Override
    protected PointValuePair doOptimize() {
        checkParameters();

        // Indirect call to ""computeObjectiveValue"" in order to update the
        // evaluations counter.
        final MultivariateFunction evalFunc
            = new MultivariateFunction() {
                public double value(double[] point) {
                    return computeObjectiveValue(point);
                }
            };

        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
        final Comparator<PointValuePair> comparator
            = new Comparator<PointValuePair>() {
            public int compare(final PointValuePair o1,
                               final PointValuePair o2) {
                final double v1 = o1.getValue();
                final double v2 = o2.getValue();
                return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);
            }
        };

        // Initialize search.
        simplex.build(getStartPoint());
        simplex.evaluate(evalFunc, comparator);

        PointValuePair[] previous = null;
         int iteration = 0;
         final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
         while (true) {
             if (iteration > 0) {
                 boolean converged = true;
                 for (int i = 0; i < simplex.getSize(); i++) {
                     PointValuePair prev = previous[i];
                    converged = converged &&
                        checker.converged(iteration, prev, simplex.getPoint(i));
                }
                if (converged) {
                    // We have found an optimum.
                    return simplex.getPoint(0);
                }
            }

            // We still need to search.
            previous = simplex.getPoints();
            simplex.iterate(evalFunc, comparator);

			++iteration;
        }
    }"
Math_6,/home/common/huangzhili/defects4j_buggy/Math_6_buggy/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java,"@Override
    protected PointValuePair doOptimize() {
         // -------------------- Initialization --------------------------------
        isMinimize = getGoalType().equals(GoalType.MINIMIZE);
        final FitnessFunction fitfun = new FitnessFunction();
        final double[] guess = getStartPoint();
        // number of objective variables/problem dimension
        dimension = guess.length;
        initializeCMA(guess);
        iterations = 0;
        double bestValue = fitfun.value(guess);
        push(fitnessHistory, bestValue);
        PointValuePair optimum
            = new PointValuePair(getStartPoint(),
                                 isMinimize ? bestValue : -bestValue);
        PointValuePair lastResult = null;

        // -------------------- Generation Loop --------------------------------
 
         generationLoop:
         for (iterations = 1; iterations <= maxIterations; iterations++) {
 
             // Generate and evaluate lambda offspring
             final RealMatrix arz = randn1(dimension, lambda);
            final RealMatrix arx = zeros(dimension, lambda);
            final double[] fitness = new double[lambda];
            // generate random offspring
            for (int k = 0; k < lambda; k++) {
                RealMatrix arxk = null;
                for (int i = 0; i < checkFeasableCount + 1; i++) {
                    if (diagonalOnly <= 0) {
                        arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))
                                         .scalarMultiply(sigma)); // m + sig * Normal(0,C)
                    } else {
                        arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))
                                         .scalarMultiply(sigma));
                    }
                    if (i >= checkFeasableCount ||
                        fitfun.isFeasible(arxk.getColumn(0))) {
                        break;
                    }
                    // regenerate random arguments for row
                    arz.setColumn(k, randn(dimension));
                }
                copyColumn(arxk, 0, arx, k);
                try {
                    fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness
                } catch (TooManyEvaluationsException e) {
                    break generationLoop;
                }
            }
            // Sort by fitness and compute weighted mean into xmean
            final int[] arindex = sortedIndices(fitness);
            // Calculate new xmean, this is selection and recombination
            final RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)
            final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));
            xmean = bestArx.multiply(weights);
            final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));
            final RealMatrix zmean = bestArz.multiply(weights);
            final boolean hsig = updateEvolutionPaths(zmean, xold);
            if (diagonalOnly <= 0) {
                updateCovariance(hsig, bestArx, arz, arindex, xold);
            } else {
                updateCovarianceDiagonalOnly(hsig, bestArz);
            }
            // Adapt step size sigma - Eq. (5)
            sigma *= Math.exp(Math.min(1, (normps/chiN - 1) * cs / damps));
            final double bestFitness = fitness[arindex[0]];
            final double worstFitness = fitness[arindex[arindex.length - 1]];
            if (bestValue > bestFitness) {
                bestValue = bestFitness;
                lastResult = optimum;
                optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)),
                                             isMinimize ? bestFitness : -bestFitness);
                if (getConvergenceChecker() != null &&
                    lastResult != null) {
                    if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {
                        break generationLoop;
                    }
                }
            }
            // handle termination criteria
            // Break, if fitness is good enough
            if (stopFitness != 0) { // only if stopFitness is defined
                if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {
                    break generationLoop;
                }
            }
            final double[] sqrtDiagC = sqrt(diagC).getColumn(0);
            final double[] pcCol = pc.getColumn(0);
            for (int i = 0; i < dimension; i++) {
                if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {
                    break;
                }
                if (i >= dimension - 1) {
                    break generationLoop;
                }
            }
            for (int i = 0; i < dimension; i++) {
                if (sigma * sqrtDiagC[i] > stopTolUpX) {
                    break generationLoop;
                }
            }
            final double historyBest = min(fitnessHistory);
            final double historyWorst = max(fitnessHistory);
            if (iterations > 2 &&
                Math.max(historyWorst, worstFitness) -
                Math.min(historyBest, bestFitness) < stopTolFun) {
                break generationLoop;
            }
            if (iterations > fitnessHistory.length &&
                historyWorst - historyBest < stopTolHistFun) {
                break generationLoop;
            }
            // condition number of the covariance matrix exceeds 1e14
            if (max(diagD) / min(diagD) > 1e7) {
                break generationLoop;
            }
            // user defined termination
            if (getConvergenceChecker() != null) {
                final PointValuePair current
                    = new PointValuePair(bestArx.getColumn(0),
                                         isMinimize ? bestFitness : -bestFitness);
                if (lastResult != null &&
                    getConvergenceChecker().converged(iterations, current, lastResult)) {
                    break generationLoop;
                    }
                lastResult = current;
            }
            // Adjust step size in case of equal function values (flat fitness)
            if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {
                sigma = sigma * Math.exp(0.2 + cs / damps);
            }
            if (iterations > 2 && Math.max(historyWorst, bestFitness) -
                Math.min(historyBest, bestFitness) == 0) {
                sigma = sigma * Math.exp(0.2 + cs / damps);
            }
            // store best in history
            push(fitnessHistory,bestFitness);
            fitfun.setValueRange(worstFitness-bestFitness);
            if (generateStatistics) {
                statisticsSigmaHistory.add(sigma);
                statisticsFitnessHistory.add(bestFitness);
                statisticsMeanHistory.add(xmean.transpose());
                statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));
            }
        }
        return optimum;
    }"
Math_6,/home/common/huangzhili/defects4j_buggy/Math_6_buggy/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java,"@Override
    protected PointValuePair doOptimize() {
        final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
        final double[] point = getStartPoint();
        final GoalType goal = getGoalType();
        final int n = point.length;
        double[] r = computeObjectiveGradient(point);
        if (goal == GoalType.MINIMIZE) {
            for (int i = 0; i < n; i++) {
                r[i] = -r[i];
            }
        }

        // Initial search direction.
        double[] steepestDescent = preconditioner.precondition(point, r);
        double[] searchDirection = steepestDescent.clone();

        double delta = 0;
        for (int i = 0; i < n; ++i) {
            delta += r[i] * searchDirection[i];
        }

        PointValuePair current = null;
        int iter = 0;
        int maxEval = getMaxEvaluations();
        while (true) {
            ++iter;

            final double objective = computeObjectiveValue(point);
            PointValuePair previous = current;
            current = new PointValuePair(point, objective);
            if (previous != null) {
                if (checker.converged(iter, previous, current)) {
                    // We have found an optimum.
                    return current;
                }
            }

            // Find the optimal step in the search direction.
            final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);
            final double uB = findUpperBound(lsf, 0, initialStep);
            // XXX Last parameters is set to a value close to zero in order to
            // work around the divergence problem in the ""testCircleFitting""
            // unit test (see MATH-439).
            final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);
            maxEval -= solver.getEvaluations(); // Subtract used up evaluations.

            // Validate new point.
            for (int i = 0; i < point.length; ++i) {
                point[i] += step * searchDirection[i];
            }

            r = computeObjectiveGradient(point);
            if (goal == GoalType.MINIMIZE) {
                for (int i = 0; i < n; ++i) {
                    r[i] = -r[i];
                }
            }

            // Compute beta.
            final double deltaOld = delta;
            final double[] newSteepestDescent = preconditioner.precondition(point, r);
            delta = 0;
            for (int i = 0; i < n; ++i) {
                delta += r[i] * newSteepestDescent[i];
            }

            final double beta;
            switch (updateFormula) {
            case FLETCHER_REEVES:
                beta = delta / deltaOld;
                break;
            case POLAK_RIBIERE:
                double deltaMid = 0;
                for (int i = 0; i < r.length; ++i) {
                    deltaMid += r[i] * steepestDescent[i];
                }
                beta = (delta - deltaMid) / deltaOld;
                break;
            default:
                // Should never happen.
                throw new MathInternalError();
            }
             steepestDescent = newSteepestDescent;
 
             // Compute conjugate search direction.
             if (iter % n == 0 ||
                 beta < 0) {
                 // Break conjugation: reset search direction.
                 searchDirection = steepestDescent.clone();
            } else {
                // Compute new conjugate search direction.
                for (int i = 0; i < n; ++i) {
                    searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];
                }
            }
        }
    }"
Math_12,/home/common/huangzhili/defects4j_buggy/Math_12_buggy/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java,"    public BitsStreamGenerator() {
        nextGaussian = Double.NaN;
    }
"
Math_14,/home/common/huangzhili/defects4j_buggy/Math_14_buggy/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java,"    private RealMatrix squareRoot(RealMatrix m) {
            final EigenDecomposition dec = new EigenDecomposition(m);
            return dec.getSquareRoot();
    }
"
Math_14,/home/common/huangzhili/defects4j_buggy/Math_14_buggy/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java,"    public Weight(double[] weight) {
        final int dim = weight.length;
        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);
        for (int i = 0; i < dim; i++) {
            weightMatrix.setEntry(i, i, weight[i]);
        }
    }
"
Math_15,/home/common/huangzhili/defects4j_buggy/Math_15_buggy/src/main/java/org/apache/commons/math3/util/FastMath.java,"public static double pow(double x, double y) {
        final double lns[] = new double[2];

        if (y == 0.0) {
            return 1.0;
        }

        if (x != x) { // X is NaN
            return x;
        }


        if (x == 0) {
            long bits = Double.doubleToLongBits(x);
            if ((bits & 0x8000000000000000L) != 0) {
                // -zero
                long yi = (long) y;

                if (y < 0 && y == yi && (yi & 1) == 1) {
                    return Double.NEGATIVE_INFINITY;
                }

                if (y > 0 && y == yi && (yi & 1) == 1) {
                    return -0.0;
                }
            }

            if (y < 0) {
                return Double.POSITIVE_INFINITY;
            }
            if (y > 0) {
                return 0.0;
            }

            return Double.NaN;
        }

        if (x == Double.POSITIVE_INFINITY) {
            if (y != y) { // y is NaN
                return y;
            }
            if (y < 0.0) {
                return 0.0;
            } else {
                return Double.POSITIVE_INFINITY;
            }
        }

        if (y == Double.POSITIVE_INFINITY) {
            if (x * x == 1.0) {
                return Double.NaN;
            }

            if (x * x > 1.0) {
                return Double.POSITIVE_INFINITY;
            } else {
                return 0.0;
            }
        }

        if (x == Double.NEGATIVE_INFINITY) {
            if (y != y) { // y is NaN
                return y;
            }

            if (y < 0) {
                long yi = (long) y;
                if (y == yi && (yi & 1) == 1) {
                    return -0.0;
                }

                return 0.0;
            }

            if (y > 0)  {
                long yi = (long) y;
                if (y == yi && (yi & 1) == 1) {
                    return Double.NEGATIVE_INFINITY;
                }

                return Double.POSITIVE_INFINITY;
            }
        }

        if (y == Double.NEGATIVE_INFINITY) {

            if (x * x == 1.0) {
                return Double.NaN;
            }

            if (x * x < 1.0) {
                return Double.POSITIVE_INFINITY;
            } else {
                return 0.0;
            }
        }

         /* Handle special case x<0 */
         if (x < 0) {
             // y is an even integer in this case
             if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {
                 return pow(-x, y);
             }
 
            if (y == (long) y) {
                // If y is an integer
                return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);
            } else {
                return Double.NaN;
            }
        }

        /* Split y into ya and yb such that y = ya+yb */
        double ya;
        double yb;
        if (y < 8e298 && y > -8e298) {
            double tmp1 = y * HEX_40000000;
            ya = y + tmp1 - tmp1;
            yb = y - ya;
        } else {
            double tmp1 = y * 9.31322574615478515625E-10;
            double tmp2 = tmp1 * 9.31322574615478515625E-10;
            ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;
            yb = y - ya;
        }

        /* Compute ln(x) */
        final double lores = log(x, lns);
        if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN
            return lores;
        }

        double lna = lns[0];
        double lnb = lns[1];

        /* resplit lns */
        double tmp1 = lna * HEX_40000000;
        double tmp2 = lna + tmp1 - tmp1;
        lnb += lna - tmp2;
        lna = tmp2;

        // y*ln(x) = (aa+ab)
        final double aa = lna * ya;
        final double ab = lna * yb + lnb * ya + lnb * yb;

        lna = aa+ab;
        lnb = -(lna - aa - ab);

        double z = 1.0 / 120.0;
        z = z * lnb + (1.0 / 24.0);
        z = z * lnb + (1.0 / 6.0);
        z = z * lnb + 0.5;
        z = z * lnb + 1.0;
        z = z * lnb;

        final double result = exp(lna, z, null);
        //result = result + result * z;
        return result;
    }"
Math_16,/home/common/huangzhili/defects4j_buggy/Math_16_buggy/src/main/java/org/apache/commons/math3/util/FastMath.java,"public static double cosh(double x) {
      if (x != x) {
          return x;
      }

      // cosh[z] = (exp(z) + exp(-z))/2

      // for numbers with magnitude 20 or so,
       // exp(-z) can be ignored in comparison with exp(z)
 
       if (x > 20) {
               // Avoid overflow (MATH-905).
               return 0.5 * exp(x);
           }
       if (x < -20) {
               // Avoid overflow (MATH-905).
               return 0.5 * exp(-x);
       }
 
       final double hiPrec[] = new double[2];
      if (x < 0.0) {
          x = -x;
      }
      exp(x, 0.0, hiPrec);

      double ya = hiPrec[0] + hiPrec[1];
      double yb = -(ya - hiPrec[0] - hiPrec[1]);

      double temp = ya * HEX_40000000;
      double yaa = ya + temp - temp;
      double yab = ya - yaa;

      // recip = 1/y
      double recip = 1.0/ya;
      temp = recip * HEX_40000000;
      double recipa = recip + temp - temp;
      double recipb = recip - recipa;

      // Correct for rounding in division
      recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;
      // Account for yb
      recipb += -yb * recip * recip;

      // y = y + 1/y
      temp = ya + recipa;
      yb += -(temp - ya - recipa);
      ya = temp;
      temp = ya + recipb;
      yb += -(temp - ya - recipb);
      ya = temp;

      double result = ya + yb;
      result *= 0.5;
      return result;
    }"
Math_16,/home/common/huangzhili/defects4j_buggy/Math_16_buggy/src/main/java/org/apache/commons/math3/util/FastMath.java,"public static double sinh(double x) {
      boolean negate = false;
      if (x != x) {
          return x;
      }

      // sinh[z] = (exp(z) - exp(-z) / 2

      // for values of z larger than about 20,
       // exp(-z) can be ignored in comparison with exp(z)
 
       if (x > 20) {
               // Avoid overflow (MATH-905).
               return 0.5 * exp(x);
           }
       if (x < -20) {
               // Avoid overflow (MATH-905).
               return -0.5 * exp(-x);
       }
 
       if (x == 0) {
          return x;
      }

      if (x < 0.0) {
          x = -x;
          negate = true;
      }

      double result;

      if (x > 0.25) {
          double hiPrec[] = new double[2];
          exp(x, 0.0, hiPrec);

          double ya = hiPrec[0] + hiPrec[1];
          double yb = -(ya - hiPrec[0] - hiPrec[1]);

          double temp = ya * HEX_40000000;
          double yaa = ya + temp - temp;
          double yab = ya - yaa;

          // recip = 1/y
          double recip = 1.0/ya;
          temp = recip * HEX_40000000;
          double recipa = recip + temp - temp;
          double recipb = recip - recipa;

          // Correct for rounding in division
          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;
          // Account for yb
          recipb += -yb * recip * recip;

          recipa = -recipa;
          recipb = -recipb;

          // y = y + 1/y
          temp = ya + recipa;
          yb += -(temp - ya - recipa);
          ya = temp;
          temp = ya + recipb;
          yb += -(temp - ya - recipb);
          ya = temp;

          result = ya + yb;
          result *= 0.5;
      }
      else {
          double hiPrec[] = new double[2];
          expm1(x, hiPrec);

          double ya = hiPrec[0] + hiPrec[1];
          double yb = -(ya - hiPrec[0] - hiPrec[1]);

          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */
          double denom = 1.0 + ya;
          double denomr = 1.0 / denom;
          double denomb = -(denom - 1.0 - ya) + yb;
          double ratio = ya * denomr;
          double temp = ratio * HEX_40000000;
          double ra = ratio + temp - temp;
          double rb = ratio - ra;

          temp = denom * HEX_40000000;
          double za = denom + temp - temp;
          double zb = denom - za;

          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;

          // Adjust for yb
          rb += yb*denomr;                        // numerator
          rb += -ya * denomb * denomr * denomr;   // denominator

          // y = y - 1/y
          temp = ya + ra;
          yb += -(temp - ya - ra);
          ya = temp;
          temp = ya + rb;
          yb += -(temp - ya - rb);
          ya = temp;

          result = ya + yb;
          result *= 0.5;
      }

      if (negate) {
          result = -result;
      }

      return result;
    }"
Math_18,/home/common/huangzhili/defects4j_buggy/Math_18_buggy/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java,"public double[] encode(final double[] x) {
            if (boundaries == null) {
                return x;
            }
             double[] res = new double[x.length];
             for (int i = 0; i < x.length; i++) {
                 double diff = boundaries[1][i] - boundaries[0][i];
                 res[i] = (x[i] - boundaries[0][i]) / diff;
             }
             return res;
         }"
Math_18,/home/common/huangzhili/defects4j_buggy/Math_18_buggy/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java,"public double[] decode(final double[] x) {
            if (boundaries == null) {
                return x;
            }
             double[] res = new double[x.length];
             for (int i = 0; i < x.length; i++) {
                 double diff = boundaries[1][i] - boundaries[0][i];
                 res[i] = diff * x[i] + boundaries[0][i];
             }
             return res;
         }"
Math_18,/home/common/huangzhili/defects4j_buggy/Math_18_buggy/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java,"public boolean isFeasible(final double[] x) {
            if (boundaries == null) {
                 return true;
             }
 
 
             for (int i = 0; i < x.length; i++) {
                 if (x[i] < 0) {
                     return false;
                 }
                 if (x[i] > 1.0) {
                     return false;
                 }
             }
            return true;
        }"
Math_22,/home/common/huangzhili/defects4j_buggy/Math_22_buggy/src/main/java/org/apache/commons/math3/distribution/FDistribution.java,"    public boolean isSupportLowerBoundInclusive() {
        return true;
    }
"
Math_22,/home/common/huangzhili/defects4j_buggy/Math_22_buggy/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java,"    public boolean isSupportUpperBoundInclusive() {
        return false;
    }"
Math_29,/home/common/huangzhili/defects4j_buggy/Math_29_buggy/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java,"@Override
    public OpenMapRealVector ebeDivide(RealVector v) {
        checkVectorDimensions(v.getDimension());
        OpenMapRealVector res = new OpenMapRealVector(this);
        /*
         * MATH-803: it is not sufficient to loop through non zero entries of
          * this only. Indeed, if this[i] = 0d and v[i] = 0d, then
          * this[i] / v[i] = NaN, and not 0d.
          */
         Iterator iter = entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
         }
         return res;
     }"
Math_29,/home/common/huangzhili/defects4j_buggy/Math_29_buggy/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java,"@Override
    public OpenMapRealVector ebeMultiply(RealVector v) {
        checkVectorDimensions(v.getDimension());
        OpenMapRealVector res = new OpenMapRealVector(this);
        Iterator iter = entries.iterator();
        while (iter.hasNext()) {
            iter.advance();
            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));
        }
        /*
         * MATH-803: the above loop assumes that 0d * x  = 0d for any double x,
         * which allows to consider only the non-zero entries of this. However,
         * this fails if this[i] == 0d and (v[i] = NaN or v[i] = Infinity).
          *
          * These special cases are handled below.
          */
         return res;
     }"
Math_35,/home/common/huangzhili/defects4j_buggy/Math_35_buggy/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java,"    public ElitisticListPopulation(final List<Chromosome> chromosomes,
                                   final int populationLimit,
                                   final double elitismRate) {
        super(chromosomes, populationLimit);
        this.elitismRate = elitismRate;
    }
"
Math_35,/home/common/huangzhili/defects4j_buggy/Math_35_buggy/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java,"    public ElitisticListPopulation(final int populationLimit, final double elitismRate) {
        super(populationLimit);
        this.elitismRate = elitismRate;
    }
"
Math_36,/home/common/huangzhili/defects4j_buggy/Math_36_buggy/src/main/java/org/apache/commons/math/fraction/BigFraction.java,"@Override
     public float floatValue() {
         float result = numerator.floatValue() / denominator.floatValue();
             // Numerator and/or denominator must be out of range:
             // Calculate how far to shift them to put them in range.
         return result;
     }"
Math_36,/home/common/huangzhili/defects4j_buggy/Math_36_buggy/src/main/java/org/apache/commons/math/fraction/BigFraction.java,"@Override
     public double doubleValue() {
         double result = numerator.doubleValue() / denominator.doubleValue();
             // Numerator and/or denominator must be out of range:
             // Calculate how far to shift them to put them in range.
         return result;
     }"
Math_37,/home/common/huangzhili/defects4j_buggy/Math_37_buggy/src/main/java/org/apache/commons/math/complex/Complex.java,"    public Complex tan() {
        if (isNaN) {
            return NaN;
        }

        double real2 = 2.0 * real;
        double imaginary2 = 2.0 * imaginary;
        double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);

        return createComplex(FastMath.sin(real2) / d,
                             FastMath.sinh(imaginary2) / d);
    }
"
Math_37,/home/common/huangzhili/defects4j_buggy/Math_37_buggy/src/main/java/org/apache/commons/math/complex/Complex.java,"    public Complex tanh() {
        if (isNaN) {
            return NaN;
        }
        double real2 = 2.0 * real;
        double imaginary2 = 2.0 * imaginary;
        double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);

        return createComplex(FastMath.sinh(real2) / d,
                             FastMath.sin(imaginary2) / d);
    }
"
Math_46,/home/common/huangzhili/defects4j_buggy/Math_46_buggy/src/main/java/org/apache/commons/math/complex/Complex.java,"public Complex divide(double divisor) {
        if (isNaN || Double.isNaN(divisor)) {
            return NaN;
         }
         if (divisor == 0d) {
             // return isZero ? NaN : INF; // See MATH-657
             return isZero ? NaN : INF;
         }
         if (Double.isInfinite(divisor)) {
             return !isInfinite() ? ZERO : NaN;
        }
        return createComplex(real / divisor,
                             imaginary  / divisor);
    }"
Math_46,/home/common/huangzhili/defects4j_buggy/Math_46_buggy/src/main/java/org/apache/commons/math/complex/Complex.java,"public Complex divide(Complex divisor)
        throws NullArgumentException {
        MathUtils.checkNotNull(divisor);
        if (isNaN || divisor.isNaN) {
            return NaN;
        }
 
         if (divisor.isZero) {
             // return isZero ? NaN : INF; // See MATH-657
             return isZero ? NaN : INF;
         }
 
         if (divisor.isInfinite() && !isInfinite()) {
            return ZERO;
        }

        final double c = divisor.getReal();
        final double d = divisor.getImaginary();

        if (FastMath.abs(c) < FastMath.abs(d)) {
            double q = c / d;
            double denominator = c * q + d;
            return createComplex((real * q + imaginary) / denominator,
                (imaginary * q - real) / denominator);
        } else {
            double q = d / c;
            double denominator = d * q + c;
            return createComplex((imaginary * q + real) / denominator,
                (imaginary - real * q) / denominator);
        }
    }"
Math_47,/home/common/huangzhili/defects4j_buggy/Math_47_buggy/src/main/java/org/apache/commons/math/complex/Complex.java,"public Complex divide(double divisor) {
        if (isNaN || Double.isNaN(divisor)) {
             return NaN;
         }
         if (divisor == 0d) {
             return NaN;
         }
         if (Double.isInfinite(divisor)) {
             return !isInfinite() ? ZERO : NaN;
        }
        return createComplex(real / divisor,
                             imaginary  / divisor);
    }"
Math_47,/home/common/huangzhili/defects4j_buggy/Math_47_buggy/src/main/java/org/apache/commons/math/complex/Complex.java,"public Complex divide(Complex divisor)
        throws NullArgumentException {
        MathUtils.checkNotNull(divisor);
        if (isNaN || divisor.isNaN) {
             return NaN;
         }
 
         if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {
             return NaN;
         }
 
         if (divisor.isInfinite() && !isInfinite()) {
            return ZERO;
        }

        final double c = divisor.getReal();
        final double d = divisor.getImaginary();

        if (FastMath.abs(c) < FastMath.abs(d)) {
            double q = c / d;
            double denominator = c * q + d;
            return createComplex((real * q + imaginary) / denominator,
                (imaginary * q - real) / denominator);
        } else {
            double q = d / c;
            double denominator = d * q + c;
            return createComplex((imaginary * q + real) / denominator,
                (imaginary - real * q) / denominator);
        }
    }"
Math_49,/home/common/huangzhili/defects4j_buggy/Math_49_buggy/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java,"public OpenMapRealVector ebeDivide(RealVector v) {
         checkVectorDimensions(v.getDimension());
         OpenMapRealVector res = new OpenMapRealVector(this);
         Iterator iter = res.entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
        }
        return res;
    }"
Math_49,/home/common/huangzhili/defects4j_buggy/Math_49_buggy/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java,"@Override
     public OpenMapRealVector ebeMultiply(double[] v) {
         checkVectorDimensions(v.length);
         OpenMapRealVector res = new OpenMapRealVector(this);
         Iterator iter = res.entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() * v[iter.key()]);
        }
        return res;
    }"
Math_49,/home/common/huangzhili/defects4j_buggy/Math_49_buggy/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java,"public OpenMapRealVector ebeMultiply(RealVector v) {
         checkVectorDimensions(v.getDimension());
         OpenMapRealVector res = new OpenMapRealVector(this);
         Iterator iter = res.entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));
        }
        return res;
    }"
Math_49,/home/common/huangzhili/defects4j_buggy/Math_49_buggy/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java,"@Override
     public OpenMapRealVector ebeDivide(double[] v) {
         checkVectorDimensions(v.length);
         OpenMapRealVector res = new OpenMapRealVector(this);
         Iterator iter = res.entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() / v[iter.key()]);
        }
        return res;
    }"
Math_54,/home/common/huangzhili/defects4j_buggy/Math_54_buggy/src/main/java/org/apache/commons/math/dfp/Dfp.java,"    protected Dfp(final DfpField field, double x) {

        // initialize as if 0
        mant = new int[field.getRadixDigits()];
        sign = 1;
        exp = 0;
        nans = FINITE;
        this.field = field;

        long bits = Double.doubleToLongBits(x);
        long mantissa = bits & 0x000fffffffffffffL;
        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;

        if (exponent == -1023) {
            // Zero or sub-normal
            if (x == 0) {
                // make sure 0 has the right sign
                return;
            }

            exponent++;

            // Normalize the subnormal number
            while ( (mantissa & 0x0010000000000000L) == 0) {
                exponent--;
                mantissa <<= 1;
            }
            mantissa &= 0x000fffffffffffffL;
        }

        if (exponent == 1024) {
            // infinity or NAN
            if (x != x) {
                sign = (byte) 1;
                nans = QNAN;
            } else if (x < 0) {
                sign = (byte) -1;
                nans = INFINITE;
            } else {
                sign = (byte) 1;
                nans = INFINITE;
            }
            return;
        }

        Dfp xdfp = new Dfp(field, mantissa);
        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one
        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));

        if ((bits & 0x8000000000000000L) != 0) {
            xdfp = xdfp.negate();
        }

        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);
        sign = xdfp.sign;
        exp  = xdfp.exp;
        nans = xdfp.nans;

    }
"
Math_54,/home/common/huangzhili/defects4j_buggy/Math_54_buggy/src/main/java/org/apache/commons/math/dfp/Dfp.java,"    public double toDouble() {

        if (isInfinite()) {
            if (lessThan(getZero())) {
                return Double.NEGATIVE_INFINITY;
            } else {
                return Double.POSITIVE_INFINITY;
            }
        }

        if (isNaN()) {
            return Double.NaN;
        }

        Dfp y = this;
        boolean negate = false;
        if (lessThan(getZero())) {
            y = negate();
            negate = true;
        }

        /* Find the exponent, first estimate by integer log10, then adjust.
         Should be faster than doing a natural logarithm.  */
        int exponent = (int)(y.log10() * 3.32);
        if (exponent < 0) {
            exponent--;
        }

        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);
        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {
            tempDfp = tempDfp.multiply(2);
            exponent++;
        }
        exponent--;

        /* We have the exponent, now work on the mantissa */

        y = y.divide(DfpMath.pow(getTwo(), exponent));
        if (exponent > -1023) {
            y = y.subtract(getOne());
        }

        if (exponent < -1074) {
            return 0;
        }

        if (exponent > 1023) {
            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;
        }


        y = y.multiply(newInstance(4503599627370496l)).rint();
        String str = y.toString();
        str = str.substring(0, str.length()-1);
        long mantissa = Long.parseLong(str);

        if (mantissa == 4503599627370496L) {
            // Handle special case where we round up to next power of two
            mantissa = 0;
            exponent++;
        }

        /* Its going to be subnormal, so make adjustments */
        if (exponent <= -1023) {
            exponent--;
        }

        while (exponent < -1023) {
            exponent++;
            mantissa >>>= 1;
        }

        long bits = mantissa | ((exponent + 1023L) << 52);
        double x = Double.longBitsToDouble(bits);

        if (negate) {
            x = -x;
        }

        return x;

    }
"
Math_61,/home/common/huangzhili/defects4j_buggy/Math_61_buggy/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java,"    public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {
        if (p <= 0) {
            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);
        }
        mean = p;
        normal = new NormalDistributionImpl(p, FastMath.sqrt(p));
        this.epsilon = epsilon;
        this.maxIterations = maxIterations;
    }
"
Math_62,/home/common/huangzhili/defects4j_buggy/Math_62_buggy/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java,"public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,
                                                 final double min, final double max,
                                                 final double startValue)
        throws FunctionEvaluationException {
        optima = new UnivariateRealPointValuePair[starts];
        totalEvaluations = 0;

         // Multi-start loop.
         for (int i = 0; i < starts; ++i) {
             try {
                 final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);
                 final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);
                 optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));
             } catch (FunctionEvaluationException fee) {
                 optima[i] = null;
             } catch (ConvergenceException ce) {
                optima[i] = null;
            }

            final int usedEvaluations = optimizer.getEvaluations();
            optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);
            totalEvaluations += usedEvaluations;
        }

        sortPairs(goal);

        if (optima[0] == null) {
            throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,
                                           starts);
        }

        // Return the point with the best objective function value.
        return optima[0];
    }"
Math_62,/home/common/huangzhili/defects4j_buggy/Math_62_buggy/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java,"public UnivariateRealPointValuePair optimize(final FUNC f,
                                                  final GoalType goal,
                                                  final double min, final double max)
         throws FunctionEvaluationException {
         return optimize(f, goal, min, max, 0);
     }"
Math_65,/home/common/huangzhili/defects4j_buggy/Math_65_buggy/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java,"public double getChiSquare() {
         double chiSquare = 0;
         for (int i = 0; i < rows; ++i) {
             final double residual = residuals[i];
             chiSquare += residual * residual / residualsWeights[i];
         }
         return chiSquare;
     }"
Math_66,/home/common/huangzhili/defects4j_buggy/Math_66_buggy/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java,"private double localMin(boolean isMinim,
                            UnivariateRealFunction f,
                            GoalType goalType,
                            double lo, double mid, double hi,
                            double eps, double t)
        throws MaxIterationsExceededException, FunctionEvaluationException {
        if (eps <= 0) {
            throw new NotStrictlyPositiveException(eps);
        }
        if (t <= 0) {
            throw new NotStrictlyPositiveException(t);
        }
        double a, b;
        if (lo < hi) {
            a = lo;
            b = hi;
        } else {
            a = hi;
            b = lo;
        }

        double x = mid;
        double v = x;
         double w = x;
         double d = 0;
         double e = 0;
         double fx = computeObjectiveValue(f, x);
         if (goalType == GoalType.MAXIMIZE) {
             fx = -fx;
         }
         double fv = fx;
         double fw = fx;
 
         int count = 0;
         while (count < maximalIterationCount) {
             double m = 0.5 * (a + b);
             final double tol1 = eps * Math.abs(x) + t;
             final double tol2 = 2 * tol1;

            // Check stopping criterion.
            if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {
                double p = 0;
                double q = 0;
                double r = 0;
                double u = 0;

                if (Math.abs(e) > tol1) { // Fit parabola.
                    r = (x - w) * (fx - fv);
                    q = (x - v) * (fx - fw);
                    p = (x - v) * q - (x - w) * r;
                    q = 2 * (q - r);

                    if (q > 0) {
                        p = -p;
                    } else {
                        q = -q;
                    }

                    r = e;
                    e = d;

                    if (p > q * (a - x)
                        && p < q * (b - x)
                        && Math.abs(p) < Math.abs(0.5 * q * r)) {
                        // Parabolic interpolation step.
                        d = p / q;
                        u = x + d;

                        // f must not be evaluated too close to a or b.
                        if (u - a < tol2
                            || b - u < tol2) {
                            if (x <= m) {
                                d = tol1;
                            } else {
                                d = -tol1;
                            }
                        }
                    } else {
                        // Golden section step.
                        if (x < m) {
                            e = b - x;
                        } else {
                            e = a - x;
                        }
                        d = GOLDEN_SECTION * e;
                    }
                } else {
                    // Golden section step.
                    if (x < m) {
                        e = b - x;
                    } else {
                        e = a - x;
                    }
                    d = GOLDEN_SECTION * e;
                }

                // Update by at least ""tol1"".
                if (Math.abs(d) < tol1) {
                    if (d >= 0) {
                        u = x + tol1;
                    } else {
                        u = x - tol1;
                    }
                } else {
                    u = x + d;
                }

                double fu = computeObjectiveValue(f, u);
                if (goalType == GoalType.MAXIMIZE) {
                    fu = -fu;
                }

                // Update a, b, v, w and x.
                if (fu <= fx) {
                    if (u < x) {
                        b = x;
                    } else {
                        a = x;
                    }
                    v = w;
                    fv = fw;
                    w = x;
                    fw = fx;
                    x = u;
                    fx = fu;
                } else {
                    if (u < x) {
                        a = u;
                    } else {
                        b = u;
                    }
                    if (fu <= fw
                        || w == x) {
                        v = w;
                        fv = fw;
                        w = u;
                        fw = fu;
                    } else if (fu <= fv
                               || v == x
                               || v == w) {
                        v = u;
                        fv = fu;
                    }
                }
            } else { // termination
                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);
                return x;
            }
            ++count;
        }
        throw new MaxIterationsExceededException(maximalIterationCount);
    }"
Math_67,/home/common/huangzhili/defects4j_buggy/Math_67_buggy/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java,"    public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer,
                                             final int starts,
                                             final RandomGenerator generator) {
        this.optimizer        = optimizer;
        this.totalIterations  = 0;
        this.starts           = starts;
        this.generator        = generator;
        this.optima           = null;
        setMaximalIterationCount(Integer.MAX_VALUE);
        setMaxEvaluations(Integer.MAX_VALUE);
    }
"
Math_68,/home/common/huangzhili/defects4j_buggy/Math_68_buggy/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java,"@Override
    protected VectorialPointValuePair doOptimize()
        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

        // arrays shared with the other private methods
        solvedCols  = Math.min(rows, cols);
        diagR       = new double[cols];
        jacNorm     = new double[cols];
        beta        = new double[cols];
        permutation = new int[cols];
        lmDir       = new double[cols];

        // local point
        double   delta   = 0;
        double   xNorm   = 0;
        double[] diag    = new double[cols];
        double[] oldX    = new double[cols];
        double[] oldRes  = new double[rows];
        double[] work1   = new double[cols];
        double[] work2   = new double[cols];
        double[] work3   = new double[cols];

        // evaluate the function at the starting point and calculate its norm
        updateResidualsAndCost();

         // outer loop
         lmPar = 0;
         boolean firstIteration = true;
         while (true) {
 
             incrementIterationsCounter();
 
             // compute the Q.R. decomposition of the jacobian matrix
             updateJacobian();
             qrDecomposition();
 
            // compute Qt.res
            qTy(residuals);

            // now we don't need Q anymore,
            // so let jacobian contain the R matrix with its diagonal elements
            for (int k = 0; k < solvedCols; ++k) {
                int pk = permutation[k];
                jacobian[k][pk] = diagR[pk];
            }

            if (firstIteration) {

                // scale the point according to the norms of the columns
                // of the initial jacobian
                xNorm = 0;
                for (int k = 0; k < cols; ++k) {
                    double dk = jacNorm[k];
                    if (dk == 0) {
                        dk = 1.0;
                    }
                    double xk = dk * point[k];
                    xNorm  += xk * xk;
                    diag[k] = dk;
                }
                xNorm = Math.sqrt(xNorm);

                // initialize the step bound delta
                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);

            }

            // check orthogonality between function vector and jacobian columns
            double maxCosine = 0;
            if (cost != 0) {
                for (int j = 0; j < solvedCols; ++j) {
                    int    pj = permutation[j];
                    double s  = jacNorm[pj];
                    if (s != 0) {
                        double sum = 0;
                        for (int i = 0; i <= j; ++i) {
                            sum += jacobian[i][pj] * residuals[i];
                        }
                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                    }
                }
            }
            if (maxCosine <= orthoTolerance) {
                // convergence has been reached
                return new VectorialPointValuePair(point, objective);
            }

            // rescale if necessary
            for (int j = 0; j < cols; ++j) {
                diag[j] = Math.max(diag[j], jacNorm[j]);
            }

            // inner loop
            for (double ratio = 0; ratio < 1.0e-4;) {

                // save the state
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    oldX[pj] = point[pj];
                }
                double previousCost = cost;
                double[] tmpVec = residuals;
                residuals = oldRes;
                oldRes    = tmpVec;

                // determine the Levenberg-Marquardt parameter
                determineLMParameter(oldRes, delta, diag, work1, work2, work3);

                // compute the new point and the norm of the evolution direction
                double lmNorm = 0;
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    lmDir[pj] = -lmDir[pj];
                    point[pj] = oldX[pj] + lmDir[pj];
                    double s = diag[pj] * lmDir[pj];
                    lmNorm  += s * s;
                }
                lmNorm = Math.sqrt(lmNorm);

                // on the first iteration, adjust the initial step bound.
                if (firstIteration) {
                    delta = Math.min(delta, lmNorm);
                }

                // evaluate the function at x + p and calculate its norm
                updateResidualsAndCost();

                // compute the scaled actual reduction
                double actRed = -1.0;
                if (0.1 * cost < previousCost) {
                    double r = cost / previousCost;
                    actRed = 1.0 - r * r;
                }

                // compute the scaled predicted reduction
                // and the scaled directional derivative
                for (int j = 0; j < solvedCols; ++j) {
                    int pj = permutation[j];
                    double dirJ = lmDir[pj];
                    work1[j] = 0;
                    for (int i = 0; i <= j; ++i) {
                        work1[i] += jacobian[i][pj] * dirJ;
                    }
                }
                double coeff1 = 0;
                for (int j = 0; j < solvedCols; ++j) {
                    coeff1 += work1[j] * work1[j];
                }
                double pc2 = previousCost * previousCost;
                coeff1 = coeff1 / pc2;
                double coeff2 = lmPar * lmNorm * lmNorm / pc2;
                double preRed = coeff1 + 2 * coeff2;
                double dirDer = -(coeff1 + coeff2);

                // ratio of the actual to the predicted reduction
                ratio = (preRed == 0) ? 0 : (actRed / preRed);

                // update the step bound
                if (ratio <= 0.25) {
                    double tmp =
                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
                        if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
                            tmp = 0.1;
                        }
                        delta = tmp * Math.min(delta, 10.0 * lmNorm);
                        lmPar /= tmp;
                } else if ((lmPar == 0) || (ratio >= 0.75)) {
                    delta = 2 * lmNorm;
                    lmPar *= 0.5;
                }

                // test for successful iteration.
                if (ratio >= 1.0e-4) {
                    // successful iteration, update the norm
                    firstIteration = false;
                    xNorm = 0;
                    for (int k = 0; k < cols; ++k) {
                        double xK = diag[k] * point[k];
                        xNorm    += xK * xK;
                    }
                    xNorm = Math.sqrt(xNorm);
                } else {
                    // failed iteration, reset the previous values
                    cost = previousCost;
                    for (int j = 0; j < solvedCols; ++j) {
                        int pj = permutation[j];
                        point[pj] = oldX[pj];
                    }
                    tmpVec    = residuals;
                    residuals = oldRes;
                    oldRes    = tmpVec;
                }

                // tests for convergence.
                    // we use the vectorial convergence checker
                    // we use the Levenberg-Marquardt specific convergence parameters
                    if (((Math.abs(actRed) <= costRelativeTolerance) &&
                         (preRed <= costRelativeTolerance) &&
                         (ratio <= 2.0)) ||
                        (delta <= parRelativeTolerance * xNorm)) {
                        return new VectorialPointValuePair(point, objective);
                    }

                // tests for termination and stringent tolerances
                // (2.2204e-16 is the machine epsilon for IEEE754)
                if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
                    throw new OptimizationException(""cost relative tolerance is too small ({0}),"" +
                            "" no further reduction in the"" +
                            "" sum of squares is possible"",
                            costRelativeTolerance);
                } else if (delta <= 2.2204e-16 * xNorm) {
                    throw new OptimizationException(""parameters relative tolerance is too small"" +
                            "" ({0}), no further improvement in"" +
                            "" the approximate solution is possible"",
                            parRelativeTolerance);
                } else if (maxCosine <= 2.2204e-16)  {
                    throw new OptimizationException(""orthogonality tolerance is too small ({0}),"" +
                            "" solution is orthogonal to the jacobian"",
                            orthoTolerance);
                }

            }

        }

    }"
Math_71,/home/common/huangzhili/defects4j_buggy/Math_71_buggy/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java,"@Override
  public double integrate(final FirstOrderDifferentialEquations equations,
                          final double t0, final double[] y0,
                          final double t, final double[] y)
  throws DerivativeException, IntegratorException {

    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;

    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
      System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][y0.length];
    final double[] yTmp = new double[y0.length];

    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {
      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
      rki.reinitialize(this, yTmp, yDotK, forward);
      interpolator = rki;
    } else {
      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);
    }
    interpolator.storeTime(t0);

    // set up integration control objects
    stepStart         = t0;
    double  hNew      = 0;
    boolean firstTime = true;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;

    // main integration loop
    while (!lastStep) {

      interpolator.shift();

      double error = 0;
      for (boolean loop = true; loop;) {

        if (firstTime || !fsal) {
          // first stage
          computeDerivatives(stepStart, y, yDotK[0]);
        }

        if (firstTime) {
          final double[] scale = new double[y0.length];
          if (vecAbsoluteTolerance == null) {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);
              }
            } else {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);
              }
            }
          hNew = initializeStep(equations, forward, getOrder(), scale,
                                stepStart, y, yDotK[0], yTmp, yDotK[1]);
          firstTime = false;
        }

        stepSize = hNew;

        // next stages
        for (int k = 1; k < stages; ++k) {

          for (int j = 0; j < y0.length; ++j) {
            double sum = a[k-1][0] * yDotK[0][j];
            for (int l = 1; l < k; ++l) {
              sum += a[k-1][l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
          }

          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);

        }

        // estimate the state at the end of the step
        for (int j = 0; j < y0.length; ++j) {
          double sum    = b[0] * yDotK[0][j];
          for (int l = 1; l < stages; ++l) {
            sum    += b[l] * yDotK[l][j];
          }
          yTmp[j] = y[j] + stepSize * sum;
        }

        // estimate the error at the end of the step
        error = estimateError(yDotK, y, yTmp, stepSize);
        if (error <= 1.0) {

          // discrete events handling
          interpolator.storeTime(stepStart + stepSize);
          if (manager.evaluateStep(interpolator)) {
              final double dt = manager.getEventTime() - stepStart;
              if (Math.abs(dt) <= Math.ulp(stepStart)) {
                  // we cannot simply truncate the step, reject the current computation
                  // and let the loop compute another state with the truncated step.
                   // it is so small (much probably exactly 0 due to limited accuracy)
                   // that the code above would fail handling it.
                   // So we set up an artificial 0 size step by copying states
                   loop     = false;
               } else {
                   // reject the step to match exactly the next switch time
                  hNew = dt;
              }
          } else {
            // accept the step
            loop = false;
          }

        } else {
          // reject the step and attempt to reduce error by stepsize control
          final double factor =
              Math.min(maxGrowth,
                       Math.max(minReduction, safety * Math.pow(error, exp)));
          hNew = filterStep(stepSize * factor, forward, false);
        }

      }

      // the step has been accepted
      final double nextStep = stepStart + stepSize;
      System.arraycopy(yTmp, 0, y, 0, y0.length);
      manager.stepAccepted(nextStep, y);
      lastStep = manager.stop();

      // provide the step data to the step handler
      interpolator.storeTime(nextStep);
      for (StepHandler handler : stepHandlers) {
          handler.handleStep(interpolator, lastStep);
      }
      stepStart = nextStep;

      if (fsal) {
        // save the last evaluation for the next step
        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);
      }

      if (manager.reset(stepStart, y) && ! lastStep) {
        // some event handler has triggered changes that
        // invalidate the derivatives, we need to recompute them
        computeDerivatives(stepStart, y, yDotK[0]);
      }

      if (! lastStep) {
        // in some rare cases we may get here with stepSize = 0, for example
        // when an event occurs at integration start, reducing the first step
        // to zero; we have to reset the step to some safe non zero value
          stepSize = filterStep(stepSize, forward, true);

        // stepsize control for next step
        final double factor = Math.min(maxGrowth,
                                       Math.max(minReduction,
                                                safety * Math.pow(error, exp)));
        final double  scaledH    = stepSize * factor;
        final double  nextT      = stepStart + scaledH;
        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
        hNew = filterStep(scaledH, forward, nextIsLast);
      }

    }

    final double stopTime = stepStart;
    resetInternalState();
    return stopTime;

  }"
Math_71,/home/common/huangzhili/defects4j_buggy/Math_71_buggy/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java,"public double integrate(final FirstOrderDifferentialEquations equations,
                          final double t0, final double[] y0,
                          final double t, final double[] y)
  throws DerivativeException, IntegratorException {

    sanityChecks(equations, t0, y0, t, y);
    setEquations(equations);
    resetEvaluations();
    final boolean forward = t > t0;

    // create some internal working arrays
    final int stages = c.length + 1;
    if (y != y0) {
      System.arraycopy(y0, 0, y, 0, y0.length);
    }
    final double[][] yDotK = new double[stages][];
    for (int i = 0; i < stages; ++i) {
      yDotK [i] = new double[y0.length];
    }
    final double[] yTmp = new double[y0.length];

    // set up an interpolator sharing the integrator arrays
    AbstractStepInterpolator interpolator;
    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {
      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();
      rki.reinitialize(this, yTmp, yDotK, forward);
      interpolator = rki;
    } else {
      interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);
    }
    interpolator.storeTime(t0);

    // set up integration control objects
    stepStart = t0;
    stepSize  = forward ? step : -step;
    for (StepHandler handler : stepHandlers) {
        handler.reset();
    }
    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);
    boolean lastStep = false;

    // main integration loop
    while (!lastStep) {

      interpolator.shift();

      for (boolean loop = true; loop;) {

        // first stage
        computeDerivatives(stepStart, y, yDotK[0]);

        // next stages
        for (int k = 1; k < stages; ++k) {

          for (int j = 0; j < y0.length; ++j) {
            double sum = a[k-1][0] * yDotK[0][j];
            for (int l = 1; l < k; ++l) {
              sum += a[k-1][l] * yDotK[l][j];
            }
            yTmp[j] = y[j] + stepSize * sum;
          }

          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);

        }

        // estimate the state at the end of the step
        for (int j = 0; j < y0.length; ++j) {
          double sum    = b[0] * yDotK[0][j];
          for (int l = 1; l < stages; ++l) {
            sum    += b[l] * yDotK[l][j];
          }
          yTmp[j] = y[j] + stepSize * sum;
        }

        // discrete events handling
        interpolator.storeTime(stepStart + stepSize);
        if (manager.evaluateStep(interpolator)) {
            final double dt = manager.getEventTime() - stepStart;
            if (Math.abs(dt) <= Math.ulp(stepStart)) {
                // we cannot simply truncate the step, reject the current computation
                // and let the loop compute another state with the truncated step.
                 // it is so small (much probably exactly 0 due to limited accuracy)
                 // that the code above would fail handling it.
                 // So we set up an artificial 0 size step by copying states
                 loop     = false;
             } else {
                 // reject the step to match exactly the next switch time
                stepSize = dt;
            }
        } else {
          loop = false;
        }

      }

      // the step has been accepted
      final double nextStep = stepStart + stepSize;
      System.arraycopy(yTmp, 0, y, 0, y0.length);
      manager.stepAccepted(nextStep, y);
      lastStep = manager.stop();

      // provide the step data to the step handler
      interpolator.storeTime(nextStep);
      for (StepHandler handler : stepHandlers) {
          handler.handleStep(interpolator, lastStep);
      }
      stepStart = nextStep;

      if (manager.reset(stepStart, y) && ! lastStep) {
        // some events handler has triggered changes that
        // invalidate the derivatives, we need to recompute them
        computeDerivatives(stepStart, y, yDotK[0]);
      }

      // make sure step size is set to default before next step
      stepSize = forward ? step : -step;

    }

    final double stopTime = stepStart;
    stepStart = Double.NaN;
    stepSize  = Double.NaN;
    return stopTime;

  }"
Math_76,/home/common/huangzhili/defects4j_buggy/Math_76_buggy/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java,"public RealMatrix getU()
        throws InvalidMatrixException {

        if (cachedU == null) {

            final int p = singularValues.length;
             if (m >= n) {
                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
                 final RealMatrix e =
                     eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
                 final double[][] eData = e.getData();
                 final double[][] wData = new double[m][p];
                 double[] ei1 = eData[0];
                 for (int i = 0; i < p - 1; ++i) {
                     // compute W = B.E.S^(-1) where E is the eigenvectors matrix
                     final double mi = mainBidiagonal[i];
                     final double[] ei0 = ei1;
                     final double[] wi  = wData[i];
                         ei1 = eData[i + 1];
                         final double si = secondaryBidiagonal[i];
                         for (int j = 0; j < p; ++j) {
                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                         }
                 }
                         for (int j = 0; j < p; ++j) {
                             wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
                         }
 
                 for (int i = p; i < m; ++i) {
                     wData[i] = new double[p];
                }
                cachedU =
                    transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));
            } else {
                // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
                final RealMatrix e =
                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
                cachedU = transformer.getU().multiply(e);
            }

        }

        // return the cached matrix
        return cachedU;

    }"
Math_76,/home/common/huangzhili/defects4j_buggy/Math_76_buggy/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java,"public RealMatrix getV()
        throws InvalidMatrixException {

        if (cachedV == null) {

            final int p = singularValues.length;
            if (m >= n) {
                // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
                final RealMatrix e =
                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);
                cachedV = transformer.getV().multiply(e);
            } else {
                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
                 // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix
                 final RealMatrix e =
                     eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
                 final double[][] eData = e.getData();
                 final double[][] wData = new double[n][p];
                 double[] ei1 = eData[0];
                 for (int i = 0; i < p - 1; ++i) {
                     final double mi = mainBidiagonal[i];
                     final double[] ei0 = ei1;
                     final double[] wi  = wData[i];
                         ei1 = eData[i + 1];
                         final double si = secondaryBidiagonal[i];
                         for (int j = 0; j < p; ++j) {
                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                         }
                 }
                         for (int j = 0; j < p; ++j) {
                             wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
                         }
                 for (int i = p; i < n; ++i) {
                     wData[i] = new double[p];
                 }
                cachedV =
                    transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));
            }

        }

        // return the cached matrix
        return cachedV;

    }"
Math_77,/home/common/huangzhili/defects4j_buggy/Math_77_buggy/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java,"@Override
     public double getLInfNorm() {
         double max = 0;
         for (double a : data) {
             max += Math.max(max, Math.abs(a));
         }
         return max;
     }"
Math_81,/home/common/huangzhili/defects4j_buggy/Math_81_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java,"private void computeShiftIncrement(final int start, final int end, final int deflated) {

        final double cnst1 = 0.563;
        final double cnst2 = 1.010;
        final double cnst3 = 1.05;

        // a negative dMin forces the shift to take that absolute value
        // tType records the type of shift.
        if (dMin <= 0.0) {
            tau = -dMin;
            tType = -1;
            return;
        }

        int nn = 4 * end + pingPong - 1;
        switch (deflated) {

        case 0 : // no realEigenvalues deflated.
            if (dMin == dN || dMin == dN1) {

                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);
                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);
                double a2 = work[nn - 7] + work[nn - 5];

                if (dMin == dN && dMin1 == dN1) {
                    // cases 2 and 3.
                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;
                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));
                    if (gap1 > 0.0 && gap1 > b1) {
                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);
                        tType = -2;
                    } else {
                        double s = 0.0;
                        if (dN > b1) {
                            s = dN - b1;
                        }
                        if (a2 > (b1 + b2)) {
                            s = Math.min(s, a2 - (b1 + b2));
                        }
                        tau   = Math.max(s, 0.333 * dMin);
                        tType = -3;
                    }
                } else {
                    // case 4.
                    tType = -4;
                    double s = 0.25 * dMin;
                    double gam;
                    int np;
                    if (dMin == dN) {
                        gam = dN;
                        a2 = 0.0;
                        if (work[nn - 5]  >  work[nn - 7]) {
                            return;
                        }
                        b2 = work[nn - 5] / work[nn - 7];
                        np = nn - 9;
                    } else {
                        np = nn - 2 * pingPong;
                        b2 = work[np - 2];
                        gam = dN1;
                        if (work[np - 4]  >  work[np - 2]) {
                            return;
                        }
                        a2 = work[np - 4] / work[np - 2];
                        if (work[nn - 9]  >  work[nn - 11]) {
                            return;
                        }
                        b2 = work[nn - 9] / work[nn - 11];
                        np = nn - 13;
                    }

                    // approximate contribution to norm squared from i < nn-1.
                    a2 = a2 + b2;
                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if(b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4]  >  work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;

                    // rayleigh quotient residual bound.
                    if (a2 < cnst1) {
                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                    }
                    tau = s;

                }
            } else if (dMin == dN2) {

                // case 5.
                tType = -5;
                double s = 0.25 * dMin;

                // compute contribution to norm squared from i > nn-2.
                final int np = nn - 2 * pingPong;
                double b1 = work[np - 2];
                double b2 = work[np - 6];
                final double gam = dN2;
                if (work[np - 8] > b2 || work[np - 4] > b1) {
                    return;
                }
                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);
 
                 // approximate contribution to norm squared from i < nn-2.
                 if (end - start > 2) {
                     b2 = work[nn - 13] / work[nn - 15];
                     a2 = a2 + b2;
                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (b2 == 0.0) {
                            break;
                        }
                        b1 = b2;
                        if (work[i4]  >  work[i4 - 2]) {
                            return;
                        }
                        b2 = b2 * (work[i4] / work[i4 - 2]);
                        a2 = a2 + b2;
                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {
                            break;
                        }
                    }
                    a2 = cnst3 * a2;
                }

                if (a2 < cnst1) {
                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);
                } else {
                    tau = s;
                }

            } else {

                // case 6, no information to guide us.
                if (tType == -6) {
                    g += 0.333 * (1 - g);
                } else if (tType == -18) {
                    g = 0.25 * 0.333;
                } else {
                    g = 0.25;
                }
                tau   = g * dMin;
                tType = -6;

            }
            break;

        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.
            if (dMin1 == dN1 && dMin2 == dN2) {

                // cases 7 and 8.
                tType = -7;
                double s = 0.333 * dMin1;
                if (work[nn - 5] > work[nn - 7]) {
                    return;
                }
                double b1 = work[nn - 5] / work[nn - 7];
                double b2 = b1;
                if (b2 != 0.0) {
                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        final double oldB1 = b1;
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b1 = b1 * (work[i4] / work[i4 - 2]);
                        b2 = b2 + b1;
                        if (100 * Math.max(b1, oldB1) < b2) {
                            break;
                        }
                    }
                }
                b2 = Math.sqrt(cnst3 * b2);
                final double a2 = dMin1 / (1 + b2 * b2);
                final double gap2 = 0.5 * dMin2 - a2;
                if (gap2 > 0.0 && gap2 > b2 * a2) {
                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
                } else {
                    tau = Math.max(s, a2 * (1 - cnst2 * b2));
                    tType = -8;
                }
            } else {

                // case 9.
                tau = 0.25 * dMin1;
                if (dMin1 == dN1) {
                    tau = 0.5 * dMin1;
                }
                tType = -9;
            }
            break;

        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.

            // cases 10 and 11.
            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {
                tType = -10;
                final double s = 0.333 * dMin2;
                if (work[nn - 5] > work[nn - 7]) {
                    return;
                }
                double b1 = work[nn - 5] / work[nn - 7];
                double b2 = b1;
                if (b2 != 0.0){
                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
                        if (work[i4] > work[i4 - 2]) {
                            return;
                        }
                        b1 *= work[i4] / work[i4 - 2];
                        b2 += b1;
                        if (100 * b1 < b2) {
                            break;
                        }
                    }
                }
                b2 = Math.sqrt(cnst3 * b2);
                final double a2 = dMin2 / (1 + b2 * b2);
                final double gap2 = work[nn - 7] + work[nn - 9] -
                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;
                if (gap2 > 0.0 && gap2 > b2 * a2) {
                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));
                } else {
                    tau = Math.max(s, a2 * (1 - cnst2 * b2));
                }
            } else {
                tau   = 0.25 * dMin2;
                tType = -11;
            }
            break;

        default : // case 12, more than two realEigenvalues deflated. no information.
            tau   = 0.0;
            tType = -12;
        }

    }"
Math_81,/home/common/huangzhili/defects4j_buggy/Math_81_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java,"private void processGeneralBlock(final int n)
        throws InvalidMatrixException {

        // check decomposed matrix data range
        double sumOffDiag = 0;
        for (int i = 0; i < n - 1; ++i) {
            final int fourI = 4 * i;
            final double ei = work[fourI + 2];
            sumOffDiag += ei;
        }

        if (sumOffDiag == 0) {
            // matrix is already diagonal
            return;
        }

        // initial checks for splits (see Parlett & Marques section 3.3)
        flipIfWarranted(n, 2);

        // two iterations with Li's test for initial splits
        initialSplits(n);

        // initialize parameters used by goodStep
        tType = 0;
        dMin1 = 0;
        dMin2 = 0;
        dN    = 0;
        dN1   = 0;
        dN2   = 0;
        tau   = 0;

        // process split segments
        int i0 = 0;
        int n0 = n;
        while (n0 > 0) {

            // retrieve shift that was temporarily stored as a negative off-diagonal element
            sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];
            sigmaLow = 0;

            // find start of a new split segment to process
            double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];
            double offDiagMax = 0;
            double diagMax    = work[4 * n0 - 4];
            double diagMin    = diagMax;
            i0 = 0;
            for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {
                if (work[i + 2] <= 0) {
                    i0 = 1 + i / 4;
                    break;
                }
                if (diagMin >= 4 * offDiagMax) {
                    diagMin    = Math.min(diagMin, work[i + 4]);
                    offDiagMax = Math.max(offDiagMax, work[i + 2]);
                }
                diagMax    = Math.max(diagMax, work[i] + work[i + 2]);
                offDiagMin = Math.min(offDiagMin, work[i + 2]);
            }
            work[4 * n0 - 2] = offDiagMin;

            // lower bound of Gershgorin disk
            dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));

            pingPong = 0;
            int maxIter = 30 * (n0 - i0);
            for (int k = 0; i0 < n0; ++k) {
                if (k >= maxIter) {
                    throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
                }

                // perform one step
                n0 = goodStep(i0, n0);
                pingPong = 1 - pingPong;

                // check for new splits after ""ping"" steps
                // when the last elements of qd array are very small
                if ((pingPong == 0) && (n0 - i0 > 3) &&
                    (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) &&
                    (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {
                    int split  = i0 - 1;
                     diagMax    = work[4 * i0];
                     offDiagMin = work[4 * i0 + 2];
                     double previousEMin = work[4 * i0 + 3];
                     for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {
                         if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&
                             (work[i + 2] <= TOLERANCE_2 * sigma)) {
                             // insert a split
                             work[i + 2]  = -sigma;
                            split        = i / 4;
                            diagMax      = 0;
                            offDiagMin   = work[i + 6];
                            previousEMin = work[i + 7];
                        } else {
                            diagMax      = Math.max(diagMax, work[i + 4]);
                            offDiagMin   = Math.min(offDiagMin, work[i + 2]);
                            previousEMin = Math.min(previousEMin, work[i + 3]);
                        }
                    }
                    work[4 * n0 - 2] = offDiagMin;
                    work[4 * n0 - 1] = previousEMin;
                    i0 = split + 1;
                }
            }

        }

    }"
Math_81,/home/common/huangzhili/defects4j_buggy/Math_81_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java,"private void computeGershgorinCircles() {

        final int m     = main.length;
        final int lowerStart = 4 * m;
        final int upperStart = 5 * m;
        lowerSpectra = Double.POSITIVE_INFINITY;
        upperSpectra = Double.NEGATIVE_INFINITY;
        double eMax = 0;

        double eCurrent = 0;
        for (int i = 0; i < m - 1; ++i) {

            final double dCurrent = main[i];
            final double ePrevious = eCurrent;
            eCurrent = Math.abs(secondary[i]);
            eMax = Math.max(eMax, eCurrent);
            final double radius = ePrevious + eCurrent;

            final double lower = dCurrent - radius;
            work[lowerStart + i] = lower;
            lowerSpectra = Math.min(lowerSpectra, lower);

            final double upper = dCurrent + radius;
            work[upperStart + i] = upper;
            upperSpectra = Math.max(upperSpectra, upper);

        }

        final double dCurrent = main[m - 1];
        final double lower = dCurrent - eCurrent;
        work[lowerStart + m - 1] = lower;
         lowerSpectra = Math.min(lowerSpectra, lower);
         final double upper = dCurrent + eCurrent;
         work[upperStart + m - 1] = upper;
         minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);
 
     }"
Math_83,/home/common/huangzhili/defects4j_buggy/Math_83_buggy/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,"protected RealPointValuePair getSolution() {
       double[] coefficients = new double[getOriginalNumDecisionVariables()];
       Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());
       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());
       Set<Integer> basicRows = new HashSet<Integer>();
       for (int i = 0; i < coefficients.length; i++) {
           Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);
           if (basicRows.contains(basicRow)) {
               // if multiple variables can take a given value 
               // then we choose the first and set the rest equal to 0
              coefficients[i] = 0;
          } else {
              basicRows.add(basicRow);
              coefficients[i] =
                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                  (restrictToNonNegative ? 0 : mostNegative);
          }
      }
        return new RealPointValuePair(coefficients, f.getValue(coefficients));
    }"
Math_83,/home/common/huangzhili/defects4j_buggy/Math_83_buggy/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,"private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {
         Integer row = null;
         int start = getNumObjectiveFunctions();
         for (int i = start; i < getHeight(); i++) {
             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {
                 row = i;
            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
                return null;
            }
        }
        return row;
    }"
Math_92,/home/common/huangzhili/defects4j_buggy/Math_92_buggy/src/java/org/apache/commons/math/util/MathUtils.java,"public static long binomialCoefficient(final int n, final int k) {
        if (n < k) {
            throw new IllegalArgumentException(
                ""must have n >= k for binomial coefficient (n,k)"");
        }
        if (n < 0) {
            throw new IllegalArgumentException(
                ""must have n >= 0 for binomial coefficient (n,k)"");
        }
        if ((n == k) || (k == 0)) {
            return 1;
        }
         if ((k == 1) || (k == n - 1)) {
             return n;
         }
         long result = Math.round(binomialCoefficientDouble(n, k));
         if (result == Long.MAX_VALUE) {
             throw new ArithmeticException(
                 ""result too large to represent in a long integer"");
         }
         // Use symmetry for large k
         
         // We use the formula
         // (n choose k) = n! / (n-k)! / k!
         // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
         // which could be written
         // (n choose k) == (n-1 choose k-1) * n / k
             // For n <= 61, the naive implementation cannot overflow.
             // For n > 61 but n <= 66, the result cannot overflow,
             // but we must take care not to overflow intermediate values.
                 // We know that (result * i) is divisible by j,
                 // but (result * i) may overflow, so we split j:
                 // Filter out the gcd, d, so j/d and i/d are integer.
                 // result is divisible by (j/d) because (j/d)
                 // is relative prime to (i/d) and is a divisor of
                 // result * (i/d).
             // For n > 66, a result overflow might occur, so we check
             // the multiplication, taking care to not overflow
             // unnecessary.
         return result;
     }"
Math_92,/home/common/huangzhili/defects4j_buggy/Math_92_buggy/src/java/org/apache/commons/math/util/MathUtils.java,"public static double binomialCoefficientLog(final int n, final int k) {
        if (n < k) {
            throw new IllegalArgumentException(
                ""must have n >= k for binomial coefficient (n,k)"");
        }
        if (n < 0) {
            throw new IllegalArgumentException(
                ""must have n >= 0 for binomial coefficient (n,k)"");
        }
        if ((n == k) || (k == 0)) {
            return 0;
        }
        if ((k == 1) || (k == n - 1)) {
            return Math.log((double) n);
        }
        
        /*
          * For values small enough to do exact integer computation,
          * return the log of the exact value 
          */
         
         /*
          * Return the log of binomialCoefficientDouble for values that will not
          * overflow binomialCoefficientDouble
          */
         
         /*
          * Sum logs for values that could overflow
         */
        double logSum = 0;

        // n!/k!
        for (int i = k + 1; i <= n; i++) {
            logSum += Math.log((double)i);
        }

        // divide by (n-k)!
        for (int i = 2; i <= n - k; i++) {
            logSum -= Math.log((double)i);
        }

        return logSum;      
    }"
Math_93,/home/common/huangzhili/defects4j_buggy/Math_93_buggy/src/java/org/apache/commons/math/util/MathUtils.java,"public static double factorialLog(final int n) {
         if (n < 0) {
             throw new IllegalArgumentException(""must have n > 0 for n!"");
         }
         double logSum = 0;
         for (int i = 2; i <= n; i++) {
             logSum += Math.log((double)i);
        }
        return logSum;
    }"
Math_93,/home/common/huangzhili/defects4j_buggy/Math_93_buggy/src/java/org/apache/commons/math/util/MathUtils.java,"public static double factorialDouble(final int n) {
         if (n < 0) {
             throw new IllegalArgumentException(""must have n >= 0 for n!"");
         }
         return Math.floor(Math.exp(factorialLog(n)) + 0.5);
     }"
Math_98,/home/common/huangzhili/defects4j_buggy/Math_98_buggy/src/java/org/apache/commons/math/linear/RealMatrixImpl.java,"public double[] operate(double[] v) throws IllegalArgumentException {
        final int nRows = this.getRowDimension();
        final int nCols = this.getColumnDimension();
         if (v.length != nCols) {
             throw new IllegalArgumentException(""vector has wrong length"");
         }
         final double[] out = new double[v.length];
         for (int row = 0; row < nRows; row++) {
             final double[] dataRow = data[row];
             double sum = 0;
            for (int i = 0; i < nCols; i++) {
                sum += dataRow[i] * v[i];
            }
            out[row] = sum;
        }
        return out;
    }"
Math_98,/home/common/huangzhili/defects4j_buggy/Math_98_buggy/src/java/org/apache/commons/math/linear/BigMatrixImpl.java,"public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {
        if (v.length != this.getColumnDimension()) {
            throw new IllegalArgumentException(""vector has wrong length"");
         }
         final int nRows = this.getRowDimension();
         final int nCols = this.getColumnDimension();
         final BigDecimal[] out = new BigDecimal[v.length];
         for (int row = 0; row < nRows; row++) {
             BigDecimal sum = ZERO;
             for (int i = 0; i < nCols; i++) {
                sum = sum.add(data[row][i].multiply(v[i]));
            }
            out[row] = sum;
        }
        return out;
    }"
Math_99,/home/common/huangzhili/defects4j_buggy/Math_99_buggy/src/java/org/apache/commons/math/util/MathUtils.java,"public static int lcm(int a, int b) {
        if (a==0 || b==0){
             return 0;
         }
         int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));
         return lcm;
     }"
Math_99,/home/common/huangzhili/defects4j_buggy/Math_99_buggy/src/java/org/apache/commons/math/util/MathUtils.java,"public static int gcd(final int p, final int q) {
         int u = p;
         int v = q;
         if ((u == 0) || (v == 0)) {
             return (Math.abs(u) + Math.abs(v));
         }
         // keep u and v negative, as negative integers range down to
        // -2^31, while positive numbers can only be as large as 2^31-1
        // (i.e. we can't necessarily negate a negative number without
        // overflow)
        /* assert u!=0 && v!=0; */
        if (u > 0) {
            u = -u;
        } // make u negative
        if (v > 0) {
            v = -v;
        } // make v negative
        // B1. [Find power of 2]
        int k = 0;
        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
                                                            // both even...
            u /= 2;
            v /= 2;
            k++; // cast out twos.
        }
        if (k == 31) {
            throw MathRuntimeException.createArithmeticException(
                    ""overflow: gcd({0}, {1}) is 2^31"",
                    new Object[] { p, q });
        }
        // B2. Initialize: u and v have been divided by 2^k and at least
        // one is odd.
        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
        // t negative: u was odd, v may be even (t replaces v)
        // t positive: u was even, v is odd (t replaces u)
        do {
            /* assert u<0 && v<0; */
            // B4/B3: cast out twos from t.
            while ((t & 1) == 0) { // while t is even..
                t /= 2; // cast out twos
            }
            // B5 [reset max(u,v)]
            if (t > 0) {
                u = -t;
            } else {
                v = t;
            }
            // B6/B3. at this point both u and v should be odd.
            t = (v - u) / 2;
            // |u| larger: t positive (replace u)
            // |v| larger: t negative (replace v)
        } while (t != 0);
        return -u * (1 << k); // gcd is u*2^k
    }"
Math_100,/home/common/huangzhili/defects4j_buggy/Math_100_buggy/src/java/org/apache/commons/math/estimation/AbstractEstimator.java,"public double[][] getCovariances(EstimationProblem problem)
      throws EstimationException {
 
        // set up the jacobian
        updateJacobian();
 
         // compute transpose(J).J, avoiding building big intermediate matrices
         final int rows = problem.getMeasurements().length;
         final int cols = problem.getAllParameters().length;
         final int max  = cols * rows;
         double[][] jTj = new double[cols][cols];
         for (int i = 0; i < cols; ++i) {
            for (int j = i; j < cols; ++j) {
                double sum = 0;
                for (int k = 0; k < max; k += cols) {
                    sum += jacobian[k + i] * jacobian[k + j];
                }
                jTj[i][j] = sum;
                jTj[j][i] = sum;
            }
        }

        try {
            // compute the covariances matrix
            return new RealMatrixImpl(jTj).inverse().getData();
        } catch (InvalidMatrixException ime) {
            throw new EstimationException(""unable to compute covariances: singular problem"",
                                          new Object[0]);
        }

    }"
Math_100,/home/common/huangzhili/defects4j_buggy/Math_100_buggy/src/java/org/apache/commons/math/estimation/AbstractEstimator.java,"public double[] guessParametersErrors(EstimationProblem problem)
       throws EstimationException {
         int m = problem.getMeasurements().length;
         int p = problem.getAllParameters().length;
         if (m <= p) {
             throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"",
                                           new Object[] { new Integer(m), new Integer(p)});
         }
         double[] errors = new double[problem.getAllParameters().length];
         final double c = Math.sqrt(getChiSquare(problem) / (m - p));
         double[][] covar = getCovariances(problem);
         for (int i = 0; i < errors.length; ++i) {
            errors[i] = Math.sqrt(covar[i][i]) * c;
        }
        return errors;
    }"
Math_104,/home/common/huangzhili/defects4j_buggy/Math_104_buggy/src/java/org/apache/commons/math/special/Gamma.java,"/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the ""License""); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.math.special;

import java.io.Serializable;

import org.apache.commons.math.MathException;
import org.apache.commons.math.MaxIterationsExceededException;
import org.apache.commons.math.util.ContinuedFraction;

/**
 * This is a utility class that provides computation methods related to the
 * Gamma family of functions.
 *
 * @version $Revision$ $Date$
 */
public class Gamma implements Serializable {
    
    /** Serializable version identifier */
    private static final long serialVersionUID = -6587513359895466954L;

    /** Maximum allowed numerical error. */
    private static final double DEFAULT_EPSILON = 10e-9;

    /** Lanczos coefficients */
    private static double[] lanczos =
    {
        0.99999999999999709182,
        57.156235665862923517,
        -59.597960355475491248,
        14.136097974741747174,
        -0.49191381609762019978,
        .33994649984811888699e-4,
        .46523628927048575665e-4,
        -.98374475304879564677e-4,
        .15808870322491248884e-3,
        -.21026444172410488319e-3,
        .21743961811521264320e-3,
        -.16431810653676389022e-3,
        .84418223983852743293e-4,
        -.26190838401581408670e-4,
        .36899182659531622704e-5,
    };

    /** Avoid repeated computation of log of 2 PI in logGamma */
    private static final double HALF_LOG_2_PI = 0.5 * Math.log(2.0 * Math.PI);

    
    /**
     * Default constructor.  Prohibit instantiation.
     */
    private Gamma() {
        super();
    }

    /**
     * Returns the natural logarithm of the gamma function &#915;(x).
     *
     * The implementation of this method is based on:
     * <ul>
     * <li><a href=""http://mathworld.wolfram.com/GammaFunction.html"">
     * Gamma Function</a>, equation (28).</li>
     * <li><a href=""http://mathworld.wolfram.com/LanczosApproximation.html"">
     * Lanczos Approximation</a>, equations (1) through (5).</li>
     * <li><a href=""http://my.fit.edu/~gabdo/gamma.txt"">Paul Godfrey, A note on
     * the computation of the convergent Lanczos complex Gamma approximation
     * </a></li>
     * </ul>
     * 
     * @param x the value.
     * @return log(&#915;(x))
     */
    public static double logGamma(double x) {
        double ret;

        if (Double.isNaN(x) || (x <= 0.0)) {
            ret = Double.NaN;
        } else {
            double g = 607.0 / 128.0;
            
            double sum = 0.0;
            for (int i = lanczos.length - 1; i > 0; --i) {
                sum = sum + (lanczos[i] / (x + i));
            }
            sum = sum + lanczos[0];

            double tmp = x + g + .5;
            ret = ((x + .5) * Math.log(tmp)) - tmp +
                HALF_LOG_2_PI + Math.log(sum / x);
        }

        return ret;
    }

    /**
     * Returns the regularized gamma function P(a, x).
     * 
     * @param a the a parameter.
     * @param x the value.
     * @return the regularized gamma function P(a, x)
     * @throws MathException if the algorithm fails to converge.
     */
    public static double regularizedGammaP(double a, double x)
        throws MathException
    {
        return regularizedGammaP(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);
    }
        
        
    /**
     * Returns the regularized gamma function P(a, x).
     * 
     * The implementation of this method is based on:
     * <ul>
     * <li>
     * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
     * Regularized Gamma Function</a>, equation (1).</li>
     * <li>
     * <a href=""http://mathworld.wolfram.com/IncompleteGammaFunction.html"">
     * Incomplete Gamma Function</a>, equation (4).</li>
     * <li>
     * <a href=""http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html"">
     * Confluent Hypergeometric Function of the First Kind</a>, equation (1).
     * </li>
     * </ul>
     * 
     * @param a the a parameter.
     * @param x the value.
     * @param epsilon When the absolute value of the nth item in the
     *                series is less than epsilon the approximation ceases
     *                to calculate further elements in the series.
     * @param maxIterations Maximum number of ""iterations"" to complete. 
     * @return the regularized gamma function P(a, x)
     * @throws MathException if the algorithm fails to converge.
     */
    public static double regularizedGammaP(double a, 
                                           double x, 
                                           double epsilon, 
                                           int maxIterations) 
        throws MathException
    {
        double ret;

        if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
            ret = Double.NaN;
        } else if (x == 0.0) {
            ret = 0.0;
        } else if (a >= 1.0 && x > a) {
            // use regularizedGammaQ because it should converge faster in this
            // case.
            ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);
        } else {
            // calculate series
            double n = 0.0; // current element index
            double an = 1.0 / a; // n-th element in the series
            double sum = an; // partial sum
            while (Math.abs(an) > epsilon && n < maxIterations) {
                // compute next element in the series
                n = n + 1.0;
                an = an * (x / (a + n));

                // update partial sum
                sum = sum + an;
            }
            if (n >= maxIterations) {
                throw new MaxIterationsExceededException(maxIterations);
            } else {
                ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;
            }
        }

        return ret;
    }
    
    /**
     * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).
     * 
     * @param a the a parameter.
     * @param x the value.
     * @return the regularized gamma function Q(a, x)
     * @throws MathException if the algorithm fails to converge.
     */
    public static double regularizedGammaQ(double a, double x)
        throws MathException
    {
        return regularizedGammaQ(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);
    }
    
    /**
     * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).
     * 
     * The implementation of this method is based on:
     * <ul>
     * <li>
     * <a href=""http://mathworld.wolfram.com/RegularizedGammaFunction.html"">
     * Regularized Gamma Function</a>, equation (1).</li>
     * <li>
     * <a href=""    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/"">
     * Regularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)</a></li>
     * </ul>
     * 
     * @param a the a parameter.
     * @param x the value.
     * @param epsilon When the absolute value of the nth item in the
     *                series is less than epsilon the approximation ceases
     *                to calculate further elements in the series.
     * @param maxIterations Maximum number of ""iterations"" to complete. 
     * @return the regularized gamma function P(a, x)
     * @throws MathException if the algorithm fails to converge.
     */
    public static double regularizedGammaQ(final double a, 
                                           double x, 
                                           double epsilon, 
                                           int maxIterations) 
        throws MathException
    {
        double ret;

        if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {
            ret = Double.NaN;
        } else if (x == 0.0) {
            ret = 1.0;
        } else if (x < a || a < 1.0) {
            // use regularizedGammaP because it should converge faster in this
            // case.
            ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);
        } else {
            // create continued fraction
            ContinuedFraction cf = new ContinuedFraction() {

                private static final long serialVersionUID = 5378525034886164398L;

                protected double getA(int n, double x) {
                    return ((2.0 * n) + 1.0) - a + x;
                }

                protected double getB(int n, double x) {
                    return n * (a - n);
                }
            };
            
            ret = 1.0 / cf.evaluate(x, epsilon, maxIterations);
            ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;
        }

        return ret;
    }
}
"
Mockito_2,/home/common/huangzhili/defects4j_buggy/Mockito_2_buggy/src/org/mockito/internal/util/Timer.java,"    public void start() {
        startTime = System.currentTimeMillis();
    }
"
Mockito_2,/home/common/huangzhili/defects4j_buggy/Mockito_2_buggy/src/org/mockito/internal/util/Timer.java,"    public Timer(long durationMillis) {
        this.durationMillis = durationMillis;
    }
"
Mockito_3,/home/common/huangzhili/defects4j_buggy/Mockito_3_buggy/src/org/mockito/internal/invocation/InvocationMatcher.java,"    public void captureArgumentsFrom(Invocation invocation) {
        if (invocation.getMethod().isVarArgs()) {
            int indexOfVararg = invocation.getRawArguments().length - 1;
            for (int position = 0; position < indexOfVararg; position++) {
                Matcher m = matchers.get(position);
                if (m instanceof CapturesArguments) {
                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
                }
            }
            for (int position = indexOfVararg; position < matchers.size(); position++) {
                Matcher m = matchers.get(position);
                if (m instanceof CapturesArguments) {
                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);
                }
            }
        } else {
            for (int position = 0; position < matchers.size(); position++) {
                Matcher m = matchers.get(position);
                if (m instanceof CapturesArguments) {
                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
                }
            }
        }
    }
"
Mockito_4,/home/common/huangzhili/defects4j_buggy/Mockito_4_buggy/src/org/mockito/exceptions/Reporter.java,"    public void cannotInjectDependency(Field field, Object matchingMock, Exception details) {
        throw new MockitoException(join(
                ""Mockito couldn't inject mock dependency '"" + safelyGetMockName(matchingMock) + ""' on field "",
                ""'"" + field + ""'"",
                ""whose type '"" + field.getDeclaringClass().getCanonicalName() + ""' was annotated by @InjectMocks in your test."",
                ""Also I failed because: "" + exceptionCauseMessageIfAvailable(details),
                """"
        ), details);
    }
"
Mockito_4,/home/common/huangzhili/defects4j_buggy/Mockito_4_buggy/src/org/mockito/exceptions/Reporter.java,"    public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwareInvocation> invocations) {
        ScenarioPrinter scenarioPrinter = new ScenarioPrinter();
        String scenario = scenarioPrinter.print(invocations);

        throw new NoInteractionsWanted(join(
                ""No interactions wanted here:"",
                new LocationImpl(),
                ""But found this interaction on mock '"" + undesired.getMock() + ""':"",
                undesired.getLocation(),
                scenario
        ));
    }
"
Mockito_4,/home/common/huangzhili/defects4j_buggy/Mockito_4_buggy/src/org/mockito/exceptions/Reporter.java,"    public void noMoreInteractionsWantedInOrder(Invocation undesired) {
        throw new VerificationInOrderFailure(join(
                ""No interactions wanted here:"",
                new LocationImpl(),
                ""But found this interaction on mock '"" + undesired.getMock() + ""':"",
                undesired.getLocation()
        ));
    }
"
Mockito_6,/home/common/huangzhili/defects4j_buggy/Mockito_6_buggy/src/org/mockito/Matchers.java,"    public static char anyChar() {
        return reportMatcher(Any.ANY).returnChar();
    }
"
Mockito_6,/home/common/huangzhili/defects4j_buggy/Mockito_6_buggy/src/org/mockito/Matchers.java,"    public static double anyDouble() {
        return reportMatcher(Any.ANY).returnZero();
    }
"
Mockito_6,/home/common/huangzhili/defects4j_buggy/Mockito_6_buggy/src/org/mockito/Matchers.java,"    public static Collection anyCollection() {
        return reportMatcher(Any.ANY).returnList();
    }    
"
Mockito_6,/home/common/huangzhili/defects4j_buggy/Mockito_6_buggy/src/org/mockito/Matchers.java,"    public static Set anySet() {
        return reportMatcher(Any.ANY).returnSet();
    }
"
Mockito_6,/home/common/huangzhili/defects4j_buggy/Mockito_6_buggy/src/org/mockito/Matchers.java,"    public static short anyShort() {
        return reportMatcher(Any.ANY).returnZero();
    }
"
Mockito_6,/home/common/huangzhili/defects4j_buggy/Mockito_6_buggy/src/org/mockito/Matchers.java,"    public static <T> T anyObject() {
        return (T) reportMatcher(Any.ANY).returnNull();
    }
"
Mockito_6,/home/common/huangzhili/defects4j_buggy/Mockito_6_buggy/src/org/mockito/Matchers.java,"    public static <T> T any(Class<T> clazz) {
        return (T) reportMatcher(Any.ANY).returnFor(clazz);
    }
"
Mockito_6,/home/common/huangzhili/defects4j_buggy/Mockito_6_buggy/src/org/mockito/Matchers.java,"    public static <T> T any() {
        return (T) anyObject();
    }
"
Mockito_6,/home/common/huangzhili/defects4j_buggy/Mockito_6_buggy/src/org/mockito/Matchers.java,"    public static String anyString() {
        return reportMatcher(Any.ANY).returnString();
    }
"
Mockito_6,/home/common/huangzhili/defects4j_buggy/Mockito_6_buggy/src/org/mockito/Matchers.java,"    public static <K, V>  Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) {
        return reportMatcher(Any.ANY).returnMap();
    }
"
Mockito_6,/home/common/huangzhili/defects4j_buggy/Mockito_6_buggy/src/org/mockito/Matchers.java,"    public static long anyLong() {
        return reportMatcher(Any.ANY).returnZero();
    }
"
Mockito_6,/home/common/huangzhili/defects4j_buggy/Mockito_6_buggy/src/org/mockito/Matchers.java,"    public static <T> List<T> anyListOf(Class<T> clazz) {
        return (List) reportMatcher(Any.ANY).returnList();
    }    
"
Mockito_6,/home/common/huangzhili/defects4j_buggy/Mockito_6_buggy/src/org/mockito/Matchers.java,"    public static float anyFloat() {
        return reportMatcher(Any.ANY).returnZero();
    }
"
Mockito_6,/home/common/huangzhili/defects4j_buggy/Mockito_6_buggy/src/org/mockito/Matchers.java,"    public static boolean anyBoolean() {
        return reportMatcher(Any.ANY).returnFalse();
    }
"
Mockito_6,/home/common/huangzhili/defects4j_buggy/Mockito_6_buggy/src/org/mockito/Matchers.java,"    public static byte anyByte() {
        return reportMatcher(Any.ANY).returnZero();
    }
"
Mockito_6,/home/common/huangzhili/defects4j_buggy/Mockito_6_buggy/src/org/mockito/Matchers.java,"    public static int anyInt() {
        return reportMatcher(Any.ANY).returnZero();
    }
"
Mockito_6,/home/common/huangzhili/defects4j_buggy/Mockito_6_buggy/src/org/mockito/Matchers.java,"    public static <T> Set<T> anySetOf(Class<T> clazz) {
        return (Set) reportMatcher(Any.ANY).returnSet();
    }
"
Mockito_6,/home/common/huangzhili/defects4j_buggy/Mockito_6_buggy/src/org/mockito/Matchers.java,"    public static Map anyMap() {
        return reportMatcher(Any.ANY).returnMap();
    }
"
Mockito_6,/home/common/huangzhili/defects4j_buggy/Mockito_6_buggy/src/org/mockito/Matchers.java,"    public static List anyList() {
        return reportMatcher(Any.ANY).returnList();
    }    
"
Mockito_6,/home/common/huangzhili/defects4j_buggy/Mockito_6_buggy/src/org/mockito/Matchers.java,"    public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {
        return (Collection) reportMatcher(Any.ANY).returnList();
    }    
"
Mockito_9,/home/common/huangzhili/defects4j_buggy/Mockito_9_buggy/src/org/mockito/internal/stubbing/answers/CallsRealMethods.java,"/*
 * Copyright (c) 2007 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */
package org.mockito.internal.stubbing.answers;

import java.io.Serializable;

import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;

/**
 * Optional Answer that adds partial mocking support
 * <p>
 * {@link Answer} can be used to define the return values of unstubbed invocations.
 * <p>
 * This implementation can be helpful when working with legacy code.
 * When this implementation is used, unstubbed methods will delegate to the real implementation.
 * This is a way to create a partial mock object that calls real methods by default.
 * <p>
 * As usual you are going to read <b>the partial mock warning</b>:
 * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
 * How does partial mock fit into this paradigm? Well, it just doesn't... 
 * Partial mock usually means that the complexity has been moved to a different method on the same object.
 * In most cases, this is not the way you want to design your application.
 * <p>
 * However, there are rare cases when partial mocks come handy: 
 * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
 * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
 * <p>
 */
public class CallsRealMethods implements Answer<Object>, Serializable {
    private static final long serialVersionUID = 9057165148930624087L;

    public Object answer(InvocationOnMock invocation) throws Throwable {
        return invocation.callRealMethod();
    }
}"
Mockito_10,/home/common/huangzhili/defects4j_buggy/Mockito_10_buggy/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java,"    private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {
        InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());
        InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();

        // matches invocation for verification
        for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {
            if (container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {
                return stubbedInvocationMatcher.answer(invocation);
            }
        }

        // record deep stub answer
        return recordDeepStubAnswer(
                newDeepStubMock(returnTypeGenericMetadata),
                container
        );
    }
"
Mockito_10,/home/common/huangzhili/defects4j_buggy/Mockito_10_buggy/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java,"    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {
        return mockitoCore().mock(
                returnTypeGenericMetadata.rawType(),
                withSettingsUsing(returnTypeGenericMetadata)
        );
    }
"
Mockito_11,/home/common/huangzhili/defects4j_buggy/Mockito_11_buggy/src/org/mockito/internal/creation/DelegatingMethod.java,"/*
 * Copyright (c) 2007 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */
package org.mockito.internal.creation;

import org.mockito.internal.invocation.MockitoMethod;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

public class DelegatingMethod implements MockitoMethod {

    private final Method method;

    public DelegatingMethod(Method method) {
        assert method != null : ""Method cannot be null"";
        this.method = method;
    }

    public Class<?>[] getExceptionTypes() {
        return method.getExceptionTypes();
    }

    public Method getJavaMethod() {
        return method;
    }

    public String getName() {
        return method.getName();
    }

    public Class<?>[] getParameterTypes() {
        return method.getParameterTypes();
    }

    public Class<?> getReturnType() {
        return method.getReturnType();
    }

    public boolean isVarArgs() {
        return method.isVarArgs();
    }

    public boolean isAbstract() {
        return (method.getModifiers() & Modifier.ABSTRACT) != 0;
    }

    /**
     * @return True if the input object is a DelegatingMethod which has an internal Method which is equal to the internal Method of this DelegatingMethod,
     * or if the input object is a Method which is equal to the internal Method of this DelegatingMethod.
     */
    @Override
    public boolean equals(Object o) {
            return method.equals(o);
    }

    @Override
    public int hashCode() {
        return 1;
    }
}"
Mockito_14,/home/common/huangzhili/defects4j_buggy/Mockito_14_buggy/src/org/mockito/internal/MockHandler.java,"public Object handle(Invocation invocation) throws Throwable {
        if (invocationContainerImpl.hasAnswersForStubbing()) {
            // stubbing voids with stubVoid() or doAnswer() style
            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress
                            .getArgumentMatcherStorage(), invocation);
            invocationContainerImpl.setMethodForStubbing(invocationMatcher);
            return null;
        }
        VerificationMode verificationMode = mockingProgress.pullVerificationMode();

        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),
                        invocation);

        mockingProgress.validateState();

        //if verificationMode is not null then someone is doing verify()        
         if (verificationMode != null) {
             //We need to check if verification was started on the correct mock 
             // - see VerifyingWithAnExtraCallToADifferentMockTest
                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            
                 verificationMode.verify(data);
                 return null;
         }
         
         invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
        mockingProgress.reportOngoingStubbing(ongoingStubbing);

        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);

        if (stubbedInvocation != null) {
            stubbedInvocation.captureArgumentsFrom(invocation);
            return stubbedInvocation.answer(invocation);
        } else {
            Object ret = mockSettings.getDefaultAnswer().answer(invocation);

            // redo setting invocation for potential stubbing in case of partial
            // mocks / spies.
            // Without it, the real method inside 'when' might have delegated
            // to other self method and overwrite the intended stubbed method
            // with a different one.
            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
            return ret;
        }
    }"
Mockito_14,/home/common/huangzhili/defects4j_buggy/Mockito_14_buggy/src/org/mockito/internal/MockitoCore.java,"public <T> T verify(T mock, VerificationMode mode) {
        if (mock == null) {
            reporter.nullPassedToVerify();
         } else if (!mockUtil.isMock(mock)) {
             reporter.notAMockPassedToVerify();
         }
         mockingProgress.verificationStarted(mode);
         return mock;
     }"
Mockito_15,/home/common/huangzhili/defects4j_buggy/Mockito_15_buggy/src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java,"public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {
        if(mocks.size() == 1) {
            final Object matchingMock = mocks.iterator().next();

             return new OngoingInjecter() {
                 public boolean thenInject() {
                     try {
                             new FieldSetter(fieldInstance, field).set(matchingMock);
                     } catch (Exception e) {
                         throw new MockitoException(""Problems injecting dependency in "" + field.getName(), e);
                     }
                    return true;
                }
            };
        }

        return new OngoingInjecter() {
            public boolean thenInject() {
                return false;
            }
        };

    }"
Mockito_16,/home/common/huangzhili/defects4j_buggy/Mockito_16_buggy/src/org/mockito/Mockito.java,"public static <T> T spy(T object) {
         return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()
                 .spiedInstance(object)
                 .defaultAnswer(CALLS_REAL_METHODS)); 
     }"
Mockito_17,/home/common/huangzhili/defects4j_buggy/Mockito_17_buggy/src/org/mockito/internal/util/MockUtil.java,"public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {
        creationValidator.validateType(classToMock);
        creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());
        creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());

        settings.initiateMockName(classToMock);

        MockHandler<T> mockHandler = new MockHandler<T>(settings);
        MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHandler, settings);
         Class<?>[] interfaces = settings.getExtraInterfaces();
 
         Class<?>[] ancillaryTypes;
             ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;
 
         Object spiedInstance = settings.getSpiedInstance();
         
        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);
        
        if (spiedInstance != null) {
            new LenientCopyTool().copyToMock(spiedInstance, mock);
        }
        
        return mock;
    }"
Mockito_19,/home/common/huangzhili/defects4j_buggy/Mockito_19_buggy/src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java,"public class NameBasedCandidateFilter implements MockCandidateFilter {
 private final MockCandidateFilter next;
 private final MockUtil mockUtil = new MockUtil();

 public NameBasedCandidateFilter(MockCandidateFilter next) {
  this.next = next;
 }

 public OngoingInjecter filterCandidate(Collection<Object> mocks,
   Field field, Object fieldInstance) {
  List<Object> mockNameMatches = new ArrayList<Object>();
  if (mocks.size() > 1) {
   for (Object mock : mocks) {
    if (field.getName().equals(mockUtil.getMockName(mock).toString())) {
     mockNameMatches.add(mock);
    }
   }
   return next.filterCandidate(mockNameMatches, field,
     fieldInstance);
   /*
    * In this case we have to check whether we have conflicting naming
    * fields. E.g. 2 fields of the same type, but we have to make sure
    * we match on the correct name.
    * 
    * Therefore we have to go through all other fields and make sure
    * whenever we find a field that does match its name with the mock
    * name, we should take that field instead.
    */
  }
  return next.filterCandidate(mocks, field, fieldInstance);
 }
}"
Mockito_19,/home/common/huangzhili/defects4j_buggy/Mockito_19_buggy/src/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java,"
import java.lang.reflect.Field;
import java.util.Collection;

public interface MockCandidateFilter {

    OngoingInjecter filterCandidate(
            Collection<Object> mocks,
            Field fieldToBeInjected,
            Object fieldInstance
    );

}
"
Mockito_19,/home/common/huangzhili/defects4j_buggy/Mockito_19_buggy/src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java,"public class TypeBasedCandidateFilter implements MockCandidateFilter {

    MockCandidateFilter next;

    public TypeBasedCandidateFilter(MockCandidateFilter next) {
        this.next = next;
    }

    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {
        List<Object> mockTypeMatches = new ArrayList<Object>();
        for (Object mock : mocks) {
            if (field.getType().isAssignableFrom(mock.getClass())) {
                mockTypeMatches.add(mock);
            }
        }

        return next.filterCandidate(mockTypeMatches, field, fieldInstance);
    }
}
"
Mockito_19,/home/common/huangzhili/defects4j_buggy/Mockito_19_buggy/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java,"    private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {
        for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {
            Field field = it.next();
            Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();
            if (injected != null) {
                injectionOccurred |= true;
                mocks.remove(injected);
                it.remove();
            }
        }
        return injectionOccurred;
    }
"
Mockito_19,/home/common/huangzhili/defects4j_buggy/Mockito_19_buggy/src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java,"    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {
        if(mocks.size() == 1) {
            final Object matchingMock = mocks.iterator().next();

            return new OngoingInjecter() {
                public Object thenInject() {
                    try {
                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {
                            new FieldSetter(fieldInstance, field).set(matchingMock);
                        }
                    } catch (RuntimeException e) {
                        new Reporter().cannotInjectDependency(field, matchingMock, e);
                    }
                    return matchingMock;
                }
            };
        }

        return new OngoingInjecter() {
            public Object thenInject() {
                return null;
            }
        };

    }
"
Mockito_21,/home/common/huangzhili/defects4j_buggy/Mockito_21_buggy/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java,"    public <T> T newInstance(Class<T> cls) {
        if (outerClassInstance == null) {
            return noArgConstructor(cls);
        }
        return withOuterClass(cls);
    }
"
Mockito_21,/home/common/huangzhili/defects4j_buggy/Mockito_21_buggy/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java,"    private static <T> InstantationException paramsException(Class<T> cls, Exception e) {
        return new InstantationException(""Unable to create mock instance of '""
                + cls.getSimpleName() + ""'.\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor."", e);
    }
"
Mockito_23,/home/common/huangzhili/defects4j_buggy/Mockito_23_buggy/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java,"private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {
        MockSettings mockSettings =
                returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?
                withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())
                : withSettings();

        return mockSettings
                .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
    }"
Mockito_23,/home/common/huangzhili/defects4j_buggy/Mockito_23_buggy/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java,"private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {
 
         container.addAnswer(new Answer<Object>() {
             public Object answer(InvocationOnMock invocation) throws Throwable {
                 return mock;
             }
        }, false);

        return mock;
    }"
Mockito_25,/home/common/huangzhili/defects4j_buggy/Mockito_25_buggy/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java,"    public Object answer(InvocationOnMock invocation) throws Throwable {
        GenericMetadataSupport returnTypeGenericMetadata =
                actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());

        Class<?> rawType = returnTypeGenericMetadata.rawType();
        if (!new MockCreationValidator().isTypeMockable(rawType)) {
            return delegate.returnValueFor(rawType);
        }

        return getMock(invocation);
    }
"
Mockito_25,/home/common/huangzhili/defects4j_buggy/Mockito_25_buggy/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java,"    private Object getMock(InvocationOnMock invocation) throws Throwable {
    	InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());
    	InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();

        // matches invocation for verification
        for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {
    		if(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {
    			return stubbedInvocationMatcher.answer(invocation);
    		}
		}

        // deep stub
        return recordDeepStubMock(invocation, container);
    }
"
Mockito_25,/home/common/huangzhili/defects4j_buggy/Mockito_25_buggy/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java,"    private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) {
        Class<?> clz = invocation.getMethod().getReturnType();
        final Object mock = org.mockito.Mockito.mock(clz, this);

        container.addAnswer(new Answer<Object>() {
            public Object answer(InvocationOnMock invocation) throws Throwable {
                return mock;
            }
        }, false);

        return mock;
    }
"
Mockito_30,/home/common/huangzhili/defects4j_buggy/Mockito_30_buggy/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java,"public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
            if (new ObjectMethodsGuru().isToString(method)) {
                 return ""SmartNull returned by unstubbed "" + formatMethodCall()  + "" method on mock"";
             }
 
             new Reporter().smartNullPointerException(location);
             return null;
         }"
Mockito_31,/home/common/huangzhili/defects4j_buggy/Mockito_31_buggy/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java,"        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
            if (new ObjectMethodsGuru().isToString(method)) {
                return ""SmartNull returned by unstubbed "" + formatMethodCall()  + "" method on mock"";
            }

            new Reporter().smartNullPointerException(location);
            return null;
        }
"
Mockito_32,/home/common/huangzhili/defects4j_buggy/Mockito_32_buggy/src/org/mockito/internal/configuration/SpyAnnotationEngine.java,"@SuppressWarnings(""deprecation"")
    public void process(Class<?> context, Object testClass) {
        Field[] fields = context.getDeclaredFields();
        for (Field field : fields) {
            if (field.isAnnotationPresent(Spy.class)) {
                assertNoAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);
                boolean wasAccessible = field.isAccessible();
                field.setAccessible(true);
                try {
                    Object instance = field.get(testClass);
                    if (instance == null) {
                        throw new MockitoException(""Cannot create a @Spy for '"" + field.getName() + ""' field because the *instance* is missing\n"" +
                        		  ""The instance must be created *before* initMocks();\n"" +
                                  ""Example of correct usage of @Spy:\n"" +
                            	  ""   @Spy List mock = new LinkedList();\n"" +
                            	  ""   //also, don't forget about MockitoAnnotations.initMocks();"");

                    }
                    if (new MockUtil().isMock(instance)) { 
                         // instance has been spied earlier
                         Mockito.reset(instance);
                     } else {
                         field.set(testClass, Mockito.spy(instance));
                     }
                 } catch (IllegalAccessException e) {
                     throw new MockitoException(""Problems initiating spied field "" + field.getName(), e);
                } finally {
                    field.setAccessible(wasAccessible);
                }
            }
        }
    }"
Mockito_35,/home/common/huangzhili/defects4j_buggy/Mockito_35_buggy/src/org/mockito/Matchers.java,"    public static <T> T same(T value) {
        return reportMatcher(new Same(value)).<T>returnNull();
    }
"
Mockito_35,/home/common/huangzhili/defects4j_buggy/Mockito_35_buggy/src/org/mockito/Matchers.java,"    public static <T> T eq(T value) {
        return reportMatcher(new Equals(value)).<T>returnNull();
    }  
"
Mockito_35,/home/common/huangzhili/defects4j_buggy/Mockito_35_buggy/src/org/mockito/Matchers.java,"    public static <T> T isA(Class<T> clazz) {
        return reportMatcher(new InstanceOf(clazz)).<T>returnNull();
    }
"
Mockito_36,/home/common/huangzhili/defects4j_buggy/Mockito_36_buggy/src/org/mockito/internal/invocation/Invocation.java,"    public Object[] getRawArguments() {
        return this.rawArguments;
    }
"
Mockito_37,/home/common/huangzhili/defects4j_buggy/Mockito_37_buggy/src/org/mockito/internal/stubbing/answers/AnswersValidator.java,"    public void validate(Answer<?> answer, Invocation invocation) {
        if (answer instanceof ThrowsException) {
            validateException((ThrowsException) answer, invocation);
        }
        
        if (answer instanceof Returns) {
            validateReturnValue((Returns) answer, invocation);
        }
        
        if (answer instanceof DoesNothing) {
            validateDoNothing((DoesNothing) answer, invocation);
        }
        
    }
"
Time_1,/home/common/huangzhili/defects4j_buggy/Time_1_buggy/src/main/java/org/joda/time/field/UnsupportedDurationField.java,"    public int compareTo(DurationField durationField) {
        if (durationField.isSupported()) {
            return 1;
        }
        return 0;
    }
"
Time_1,/home/common/huangzhili/defects4j_buggy/Time_1_buggy/src/main/java/org/joda/time/Partial.java,"    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
        super();
        chronology = DateTimeUtils.getChronology(chronology).withUTC();
        iChronology = chronology;
        if (types == null) {
            throw new IllegalArgumentException(""Types array must not be null"");
        }
        if (values == null) {
            throw new IllegalArgumentException(""Values array must not be null"");
        }
        if (values.length != types.length) {
            throw new IllegalArgumentException(""Values array must be the same length as the types array"");
        }
        if (types.length == 0) {
            iTypes = types;
            iValues = values;
            return;
        }
        for (int i = 0; i < types.length; i++) {
            if (types[i] == null) {
                throw new IllegalArgumentException(""Types array must not contain null: index "" + i);
            }
        }
        DurationField lastUnitField = null;
        for (int i = 0; i < types.length; i++) {
            DateTimeFieldType loopType = types[i];
            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
            if (i > 0) {
                int compare = lastUnitField.compareTo(loopUnitField);
                if (compare < 0) {
                    throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                            types[i - 1].getName() + "" < "" + loopType.getName());
                } else if (compare == 0) {
                    if (types[i - 1].getRangeDurationType() == null) {
                        if (loopType.getRangeDurationType() == null) {
                            throw new IllegalArgumentException(""Types array must not contain duplicate: "" +
                                            types[i - 1].getName() + "" and "" + loopType.getName());
                        }
                    } else {
                        if (loopType.getRangeDurationType() == null) {
                            throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                                    types[i - 1].getName() + "" < "" + loopType.getName());
                        }
                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                        if (lastRangeField.compareTo(loopRangeField) < 0) {
                            throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                                    types[i - 1].getName() + "" < "" + loopType.getName());
                        }
                        if (lastRangeField.compareTo(loopRangeField) == 0) {
                            throw new IllegalArgumentException(""Types array must not contain duplicate: "" +
                                            types[i - 1].getName() + "" and "" + loopType.getName());
                        }
                    }
                }
            }
            lastUnitField = loopUnitField;
        }
        
        iTypes = (DateTimeFieldType[]) types.clone();
        chronology.validate(this, values);
        iValues = (int[]) values.clone();
    }
"
Time_2,/home/common/huangzhili/defects4j_buggy/Time_2_buggy/src/main/java/org/joda/time/Partial.java,"public Partial with(DateTimeFieldType fieldType, int value) {
        if (fieldType == null) {
            throw new IllegalArgumentException(""The field type must not be null"");
        }
        int index = indexOf(fieldType);
        if (index == -1) {
            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
            int[] newValues = new int[newTypes.length];
            
            // find correct insertion point to keep largest-smallest order
            int i = 0;
            DurationField unitField = fieldType.getDurationType().getField(iChronology);
            if (unitField.isSupported()) {
                for (; i < iTypes.length; i++) {
                    DateTimeFieldType loopType = iTypes[i];
                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
                    if (loopUnitField.isSupported()) {
                        int compare = unitField.compareTo(loopUnitField);
                         if (compare > 0) {
                             break;
                         } else if (compare == 0) {
                             DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                             DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                             if (rangeField.compareTo(loopRangeField) > 0) {
                                break;
                            }
                        }
                    }
                }
            }
            System.arraycopy(iTypes, 0, newTypes, 0, i);
            System.arraycopy(iValues, 0, newValues, 0, i);
            newTypes[i] = fieldType;
            newValues[i] = value;
            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
            // use public constructor to ensure full validation
            // this isn't overly efficient, but is safe
            Partial newPartial = new Partial(newTypes, newValues, iChronology);
            iChronology.validate(newPartial, newValues);
            return newPartial;
        }
        if (value == getValue(index)) {
            return this;
        }
        int[] newValues = getValues();
        newValues = getField(index).set(this, index, newValues, value);
        return new Partial(this, newValues);
    }"
Time_3,/home/common/huangzhili/defects4j_buggy/Time_3_buggy/src/main/java/org/joda/time/MutableDateTime.java,"public void add(DurationFieldType type, int amount) {
         if (type == null) {
             throw new IllegalArgumentException(""Field must not be null"");
         }
             setMillis(type.getField(getChronology()).add(getMillis(), amount));
     }"
Time_6,/home/common/huangzhili/defects4j_buggy/Time_6_buggy/src/main/java/org/joda/time/chrono/GJChronology.java,"public static synchronized GJChronology getInstance(
            DateTimeZone zone,
            ReadableInstant gregorianCutover,
            int minDaysInFirstWeek) {
        
        zone = DateTimeUtils.getZone(zone);
        Instant cutoverInstant;
        if (gregorianCutover == null) {
             cutoverInstant = DEFAULT_CUTOVER;
         } else {
             cutoverInstant = gregorianCutover.toInstant();
         }
 
         GJChronology chrono;
        synchronized (cCache) {
            ArrayList<GJChronology> chronos = cCache.get(zone);
            if (chronos == null) {
                chronos = new ArrayList<GJChronology>(2);
                cCache.put(zone, chronos);
            } else {
                for (int i = chronos.size(); --i >= 0;) {
                    chrono = chronos.get(i);
                    if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&
                        cutoverInstant.equals(chrono.getGregorianCutover())) {
                        
                        return chrono;
                    }
                }
            }
            if (zone == DateTimeZone.UTC) {
                chrono = new GJChronology
                    (JulianChronology.getInstance(zone, minDaysInFirstWeek),
                     GregorianChronology.getInstance(zone, minDaysInFirstWeek),
                     cutoverInstant);
            } else {
                chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);
                chrono = new GJChronology
                    (ZonedChronology.getInstance(chrono, zone),
                     chrono.iJulianChronology,
                     chrono.iGregorianChronology,
                     chrono.iCutoverInstant);
            }
            chronos.add(chrono);
        }
        return chrono;
    }"
Time_6,/home/common/huangzhili/defects4j_buggy/Time_6_buggy/src/main/java/org/joda/time/chrono/GJChronology.java,"ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,
                              DurationField durationField,
                              long cutoverMillis, boolean convertByWeekyear)
        {
            super(julianField, gregorianField, cutoverMillis, convertByWeekyear);
            if (durationField == null) {
                durationField = new LinkedDurationField(iDurationField, this);
            }
            iDurationField = durationField;
        }

        public long add(long instant, int value) {
            if (instant >= iCutover) {
                instant = iGregorianField.add(instant, value);
                 if (instant < iCutover) {
                     // Only adjust if gap fully crossed.
                     if (instant + iGapDuration < iCutover) {
                         instant = gregorianToJulian(instant);
                     }
                 }
            } else {"
Time_6,/home/common/huangzhili/defects4j_buggy/Time_6_buggy/src/main/java/org/joda/time/chrono/GJChronology.java,"instant = gregorianToJulian(instant);
                     }
                 }
            } else {
                instant = iJulianField.add(instant, value);
                if (instant >= iCutover) {
                    // Only adjust if gap fully crossed.
                    if (instant - iGapDuration >= iCutover) {
                        // no special handling for year zero as cutover always after year zero
                        instant = julianToGregorian(instant);
                    }
                }
            }
            return instant;
        }
        
        public long add(long instant, long value) {
            if (instant >= iCutover) {
                instant = iGregorianField.add(instant, value);
                 if (instant < iCutover) {
                     // Only adjust if gap fully crossed.
                     if (instant + iGapDuration < iCutover) {"
Time_9,/home/common/huangzhili/defects4j_buggy/Time_9_buggy/src/main/java/org/joda/time/DateTimeZone.java,"public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
         if (hoursOffset == 0 && minutesOffset == 0) {
             return DateTimeZone.UTC;
         }
         if (minutesOffset < 0 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
         int offset = 0;
         try {
             int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);
             if (hoursInMinutes < 0) {
                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);
             } else {
                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);
             }
             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
         } catch (ArithmeticException ex) {
            throw new IllegalArgumentException(""Offset is too large"");
        }
        return forOffsetMillis(offset);
    }"
Time_10,/home/common/huangzhili/defects4j_buggy/Time_10_buggy/src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java,"protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {
        if (start == null || end == null) {
            throw new IllegalArgumentException(""ReadablePartial objects must not be null"");
        }
        if (start.size() != end.size()) {
            throw new IllegalArgumentException(""ReadablePartial objects must have the same set of fields"");
        }
        for (int i = 0, isize = start.size(); i < isize; i++) {
            if (start.getFieldType(i) != end.getFieldType(i)) {
                throw new IllegalArgumentException(""ReadablePartial objects must have the same set of fields"");
            }
        }
        if (DateTimeUtils.isContiguous(start) == false) {
             throw new IllegalArgumentException(""ReadablePartial objects must be contiguous"");
         }
         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();
         int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));
         return values[0];
     }"
Time_12,/home/common/huangzhili/defects4j_buggy/Time_12_buggy/src/main/java/org/joda/time/LocalDateTime.java,"@SuppressWarnings(""deprecation"")
    public static LocalDateTime fromDateFields(Date date) {
         if (date == null) {
             throw new IllegalArgumentException(""The date must not be null"");
         }
             // handle years in era BC
         return new LocalDateTime(
             date.getYear() + 1900,
             date.getMonth() + 1,
            date.getDate(),
            date.getHours(),
            date.getMinutes(),
            date.getSeconds(),
            (((int) (date.getTime() % 1000)) + 1000) % 1000
        );
    }"
Time_12,/home/common/huangzhili/defects4j_buggy/Time_12_buggy/src/main/java/org/joda/time/LocalDateTime.java,"public static LocalDateTime fromCalendarFields(Calendar calendar) {
         if (calendar == null) {
             throw new IllegalArgumentException(""The calendar must not be null"");
         }
         int yearOfEra = calendar.get(Calendar.YEAR);
         return new LocalDateTime(
             yearOfEra,
             calendar.get(Calendar.MONTH) + 1,
             calendar.get(Calendar.DAY_OF_MONTH),
             calendar.get(Calendar.HOUR_OF_DAY),
            calendar.get(Calendar.MINUTE),
            calendar.get(Calendar.SECOND),
            calendar.get(Calendar.MILLISECOND)
        );
    }"
Time_12,/home/common/huangzhili/defects4j_buggy/Time_12_buggy/src/main/java/org/joda/time/LocalDate.java,"@SuppressWarnings(""deprecation"")
    public static LocalDate fromDateFields(Date date) {
         if (date == null) {
             throw new IllegalArgumentException(""The date must not be null"");
         }
             // handle years in era BC
         return new LocalDate(
             date.getYear() + 1900,
             date.getMonth() + 1,
            date.getDate()
        );
    }"
Time_12,/home/common/huangzhili/defects4j_buggy/Time_12_buggy/src/main/java/org/joda/time/LocalDate.java,"public static LocalDate fromCalendarFields(Calendar calendar) {
         if (calendar == null) {
             throw new IllegalArgumentException(""The calendar must not be null"");
         }
         int yearOfEra = calendar.get(Calendar.YEAR);
         return new LocalDate(
             yearOfEra,
             calendar.get(Calendar.MONTH) + 1,
             calendar.get(Calendar.DAY_OF_MONTH)
         );
    }"
Time_13,/home/common/huangzhili/defects4j_buggy/Time_13_buggy/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java,"public int calculatePrintedLength(ReadablePeriod period, Locale locale) {
            long valueLong = getFieldValue(period);
            if (valueLong == Long.MAX_VALUE) {
                return 0;
            }

            int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);
             if (iFieldType >= SECONDS_MILLIS) {
                 // valueLong contains the seconds and millis fields
                 // the minimum output is 0.000, which is 4 or 5 digits with a negative
                 sum = Math.max(sum, 4);
                 // plus one for the decimal point
                 sum++;
                 if (iFieldType == SECONDS_OPTIONAL_MILLIS &&
                        (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {
                    sum -= 4; // remove three digits and decimal point
                }
                // reset valueLong to refer to the seconds part for the prefic/suffix calculation
                valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND;
            }
            int value = (int) valueLong;

            if (iPrefix != null) {
                sum += iPrefix.calculatePrintedLength(value);
            }
            if (iSuffix != null) {
                sum += iSuffix.calculatePrintedLength(value);
            }

            return sum;
        }"
Time_13,/home/common/huangzhili/defects4j_buggy/Time_13_buggy/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java,"public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {
            long valueLong = getFieldValue(period);
            if (valueLong == Long.MAX_VALUE) {
                return;
            }
            int value = (int) valueLong;
            if (iFieldType >= SECONDS_MILLIS) {
                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);
            }

             if (iPrefix != null) {
                 iPrefix.printTo(buf, value);
             }
             int minDigits = iMinPrintedDigits;
             if (minDigits <= 1) {
                 FormatUtils.appendUnpaddedInteger(buf, value);
            } else {
                FormatUtils.appendPaddedInteger(buf, value, minDigits);
            }
            if (iFieldType >= SECONDS_MILLIS) {
                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);
                if (iFieldType == SECONDS_MILLIS || dp > 0) {
                    buf.append('.');
                    FormatUtils.appendPaddedInteger(buf, dp, 3);
                }
            }
            if (iSuffix != null) {
                iSuffix.printTo(buf, value);
            }
        }"
Time_26,/home/common/huangzhili/defects4j_buggy/Time_26_buggy/src/main/java/org/joda/time/chrono/ZonedChronology.java,"public long roundCeiling(long instant) {
            if (iTimeField) {
                int offset = getOffsetToAdd(instant);
                instant = iField.roundCeiling(instant + offset);
                return instant - offset;
             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.roundCeiling(localInstant);
                 return iZone.convertLocalToUTC(localInstant, false);
             }
         }"
Time_26,/home/common/huangzhili/defects4j_buggy/Time_26_buggy/src/main/java/org/joda/time/chrono/ZonedChronology.java,"public long roundFloor(long instant) {
            if (iTimeField) {
                int offset = getOffsetToAdd(instant);
                instant = iField.roundFloor(instant + offset);
                return instant - offset;
             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.roundFloor(localInstant);
                 return iZone.convertLocalToUTC(localInstant, false);
             }
         }"
Time_26,/home/common/huangzhili/defects4j_buggy/Time_26_buggy/src/main/java/org/joda/time/field/LenientDateTimeField.java,"public long set(long instant, int value) {
        // lenient needs to handle time zone chronologies
        // so we do the calculation using local milliseconds
         long localInstant = iBase.getZone().convertUTCToLocal(instant);
         long difference = FieldUtils.safeSubtract(value, get(instant));
         localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);
         return iBase.getZone().convertLocalToUTC(localInstant, false);
     }"
Time_26,/home/common/huangzhili/defects4j_buggy/Time_26_buggy/src/main/java/org/joda/time/chrono/ZonedChronology.java,"public long add(long instant, long value) {
            if (iTimeField) {
                int offset = getOffsetToAdd(instant);
                long localInstant = iField.add(instant + offset, value);
                return localInstant - offset;
             } else {
                long localInstant = iZone.convertUTCToLocal(instant);
                localInstant = iField.add(localInstant, value);
                return iZone.convertLocalToUTC(localInstant, false);
             }"
Time_26,/home/common/huangzhili/defects4j_buggy/Time_26_buggy/src/main/java/org/joda/time/chrono/ZonedChronology.java,"public long add(long instant, int value) {
            if (iTimeField) {
                int offset = getOffsetToAdd(instant);
                long localInstant = iField.add(instant + offset, value);
                return localInstant - offset;
             } else {
                long localInstant = iZone.convertUTCToLocal(instant);
                localInstant = iField.add(localInstant, value);
                return iZone.convertLocalToUTC(localInstant, false);
             }
         }"
Time_26,/home/common/huangzhili/defects4j_buggy/Time_26_buggy/src/main/java/org/joda/time/chrono/ZonedChronology.java,"public long set(long instant, String text, Locale locale) {
             // cannot verify that new value stuck because set may be lenient
             long localInstant = iZone.convertUTCToLocal(instant);
             localInstant = iField.set(localInstant, text, locale);
             return iZone.convertLocalToUTC(localInstant, false);
         }"
