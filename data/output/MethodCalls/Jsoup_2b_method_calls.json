[
  {
    "method": "org.jsoup.nodes.Element.appendChild",
    "doc": "/**\n     * Add a node to the last child of this element.\n     *\n     * @param child node to add. Must not already have a parent.\n     * @return this element, so that you can add more child nodes or elements.\n     */",
    "code": "public Element appendChild(Node child) {\n        Validate.notNull(child);\n\n        child.setParentNode(this);\n        childNodes.add(child);\n        return this;\n    }"
  },
  {
    "method": "org.jsoup.nodes.Element.tagName",
    "doc": "/**\n     * Get the name of the tag for this element. E.g. {@code div}\n     *\n     * @return the tag name\n     */",
    "code": "public String tagName() {\n        return tag.getName();\n    }"
  },
  {
    "method": "org.jsoup.parser.Parser.addChildToParent",
    "doc": "/**\n     Parse a fragment of HTML into the {@code body} of a Document.\n     @param bodyHtml fragment of HTML\n     @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n     @return Document, with empty head, and HTML parsed into body\n     */",
    "code": "private Element addChildToParent(Element child, boolean isEmptyElement) {\n        Element parent = popStackToSuitableContainer(child.tag());\n        Tag childTag = child.tag();\n        boolean validAncestor = stackHasValidParent(childTag);\n\n        if (!validAncestor) {\n            Tag parentTag = childTag.getImplicitParent();\n            Element implicit = new Element(parentTag, baseUri);\n            if (child.tag().equals(bodyTag)) {\n                Element head = new Element(headTag, baseUri);\n                implicit.appendChild(head);\n            }\n            implicit.appendChild(child);\n\n            Element root = addChildToParent(implicit, false);\n            if (!isEmptyElement)\n                stack.addLast(child);\n            return root;\n        }\n\n        parent.appendChild(child);\n\n        if (!isEmptyElement)\n            stack.addLast(child);\n        return parent;\n    }"
  },
  {
    "method": "org.jsoup.parser.Tag.equals",
    "doc": "/**\n     Get if this tag should preserve whitespace within child text nodes.\n     @return if preserve whitepace\n     */",
    "code": "public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Tag tag = (Tag) o;\n\n        if (canContainBlock != tag.canContainBlock) return false;\n        if (canContainInline != tag.canContainInline) return false;\n        if (empty != tag.empty) return false;\n        if (isBlock != tag.isBlock) return false;\n        if (optionalClosing != tag.optionalClosing) return false;\n        if (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) return false;\n\n        return true;\n    }"
  },
  {
    "method": "org.jsoup.parser.Tag.isData",
    "doc": "/**\n     Gets if this tag is a data only tag.\n     @return if this tag is a data only tag\n     */",
    "code": "public boolean isData() {\n        return !canContainInline && !isEmpty();\n    }"
  },
  {
    "method": "org.jsoup.parser.Tag.isEmpty",
    "doc": "/**\n     Get if this is an empty tag\n     @return if this is an emtpy tag\n     */",
    "code": "public boolean isEmpty() {\n        return empty;\n    }"
  },
  {
    "method": "org.jsoup.parser.Tag.valueOf",
    "doc": "/**\n     Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.\n     <p>\n     Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().\n     @param tagName Name of tag, e.g. \"p\". Case insensitive.\n     @return The tag, either defined or new generic.\n     */",
    "code": "public static Tag valueOf(String tagName) {\n        Validate.notNull(tagName);\n        tagName = tagName.trim().toLowerCase();\n        Validate.notEmpty(tagName);\n\n        synchronized (tags) {\n            Tag tag = tags.get(tagName);\n            if (tag == null) {\n                tag = new Tag(tagName);\n                tag.setAncestor(defaultAncestor.tagName);\n                tag.isBlock = false;\n                tag.canContainBlock = true;\n            }\n            return tag;\n        }\n    }"
  },
  {
    "method": "org.jsoup.parser.TokenQueue.chompTo",
    "doc": "/**\n     * Pulls a string off the queue (like consumeTo), and then pulls off the matched string (but does not return it).\n     * <p>\n     * If the queue runs out of characters before finding the seq, will return as much as it can (and queue will go\n     * isEmpty() == true).\n     * @param seq String to match up to, and not include in return, and to pull off queue\n     * @return Data matched from queue.\n     */",
    "code": "public String chompTo(String seq) {\n        String data = consumeTo(seq);\n        matchChomp(seq);\n        return data;\n    }"
  },
  {
    "method": "org.jsoup.parser.TokenQueue.consume",
    "doc": "/**\n     * Consume one character off queue.\n     * @return first character on queue.\n     */",
    "code": "public Character consume() {\n        return queue.removeFirst();\n    }"
  },
  {
    "method": "org.jsoup.parser.TokenQueue.consumeWord",
    "doc": "/**\n     * Retrieves the next run of word type (letter or digit) off the queue.\n     * @return String of word characters from queue, or empty string if none.\n     */",
    "code": "public String consumeWord() {\n        StringBuilder wordAccum = new StringBuilder();\n        while (!queue.isEmpty() && Character.isLetterOrDigit(queue.peek())) {\n            wordAccum.append(queue.removeFirst());\n        }\n        return wordAccum.toString();\n    }"
  },
  {
    "method": "org.jsoup.parser.TokenQueue.matchChomp",
    "doc": "/**\n     * Tests if the queue matches the sequence (as with match), and if they do, removes the matched string from the\n     * queue.\n     * @param seq String to search for, and if found, remove from queue.\n     * @return true if found and removed, false if not found.\n     */",
    "code": "public boolean matchChomp(String seq) {\n        if (matches(seq)) {\n            consume(seq);\n            return true;\n        } else {\n            return false;\n        }\n    }"
  },
  {
    "method": "org.jsoup.parser.TokenQueue.matchesAny",
    "doc": "/**\n     Tests if the next characters match any of the sequences.\n     @param seq\n     @return\n     */",
    "code": "public boolean matchesAny(String... seq) {\n        for (String s : seq) {\n            if (matches(s))\n                return true;\n        }\n        return false;\n    }"
  }
]