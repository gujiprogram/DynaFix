[
  {
    "method": "org.mockito.Mockito.spy",
    "doc": "/**\n     * Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.\n     * <p>\n     * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.\n     * <p>\n     * As usual you are going to read <b>the partial mock warning</b>:\n     * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.\n     * How does partial mock fit into this paradigm? Well, it just doesn't...\n     * Partial mock usually means that the complexity has been moved to a different method on the same object.\n     * In most cases, this is not the way you want to design your application.\n     * <p>\n     * However, there are rare cases when partial mocks come handy:\n     * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)\n     * However, I wouldn't use partial mocks for new, test-driven & well-designed code.\n     * <p>\n     * Example:\n     *\n     * <pre>\n     *   List list = new LinkedList();\n     *   List spy = spy(list);\n     *\n     *   //optionally, you can stub out some methods:\n     *   when(spy.size()).thenReturn(100);\n     *\n     *   //using the spy calls <b>real</b> methods\n     *   spy.add(\"one\");\n     *   spy.add(\"two\");\n     *\n     *   //prints \"one\" - the first element of a list\n     *   System.out.println(spy.get(0));\n     *\n     *   //size() method was stubbed - 100 is printed\n     *   System.out.println(spy.size());\n     *\n     *   //optionally, you can verify\n     *   verify(spy).add(\"one\");\n     *   verify(spy).add(\"two\");\n     * </pre>\n     *\n     * <h4>Important gotcha on spying real objects!</h4>\n     *\n     * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:\n     *\n     * <pre>\n     *   List list = new LinkedList();\n     *   List spy = spy(list);\n     *\n     *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)\n     *   when(spy.get(0)).thenReturn(\"foo\");\n     *\n     *   //You have to use doReturn() for stubbing\n     *   doReturn(\"foo\").when(spy).get(0);\n     * </pre>\n     *\n     * 2. Watch out for final methods.\n     * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.\n     * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.\n     * Typically you may get a NullPointerException because mock instances don't have fields initiated.\n     *\n     * <p>\n     * See examples in javadoc for {@link Mockito} class\n     *\n     * @param object\n     *            to spy on\n     * @return a spy of the real object\n     */",
    "code": "public static <T> T spy(T object) {\n        return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()\n                .spiedInstance(object)\n                .defaultAnswer(CALLS_REAL_METHODS));\n    }"
  },
  {
    "method": "org.mockito.internal.configuration.SpyAnnotationEngine.assertNoAnnotations",
    "doc": "[No documentation]",
    "code": "void assertNoAnnotations(Class annotation, Field field, Class ... undesiredAnnotations) {\n        for (Class u : undesiredAnnotations) {\n            if (field.isAnnotationPresent(u)) {\n                new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), annotation.getClass().getSimpleName());\n            }\n        }\n    }"
  },
  {
    "method": "org.mockito.internal.util.MockUtil.isMock",
    "doc": "[No documentation]",
    "code": "public boolean isMock(Object mock) {\n        return mock != null && isMockitoMock(mock);\n    }"
  }
]