slug,class_path,buggy_code
Chart_1b_1,/path/to/defects4j_buggy/Chart_1_buggy/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java,"public void setPlot(CategoryPlot plot) {
if (plot == null) {
throw new IllegalArgumentException(""Null 'plot' argument."");
}
this.plot = plot;
}"
Chart_3b_1,/path/to/defects4j_buggy/Chart_3_buggy/source/org/jfree/data/time/TimeSeries.java,"public TimeSeries createCopy(int start, int end)
throws CloneNotSupportedException {
if (start < 0) {
throw new IllegalArgumentException(""Requires start >= 0."");
}
if (end < start) {
throw new IllegalArgumentException(""Requires start <= end."");
}
TimeSeries copy = (TimeSeries) super.clone();
copy.data = new java.util.ArrayList();
if (this.data.size() > 0) {
for (int index = start; index <= end; index++) {
TimeSeriesDataItem item
= (TimeSeriesDataItem) this.data.get(index);
TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();
try {
copy.add(clone);
}
catch (SeriesException e) {
e.printStackTrace();
}
}
}
return copy;
}"
Chart_4b_1,/path/to/defects4j_buggy/Chart_4_buggy/source/org/jfree/chart/plot/XYPlot.java,"public Range getDataRange(ValueAxis axis) {

Range result = null;
List mappedDatasets = new ArrayList();
List includedAnnotations = new ArrayList();
boolean isDomainAxis = true;

// is it a domain axis?
int domainIndex = getDomainAxisIndex(axis);
if (domainIndex >= 0) {
isDomainAxis = true;
mappedDatasets.addAll(getDatasetsMappedToDomainAxis(
new Integer(domainIndex)));
if (domainIndex == 0) {
// grab the plot's annotations
Iterator iterator = this.annotations.iterator();
while (iterator.hasNext()) {
XYAnnotation annotation = (XYAnnotation) iterator.next();
if (annotation instanceof XYAnnotationBoundsInfo) {
includedAnnotations.add(annotation);
}
}
}
}

// or is it a range axis?
int rangeIndex = getRangeAxisIndex(axis);
if (rangeIndex >= 0) {
isDomainAxis = false;
mappedDatasets.addAll(getDatasetsMappedToRangeAxis(
new Integer(rangeIndex)));
if (rangeIndex == 0) {
Iterator iterator = this.annotations.iterator();
while (iterator.hasNext()) {
XYAnnotation annotation = (XYAnnotation) iterator.next();
if (annotation instanceof XYAnnotationBoundsInfo) {
includedAnnotations.add(annotation);
}
}
}
}

// iterate through the datasets that map to the axis and get the union
// of the ranges.
Iterator iterator = mappedDatasets.iterator();
while (iterator.hasNext()) {
XYDataset d = (XYDataset) iterator.next();
if (d != null) {
XYItemRenderer r = getRendererForDataset(d);
if (isDomainAxis) {
if (r != null) {
result = Range.combine(result, r.findDomainBounds(d));
}
else {
result = Range.combine(result,
DatasetUtilities.findDomainBounds(d));
}
}
else {
if (r != null) {
result = Range.combine(result, r.findRangeBounds(d));
}
else {
result = Range.combine(result,
DatasetUtilities.findRangeBounds(d));
}
}

Collection c = r.getAnnotations();
Iterator i = c.iterator();
while (i.hasNext()) {
XYAnnotation a = (XYAnnotation) i.next();
if (a instanceof XYAnnotationBoundsInfo) {
includedAnnotations.add(a);
}
}
}
}

Iterator it = includedAnnotations.iterator();
while (it.hasNext()) {
XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();
if (xyabi.getIncludeInDataBounds()) {
if (isDomainAxis) {
result = Range.combine(result, xyabi.getXRange());
}
else {
result = Range.combine(result, xyabi.getYRange());
}
}
}

return result;

}"
Chart_5b_1,/path/to/defects4j_buggy/Chart_5_buggy/source/org/jfree/data/xy/XYSeries.java,"return addOrUpdate(new Double(x), new Double(y));
}

/**
* Adds or updates an item in the series and sends a
* {@link SeriesChangeEvent} to all registered listeners.
*
* @param x  the x-value (<code>null</code> not permitted).
* @param y  the y-value (<code>null</code> permitted).
*
* @return A copy of the overwritten data item, or <code>null</code> if no
*         item was overwritten.
*/
public XYDataItem addOrUpdate(Number x, Number y) {"
Chart_6b_1,/path/to/defects4j_buggy/Chart_6_buggy/source/org/jfree/chart/util/ShapeList.java,"public ShapeList() {
super();
}"
Chart_7b_1,/path/to/defects4j_buggy/Chart_7_buggy/source/org/jfree/data/time/TimePeriodValues.java,"public int getMaxMiddleIndex() {
return this.maxMiddleIndex;
}"
Chart_8b_1,/path/to/defects4j_buggy/Chart_8_buggy/source/org/jfree/data/time/Week.java,"public Week(Date time, TimeZone zone) {
        // defer argument checking...
        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());
    }"
Chart_9b_1,/path/to/defects4j_buggy/Chart_9_buggy/source/org/jfree/data/time/TimeSeries.java,"public TimeSeries createCopy(int start, int end)
throws CloneNotSupportedException {

if (start < 0) {
throw new IllegalArgumentException(""Requires start >= 0."");
}
if (end < start) {
throw new IllegalArgumentException(""Requires start <= end."");
}
TimeSeries copy = (TimeSeries) super.clone();

copy.data = new java.util.ArrayList();
if (this.data.size() > 0) {
for (int index = start; index <= end; index++) {
TimeSeriesDataItem item
= (TimeSeriesDataItem) this.data.get(index);
TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();
try {
copy.add(clone);
}
catch (SeriesException e) {
e.printStackTrace();
}
}
}
return copy;
}"
Chart_10b_1,/path/to/defects4j_buggy/Chart_10_buggy/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java,"public StandardToolTipTagFragmentGenerator() {
super();
}"
Chart_11b_1,/path/to/defects4j_buggy/Chart_11_buggy/source/org/jfree/chart/util/ShapeUtilities.java,"public static boolean equal(GeneralPath p1, GeneralPath p2) {
if (p1 == null) {
return (p2 == null);
}
if (p2 == null) {
return false;
}
if (p1.getWindingRule() != p2.getWindingRule()) {
return false;
}
PathIterator iterator1 = p1.getPathIterator(null);
PathIterator iterator2 = p1.getPathIterator(null);
double[] d1 = new double[6];
double[] d2 = new double[6];
boolean done = iterator1.isDone() && iterator2.isDone();
while (!done) {
if (iterator1.isDone() != iterator2.isDone()) {
return false;
}
int seg1 = iterator1.currentSegment(d1);
int seg2 = iterator2.currentSegment(d2);
if (seg1 != seg2) {
return false;
}
if (!Arrays.equals(d1, d2)) {
return false;
}
iterator1.next();
iterator2.next();
done = iterator1.isDone() && iterator2.isDone();
}
return true;
}"
Chart_12b_1,/path/to/defects4j_buggy/Chart_12_buggy/source/org/jfree/chart/plot/MultiplePiePlot.java,"public CategoryDataset getDataset() {
return this.dataset;
}"
Chart_13b_1,/path/to/defects4j_buggy/Chart_13_buggy/source/org/jfree/chart/block/BorderArrangement.java,"public Size2D arrange(BlockContainer container,
Graphics2D g2,"
Chart_17b_1,/path/to/defects4j_buggy/Chart_17_buggy/source/org/jfree/data/time/TimeSeries.java,"public TimeSeries createCopy(int start, int end)
throws CloneNotSupportedException {

if (start < 0) {
throw new IllegalArgumentException(""Requires start >= 0."");
}
if (end < start) {
throw new IllegalArgumentException(""Requires start <= end."");
}
TimeSeries copy = (TimeSeries) super.clone();

copy.data = new java.util.ArrayList();
if (this.data.size() > 0) {
for (int index = start; index <= end; index++) {
TimeSeriesDataItem item
= (TimeSeriesDataItem) this.data.get(index);
TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();
try {
copy.add(clone);
}
catch (SeriesException e) {
e.printStackTrace();
}
}
}
return copy;
}"
Chart_20b_1,/path/to/defects4j_buggy/Chart_20_buggy/source/org/jfree/chart/plot/ValueMarker.java,"public ValueMarker(double value, Paint paint, Stroke stroke,
Paint outlinePaint, Stroke outlineStroke, float alpha) {
super(paint, stroke, paint, stroke, alpha);
this.value = value;
}"
Chart_24b_1,/path/to/defects4j_buggy/Chart_24_buggy/source/org/jfree/chart/renderer/GrayPaintScale.java,"public Paint getPaint(double value) {
double v = Math.max(value, this.lowerBound);
v = Math.min(v, this.upperBound);
int g = (int) ((value - this.lowerBound) / (this.upperBound
- this.lowerBound) * 255.0);
return new Color(g, g, g);
}"
Chart_26b_1,/path/to/defects4j_buggy/Chart_26_buggy/source/org/jfree/chart/axis/Axis.java,"public boolean isVisible() {
return this.visible;
}"
Closure_1b_1,/path/to/defects4j_buggy/Closure_1_buggy/src/com/google/javascript/jscomp/RemoveUnusedVars.java,"private void removeUnreferencedFunctionArgs(Scope fnScope) {
// Notice that removing unreferenced function args breaks
// Function.prototype.length. In advanced mode, we don't really care
// about this: we consider ""length"" the equivalent of reflecting on
// the function's lexical source.
//
// Rather than create a new option for this, we assume that if the user
// is removing globals, then it's OK to remove unused function args.
//
// See http://code.google.com/p/closure-compiler/issues/detail?id=253

Node function = fnScope.getRootNode();

Preconditions.checkState(function.isFunction());
if (NodeUtil.isGetOrSetKey(function.getParent())) {
// The parameters object literal setters can not be removed.
return;
}

Node argList = getFunctionArgList(function);
boolean modifyCallers = modifyCallSites
&& callSiteOptimizer.canModifyCallers(function);
if (!modifyCallers) {
// Strip unreferenced args off the end of the function declaration.
Node lastArg;
while ((lastArg = argList.getLastChild()) != null) {
Var var = fnScope.getVar(lastArg.getString());
if (!referenced.contains(var)) {
argList.removeChild(lastArg);
compiler.reportCodeChange();
} else {
break;
}
}
} else {
callSiteOptimizer.optimize(fnScope, referenced);
}
}"
Closure_2b_1,/path/to/defects4j_buggy/Closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"private void checkInterfaceConflictProperties(NodeTraversal t, Node n,
String functionName, HashMap<String, ObjectType> properties,"
Closure_4b_1,/path/to/defects4j_buggy/Closure_4_buggy/src/com/google/javascript/rhino/jstype/NamedType.java,"private void setReferencedAndResolvedType(JSType type, ErrorReporter t,
StaticScope<JSType> enclosing) {
if (validator != null) {
validator.apply(type);
}
setReferencedType(type);
checkEnumElementCycle(t);
setResolvedTypeInternal(getReferencedType());
}"
Closure_5b_1,/path/to/defects4j_buggy/Closure_5_buggy/src/com/google/javascript/jscomp/InlineObjectLiterals.java,"InlineObjectLiterals(
AbstractCompiler compiler,"
Closure_7b_1,/path/to/defects4j_buggy/Closure_7_buggy/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java,"JSType getRestrictedByTypeOfResult(JSType type, String value,
boolean resultEqualsValue) {
if (type == null) {
if (resultEqualsValue) {
JSType result = getNativeTypeForTypeOf(value);
return result == null ? getNativeType(CHECKED_UNKNOWN_TYPE) : result;
} else {
return null;
}
}
return type.visit(
new RestrictByOneTypeOfResultVisitor(value, resultEqualsValue));
}"
Closure_10b_1,/path/to/defects4j_buggy/Closure_10_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static boolean allResultsMatch(Node n, Predicate<Node> p) {
switch (n.getType()) {
case Token.ASSIGN:
case Token.COMMA:
return allResultsMatch(n.getLastChild(), p);
case Token.AND:
case Token.OR:
return allResultsMatch(n.getFirstChild(), p)
&& allResultsMatch(n.getLastChild(), p);
case Token.HOOK:
return allResultsMatch(n.getFirstChild().getNext(), p)
&& allResultsMatch(n.getLastChild(), p);
default:
return p.apply(n);
}
}"
Closure_11b_1,/path/to/defects4j_buggy/Closure_11_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"private void visitAssign(NodeTraversal t, Node assign) {
JSDocInfo info = assign.getJSDocInfo();
Node lvalue = assign.getFirstChild();
Node rvalue = assign.getLastChild();

// Check property sets to 'object.property' when 'object' is known.
if (lvalue.isGetProp()) {
Node object = lvalue.getFirstChild();
JSType objectJsType = getJSType(object);
String property = lvalue.getLastChild().getString();

// the first name in this getprop refers to an interface
// we perform checks in addition to the ones below
if (object.isGetProp()) {
JSType jsType = getJSType(object.getFirstChild());
if (jsType.isInterface() &&
object.getLastChild().getString().equals(""prototype"")) {
visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);
}
}

checkEnumAlias(t, info, rvalue);

// Prototype assignments are special, because they actually affect
// the definition of a class. These are mostly validated
// during TypedScopeCreator, and we only look for the ""dumb"" cases here.
// object.prototype = ...;
if (property.equals(""prototype"")) {
if (objectJsType != null && objectJsType.isFunctionType()) {
FunctionType functionType = objectJsType.toMaybeFunctionType();
if (functionType.isConstructor()) {
JSType rvalueType = rvalue.getJSType();
validator.expectObject(t, rvalue, rvalueType,
OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);
return;
}
}
}

// The generic checks for 'object.property' when 'object' is known,
// and 'property' is declared on it.
// object.property = ...;
ObjectType type = ObjectType.cast(
objectJsType.restrictByNotNullOrUndefined());
if (type != null) {
if (type.hasProperty(property) &&
!type.isPropertyTypeInferred(property) &&
!propertyIsImplicitCast(type, property)) {
JSType expectedType = type.getPropertyType(property);
if (!expectedType.isUnknownType()) {
validator.expectCanAssignToPropertyOf(
t, assign, getJSType(rvalue),
expectedType, object, property);
checkPropertyInheritanceOnGetpropAssign(
t, assign, object, property, info, expectedType);
return;
}
}
}

// If we couldn't get the property type with normal object property
// lookups, then check inheritance anyway with the unknown type.
checkPropertyInheritanceOnGetpropAssign(
t, assign, object, property, info, getNativeType(UNKNOWN_TYPE));
}

// Check qualified name sets to 'object' and 'object.property'.
// This can sometimes handle cases when the type of 'object' is not known.
// e.g.,
// var obj = createUnknownType();
// /** @type {number} */ obj.foo = true;
JSType leftType = getJSType(lvalue);
if (lvalue.isQualifiedName()) {
// variable with inferred type case
JSType rvalueType = getJSType(assign.getLastChild());
Var var = t.getScope().getVar(lvalue.getQualifiedName());
if (var != null) {
if (var.isTypeInferred()) {
return;
}

if (NodeUtil.getRootOfQualifiedName(lvalue).isThis() &&
t.getScope() != var.getScope()) {
// Don't look at ""this.foo"" variables from other scopes.
return;
}

if (var.getType() != null) {
leftType = var.getType();
}
}
}

// Fall through case for arbitrary LHS and arbitrary RHS.
Node rightChild = assign.getLastChild();
JSType rightType = getJSType(rightChild);
if (validator.expectCanAssignTo(
t, assign, rightType, leftType, ""assignment"")) {
ensureTyped(t, assign, rightType);
} else {
ensureTyped(t, assign);
}
}"
Closure_12b_1,/path/to/defects4j_buggy/Closure_12_buggy/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java,"Collection<Node> getUses(String name, Node defNode) {
GraphNode<Node, Branch> n = getCfg().getNode(defNode);
Preconditions.checkNotNull(n);
FlowState<ReachingUses> state = n.getAnnotation();
return state.getOut().mayUseMap.get(jsScope.getVar(name));
}"
Closure_13b_1,/path/to/defects4j_buggy/Closure_13_buggy/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java,"private void traverse(Node node) {
// The goal here is to avoid retraversing
// the entire AST to catch newly created opportunities.
// So we track whether a ""unit of code"" has changed,
// and revisit immediately.
if (!shouldVisit(node)) {
return;
}

int visits = 0;
do {
Node c = node.getFirstChild();
while(c != null) {
traverse(c);
Node next = c.getNext();
c = next;
}

visit(node);
visits++;

Preconditions.checkState(visits < 10000, ""too many interations"");
} while (shouldRetraverse(node));

exitNode(node);
}"
Closure_14b_1,/path/to/defects4j_buggy/Closure_14_buggy/src/com/google/javascript/jscomp/ControlFlowAnalysis.java,"return computeFollowNode(node, node, cfa);
}

static Node computeFollowNode(Node node) {"
Closure_15b_1,/path/to/defects4j_buggy/Closure_15_buggy/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java,"public void enterScope(NodeTraversal t) {

if (t.inGlobalScope()) {
return; // Don't even brother. All global variables are likely escaped.
}

if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <
t.getScope().getVarCount()) {
return;
}

// Compute the forward reaching definition.
ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);
// Process the body of the function.
Preconditions.checkState(t.getScopeRoot().isFunction());
cfa.process(null, t.getScopeRoot().getLastChild());
cfg = cfa.getCfg();
reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);
reachingDef.analyze();
candidates = Lists.newLinkedList();

// Using the forward reaching definition search to find all the inline
// candidates
new NodeTraversal(compiler, new GatherCandiates()).traverse(
t.getScopeRoot().getLastChild());

// Compute the backward reaching use. The CFG can be reused.
reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);
reachingUses.analyze();
for (Candidate c : candidates) {
if (c.canInline()) {
c.inlineVariable();
}
}
}"
Closure_17b_1,/path/to/defects4j_buggy/Closure_17_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"public Scope createScope(Node root, Scope parent) {
// Constructing the global scope is very different than constructing
// inner scopes, because only global scopes can contain named classes that
// show up in the type registry.
Scope newScope = null;
AbstractScopeBuilder scopeBuilder = null;
if (parent == null) {
// Run a first-order analysis over the syntax tree.
(new FirstOrderFunctionAnalyzer(compiler, functionAnalysisResults))
.process(root.getFirstChild(), root.getLastChild());

// Find all the classes in the global scope.
newScope = createInitialScope(root);

GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);
scopeBuilder = globalScopeBuilder;
NodeTraversal.traverse(compiler, root, scopeBuilder);
} else {
newScope = new Scope(parent, root);
LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);
scopeBuilder = localScopeBuilder;
localScopeBuilder.build();
}

scopeBuilder.resolveStubDeclarations();
scopeBuilder.resolveTypes();

// Gather the properties in each function that we found in the
// global scope, if that function has a @this type that we can
// build properties on.
for (Node functionNode : scopeBuilder.nonExternFunctions) {
JSType type = functionNode.getJSType();
if (type != null && type.isFunctionType()) {
FunctionType fnType = type.toMaybeFunctionType();
ObjectType fnThisType = fnType.getTypeOfThis();
if (!fnThisType.isUnknownType()) {
NodeTraversal.traverse(compiler, functionNode.getLastChild(),
scopeBuilder.new CollectProperties(fnThisType));
}
}
}

if (parent == null) {
codingConvention.defineDelegateProxyPrototypeProperties(
typeRegistry, newScope, delegateProxyPrototypes,
delegateCallingConventions);
}
return newScope;
}"
Closure_18b_1,/path/to/defects4j_buggy/Closure_18_buggy/src/com/google/javascript/jscomp/Compiler.java,"public <T extends SourceFile> void initModules(
List<T> externs, List<JSModule> modules, CompilerOptions options) {
initOptions(options);

checkFirstModule(modules);
fillEmptyModules(modules);

this.externs = makeCompilerInput(externs, true);

// Generate the module graph, and report any errors in the module
// specification as errors.
this.modules = modules;
if (modules.size() > 1) {
try {
this.moduleGraph = new JSModuleGraph(modules);
} catch (JSModuleGraph.ModuleDependenceException e) {
// problems with the module format.  Report as an error.  The
// message gives all details.
report(JSError.make(MODULE_DEPENDENCY_ERROR,
e.getModule().getName(), e.getDependentModule().getName()));
return;
}
} else {
this.moduleGraph = null;
}

this.inputs = getAllInputsFromModules(modules);
initBasedOnOptions();

initInputsByIdMap();
}"
Closure_19b_1,/path/to/defects4j_buggy/Closure_19_buggy/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java,"protected void declareNameInScope(FlowScope scope, Node node, JSType type) {
switch (node.getType()) {
case Token.NAME:
scope.inferSlotType(node.getString(), type);
break;

case Token.GETPROP:
String qualifiedName = node.getQualifiedName();
Preconditions.checkNotNull(qualifiedName);

JSType origType = node.getJSType();
origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;
scope.inferQualifiedSlot(node, qualifiedName, origType, type);
break;

// ""this"" references aren't currently modeled in the CFG.

default:
throw new IllegalArgumentException(""Node cannot be refined. \n"" +
node.toStringTree());
}
}"
Closure_20b_1,/path/to/defects4j_buggy/Closure_20_buggy/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,"private Node tryFoldSimpleFunctionCall(Node n) {
Preconditions.checkState(n.isCall());
Node callTarget = n.getFirstChild();
if (callTarget != null && callTarget.isName() &&
callTarget.getString().equals(""String"")) {
// Fold String(a) to '' + (a) on immutable literals,
// which allows further optimizations
//
// We can't do this in the general case, because String(a) has
// slightly different semantics than '' + (a). See
// http://code.google.com/p/closure-compiler/issues/detail?id=759
Node value = callTarget.getNext();
if (value != null) {
Node addition = IR.add(
IR.string("""").srcref(callTarget),
value.detachFromParent());
n.getParent().replaceChild(n, addition);
reportCodeChange();
return addition;
}
}
return n;
}"
Closure_21b_1,/path/to/defects4j_buggy/Closure_21_buggy/src/com/google/javascript/jscomp/CheckSideEffects.java,"public void visit(NodeTraversal t, Node n, Node parent) {
// VOID nodes appear when there are extra semicolons at the BLOCK level.
// I've been unable to think of any cases where this indicates a bug,
// and apparently some people like keeping these semicolons around,
// so we'll allow it.
if (n.isEmpty() ||
n.isComma()) {
return;
}

if (parent == null) {
return;
}

// Do not try to remove a block or an expr result. We already handle
// these cases when we visit the child, and the peephole passes will
// fix up the tree in more clever ways when these are removed.
if (n.isExprResult()) {
return;
}

// This no-op statement was there so that JSDoc information could
// be attached to the name. This check should not complain about it.
if (n.isQualifiedName() && n.getJSDocInfo() != null) {
return;
}

boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
if (parent.getType() == Token.COMMA) {
if (isResultUsed) {
return;
}
if (n == parent.getLastChild()) {
for (Node an : parent.getAncestors()) {
int ancestorType = an.getType();
if (ancestorType == Token.COMMA) continue;
if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;
else break;
}
}
} else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
return;
}
}
if (
(isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
String msg = ""This code lacks side-effects. Is there a bug?"";
if (n.isString()) {
msg = ""Is there a missing '+' on the previous line?"";
} else if (isSimpleOp) {
msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
""' operator is not being used."";
}

t.getCompiler().report(
t.makeError(n, level, USELESS_CODE_ERROR, msg));
// TODO(johnlenz): determine if it is necessary to
// try to protect side-effect free statements as well.
if (!NodeUtil.isStatement(n)) {
problemNodes.add(n);
}
}
}"
Closure_22b_1,/path/to/defects4j_buggy/Closure_22_buggy/src/com/google/javascript/jscomp/CheckSideEffects.java,"public void visit(NodeTraversal t, Node n, Node parent) {
// VOID nodes appear when there are extra semicolons at the BLOCK level.
// I've been unable to think of any cases where this indicates a bug,
// and apparently some people like keeping these semicolons around,
// so we'll allow it.
if (n.isEmpty() ||
n.isComma()) {
return;
}

if (parent == null) {
return;
}

// Do not try to remove a block or an expr result. We already handle
// these cases when we visit the child, and the peephole passes will
// fix up the tree in more clever ways when these are removed.
if (parent.getType() == Token.COMMA) {
Node gramps = parent.getParent();
if (gramps.isCall() && parent == gramps.getFirstChild()) {
if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
return;
}
}

// This no-op statement was there so that JSDoc information could
// be attached to the name. This check should not complain about it.
if (n == parent.getLastChild()) {
for (Node an : parent.getAncestors()) {
int ancestorType = an.getType();
if (ancestorType == Token.COMMA)
continue;
if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)
return;
else
break;
}
}
} else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||
n == parent.getFirstChild().getNext().getNext())) {
} else {
return;
}
}

boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
if (!isResultUsed &&
(isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
if (n.isQualifiedName() && n.getJSDocInfo() != null) {
return;
} else if (n.isExprResult()) {
return;
}
String msg = ""This code lacks side-effects. Is there a bug?"";
if (n.isString()) {
msg = ""Is there a missing '+' on the previous line?"";
} else if (isSimpleOp) {
msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
""' operator is not being used."";
}

t.getCompiler().report(
t.makeError(n, level, USELESS_CODE_ERROR, msg));
// TODO(johnlenz): determine if it is necessary to
// try to protect side-effect free statements as well.
if (!NodeUtil.isStatement(n)) {
problemNodes.add(n);
}
}
}"
Closure_23b_1,/path/to/defects4j_buggy/Closure_23_buggy/src/com/google/javascript/jscomp/PeepholeFoldConstants.java,"private Node tryFoldArrayAccess(Node n, Node left, Node right) {
Node parent = n.getParent();
// If GETPROP/GETELEM is used as assignment target the array literal is
// acting as a temporary we can't fold it here:
//    ""[][0] += 1""
if (isAssignmentTarget(n)) {
return n;
}

if (!right.isNumber()) {
// Sometimes people like to use complex expressions to index into
// arrays, or strings to index into array methods.
return n;
}

double index = right.getDouble();
int intIndex = (int) index;
if (intIndex != index) {
error(INVALID_GETELEM_INDEX_ERROR, right);
return n;
}

if (intIndex < 0) {
error(INDEX_OUT_OF_BOUNDS_ERROR, right);
return n;
}

Node current = left.getFirstChild();
Node elem = null;
for (int i = 0; current != null && i < intIndex; i++) {
elem = current;

current = current.getNext();
}

if (elem == null) {
error(INDEX_OUT_OF_BOUNDS_ERROR, right);
return n;
}

if (elem.isEmpty()) {
elem = NodeUtil.newUndefinedNode(elem);
} else {
left.removeChild(elem);
}

// Replace the entire GETELEM with the value
n.getParent().replaceChild(n, elem);
reportCodeChange();
return elem;
}"
Closure_24b_1,/path/to/defects4j_buggy/Closure_24_buggy/src/com/google/javascript/jscomp/ScopedAliases.java,"public void hotSwapScript(Node root, Node originalRoot) {
Traversal traversal = new Traversal();
NodeTraversal.traverse(compiler, root, traversal);

if (!traversal.hasErrors()) {

// Apply the aliases.
for (AliasUsage aliasUsage : traversal.getAliasUsages()) {
aliasUsage.applyAlias();
}

// Remove the alias definitions.
for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) {
if (aliasDefinition.getParent().isVar() &&
aliasDefinition.getParent().hasOneChild()) {
aliasDefinition.getParent().detachFromParent();
} else {
aliasDefinition.detachFromParent();
}
}

// Collapse the scopes.
for (Node scopeCall : traversal.getScopeCalls()) {
Node expressionWithScopeCall = scopeCall.getParent();
Node scopeClosureBlock = scopeCall.getLastChild().getLastChild();
scopeClosureBlock.detachFromParent();
expressionWithScopeCall.getParent().replaceChild(
expressionWithScopeCall,
scopeClosureBlock);
NodeUtil.tryMergeBlock(scopeClosureBlock);
}

if (traversal.getAliasUsages().size() > 0 ||
traversal.getAliasDefinitionsInOrder().size() > 0 ||
traversal.getScopeCalls().size() > 0) {
compiler.reportCodeChange();
}
}
}"
Closure_25b_1,/path/to/defects4j_buggy/Closure_25_buggy/src/com/google/javascript/jscomp/TypeInference.java,"private FlowScope traverseNew(Node n, FlowScope scope) {

Node constructor = n.getFirstChild();
scope = traverse(constructor, scope);
JSType constructorType = constructor.getJSType();
JSType type = null;
if (constructorType != null) {
constructorType = constructorType.restrictByNotNullOrUndefined();
if (constructorType.isUnknownType()) {
type = getNativeType(UNKNOWN_TYPE);
} else {
FunctionType ct = constructorType.toMaybeFunctionType();
if (ct == null && constructorType instanceof FunctionType) {
// If constructorType is a NoObjectType, then toMaybeFunctionType will
// return null. But NoObjectType implements the FunctionType
// interface, precisely because it can validly construct objects.
ct = (FunctionType) constructorType;
}
if (ct != null && ct.isConstructor()) {
type = ct.getInstanceType();
}
}
}
n.setJSType(type);
for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
scope = traverse(arg, scope);
}
return scope;
}"
Closure_28b_1,/path/to/defects4j_buggy/Closure_28_buggy/src/com/google/javascript/jscomp/InlineCostEstimator.java,"return getCost(root, Integer.MAX_VALUE);
}

/**
* Determines the estimated size of the js snippet represented by the node.
*/
static int getCost(Node root, int costThreshhold) {"
Closure_29b_1,/path/to/defects4j_buggy/Closure_29_buggy/src/com/google/javascript/jscomp/InlineObjectLiterals.java,"InlineObjectLiterals(
AbstractCompiler compiler,"
Closure_31b_1,/path/to/defects4j_buggy/Closure_31_buggy/src/com/google/javascript/jscomp/Compiler.java,"Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
      externsRoot.detachChildren();
    }
    if (jsRoot != null) {
      jsRoot.detachChildren();
    }

    // Parse main js sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
      tracker = new PerformanceTracker(jsRoot, options.tracer);
      addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
      // Parse externs sources.
      for (CompilerInput input : externs) {
        Node n = input.getAstRoot(this);
        if (hasErrors()) {
          return null;
        }
        externsRoot.addChildToBack(n);
      }

      // Modules inferred in ProcessCommonJS pass.
      if (options.transformAMDToCJSModules || options.processCommonJSModules) {
        processAMDAndCommonJSModules();
      }

      // Check if inputs need to be rebuilt from modules.
      boolean staleInputs = false;

      // Check if the sources need to be re-ordered.
      if (options.dependencyOptions.needsManagement() &&
          !options.skipAllPasses &&
          options.closurePass) {
        for (CompilerInput input : inputs) {
          // Forward-declare all the provided types, so that they
          // are not flagged even if they are dropped from the process.
          for (String provide : input.getProvides()) {
            getTypeRegistry().forwardDeclareType(provide);
          }
        }

        try {
          inputs =
              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
              .manageDependencies(options.dependencyOptions, inputs);
          staleInputs = true;
        } catch (CircularDependencyException e) {
          report(JSError.make(
              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        } catch (MissingProvideException e) {
          report(JSError.make(
              MISSING_ENTRY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        }
      }

      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);

        // Inputs can have a null AST during initial parse.
        if (n == null) {
          continue;
        }

        if (n.getJSDocInfo() != null) {
          JSDocInfo info = n.getJSDocInfo();
          if (info.isExterns()) {
            // If the input file is explicitly marked as an externs file, then
            // assume the programmer made a mistake and throw it into
            // the externs pile anyways.
            externsRoot.addChildToBack(n);
            input.setIsExtern(true);

            input.getModule().remove(input);

            externs.add(input);
            staleInputs = true;
          } else if (info.isNoCompile()) {
            input.getModule().remove(input);
            staleInputs = true;
          }
        }
      }

      if (staleInputs) {
        fillEmptyModules(modules);
        rebuildInputsFromModules();
      }

      // Build the AST.
      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);
        if (n == null) {
          continue;
        }

        if (devMode) {
          runSanityCheck();
          if (hasErrors()) {
            return null;
          }
        }

        if (options.sourceMapOutputPath != null ||
            options.nameReferenceReportPath != null) {

          // Annotate the nodes in the tree with information from the
          // input file. This information is used to construct the SourceMap.
          SourceInformationAnnotator sia =
              new SourceInformationAnnotator(
                  input.getName(), options.devMode != DevMode.OFF);
          NodeTraversal.traverse(this, n, sia);
        }

        jsRoot.addChildToBack(n);
      }

      if (hasErrors()) {
        return null;
      }
      return externAndJsRoot;
    } finally {
      stopTracer(tracer, ""parseInputs"");
    }
  }"
Closure_32b_1,/path/to/defects4j_buggy/Closure_32_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,"boolean parse() {
int lineno;
int charno;

// JSTypes are represented as Rhino AST nodes, and then resolved later.
JSTypeExpression type;

state = State.SEARCHING_ANNOTATION;
skipEOLs();

JsDocToken token = next();

List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();

// Always record that we have a comment.
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo blockInfo = extractBlockComment(token);
token = blockInfo.token;
if (!blockInfo.string.isEmpty()) {
jsdocBuilder.recordBlockDescription(blockInfo.string);
}
} else {
if (token != JsDocToken.ANNOTATION &&
token != JsDocToken.EOC) {
// Mark that there was a description, but don't bother marking
// what it was.
jsdocBuilder.recordBlockDescription("""");
}
}

// Parse the actual JsDoc.
retry: for (;;) {
switch (token) {
case ANNOTATION:
if (state == State.SEARCHING_ANNOTATION) {
state = State.SEARCHING_NEWLINE;
lineno = stream.getLineno();
charno = stream.getCharno();

String annotationName = stream.getString();
Annotation annotation = annotationNames.get(annotationName);
if (annotation == null) {
parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName,
stream.getLineno(), stream.getCharno());
} else {
// Mark the beginning of the annotation.
jsdocBuilder.markAnnotation(annotationName, lineno, charno);

switch (annotation) {
case AUTHOR:
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo authorInfo = extractSingleLineBlock();
String author = authorInfo.string;

if (author.length() == 0) {
parser.addParserWarning(""msg.jsdoc.authormissing"",
stream.getLineno(), stream.getCharno());
} else {
jsdocBuilder.addAuthor(author);
}
token = authorInfo.token;
} else {
token = eatTokensUntilEOL(token);
}
continue retry;

case CONSISTENTIDGENERATOR:
if (!jsdocBuilder.recordConsistentIdGenerator()) {
parser.addParserWarning(""msg.jsdoc.consistidgen"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case CONSTANT:
if (!jsdocBuilder.recordConstancy()) {
parser.addParserWarning(""msg.jsdoc.const"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case CONSTRUCTOR:
if (!jsdocBuilder.recordConstructor()) {
if (jsdocBuilder.isInterfaceRecorded()) {
parser.addTypeWarning(""msg.jsdoc.interface.constructor"",
stream.getLineno(), stream.getCharno());
} else {
parser.addTypeWarning(""msg.jsdoc.incompat.type"",
stream.getLineno(), stream.getCharno());
}
}
token = eatTokensUntilEOL();
continue retry;

case DEPRECATED:
if (!jsdocBuilder.recordDeprecated()) {
parser.addParserWarning(""msg.jsdoc.deprecated"",
stream.getLineno(), stream.getCharno());
}

// Find the reason/description, if any.
ExtractionInfo reasonInfo =
extractMultilineTextualBlock(token);

String reason = reasonInfo.string;

if (reason.length() > 0) {
jsdocBuilder.recordDeprecationReason(reason);
}

token = reasonInfo.token;
continue retry;

case INTERFACE:
if (!jsdocBuilder.recordInterface()) {
if (jsdocBuilder.isConstructorRecorded()) {
parser.addTypeWarning(""msg.jsdoc.interface.constructor"",
stream.getLineno(), stream.getCharno());
} else {
parser.addTypeWarning(""msg.jsdoc.incompat.type"",
stream.getLineno(), stream.getCharno());
}
}
token = eatTokensUntilEOL();
continue retry;

case DESC:
if (jsdocBuilder.isDescriptionRecorded()) {
parser.addParserWarning(""msg.jsdoc.desc.extra"",
stream.getLineno(), stream.getCharno());
token = eatTokensUntilEOL();
continue retry;
} else {
ExtractionInfo descriptionInfo =
extractMultilineTextualBlock(token);

String description = descriptionInfo.string;

jsdocBuilder.recordDescription(description);
token = descriptionInfo.token;
continue retry;
}

case FILE_OVERVIEW:
String fileOverview = """";
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo fileOverviewInfo =
extractMultilineTextualBlock(token,
WhitespaceOption.TRIM);

fileOverview = fileOverviewInfo.string;

token = fileOverviewInfo.token;
} else {
token = eatTokensUntilEOL(token);
}

if (!jsdocBuilder.recordFileOverview(fileOverview) ||
fileOverviewJSDocInfo != null) {
parser.addParserWarning(""msg.jsdoc.fileoverview.extra"",
stream.getLineno(), stream.getCharno());
}
continue retry;

case LICENSE:
case PRESERVE:
ExtractionInfo preserveInfo =
extractMultilineTextualBlock(token,
WhitespaceOption.PRESERVE);

String preserve = preserveInfo.string;

if (preserve.length() > 0) {
if (fileLevelJsDocBuilder != null) {
fileLevelJsDocBuilder.append(preserve);
}
}

token = preserveInfo.token;
continue retry;

case ENUM:
token = next();
lineno = stream.getLineno();
charno = stream.getCharno();

type = null;
if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
type = createJSTypeExpression(
parseAndRecordTypeNode(token));
}

if (type == null) {
type = createJSTypeExpression(newStringNode(""number""));
}
if (!jsdocBuilder.recordEnumParameterType(type)) {
parser.addTypeWarning(
""msg.jsdoc.incompat.type"", lineno, charno);
}
token = eatTokensUntilEOL(token);
continue retry;

case EXPORT:
if (!jsdocBuilder.recordExport()) {
parser.addParserWarning(""msg.jsdoc.export"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case EXPOSE:
if (!jsdocBuilder.recordExpose()) {
parser.addParserWarning(""msg.jsdoc.expose"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case EXTERNS:
if (!jsdocBuilder.recordExterns()) {
parser.addParserWarning(""msg.jsdoc.externs"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case JAVA_DISPATCH:
if (!jsdocBuilder.recordJavaDispatch()) {
parser.addParserWarning(""msg.jsdoc.javadispatch"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case EXTENDS:
case IMPLEMENTS:
skipEOLs();
token = next();
lineno = stream.getLineno();
charno = stream.getCharno();
boolean matchingRc = false;

if (token == JsDocToken.LC) {
token = next();
matchingRc = true;
}

if (token == JsDocToken.STRING) {
Node typeNode = parseAndRecordTypeNameNode(
token, lineno, charno, matchingRc);

lineno = stream.getLineno();
charno = stream.getCharno();

typeNode = wrapNode(Token.BANG, typeNode);
if (typeNode != null && !matchingRc) {
typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
}
type = createJSTypeExpression(typeNode);

if (annotation == Annotation.EXTENDS) {
// record the extended type, check later
extendedTypes.add(new ExtendedTypeInfo(
type, stream.getLineno(), stream.getCharno()));
} else {
Preconditions.checkState(
annotation == Annotation.IMPLEMENTS);
if (!jsdocBuilder.recordImplementedInterface(type)) {
parser.addTypeWarning(""msg.jsdoc.implements.duplicate"",
lineno, charno);
}
}
token = next();
if (matchingRc) {
if (token != JsDocToken.RC) {
parser.addTypeWarning(""msg.jsdoc.missing.rc"",
stream.getLineno(), stream.getCharno());
}
} else if (token != JsDocToken.EOL &&
token != JsDocToken.EOF && token != JsDocToken.EOC) {
parser.addTypeWarning(""msg.end.annotation.expected"",
stream.getLineno(), stream.getCharno());
}
} else {
parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
}
token = eatTokensUntilEOL(token);
continue retry;

case HIDDEN:
if (!jsdocBuilder.recordHiddenness()) {
parser.addParserWarning(""msg.jsdoc.hidden"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case LENDS:
skipEOLs();

matchingRc = false;
if (match(JsDocToken.LC)) {
token = next();
matchingRc = true;
}

if (match(JsDocToken.STRING)) {
token = next();
if (!jsdocBuilder.recordLends(stream.getString())) {
parser.addTypeWarning(""msg.jsdoc.lends.incompatible"",
stream.getLineno(), stream.getCharno());
}
} else {
parser.addTypeWarning(""msg.jsdoc.lends.missing"",
stream.getLineno(), stream.getCharno());
}

if (matchingRc && !match(JsDocToken.RC)) {
parser.addTypeWarning(""msg.jsdoc.missing.rc"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case MEANING:
ExtractionInfo meaningInfo =
extractMultilineTextualBlock(token);
String meaning = meaningInfo.string;
token = meaningInfo.token;
if (!jsdocBuilder.recordMeaning(meaning)) {
parser.addParserWarning(""msg.jsdoc.meaning.extra"",
stream.getLineno(), stream.getCharno());
}
continue retry;

case NO_ALIAS:
if (!jsdocBuilder.recordNoAlias()) {
parser.addParserWarning(""msg.jsdoc.noalias"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case NO_COMPILE:
if (!jsdocBuilder.recordNoCompile()) {
parser.addParserWarning(""msg.jsdoc.nocompile"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case NO_TYPE_CHECK:
if (!jsdocBuilder.recordNoTypeCheck()) {
parser.addParserWarning(""msg.jsdoc.nocheck"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case NOT_IMPLEMENTED:
token = eatTokensUntilEOL();
continue retry;

case INHERIT_DOC:
case OVERRIDE:
if (!jsdocBuilder.recordOverride()) {
parser.addTypeWarning(""msg.jsdoc.override"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case THROWS:
skipEOLs();
token = next();
lineno = stream.getLineno();
charno = stream.getCharno();
type = null;

if (token == JsDocToken.LC) {
type = createJSTypeExpression(
parseAndRecordTypeNode(token));

if (type == null) {
// parsing error reported during recursive descent
// recovering parsing
token = eatTokensUntilEOL();
continue retry;
}
}

// *Update* the token to that after the type annotation.
token = current();

// Save the throw type.
jsdocBuilder.recordThrowType(type);

// Find the throw's description (if applicable).
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo descriptionInfo =
extractMultilineTextualBlock(token);

String description = descriptionInfo.string;

if (description.length() > 0) {
jsdocBuilder.recordThrowDescription(type, description);
}

token = descriptionInfo.token;
} else {
token = eatTokensUntilEOL(token);
}
continue retry;

case PARAM:
skipEOLs();
token = next();
lineno = stream.getLineno();
charno = stream.getCharno();
type = null;

if (token == JsDocToken.LC) {
type = createJSTypeExpression(
parseAndRecordParamTypeNode(token));

if (type == null) {
// parsing error reported during recursive descent
// recovering parsing
token = eatTokensUntilEOL();
continue retry;
}
skipEOLs();
token = next();
lineno = stream.getLineno();
charno = stream.getCharno();
}

String name = null;
boolean isBracketedParam = JsDocToken.LB == token;
if (isBracketedParam) {
token = next();
}

if (JsDocToken.STRING != token) {
parser.addTypeWarning(""msg.missing.variable.name"",
lineno, charno);
} else {
name = stream.getString();

if (isBracketedParam) {
token = next();

// Throw out JsDocToolkit's ""default"" parameter
// annotation.  It makes no sense under our type
// system.
if (JsDocToken.EQUALS == token) {
token = next();
if (JsDocToken.STRING == token) {
token = next();
}
}

if (JsDocToken.RB != token) {
reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
} else if (type != null) {
// Make the type expression optional, if it isn't
// already.
type = JSTypeExpression.makeOptionalArg(type);
}
}

// If the param name has a DOT in it, just throw it out
// quietly. We do not handle the JsDocToolkit method
// for handling properties of params.
if (name.indexOf('.') > -1) {
name = null;
} else if (!jsdocBuilder.recordParameter(name, type)) {
if (jsdocBuilder.hasParameter(name)) {
parser.addTypeWarning(""msg.dup.variable.name"", name,
lineno, charno);
} else {
parser.addTypeWarning(""msg.jsdoc.incompat.type"", name,
lineno, charno);
}
}
}

if (name == null) {
token = eatTokensUntilEOL(token);
continue retry;
}

jsdocBuilder.markName(name, sourceFile, lineno, charno);

// Find the parameter's description (if applicable).
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo paramDescriptionInfo =
extractMultilineTextualBlock(token);

String paramDescription = paramDescriptionInfo.string;

if (paramDescription.length() > 0) {
jsdocBuilder.recordParameterDescription(name,
paramDescription);
}

token = paramDescriptionInfo.token;
} else {
token = eatTokensUntilEOL(token);
}
continue retry;

case PRESERVE_TRY:
if (!jsdocBuilder.recordPreserveTry()) {
parser.addParserWarning(""msg.jsdoc.preservertry"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case PRIVATE:
if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
parser.addParserWarning(""msg.jsdoc.visibility.private"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case PROTECTED:
if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
parser.addParserWarning(""msg.jsdoc.visibility.protected"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case PUBLIC:
if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
parser.addParserWarning(""msg.jsdoc.visibility.public"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case NO_SHADOW:
if (!jsdocBuilder.recordNoShadow()) {
parser.addParserWarning(""msg.jsdoc.noshadow"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case NO_SIDE_EFFECTS:
if (!jsdocBuilder.recordNoSideEffects()) {
parser.addParserWarning(""msg.jsdoc.nosideeffects"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case MODIFIES:
token = parseModifiesTag(next());
continue retry;

case IMPLICIT_CAST:
if (!jsdocBuilder.recordImplicitCast()) {
parser.addTypeWarning(""msg.jsdoc.implicitcast"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case SEE:
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo referenceInfo = extractSingleLineBlock();
String reference = referenceInfo.string;

if (reference.length() == 0) {
parser.addParserWarning(""msg.jsdoc.seemissing"",
stream.getLineno(), stream.getCharno());
} else {
jsdocBuilder.addReference(reference);
}

token = referenceInfo.token;
} else {
token = eatTokensUntilEOL(token);
}
continue retry;

case SUPPRESS:
token = parseSuppressTag(next());
continue retry;

case TEMPLATE:
ExtractionInfo templateInfo = extractSingleLineBlock();
String templateTypeName = templateInfo.string;

if (templateTypeName.length() == 0) {
parser.addTypeWarning(""msg.jsdoc.templatemissing"",
stream.getLineno(), stream.getCharno());
} else if (!jsdocBuilder.recordTemplateTypeName(
templateTypeName)) {
parser.addTypeWarning(""msg.jsdoc.template.at.most.once"",
stream.getLineno(), stream.getCharno());
}

token = templateInfo.token;
continue retry;

case IDGENERATOR:
if (!jsdocBuilder.recordIdGenerator()) {
parser.addParserWarning(""msg.jsdoc.idgen"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case VERSION:
ExtractionInfo versionInfo = extractSingleLineBlock();
String version = versionInfo.string;

if (version.length() == 0) {
parser.addParserWarning(""msg.jsdoc.versionmissing"",
stream.getLineno(), stream.getCharno());
} else {
if (!jsdocBuilder.recordVersion(version)) {
parser.addParserWarning(""msg.jsdoc.extraversion"",
stream.getLineno(), stream.getCharno());
}
}

token = versionInfo.token;
continue retry;

case DEFINE:
case RETURN:
case THIS:
case TYPE:
case TYPEDEF:
lineno = stream.getLineno();
charno = stream.getCharno();

Node typeNode = null;
if (!lookAheadForTypeAnnotation() &&
annotation == Annotation.RETURN) {
// If RETURN doesn't have a type annotation, record
// it as the unknown type.
typeNode = newNode(Token.QMARK);
} else {
skipEOLs();
token = next();
typeNode = parseAndRecordTypeNode(token);
}

if (annotation == Annotation.THIS) {
typeNode = wrapNode(Token.BANG, typeNode);
if (typeNode != null && token != JsDocToken.LC) {
typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
}
}
type = createJSTypeExpression(typeNode);

if (type == null) {
// error reported during recursive descent
// recovering parsing
} else {
switch (annotation) {
case DEFINE:
if (!jsdocBuilder.recordDefineType(type)) {
parser.addParserWarning(""msg.jsdoc.define"",
lineno, charno);
}
break;

case RETURN:
if (!jsdocBuilder.recordReturnType(type)) {
parser.addTypeWarning(
""msg.jsdoc.incompat.type"", lineno, charno);
break;
}

// Find the return's description (if applicable).
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo returnDescriptionInfo =
extractMultilineTextualBlock(token);

String returnDescription =
returnDescriptionInfo.string;

if (returnDescription.length() > 0) {
jsdocBuilder.recordReturnDescription(
returnDescription);
}

token = returnDescriptionInfo.token;
} else {
token = eatTokensUntilEOL(token);
}
continue retry;

case THIS:
if (!jsdocBuilder.recordThisType(type)) {
parser.addTypeWarning(
""msg.jsdoc.incompat.type"", lineno, charno);
}
break;

case TYPE:
if (!jsdocBuilder.recordType(type)) {
parser.addTypeWarning(
""msg.jsdoc.incompat.type"", lineno, charno);
}
break;

case TYPEDEF:
if (!jsdocBuilder.recordTypedef(type)) {
parser.addTypeWarning(
""msg.jsdoc.incompat.type"", lineno, charno);
}
break;
}
}

token = eatTokensUntilEOL();
continue retry;
}
}
}
break;

case EOC:
if (hasParsedFileOverviewDocInfo()) {
fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
}
checkExtendedTypes(extendedTypes);
return true;

case EOF:
// discard any accumulated information
jsdocBuilder.build(null);
parser.addParserWarning(""msg.unexpected.eof"",
stream.getLineno(), stream.getCharno());
checkExtendedTypes(extendedTypes);
return false;

case EOL:
if (state == State.SEARCHING_NEWLINE) {
state = State.SEARCHING_ANNOTATION;
}
token = next();
continue retry;

default:
if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
token = next();
continue retry;
} else {
state = State.SEARCHING_NEWLINE;
token = eatTokensUntilEOL();
continue retry;
}
}

// next token
token = next();
}
}"
Closure_33b_1,/path/to/defects4j_buggy/Closure_33_buggy/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java,"String toStringHelper(boolean forAnnotations) {
if (hasReferenceName()) {
return getReferenceName();
} else if (prettyPrint) {
// Don't pretty print recursively.
prettyPrint = false;

// Use a tree set so that the properties are sorted.
Set<String> propertyNames = Sets.newTreeSet();
for (ObjectType current = this;
current != null && !current.isNativeObjectType() &&
propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;
current = current.getImplicitPrototype()) {
propertyNames.addAll(current.getOwnPropertyNames());
}

StringBuilder sb = new StringBuilder();
sb.append(""{"");

int i = 0;
for (String property : propertyNames) {
if (i > 0) {
sb.append("", "");
}

sb.append(property);
sb.append("": "");
sb.append(getPropertyType(property).toStringHelper(forAnnotations));

++i;
if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {
sb.append("", ..."");
break;
}
}

sb.append(""}"");

prettyPrint = true;
return sb.toString();
} else {
return forAnnotations ? ""?"" : ""{...}"";
}
}"
Closure_35b_1,/path/to/defects4j_buggy/Closure_35_buggy/src/com/google/javascript/jscomp/TypeInference.java,"private void inferPropertyTypesToMatchConstraint(
JSType type, JSType constraint) {
if (type == null || constraint == null) {
return;
}

ObjectType constraintObj =
ObjectType.cast(constraint.restrictByNotNullOrUndefined());
if (constraintObj != null && constraintObj.isRecordType()) {
ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
if (objType != null) {
for (String prop : constraintObj.getOwnPropertyNames()) {
JSType propType = constraintObj.getPropertyType(prop);
if (!objType.isPropertyTypeDeclared(prop)) {
JSType typeToInfer = propType;
if (!objType.hasProperty(prop)) {
typeToInfer =
getNativeType(VOID_TYPE).getLeastSupertype(propType);
}
objType.defineInferredProperty(prop, typeToInfer, null);
}
}
}
}
}"
Closure_36b_1,/path/to/defects4j_buggy/Closure_36_buggy/src/com/google/javascript/jscomp/InlineVariables.java,"private Predicate<Var> getFilterForMode() {
switch (mode) {
case ALL:
return Predicates.<Var>alwaysTrue();
case LOCALS_ONLY:
return new IdentifyLocals();
case CONSTANTS_ONLY:
return new IdentifyConstants();
default:
throw new IllegalStateException();
}
}"
Closure_38b_1,/path/to/defects4j_buggy/Closure_38_buggy/src/com/google/javascript/jscomp/CodeConsumer.java,"void addNumber(double x) {
// This is not pretty printing. This is to prevent misparsing of x- -4 as
// x--4 (which is a syntax error).
char prev = getLastChar();
boolean negativeZero = isNegativeZero(x);
if (x < 0 && prev == '-') {
add("" "");
}

if ((long) x == x && !negativeZero) {
long value = (long) x;
long mantissa = value;
int exp = 0;
if (Math.abs(x) >= 100) {
while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
mantissa /= 10;
exp++;
}
}
if (exp > 2) {
add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
} else {
add(Long.toString(value));
}
} else {
add(String.valueOf(x));
}
}"
Closure_39b_1,/path/to/defects4j_buggy/Closure_39_buggy/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java,"public Property getSlot(String name) {
if (properties.containsKey(name)) {
return properties.get(name);
}
ObjectType implicitPrototype = getImplicitPrototype();
if (implicitPrototype != null) {
Property prop = implicitPrototype.getSlot(name);
if (prop != null) {
return prop;
}
}
for (ObjectType interfaceType : getCtorExtendedInterfaces()) {
Property prop = interfaceType.getSlot(name);
if (prop != null) {
return prop;
}
}
return null;
}"
Closure_40b_1,/path/to/defects4j_buggy/Closure_40_buggy/src/com/google/javascript/jscomp/NameAnalyzer.java,"private NameInformation createNameInformation(NodeTraversal t, Node n,
Node parent) {
// Build the full name and find its root node by iterating down through all
// GETPROP/GETELEM nodes.
String name = """";
Node rootNameNode = n;
boolean bNameWasShortened = false;
while (true) {
if (NodeUtil.isGet(rootNameNode)) {
Node prop = rootNameNode.getLastChild();
if (rootNameNode.isGetProp()) {
name = ""."" + prop.getString() + name;
} else {
// We consider the name to be ""a.b"" in a.b['c'] or a.b[x].d.
bNameWasShortened = true;
name = """";
}
rootNameNode = rootNameNode.getFirstChild();
} else if (NodeUtil.isObjectLitKey(
rootNameNode, rootNameNode.getParent())) {
name = ""."" + rootNameNode.getString() + name;

// Check if this is an object literal assigned to something.
Node objLit = rootNameNode.getParent();
Node objLitParent = objLit.getParent();
if (objLitParent.isAssign()) {
// This must be the right side of the assign.
rootNameNode = objLitParent.getFirstChild();
} else if (objLitParent.isName()) {
// This must be a VAR initialization.
rootNameNode = objLitParent;
} else if (objLitParent.isString()) {
// This must be a object literal key initialization.
rootNameNode = objLitParent;
} else {
return null;
}
} else {
break;
}
}

// Check whether this is a class-defining call. Classes may only be defined
// in the global scope.
if (parent.isCall() && t.inGlobalScope()) {
CodingConvention convention = compiler.getCodingConvention();
SubclassRelationship classes = convention.getClassesDefinedByCall(parent);
if (classes != null) {
NameInformation nameInfo = new NameInformation();
nameInfo.name = classes.subclassName;
nameInfo.onlyAffectsClassDef = true;
nameInfo.superclass = classes.superclassName;
return nameInfo;
}

String singletonGetterClass =
convention.getSingletonGetterClassName(parent);
if (singletonGetterClass != null) {
NameInformation nameInfo = new NameInformation();
nameInfo.name = singletonGetterClass;
nameInfo.onlyAffectsClassDef = true;
return nameInfo;
}
}

switch (rootNameNode.getType()) {
case Token.NAME:
// Check whether this is an assignment to a prototype property
// of an object defined in the global scope.
if (!bNameWasShortened &&
n.isGetProp() &&
parent.isAssign() &&
""prototype"".equals(n.getLastChild().getString())) {
if (createNameInformation(t, n.getFirstChild(), n) != null) {
name = rootNameNode.getString() + name;
name = name.substring(0, name.length() - PROTOTYPE_SUFFIX_LEN);
NameInformation nameInfo = new NameInformation();
nameInfo.name = name;
return nameInfo;
} else {
return null;
}
}
return createNameInformation(
rootNameNode.getString() + name, t.getScope(), rootNameNode);
case Token.THIS:
if (t.inGlobalScope()) {
NameInformation nameInfo = new NameInformation();
if (name.indexOf('.') == 0) {
nameInfo.name = name.substring(1);  // strip leading "".""
} else {
nameInfo.name = name;
}
nameInfo.isExternallyReferenceable = true;
return nameInfo;
}
return null;
default:
return null;
}
}"
Closure_42b_1,/path/to/defects4j_buggy/Closure_42_buggy/src/com/google/javascript/jscomp/parsing/IRFactory.java,"private static int transformTokenType(int token) {
switch (token) {
case com.google.javascript.rhino.head.Token.RETURN:
return Token.RETURN;
case com.google.javascript.rhino.head.Token.BITOR:
return Token.BITOR;
case com.google.javascript.rhino.head.Token.BITXOR:
return Token.BITXOR;
case com.google.javascript.rhino.head.Token.BITAND:
return Token.BITAND;
case com.google.javascript.rhino.head.Token.EQ:
return Token.EQ;
case com.google.javascript.rhino.head.Token.NE:
return Token.NE;
case com.google.javascript.rhino.head.Token.LT:
return Token.LT;
case com.google.javascript.rhino.head.Token.LE:
return Token.LE;
case com.google.javascript.rhino.head.Token.GT:
return Token.GT;
case com.google.javascript.rhino.head.Token.GE:
return Token.GE;
case com.google.javascript.rhino.head.Token.LSH:
return Token.LSH;
case com.google.javascript.rhino.head.Token.RSH:
return Token.RSH;
case com.google.javascript.rhino.head.Token.URSH:
return Token.URSH;
case com.google.javascript.rhino.head.Token.ADD:
return Token.ADD;
case com.google.javascript.rhino.head.Token.SUB:
return Token.SUB;
case com.google.javascript.rhino.head.Token.MUL:
return Token.MUL;
case com.google.javascript.rhino.head.Token.DIV:
return Token.DIV;
case com.google.javascript.rhino.head.Token.MOD:
return Token.MOD;
case com.google.javascript.rhino.head.Token.NOT:
return Token.NOT;
case com.google.javascript.rhino.head.Token.BITNOT:
return Token.BITNOT;
case com.google.javascript.rhino.head.Token.POS:
return Token.POS;
case com.google.javascript.rhino.head.Token.NEG:
return Token.NEG;
case com.google.javascript.rhino.head.Token.NEW:
return Token.NEW;
case com.google.javascript.rhino.head.Token.DELPROP:
return Token.DELPROP;
case com.google.javascript.rhino.head.Token.TYPEOF:
return Token.TYPEOF;
case com.google.javascript.rhino.head.Token.GETPROP:
return Token.GETPROP;
case com.google.javascript.rhino.head.Token.GETELEM:
return Token.GETELEM;
case com.google.javascript.rhino.head.Token.CALL:
return Token.CALL;
case com.google.javascript.rhino.head.Token.NAME:
return Token.NAME;
case com.google.javascript.rhino.head.Token.NUMBER:
return Token.NUMBER;
case com.google.javascript.rhino.head.Token.STRING:
return Token.STRING;
case com.google.javascript.rhino.head.Token.NULL:
return Token.NULL;
case com.google.javascript.rhino.head.Token.THIS:
return Token.THIS;
case com.google.javascript.rhino.head.Token.FALSE:
return Token.FALSE;
case com.google.javascript.rhino.head.Token.TRUE:
return Token.TRUE;
case com.google.javascript.rhino.head.Token.SHEQ:
return Token.SHEQ;
case com.google.javascript.rhino.head.Token.SHNE:
return Token.SHNE;
case com.google.javascript.rhino.head.Token.REGEXP:
return Token.REGEXP;
case com.google.javascript.rhino.head.Token.THROW:
return Token.THROW;
case com.google.javascript.rhino.head.Token.IN:
return Token.IN;
case com.google.javascript.rhino.head.Token.INSTANCEOF:
return Token.INSTANCEOF;
case com.google.javascript.rhino.head.Token.ARRAYLIT:
return Token.ARRAYLIT;
case com.google.javascript.rhino.head.Token.OBJECTLIT:
return Token.OBJECTLIT;
case com.google.javascript.rhino.head.Token.TRY:
return Token.TRY;
// The LP represents a parameter list
case com.google.javascript.rhino.head.Token.LP:
return Token.PARAM_LIST;
case com.google.javascript.rhino.head.Token.COMMA:
return Token.COMMA;
case com.google.javascript.rhino.head.Token.ASSIGN:
return Token.ASSIGN;
case com.google.javascript.rhino.head.Token.ASSIGN_BITOR:
return Token.ASSIGN_BITOR;
case com.google.javascript.rhino.head.Token.ASSIGN_BITXOR:
return Token.ASSIGN_BITXOR;
case com.google.javascript.rhino.head.Token.ASSIGN_BITAND:
return Token.ASSIGN_BITAND;
case com.google.javascript.rhino.head.Token.ASSIGN_LSH:
return Token.ASSIGN_LSH;
case com.google.javascript.rhino.head.Token.ASSIGN_RSH:
return Token.ASSIGN_RSH;
case com.google.javascript.rhino.head.Token.ASSIGN_URSH:
return Token.ASSIGN_URSH;
case com.google.javascript.rhino.head.Token.ASSIGN_ADD:
return Token.ASSIGN_ADD;
case com.google.javascript.rhino.head.Token.ASSIGN_SUB:
return Token.ASSIGN_SUB;
case com.google.javascript.rhino.head.Token.ASSIGN_MUL:
return Token.ASSIGN_MUL;
case com.google.javascript.rhino.head.Token.ASSIGN_DIV:
return Token.ASSIGN_DIV;
case com.google.javascript.rhino.head.Token.ASSIGN_MOD:
return Token.ASSIGN_MOD;
case com.google.javascript.rhino.head.Token.HOOK:
return Token.HOOK;
case com.google.javascript.rhino.head.Token.OR:
return Token.OR;
case com.google.javascript.rhino.head.Token.AND:
return Token.AND;
case com.google.javascript.rhino.head.Token.INC:
return Token.INC;
case com.google.javascript.rhino.head.Token.DEC:
return Token.DEC;
case com.google.javascript.rhino.head.Token.FUNCTION:
return Token.FUNCTION;
case com.google.javascript.rhino.head.Token.IF:
return Token.IF;
case com.google.javascript.rhino.head.Token.SWITCH:
return Token.SWITCH;
case com.google.javascript.rhino.head.Token.CASE:
return Token.CASE;
case com.google.javascript.rhino.head.Token.DEFAULT:
return Token.DEFAULT_CASE;
case com.google.javascript.rhino.head.Token.WHILE:
return Token.WHILE;
case com.google.javascript.rhino.head.Token.DO:
return Token.DO;
case com.google.javascript.rhino.head.Token.FOR:
return Token.FOR;
case com.google.javascript.rhino.head.Token.BREAK:
return Token.BREAK;
case com.google.javascript.rhino.head.Token.CONTINUE:
return Token.CONTINUE;
case com.google.javascript.rhino.head.Token.VAR:
return Token.VAR;
case com.google.javascript.rhino.head.Token.WITH:
return Token.WITH;
case com.google.javascript.rhino.head.Token.CATCH:
return Token.CATCH;
case com.google.javascript.rhino.head.Token.VOID:
return Token.VOID;
case com.google.javascript.rhino.head.Token.EMPTY:
return Token.EMPTY;
case com.google.javascript.rhino.head.Token.BLOCK:
return Token.BLOCK;
case com.google.javascript.rhino.head.Token.LABEL:
return Token.LABEL;
case com.google.javascript.rhino.head.Token.EXPR_VOID:
case com.google.javascript.rhino.head.Token.EXPR_RESULT:
return Token.EXPR_RESULT;
case com.google.javascript.rhino.head.Token.SCRIPT:
return Token.SCRIPT;
case com.google.javascript.rhino.head.Token.GET:
return Token.GETTER_DEF;
case com.google.javascript.rhino.head.Token.SET:
return Token.SETTER_DEF;
case com.google.javascript.rhino.head.Token.CONST:
return Token.CONST;
case com.google.javascript.rhino.head.Token.DEBUGGER:
return Token.DEBUGGER;
}

// Token without name
throw new IllegalStateException(String.valueOf(token));
}"
Closure_44b_1,/path/to/defects4j_buggy/Closure_44_buggy/src/com/google/javascript/jscomp/CodeConsumer.java,"void appendOp(String op, boolean binOp) {
append(op);
}"
Closure_46b_1,/path/to/defects4j_buggy/Closure_46_buggy/src/com/google/javascript/rhino/jstype/RecordType.java,"public JSType getLeastSupertype(JSType that) {
if (!that.isRecordType()) {
return super.getLeastSupertype(that);
}
RecordTypeBuilder builder = new RecordTypeBuilder(registry);
for (String property : properties.keySet()) {
if (that.toMaybeRecordType().hasProperty(property) &&
that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(
getPropertyType(property))) {
builder.addProperty(property, getPropertyType(property),
getPropertyNode(property));
}
}
return builder.build();
}"
Closure_48b_1,/path/to/defects4j_buggy/Closure_48_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"public Scope createScope(Node root, Scope parent) {
// Constructing the global scope is very different than constructing
// inner scopes, because only global scopes can contain named classes that
// show up in the type registry.
Scope newScope = null;
AbstractScopeBuilder scopeBuilder = null;
if (parent == null) {
// Run a first-order analysis over the syntax tree.
(new FirstOrderFunctionAnalyzer(compiler, functionAnalysisResults))
.process(root.getFirstChild(), root.getLastChild());

// Find all the classes in the global scope.
newScope = createInitialScope(root);

GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);
scopeBuilder = globalScopeBuilder;
NodeTraversal.traverse(compiler, root, scopeBuilder);
} else {
newScope = new Scope(parent, root);
LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);
scopeBuilder = localScopeBuilder;
localScopeBuilder.build();
}

scopeBuilder.resolveStubDeclarations();
scopeBuilder.resolveTypes();

// Gather the properties in each function that we found in the
// global scope, if that function has a @this type that we can
// build properties on.
for (Node functionNode : scopeBuilder.nonExternFunctions) {
JSType type = functionNode.getJSType();
if (type != null && type.isFunctionType()) {
FunctionType fnType = type.toMaybeFunctionType();
ObjectType fnThisType = fnType.getTypeOfThis();
if (!fnThisType.isUnknownType()) {
NodeTraversal.traverse(compiler, functionNode.getLastChild(),
scopeBuilder.new CollectProperties(fnThisType));
}
}
}

if (parent == null) {
codingConvention.defineDelegateProxyPrototypeProperties(
typeRegistry, newScope, delegateProxyPrototypes,
delegateCallingConventions);
}
return newScope;
}"
Closure_50b_1,/path/to/defects4j_buggy/Closure_50_buggy/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java,"private Node tryFoldArrayJoin(Node n) {
Node callTarget = n.getFirstChild();

if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
return n;
}

Node right = callTarget.getNext();
if (right != null) {
if (!NodeUtil.isImmutableValue(right)) {
return n;
}
}

Node arrayNode = callTarget.getFirstChild();
Node functionName = arrayNode.getNext();

if ((arrayNode.getType() != Token.ARRAYLIT) ||
!functionName.getString().equals(""join"")) {
return n;
}

// "","" is the default, it doesn't need to be explicit

String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
List<Node> arrayFoldedChildren = Lists.newLinkedList();
StringBuilder sb = null;
int foldedSize = 0;
Node prev = null;
Node elem = arrayNode.getFirstChild();
// Merges adjacent String nodes.
while (elem != null) {
if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {
if (sb == null) {
sb = new StringBuilder();
} else {
sb.append(joinString);
}
sb.append(NodeUtil.getArrayElementStringValue(elem));
} else {
if (sb != null) {
Preconditions.checkNotNull(prev);
// + 2 for the quotes.
foldedSize += sb.length() + 2;
arrayFoldedChildren.add(
Node.newString(sb.toString()).copyInformationFrom(prev));
sb = null;
}
foldedSize += InlineCostEstimator.getCost(elem);
arrayFoldedChildren.add(elem);
}
prev = elem;
elem = elem.getNext();
}

if (sb != null) {
Preconditions.checkNotNull(prev);
// + 2 for the quotes.
foldedSize += sb.length() + 2;
arrayFoldedChildren.add(
Node.newString(sb.toString()).copyInformationFrom(prev));
}
// one for each comma.
foldedSize += arrayFoldedChildren.size() - 1;

int originalSize = InlineCostEstimator.getCost(n);
switch (arrayFoldedChildren.size()) {
case 0:
Node emptyStringNode = Node.newString("""");
n.getParent().replaceChild(n, emptyStringNode);
reportCodeChange();
return emptyStringNode;
case 1:
Node foldedStringNode = arrayFoldedChildren.remove(0);
if (foldedSize > originalSize) {
return n;
}
arrayNode.detachChildren();
if (foldedStringNode.getType() != Token.STRING) {
// If the Node is not a string literal, ensure that
// it is coerced to a string.
Node replacement = new Node(Token.ADD,
Node.newString("""").copyInformationFrom(n),
foldedStringNode);
foldedStringNode = replacement;
}
n.getParent().replaceChild(n, foldedStringNode);
reportCodeChange();
return foldedStringNode;
default:
// No folding could actually be performed.
if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
return n;
}
int kJoinOverhead = ""[].join()"".length();
foldedSize += kJoinOverhead;
foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;
if (foldedSize > originalSize) {
return n;
}
arrayNode.detachChildren();
for (Node node : arrayFoldedChildren) {
arrayNode.addChildToBack(node);
}
reportCodeChange();
break;
}

return n;
}"
Closure_51b_1,/path/to/defects4j_buggy/Closure_51_buggy/src/com/google/javascript/jscomp/CodeConsumer.java,"void appendOp(String op, boolean binOp) {
append(op);
}"
Closure_52b_1,/path/to/defects4j_buggy/Closure_52_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"static double getSimpleNumber(String s) {
if (isSimpleNumber(s)) {
try {
long l = Long.parseLong(s);
if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) {
return l;
}
} catch (NumberFormatException e) {
// The number was too long to parse. Fall through to NaN.
}
}
return Double.NaN;
}"
Closure_53b_1,/path/to/defects4j_buggy/Closure_53_buggy/src/com/google/javascript/jscomp/InlineObjectLiterals.java,"InlineObjectLiterals(
AbstractCompiler compiler,"
Closure_55b_1,/path/to/defects4j_buggy/Closure_55_buggy/src/com/google/javascript/jscomp/FunctionRewriter.java,"public void process(Node externs, Node root) {
List<Reducer> reducers = ImmutableList.of(new ReturnConstantReducer(),
new GetterReducer(),
new SetterReducer(),
new EmptyFunctionReducer(),
new IdentityReducer());

Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();

// Accumulate possible reductions in the reduction multi map.  They
// will be applied in the loop below.
NodeTraversal.traverse(compiler, root,
new ReductionGatherer(reducers, reductionMap));

// Apply reductions iff they will provide some savings.
for (Reducer reducer : reducers) {
Collection<Reduction> reductions = reductionMap.get(reducer);
if (reductions.isEmpty()) {
continue;
}

Node helperCode = parseHelperCode(reducer);
if (helperCode == null) {
continue;
}

int helperCodeCost = InlineCostEstimator.getCost(helperCode);

// Estimate savings
int savings = 0;
for (Reduction reduction : reductions) {
savings += reduction.estimateSavings();
}

// Compare estimated savings against the helper cost.  Apply
// reductions if doing so will result in some savings.
if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) {
for (Reduction reduction : reductions) {
reduction.apply();
}

Node addingRoot = compiler.getNodeForCodeInsertion(null);
addingRoot.addChildrenToFront(helperCode);
compiler.reportCodeChange();
}
}
}"
Closure_56b_1,/path/to/defects4j_buggy/Closure_56_buggy/src/com/google/javascript/jscomp/SourceFile.java,"public String getLine(int lineNumber) {
String js = """";
try {
// NOTE(nicksantos): Right now, this is optimized for few warnings.
// This is probably the right trade-off, but will be slow if there
// are lots of warnings in one file.
js = getCode();
} catch (IOException e) {
return null;
}

int pos = 0;
int startLine = 1;

// If we've saved a previous offset and it's for a line less than the
// one we're searching for, then start at that point.
if (lineNumber >= lastLine) {
pos = lastOffset;
startLine = lastLine;
}

for (int n = startLine; n < lineNumber; n++) {
int nextpos = js.indexOf('\n', pos);
if (nextpos == -1) {
return null;
}
pos = nextpos + 1;
}

// Remember this offset for the next search we do.
lastOffset = pos;
lastLine = lineNumber;

if (js.indexOf('\n', pos) == -1) {
// If next new line cannot be found, there are two cases
// 1. pos already reaches the end of file, then null should be returned
// 2. otherwise, return the contents between pos and the end of file.
return null;
} else {
return js.substring(pos, js.indexOf('\n', pos));
}
}"
Closure_57b_1,/path/to/defects4j_buggy/Closure_57_buggy/src/com/google/javascript/jscomp/ClosureCodingConvention.java,"public String extractClassNameIfRequire(Node node, Node parent){
return extractClassNameIfGoog(node, parent, ""goog.require"");
}"
Closure_58b_1,/path/to/defects4j_buggy/Closure_58_buggy/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java,"private void computeGenKill(Node n, BitSet gen, BitSet kill,
boolean conditional) {

switch (n.getType()) {
case Token.SCRIPT:
case Token.BLOCK:
case Token.FUNCTION:
return;

case Token.WHILE:
case Token.DO:
case Token.IF:
computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
conditional);
return;

case Token.FOR:
if (!NodeUtil.isForIn(n)) {
computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
conditional);
} else {
// for(x in y) {...}
Node lhs = n.getFirstChild();
Node rhs = lhs.getNext();
if (NodeUtil.isVar(lhs)) {
// for(var x in y) {...}
lhs = lhs.getLastChild();
}
addToSetIfLocal(lhs, kill);
addToSetIfLocal(lhs, gen);
computeGenKill(rhs, gen, kill, conditional);
}
return;

case Token.VAR:
for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
if (c.hasChildren()) {
computeGenKill(c.getFirstChild(), gen, kill, conditional);
if (!conditional) {
addToSetIfLocal(c, kill);
}
}
}
return;

case Token.AND:
case Token.OR:
computeGenKill(n.getFirstChild(), gen, kill, conditional);
// May short circuit.
computeGenKill(n.getLastChild(), gen, kill, true);
return;

case Token.HOOK:
computeGenKill(n.getFirstChild(), gen, kill, conditional);
// Assume both sides are conditional.
computeGenKill(n.getFirstChild().getNext(), gen, kill, true);
computeGenKill(n.getLastChild(), gen, kill, true);
return;

case Token.NAME:
if (isArgumentsName(n)) {
markAllParametersEscaped();
} else {
addToSetIfLocal(n, gen);
}
return;

default:
if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
Node lhs = n.getFirstChild();
if (!conditional) {
addToSetIfLocal(lhs, kill);
}
if (!NodeUtil.isAssign(n)) {
// assignments such as a += 1 reads a.
addToSetIfLocal(lhs, gen);
}
computeGenKill(lhs.getNext(), gen, kill, conditional);
} else {
for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
computeGenKill(c, gen, kill, conditional);
}
}
return;
}
}"
Closure_59b_1,/path/to/defects4j_buggy/Closure_59_buggy/src/com/google/javascript/jscomp/Compiler.java,"public void initOptions(CompilerOptions options) {
    this.options = options;
    if (errorManager == null) {
      if (outStream == null) {
        setErrorManager(
            new LoggerErrorManager(createMessageFormatter(), logger));
      } else {
        PrintStreamErrorManager printer =
            new PrintStreamErrorManager(createMessageFormatter(), outStream);
        printer.setSummaryDetailLevel(options.summaryDetailLevel);
        setErrorManager(printer);
      }
    }

    // DiagnosticGroups override the plain checkTypes option.
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
      options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
      options.checkTypes = false;
    } else if (!options.checkTypes) {
      // If DiagnosticGroups did not override the plain checkTypes
      // option, and checkTypes is enabled, then turn off the
      // parser type warnings.
      options.setWarningLevel(
          DiagnosticGroup.forType(
              RhinoErrorReporter.TYPE_PARSE_ERROR),
          CheckLevel.OFF);
    }

    if (options.checkGlobalThisLevel.isOn()) {
      options.setWarningLevel(
          DiagnosticGroups.GLOBAL_THIS,
          options.checkGlobalThisLevel);
    }

    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {
      options.setWarningLevel(
          DiagnosticGroups.ES5_STRICT,
          CheckLevel.ERROR);
    }

    // Initialize the warnings guard.
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(
        new SuppressDocWarningsGuard(
            getDiagnosticGroups().getRegisteredGroups()));
    guards.add(options.getWarningsGuard());

    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);

    // All passes must run the variable check. This synthesizes
    // variables later so that the compiler doesn't crash. It also
    // checks the externs file for validity. If you don't want to warn
    // about missing variable declarations, we shut that specific
    // error off.
    if (!options.checkSymbols &&
        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(
          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
    }

    this.warningsGuard = composedGuards;
  }"
Closure_61b_1,/path/to/defects4j_buggy/Closure_61_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static boolean functionCallHasSideEffects(
Node callNode, @Nullable AbstractCompiler compiler) {
if (callNode.getType() != Token.CALL) {
throw new IllegalStateException(
""Expected CALL node, got "" + Token.name(callNode.getType()));
}

if (callNode.isNoSideEffectsCall()) {
return false;
}

Node nameNode = callNode.getFirstChild();

// Built-in functions with no side effects.
if (nameNode.getType() == Token.NAME) {
String name = nameNode.getString();
if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
return false;
}
} else if (nameNode.getType() == Token.GETPROP) {
if (callNode.hasOneChild()
&& OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(
nameNode.getLastChild().getString())) {
return false;
}

if (callNode.isOnlyModifiesThisCall()
&& evaluatesToLocalValue(nameNode.getFirstChild())) {
return false;
}

// Functions in the ""Math"" namespace have no side effects.

if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
if (nameNode.getFirstChild().getType() == Token.REGEXP
&& REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
return false;
} else if (nameNode.getFirstChild().getType() == Token.STRING
&& STRING_REGEXP_METHODS.contains(
nameNode.getLastChild().getString())) {
Node param = nameNode.getNext();
if (param != null &&
(param.getType() == Token.STRING
|| param.getType() == Token.REGEXP))
return false;
}
}
}

return true;
}"
Closure_62b_1,/path/to/defects4j_buggy/Closure_62_buggy/src/com/google/javascript/jscomp/LightweightMessageFormatter.java,"public LightweightMessageFormatter(SourceExcerptProvider source) {
this(source, LINE);
}"
Closure_65b_1,/path/to/defects4j_buggy/Closure_65_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"static String strEscape(String s, char quote,
String doublequoteEscape,"
Closure_66b_1,/path/to/defects4j_buggy/Closure_66_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"double getTypedPercent() {
int total = nullCount + unknownCount + typedCount;
if (total == 0) {
return 0.0;
} else {
return (100.0 * typedCount) / total;
}
}"
Closure_67b_1,/path/to/defects4j_buggy/Closure_67_buggy/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java,"public void process(Node externRoot, Node root) {
if (!canModifyExterns) {
NodeTraversal.traverse(compiler, externRoot,
new ProcessExternProperties());
}

NodeTraversal.traverse(compiler, root, new ProcessProperties());

FixedPointGraphTraversal<NameInfo, JSModule> t =
FixedPointGraphTraversal.newTraversal(new PropagateReferences());
t.computeFixedPoint(symbolGraph,
Sets.newHashSet(externNode, globalNode));
}"
Closure_69b_1,/path/to/defects4j_buggy/Closure_69_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"public void visit(NodeTraversal t, Node n, Node parent) {
JSType childType;
JSType leftType, rightType;
Node left, right;
// To be explicitly set to false if the node is not typeable.
boolean typeable = true;

switch (n.getType()) {
case Token.NAME:
typeable = visitName(t, n, parent);
break;

case Token.LP:
// If this is under a FUNCTION node, it is a parameter list and can be
// ignored here.
if (parent.getType() != Token.FUNCTION) {
ensureTyped(t, n, getJSType(n.getFirstChild()));
} else {
typeable = false;
}
break;

case Token.COMMA:
ensureTyped(t, n, getJSType(n.getLastChild()));
break;

case Token.TRUE:
case Token.FALSE:
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.THIS:
ensureTyped(t, n, t.getScope().getTypeOfThis());
break;

case Token.REF_SPECIAL:
ensureTyped(t, n);
break;

case Token.GET_REF:
ensureTyped(t, n, getJSType(n.getFirstChild()));
break;

case Token.NULL:
ensureTyped(t, n, NULL_TYPE);
break;

case Token.NUMBER:
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.STRING:
// Object literal keys are handled with OBJECTLIT
if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
ensureTyped(t, n, STRING_TYPE);
}
break;

case Token.GET:
case Token.SET:
// Object literal keys are handled with OBJECTLIT
break;

case Token.ARRAYLIT:
ensureTyped(t, n, ARRAY_TYPE);
break;

case Token.REGEXP:
ensureTyped(t, n, REGEXP_TYPE);
break;

case Token.GETPROP:
visitGetProp(t, n, parent);
typeable = !(parent.getType() == Token.ASSIGN &&
parent.getFirstChild() == n);
break;

case Token.GETELEM:
visitGetElem(t, n);
// The type of GETELEM is always unknown, so no point counting that.
// If that unknown leaks elsewhere (say by an assignment to another
// variable), then it will be counted.
typeable = false;
break;

case Token.VAR:
visitVar(t, n);
typeable = false;
break;

case Token.NEW:
visitNew(t, n);
typeable = true;
break;

case Token.CALL:
visitCall(t, n);
typeable = !NodeUtil.isExpressionNode(parent);
break;

case Token.RETURN:
visitReturn(t, n);
typeable = false;
break;

case Token.DEC:
case Token.INC:
left = n.getFirstChild();
validator.expectNumber(
t, left, getJSType(left), ""increment/decrement"");
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.NOT:
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.VOID:
ensureTyped(t, n, VOID_TYPE);
break;

case Token.TYPEOF:
ensureTyped(t, n, STRING_TYPE);
break;

case Token.BITNOT:
childType = getJSType(n.getFirstChild());
if (!childType.matchesInt32Context()) {
report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),
childType.toString());
}
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.POS:
case Token.NEG:
left = n.getFirstChild();
validator.expectNumber(t, left, getJSType(left), ""sign operator"");
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.EQ:
case Token.NE: {
leftType = getJSType(n.getFirstChild());
rightType = getJSType(n.getLastChild());

JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
TernaryValue result =
leftTypeRestricted.testForEquality(rightTypeRestricted);
if (result != TernaryValue.UNKNOWN) {
if (n.getType() == Token.NE) {
result = result.not();
}
report(t, n, DETERMINISTIC_TEST, leftType.toString(),
rightType.toString(), result.toString());
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;
}

case Token.SHEQ:
case Token.SHNE: {
leftType = getJSType(n.getFirstChild());
rightType = getJSType(n.getLastChild());

JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
if (!leftTypeRestricted.canTestForShallowEqualityWith(
rightTypeRestricted)) {
report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),
rightType.toString());
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;
}

case Token.LT:
case Token.LE:
case Token.GT:
case Token.GE:
leftType = getJSType(n.getFirstChild());
rightType = getJSType(n.getLastChild());
if (rightType.isNumber()) {
validator.expectNumber(
t, n, leftType, ""left side of numeric comparison"");
} else if (leftType.isNumber()) {
validator.expectNumber(
t, n, rightType, ""right side of numeric comparison"");
} else if (leftType.matchesNumberContext() &&
rightType.matchesNumberContext()) {
// OK.
} else {
// Whether the comparison is numeric will be determined at runtime
// each time the expression is evaluated. Regardless, both operands
// should match a string context.
String message = ""left side of comparison"";
validator.expectString(t, n, leftType, message);
validator.expectNotNullOrUndefined(
t, n, leftType, message, getNativeType(STRING_TYPE));
message = ""right side of comparison"";
validator.expectString(t, n, rightType, message);
validator.expectNotNullOrUndefined(
t, n, rightType, message, getNativeType(STRING_TYPE));
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.IN:
left = n.getFirstChild();
right = n.getLastChild();
leftType = getJSType(left);
rightType = getJSType(right);
validator.expectObject(t, n, rightType, ""'in' requires an object"");
validator.expectString(t, left, leftType, ""left side of 'in'"");
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.INSTANCEOF:
left = n.getFirstChild();
right = n.getLastChild();
leftType = getJSType(left);
rightType = getJSType(right).restrictByNotNullOrUndefined();

validator.expectAnyObject(
t, left, leftType, ""deterministic instanceof yields false"");
validator.expectActualObject(
t, right, rightType, ""instanceof requires an object"");
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.ASSIGN:
visitAssign(t, n);
typeable = false;
break;

case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_SUB:
case Token.ASSIGN_ADD:
case Token.ASSIGN_MUL:
case Token.LSH:
case Token.RSH:
case Token.URSH:
case Token.DIV:
case Token.MOD:
case Token.BITOR:
case Token.BITXOR:
case Token.BITAND:
case Token.SUB:
case Token.ADD:
case Token.MUL:
visitBinaryOperator(n.getType(), t, n);
break;

case Token.DELPROP:
if (!isReference(n.getFirstChild())) {
report(t, n, BAD_DELETE);
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.CASE:
JSType switchType = getJSType(parent.getFirstChild());
JSType caseType = getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t, n, switchType, caseType);
typeable = false;
break;

case Token.WITH: {
Node child = n.getFirstChild();
childType = getJSType(child);
validator.expectObject(
t, child, childType, ""with requires an object"");
typeable = false;
break;
}

case Token.FUNCTION:
visitFunction(t, n);
break;

// These nodes have no interesting type behavior.
case Token.LABEL:
case Token.LABEL_NAME:
case Token.SWITCH:
case Token.BREAK:
case Token.CATCH:
case Token.TRY:
case Token.SCRIPT:
case Token.EXPR_RESULT:
case Token.BLOCK:
case Token.EMPTY:
case Token.DEFAULT:
case Token.CONTINUE:
case Token.DEBUGGER:
case Token.THROW:
typeable = false;
break;

// These nodes require data flow analysis.
case Token.DO:
case Token.FOR:
case Token.IF:
case Token.WHILE:
typeable = false;
break;

// These nodes are typed during the type inference.
case Token.AND:
case Token.HOOK:
case Token.OBJECTLIT:
case Token.OR:
if (n.getJSType() != null) { // If we didn't run type inference.
ensureTyped(t, n);
} else {
// If this is an enum, then give that type to the objectlit as well.
if ((n.getType() == Token.OBJECTLIT)
&& (parent.getJSType() instanceof EnumType)) {
ensureTyped(t, n, parent.getJSType());
} else {
ensureTyped(t, n);
}
}
if (n.getType() == Token.OBJECTLIT) {
for (Node key : n.children()) {
visitObjLitKey(t, key, n);
}
}
break;

default:
report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
ensureTyped(t, n);
break;
}

// Don't count externs since the user's code may not even use that part.
typeable = typeable && !inExterns;

if (typeable) {
doPercentTypedAccounting(t, n);
}

checkNoTypeCheckSection(n, false);
}"
Closure_70b_1,/path/to/defects4j_buggy/Closure_70_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"public Scope createScope(Node root, Scope parent) {
// Constructing the global scope is very different than constructing
// inner scopes, because only global scopes can contain named classes that
// show up in the type registry.
Scope newScope = null;
AbstractScopeBuilder scopeBuilder = null;
if (parent == null) {
// Find all the classes in the global scope.
newScope = createInitialScope(root);

GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);
scopeBuilder = globalScopeBuilder;
NodeTraversal.traverse(compiler, root, scopeBuilder);
} else {
newScope = new Scope(parent, root);
LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);
scopeBuilder = localScopeBuilder;
localScopeBuilder.build();
}

scopeBuilder.resolveStubDeclarations();
scopeBuilder.resolveTypes();

// Gather the properties in each function that we found in the
// global scope, if that function has a @this type that we can
// build properties on.
for (Node functionNode : scopeBuilder.nonExternFunctions) {
JSType type = functionNode.getJSType();
if (type != null && type instanceof FunctionType) {
FunctionType fnType = (FunctionType) type;
ObjectType fnThisType = fnType.getTypeOfThis();
if (!fnThisType.isUnknownType()) {
NodeTraversal.traverse(compiler, functionNode.getLastChild(),
scopeBuilder.new CollectProperties(fnThisType));
}
}
}

if (parent == null) {
codingConvention.defineDelegateProxyPrototypeProperties(
typeRegistry, newScope, delegateProxyPrototypes);
}
return newScope;
}"
Closure_71b_1,/path/to/defects4j_buggy/Closure_71_buggy/src/com/google/javascript/jscomp/CheckAccessControls.java,"private void checkPropertyVisibility(NodeTraversal t,
Node getprop, Node parent) {
ObjectType objectType =
ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
String propertyName = getprop.getLastChild().getString();

if (objectType != null) {
// Is this a normal property access, or are we trying to override
// an existing property?
boolean isOverride = t.inGlobalScope() &&
parent.getType() == Token.ASSIGN &&
parent.getFirstChild() == getprop;

// Find the lowest property defined on a class with visibility
// information.
if (isOverride) {
objectType = objectType.getImplicitPrototype();
}
JSDocInfo docInfo = null;
for (; objectType != null;
objectType = objectType.getImplicitPrototype()) {
docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
if (docInfo != null &&
docInfo.getVisibility() != Visibility.INHERITED) {
break;
}
}

if (objectType == null) {
// We couldn't find a visibility modifier; assume it's public.
return;
}

boolean sameInput =
t.getInput().getName().equals(docInfo.getSourceName());
Visibility visibility = docInfo.getVisibility();
JSType ownerType = normalizeClassType(objectType);
if (isOverride) {
// Check an ASSIGN statement that's trying to override a property
// on a superclass.
JSDocInfo overridingInfo = parent.getJSDocInfo();
Visibility overridingVisibility = overridingInfo == null ?
Visibility.INHERITED : overridingInfo.getVisibility();

// Check that (a) the property *can* be overridden, and
// (b) that the visibility of the override is the same as the
// visibility of the original property.
if (visibility == Visibility.PRIVATE && !sameInput) {
compiler.report(
t.makeError(getprop, PRIVATE_OVERRIDE,
objectType.toString()));
} else if (overridingVisibility != Visibility.INHERITED &&
overridingVisibility != visibility) {
compiler.report(
t.makeError(getprop, VISIBILITY_MISMATCH,
visibility.name(), objectType.toString(),
overridingVisibility.name()));
}
} else {
if (sameInput) {
// private access is always allowed in the same file.
return;
} else if (visibility == Visibility.PRIVATE &&
(currentClass == null || ownerType.differsFrom(currentClass))) {
if (docInfo.isConstructor() &&
isValidPrivateConstructorAccess(parent)) {
return;
}

// private access is not allowed outside the file from a different
// enclosing class.
compiler.report(
t.makeError(getprop,
BAD_PRIVATE_PROPERTY_ACCESS,
propertyName,
validator.getReadableJSTypeName(
getprop.getFirstChild(), true)));
} else if (visibility == Visibility.PROTECTED) {
// There are 3 types of legal accesses of a protected property:
// 1) Accesses in the same file
// 2) Overriding the property in a subclass
// 3) Accessing the property from inside a subclass
// The first two have already been checked for.
if (currentClass == null || !currentClass.isSubtype(ownerType)) {
compiler.report(
t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,
propertyName,
validator.getReadableJSTypeName(
getprop.getFirstChild(), true)));
}
}
}
}
}"
Closure_73b_1,/path/to/defects4j_buggy/Closure_73_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"static String strEscape(String s, char quote,
String doublequoteEscape,"
Closure_77b_1,/path/to/defects4j_buggy/Closure_77_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"static String strEscape(String s, char quote,
String doublequoteEscape,"
Closure_78b_1,/path/to/defects4j_buggy/Closure_78_buggy/src/com/google/javascript/jscomp/PeepholeFoldConstants.java,"private Node performArithmeticOp(int opType, Node left, Node right) {
// Unlike other operations, ADD operands are not always converted
// to Number.
if (opType == Token.ADD
&& (NodeUtil.mayBeString(left, false)
|| NodeUtil.mayBeString(right, false))) {
return null;
}

double result;

// TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN
// to zero so this is a little akward here.

Double lValObj = NodeUtil.getNumberValue(left);
if (lValObj == null) {
return null;
}
Double rValObj = NodeUtil.getNumberValue(right);
if (rValObj == null) {
return null;
}

double lval = lValObj;
double rval = rValObj;

switch (opType) {
case Token.BITAND:
result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
break;
case Token.BITOR:
result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
break;
case Token.BITXOR:
result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
break;
case Token.ADD:
result = lval + rval;
break;
case Token.SUB:
result = lval - rval;
break;
case Token.MUL:
result = lval * rval;
break;
case Token.MOD:
if (rval == 0) {
error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
return null;
}
result = lval % rval;
break;
case Token.DIV:
if (rval == 0) {
error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
return null;
}
result = lval / rval;
break;
default:
throw new Error(""Unexpected arithmetic operator"");
}

// TODO(johnlenz): consider removing the result length check.
// length of the left and right value plus 1 byte for the operator.
if (String.valueOf(result).length() <=
String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&

// Do not try to fold arithmetic for numbers > 2^53. After that
// point, fixed-point math starts to break down and become inaccurate.
Math.abs(result) <= MAX_FOLD_NUMBER) {
Node newNumber = Node.newNumber(result);
return newNumber;
} else if (Double.isNaN(result)) {
return Node.newString(Token.NAME, ""NaN"");
} else if (result == Double.POSITIVE_INFINITY) {
return Node.newString(Token.NAME, ""Infinity"");
} else if (result == Double.NEGATIVE_INFINITY) {
return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
}

return null;
}"
Closure_81b_1,/path/to/defects4j_buggy/Closure_81_buggy/src/com/google/javascript/jscomp/parsing/IRFactory.java,"private Node transform(AstNode node) {
JSDocInfo jsDocInfo = handleJsDoc(node);
Node irNode = justTransform(node);
if (jsDocInfo != null) {
irNode.setJSDocInfo(jsDocInfo);
}

// If we have a named function, set the position to that of the name.
if (irNode.getType() == Token.FUNCTION &&
irNode.getFirstChild().getLineno() != -1) {
irNode.setLineno(irNode.getFirstChild().getLineno());
irNode.setCharno(irNode.getFirstChild().getCharno());
} else {
if (irNode.getLineno() == -1) {
// If we didn't already set the line, then set it now.  This avoids
// cases like ParenthesizedExpression where we just return a previous
// node, but don't want the new node to get its parent's line number.
int lineno = node.getLineno();
irNode.setLineno(lineno);
int charno = position2charno(node.getAbsolutePosition());
irNode.setCharno(charno);
}
}
return irNode;
}"
Closure_82b_1,/path/to/defects4j_buggy/Closure_82_buggy/src/com/google/javascript/rhino/jstype/JSType.java,"public JSType findPropertyType(String propertyName) {
ObjectType autoboxObjType = ObjectType.cast(autoboxesTo());
if (autoboxObjType != null) {
return autoboxObjType.findPropertyType(propertyName);
}

return null;
}"
Closure_83b_1,/path/to/defects4j_buggy/Closure_83_buggy/src/com/google/javascript/jscomp/CommandLineRunner.java,"private void initConfigFromFlags(String[] args, PrintStream err) {
// Args4j has a different format that the old command-line parser.
// So we use some voodoo to get the args into the format that args4j
// expects.
Pattern argPattern = Pattern.compile(""(--[a-zA-Z_]+)=(.*)"");
Pattern quotesPattern = Pattern.compile(""^['\""](.*)['\""]$"");
List<String> processedArgs = Lists.newArrayList();
for (String arg : args) {
Matcher matcher = argPattern.matcher(arg);
if (matcher.matches()) {
processedArgs.add(matcher.group(1));

String value = matcher.group(2);
Matcher quotesMatcher = quotesPattern.matcher(value);
if (quotesMatcher.matches()) {
processedArgs.add(quotesMatcher.group(1));
} else {
processedArgs.add(value);
}
} else {
processedArgs.add(arg);
}
}

CmdLineParser parser = new CmdLineParser(flags);
isConfigValid = true;
try {
parser.parseArgument(processedArgs.toArray(new String[] {}));
} catch (CmdLineException e) {
err.println(e.getMessage());
isConfigValid = false;
}

if (flags.version) {
ResourceBundle config = ResourceBundle.getBundle(configResource);
err.println(
""Closure Compiler (http://code.google.com/closure/compiler)\n"" +
""Version: "" + config.getString(""compiler.version"") + ""\n"" +
""Built on: "" + config.getString(""compiler.date""));
err.flush();
}

if (!isConfigValid || flags.display_help) {
isConfigValid = false;
parser.printUsage(err);
} else {
getCommandLineConfig()
.setPrintTree(flags.print_tree)
.setComputePhaseOrdering(flags.compute_phase_ordering)
.setPrintAst(flags.print_ast)
.setPrintPassGraph(flags.print_pass_graph)
.setJscompDevMode(flags.jscomp_dev_mode)
.setLoggingLevel(flags.logging_level)
.setExterns(flags.externs)
.setJs(flags.js)
.setJsOutputFile(flags.js_output_file)
.setModule(flags.module)
.setVariableMapInputFile(flags.variable_map_input_file)
.setPropertyMapInputFile(flags.property_map_input_file)
.setVariableMapOutputFile(flags.variable_map_output_file)
.setCreateNameMapFiles(flags.create_name_map_files)
.setPropertyMapOutputFile(flags.property_map_output_file)
.setCodingConvention(flags.third_party ?
new DefaultCodingConvention() :
new ClosureCodingConvention())
.setSummaryDetailLevel(flags.summary_detail_level)
.setOutputWrapper(flags.output_wrapper)
.setOutputWrapperMarker(flags.output_wrapper_marker)
.setModuleWrapper(flags.module_wrapper)
.setModuleOutputPathPrefix(flags.module_output_path_prefix)
.setCreateSourceMap(flags.create_source_map)
.setJscompError(flags.jscomp_error)
.setJscompWarning(flags.jscomp_warning)
.setJscompOff(flags.jscomp_off)
.setDefine(flags.define)
.setCharset(flags.charset)
.setManageClosureDependencies(flags.manage_closure_dependencies)
.setClosureEntryPoints(flags.closure_entry_point)
.setOutputManifest(flags.output_manifest);
}
}"
Closure_86b_1,/path/to/defects4j_buggy/Closure_86_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"return functionCallHasSideEffects(callNode, null);
}

/**
* Returns true if calls to this function have side effects.
*
* @param callNode The call node to inspected.
* @param compiler A compiler object to provide program state changing
*     context information. Can be null.
*/
static boolean functionCallHasSideEffects(
Node callNode, @Nullable AbstractCompiler compiler) {"
Closure_87b_1,/path/to/defects4j_buggy/Closure_87_buggy/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,"private Node tryMinimizeIf(Node n) {

Node parent = n.getParent();

Node cond = n.getFirstChild();

/* If the condition is a literal, we'll let other
* optimizations try to remove useless code.
*/
if (NodeUtil.isLiteralValue(cond, true)) {
return n;
}

Node thenBranch = cond.getNext();
Node elseBranch = thenBranch.getNext();

if (elseBranch == null) {
if (isFoldableExpressBlock(thenBranch)) {
Node expr = getBlockExpression(thenBranch);
if (isPropertyAssignmentInExpression(expr)) {
// Keep opportunities for CollapseProperties such as
// a.longIdentifier || a.longIdentifier = ... -> var a = ...;
return n;
}

if (cond.getType() == Token.NOT) {
// if(!x)bar(); -> x||bar();
if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&
isLowerPrecedenceInExpression(expr.getFirstChild(),
OR_PRECEDENCE)) {
// It's not okay to add two sets of parentheses.
return n;
}

Node or = new Node(Token.OR, cond.removeFirstChild(),
expr.removeFirstChild()).copyInformationFrom(n);
Node newExpr = NodeUtil.newExpr(or);
parent.replaceChild(n, newExpr);
reportCodeChange();

return newExpr;
}

// if(x)foo(); -> x&&foo();
if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) ||
isLowerPrecedenceInExpression(expr.getFirstChild(),
AND_PRECEDENCE)) {
// One additional set of parentheses isn't worth it.
return n;
}

n.removeChild(cond);
Node and = new Node(Token.AND, cond, expr.removeFirstChild())
.copyInformationFrom(n);
Node newExpr = NodeUtil.newExpr(and);
parent.replaceChild(n, newExpr);
reportCodeChange();

return newExpr;
}

return n;
}

/* TODO(dcc) This modifies the siblings of n, which is undesirable for a
* peephole optimization. This should probably get moved to another pass.
*/
tryRemoveRepeatedStatements(n);

// if(!x)foo();else bar(); -> if(x)bar();else foo();
// An additional set of curly braces isn't worth it.
if (cond.getType() == Token.NOT && !consumesDanglingElse(elseBranch)) {
n.replaceChild(cond, cond.removeFirstChild());
n.removeChild(thenBranch);
n.addChildToBack(thenBranch);
reportCodeChange();
return n;
}

// if(x)return 1;else return 2; -> return x?1:2;
if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
Node thenExpr = getBlockReturnExpression(thenBranch);
Node elseExpr = getBlockReturnExpression(elseBranch);
n.removeChild(cond);
thenExpr.detachFromParent();
elseExpr.detachFromParent();

// note - we ignore any cases with ""return;"", technically this
// can be converted to ""return undefined;"" or some variant, but
// that does not help code size.
Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)
.copyInformationFrom(n);
Node returnNode = new Node(Token.RETURN, hookNode);
parent.replaceChild(n, returnNode);
reportCodeChange();
return returnNode;
}

boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);

if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
Node thenOp = getBlockExpression(thenBranch).getFirstChild();
Node elseOp = getBlockExpression(elseBranch).getFirstChild();
if (thenOp.getType() == elseOp.getType()) {
// if(x)a=1;else a=2; -> a=x?1:2;
if (NodeUtil.isAssignmentOp(thenOp)) {
Node lhs = thenOp.getFirstChild();
if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&
// if LHS has side effects, don't proceed [since the optimization
// evaluates LHS before cond]
// NOTE - there are some circumstances where we can
// proceed even if there are side effects...
!mayEffectMutableState(lhs)) {

n.removeChild(cond);
Node assignName = thenOp.removeFirstChild();
Node thenExpr = thenOp.removeFirstChild();
Node elseExpr = elseOp.getLastChild();
elseOp.removeChild(elseExpr);

Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)
.copyInformationFrom(n);
Node assign = new Node(thenOp.getType(), assignName, hookNode)
.copyInformationFrom(thenOp);
Node expr = NodeUtil.newExpr(assign);
parent.replaceChild(n, expr);
reportCodeChange();

return expr;
}
} else if (NodeUtil.isCall(thenOp)) {
// if(x)foo();else bar(); -> x?foo():bar()
n.removeChild(cond);
thenOp.detachFromParent();
elseOp.detachFromParent();
Node hookNode = new Node(Token.HOOK, cond, thenOp, elseOp)
.copyInformationFrom(n);
Node expr = NodeUtil.newExpr(hookNode);
parent.replaceChild(n, expr);
reportCodeChange();

return expr;
}
}
return n;
}

boolean thenBranchIsVar = isVarBlock(thenBranch);
boolean elseBranchIsVar = isVarBlock(elseBranch);

// if(x)var y=1;else y=2  ->  var y=x?1:2
if (thenBranchIsVar && elseBranchIsExpressionBlock &&
NodeUtil.isAssign(getBlockExpression(elseBranch).getFirstChild())) {

Node var = getBlockVar(thenBranch);
Node elseAssign = getBlockExpression(elseBranch).getFirstChild();

Node name1 = var.getFirstChild();
Node maybeName2 = elseAssign.getFirstChild();

if (name1.hasChildren()
&& maybeName2.getType() == Token.NAME
&& name1.getString().equals(maybeName2.getString())) {
Node thenExpr = name1.removeChildren();
Node elseExpr = elseAssign.getLastChild().detachFromParent();
cond.detachFromParent();
Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)
.copyInformationFrom(n);
var.detachFromParent();
name1.addChildrenToBack(hookNode);
parent.replaceChild(n, var);
reportCodeChange();
return var;
}

// if(x)y=1;else var y=2  ->  var y=x?1:2
} else if (elseBranchIsVar && thenBranchIsExpressionBlock &&
NodeUtil.isAssign(getBlockExpression(thenBranch).getFirstChild())) {

Node var = getBlockVar(elseBranch);
Node thenAssign = getBlockExpression(thenBranch).getFirstChild();

Node maybeName1 = thenAssign.getFirstChild();
Node name2 = var.getFirstChild();

if (name2.hasChildren()
&& maybeName1.getType() == Token.NAME
&& maybeName1.getString().equals(name2.getString())) {
Node thenExpr = thenAssign.getLastChild().detachFromParent();
Node elseExpr = name2.removeChildren();
cond.detachFromParent();
Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)
.copyInformationFrom(n);
var.detachFromParent();
name2.addChildrenToBack(hookNode);
parent.replaceChild(n, var);
reportCodeChange();

return var;
}
}

return n;
}"
Closure_88b_1,/path/to/defects4j_buggy/Closure_88_buggy/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java,"private boolean isVariableStillLiveWithinExpression(
Node n, Node exprRoot, String variable) {
while (n != exprRoot) {
for(Node sibling = n.getNext(); sibling != null;
sibling = sibling.getNext()) {
if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {
VariableLiveness state = isVariableReadBeforeKill(sibling, variable);

// If we see a READ or KILL there is no need to continue.
if (state == VariableLiveness.READ) {
return true;
} else if (state == VariableLiveness.KILL) {
return false;
}
}
}
n = n.getParent();
}
return false;
}"
Closure_91b_1,/path/to/defects4j_buggy/Closure_91_buggy/src/com/google/javascript/jscomp/CheckGlobalThis.java,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

if (n.getType() == Token.FUNCTION) {
// Don't traverse functions that are constructors or have the @this
// or @override annotation.
JSDocInfo jsDoc = getFunctionJsDocInfo(n);
if (jsDoc != null &&
(jsDoc.isConstructor() ||
jsDoc.isInterface() ||
jsDoc.hasThisType() ||
jsDoc.isOverride())) {
return false;
}

// Don't traverse functions unless they would normally
// be able to have a @this annotation associated with them. e.g.,
// var a = function() { }; // or
// function a() {} // or
// a.x = function() {}; // or
// var a = {x: function() {}};
int pType = parent.getType();
if (!(pType == Token.BLOCK ||
pType == Token.SCRIPT ||
pType == Token.NAME ||
pType == Token.ASSIGN ||

// object literal keys
pType == Token.STRING ||
pType == Token.NUMBER)) {
return false;
}

// Don't traverse functions that are getting lent to a prototype.
}

if (parent != null && parent.getType() == Token.ASSIGN) {
Node lhs = parent.getFirstChild();
Node rhs = lhs.getNext();

if (n == lhs) {
// Always traverse the left side of the assignment. To handle
// nested assignments properly (e.g., (a = this).property = c;),
// assignLhsChild should not be overridden.
if (assignLhsChild == null) {
assignLhsChild = lhs;
}
} else {
// Only traverse the right side if it's not an assignment to a prototype
// property or subproperty.
if (NodeUtil.isGet(lhs)) {
if (lhs.getType() == Token.GETPROP &&
lhs.getLastChild().getString().equals(""prototype"")) {
return false;
}
Node llhs = lhs.getFirstChild();
if (llhs.getType() == Token.GETPROP &&
llhs.getLastChild().getString().equals(""prototype"")) {
return false;
}
}
}
}

return true;
}"
Closure_92b_1,/path/to/defects4j_buggy/Closure_92_buggy/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java,"private static boolean isNamespacePlaceholder(Node n) {
if (!n.getBooleanProp(Node.IS_NAMESPACE)) {
return false;
}

Node value = null;
if (n.getType() == Token.EXPR_RESULT) {
Node assign = n.getFirstChild();
value = assign.getLastChild();
} else if (n.getType() == Token.VAR) {
Node name = n.getFirstChild();
value = name.getFirstChild();
}

return value != null
&& value.getType() == Token.OBJECTLIT
&& !value.hasChildren();
}"
Closure_94b_1,/path/to/defects4j_buggy/Closure_94_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static boolean isValidDefineValue(Node val, Set<String> defines) {
switch (val.getType()) {
case Token.STRING:
case Token.NUMBER:
case Token.TRUE:
case Token.FALSE:
return true;

// Binary operators are only valid if both children are valid.
case Token.BITAND:
case Token.BITNOT:
case Token.BITOR:
case Token.BITXOR:

// Uniary operators are valid if the child is valid.
case Token.NOT:
case Token.NEG:
return isValidDefineValue(val.getFirstChild(), defines);

// Names are valid if and only if they are defines themselves.
case Token.NAME:
case Token.GETPROP:
if (val.isQualifiedName()) {
return defines.contains(val.getQualifiedName());
}
}
return false;
}"
Closure_95b_1,/path/to/defects4j_buggy/Closure_95_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"private static Node getPrototypePropertyOwner(Node n) {
if (n.getType() == Token.GETPROP) {
Node firstChild = n.getFirstChild();
if (firstChild.getType() == Token.GETPROP &&
firstChild.getLastChild().getString().equals(""prototype"")) {
Node maybeOwner = firstChild.getFirstChild();
if (maybeOwner.isQualifiedName()) {
return maybeOwner;
}
}
}
return null;
}"
Closure_96b_1,/path/to/defects4j_buggy/Closure_96_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"public void visit(NodeTraversal t, Node n, Node parent) {
JSType childType;
JSType leftType, rightType;
Node left, right;
// To be explicitly set to false if the node is not typeable.
boolean typeable = true;

switch (n.getType()) {
case Token.NAME:
typeable = visitName(t, n, parent);
break;

case Token.LP:
// If this is under a FUNCTION node, it is a parameter list and can be
// ignored here.
if (parent.getType() != Token.FUNCTION) {
ensureTyped(t, n, getJSType(n.getFirstChild()));
} else {
typeable = false;
}
break;

case Token.COMMA:
ensureTyped(t, n, getJSType(n.getLastChild()));
break;

case Token.TRUE:
case Token.FALSE:
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.THIS:
ensureTyped(t, n, t.getScope().getTypeOfThis());
break;

case Token.REF_SPECIAL:
ensureTyped(t, n);
break;

case Token.GET_REF:
ensureTyped(t, n, getJSType(n.getFirstChild()));
break;

case Token.NULL:
ensureTyped(t, n, NULL_TYPE);
break;

case Token.NUMBER:
if (n.getParent().getType() != Token.OBJECTLIT) {
ensureTyped(t, n, NUMBER_TYPE);
} else {
typeable = false;
}
break;

case Token.ARRAYLIT:
ensureTyped(t, n, ARRAY_TYPE);
break;

case Token.STRING:
if (n.getParent().getType() != Token.OBJECTLIT) {
ensureTyped(t, n, STRING_TYPE);
} else {
typeable = false;
}
break;

case Token.REGEXP:
ensureTyped(t, n, REGEXP_TYPE);
break;

case Token.GETPROP:
visitGetProp(t, n, parent);
typeable = !(parent.getType() == Token.ASSIGN &&
parent.getFirstChild() == n);
break;

case Token.GETELEM:
visitGetElem(t, n);
// The type of GETELEM is always unknown, so no point counting that.
// If that unknown leaks elsewhere (say by an assignment to another
// variable), then it will be counted.
typeable = false;
break;

case Token.VAR:
visitVar(t, n);
typeable = false;
break;

case Token.NEW:
visitNew(t, n);
typeable = true;
break;

case Token.CALL:
visitCall(t, n);
typeable = !NodeUtil.isExpressionNode(parent);
break;

case Token.RETURN:
visitReturn(t, n);
typeable = false;
break;

case Token.DEC:
case Token.INC:
left = n.getFirstChild();
validator.expectNumber(
t, left, getJSType(left), ""increment/decrement"");
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.NOT:
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.VOID:
ensureTyped(t, n, VOID_TYPE);
break;

case Token.TYPEOF:
ensureTyped(t, n, STRING_TYPE);
break;

case Token.BITNOT:
childType = getJSType(n.getFirstChild());
if (!childType.matchesInt32Context()) {
report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),
childType.toString());
}
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.POS:
case Token.NEG:
left = n.getFirstChild();
validator.expectNumber(t, left, getJSType(left), ""sign operator"");
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.EQ:
case Token.NE: {
leftType = getJSType(n.getFirstChild());
rightType = getJSType(n.getLastChild());

JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
TernaryValue result =
leftTypeRestricted.testForEquality(rightTypeRestricted);
if (result != TernaryValue.UNKNOWN) {
if (n.getType() == Token.NE) {
result = result.not();
}
report(t, n, DETERMINISTIC_TEST, leftType.toString(),
rightType.toString(), result.toString());
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;
}

case Token.SHEQ:
case Token.SHNE: {
leftType = getJSType(n.getFirstChild());
rightType = getJSType(n.getLastChild());

JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
if (!leftTypeRestricted.canTestForShallowEqualityWith(
rightTypeRestricted)) {
report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),
rightType.toString());
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;
}

case Token.LT:
case Token.LE:
case Token.GT:
case Token.GE:
leftType = getJSType(n.getFirstChild());
rightType = getJSType(n.getLastChild());
if (rightType.isNumber()) {
validator.expectNumber(
t, n, leftType, ""left side of numeric comparison"");
} else if (leftType.isNumber()) {
validator.expectNumber(
t, n, rightType, ""right side of numeric comparison"");
} else if (leftType.matchesNumberContext() &&
rightType.matchesNumberContext()) {
// OK.
} else {
// Whether the comparison is numeric will be determined at runtime
// each time the expression is evaluated. Regardless, both operands
// should match a string context.
String message = ""left side of comparison"";
validator.expectString(t, n, leftType, message);
validator.expectNotVoid(
t, n, leftType, message, getNativeType(STRING_TYPE));
message = ""right side of comparison"";
validator.expectString(t, n, rightType, message);
validator.expectNotVoid(
t, n, rightType, message, getNativeType(STRING_TYPE));
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.IN:
left = n.getFirstChild();
right = n.getLastChild();
leftType = getJSType(left);
rightType = getJSType(right);
validator.expectObject(t, n, rightType, ""'in' requires an object"");
validator.expectString(t, left, leftType, ""left side of 'in'"");
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.INSTANCEOF:
left = n.getFirstChild();
right = n.getLastChild();
leftType = getJSType(left);
rightType = getJSType(right).restrictByNotNullOrUndefined();

validator.expectAnyObject(
t, left, leftType, ""deterministic instanceof yields false"");
validator.expectActualObject(
t, right, rightType, ""instanceof requires an object"");
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.ASSIGN:
visitAssign(t, n);
typeable = false;
break;

case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_SUB:
case Token.ASSIGN_ADD:
case Token.ASSIGN_MUL:
case Token.LSH:
case Token.RSH:
case Token.URSH:
case Token.DIV:
case Token.MOD:
case Token.BITOR:
case Token.BITXOR:
case Token.BITAND:
case Token.SUB:
case Token.ADD:
case Token.MUL:
visitBinaryOperator(n.getType(), t, n);
break;

case Token.DELPROP:
if (!isReference(n.getFirstChild())) {
report(t, n, BAD_DELETE);
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.CASE:
JSType switchType = getJSType(parent.getFirstChild());
JSType caseType = getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t, n, switchType, caseType);
typeable = false;
break;

case Token.WITH: {
Node child = n.getFirstChild();
childType = getJSType(child);
validator.expectObject(
t, child, childType, ""with requires an object"");
typeable = false;
break;
}

case Token.FUNCTION:
visitFunction(t, n);
break;

// These nodes have no interesting type behavior.
case Token.LABEL:
case Token.LABEL_NAME:
case Token.SWITCH:
case Token.BREAK:
case Token.CATCH:
case Token.TRY:
case Token.SCRIPT:
case Token.EXPR_RESULT:
case Token.BLOCK:
case Token.EMPTY:
case Token.DEFAULT:
case Token.CONTINUE:
case Token.DEBUGGER:
case Token.THROW:
typeable = false;
break;

// These nodes require data flow analysis.
case Token.DO:
case Token.FOR:
case Token.IF:
case Token.WHILE:
typeable = false;
break;

// These nodes are typed during the type inference.
case Token.AND:
case Token.HOOK:
case Token.OBJECTLIT:
case Token.OR:
if (n.getJSType() != null) { // If we didn't run type inference.
ensureTyped(t, n);
} else {
// If this is an enum, then give that type to the objectlit as well.
if ((n.getType() == Token.OBJECTLIT)
&& (parent.getJSType() instanceof EnumType)) {
ensureTyped(t, n, parent.getJSType());
} else {
ensureTyped(t, n);
}
}
break;

default:
report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
ensureTyped(t, n);
break;
}

// Don't count externs since the user's code may not even use that part.
typeable = typeable && !inExterns;

if (typeable) {
doPercentTypedAccounting(t, n);
}

checkNoTypeCheckSection(n, false);
}"
Closure_97b_1,/path/to/defects4j_buggy/Closure_97_buggy/src/com/google/javascript/jscomp/PeepholeFoldConstants.java,"private Node tryFoldShift(Node n, Node left, Node right) {
if (left.getType() == Token.NUMBER &&
right.getType() == Token.NUMBER) {

double result;
double lval = left.getDouble();
double rval = right.getDouble();

// check ranges.  We do not do anything that would clip the double to
// a 32-bit range, since the user likely does not intend that.
if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {
error(BITWISE_OPERAND_OUT_OF_RANGE, left);
return n;
}

// only the lower 5 bits are used when shifting, so don't do anything
// if the shift amount is outside [0,32)
if (!(rval >= 0 && rval < 32)) {
error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
return n;
}

// Convert the numbers to ints
int lvalInt = (int) lval;
if (lvalInt != lval) {
error(FRACTIONAL_BITWISE_OPERAND, left);
return n;
}

int rvalInt = (int) rval;
if (rvalInt != rval) {
error(FRACTIONAL_BITWISE_OPERAND, right);
return n;
}

switch (n.getType()) {
case Token.LSH:
result = lvalInt << rvalInt;
break;
case Token.RSH:
result = lvalInt >> rvalInt;
break;
case Token.URSH:
// JavaScript handles zero shifts on signed numbers differently than
// Java as an Java int can not represent the unsigned 32-bit number
// where JavaScript can so use a long here.
result = lvalInt >>> rvalInt;
break;
default:
throw new AssertionError(""Unknown shift operator: "" +
Node.tokenToName(n.getType()));
}

Node newNumber = Node.newNumber(result);
n.getParent().replaceChild(n, newNumber);
reportCodeChange();

return newNumber;
}

return n;
}"
Closure_99b_1,/path/to/defects4j_buggy/Closure_99_buggy/src/com/google/javascript/jscomp/CheckGlobalThis.java,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

if (n.getType() == Token.FUNCTION) {
// Don't traverse functions that are constructors or have the @this
// or @override annotation.
JSDocInfo jsDoc = getFunctionJsDocInfo(n);
if (jsDoc != null &&
(jsDoc.isConstructor() ||
jsDoc.hasThisType() ||
jsDoc.isOverride())) {
return false;
}

// Don't traverse functions unless they would normally
// be able to have a @this annotation associated with them. e.g.,
// var a = function() { }; // or
// function a() {} // or
// a.x = function() {};
int pType = parent.getType();
if (!(pType == Token.BLOCK ||
pType == Token.SCRIPT ||
pType == Token.NAME ||
pType == Token.ASSIGN)) {
return false;
}
}

if (parent != null && parent.getType() == Token.ASSIGN) {
Node lhs = parent.getFirstChild();
Node rhs = lhs.getNext();

if (n == lhs) {
// Always traverse the left side of the assignment. To handle
// nested assignments properly (e.g., (a = this).property = c;),
// assignLhsChild should not be overridden.
if (assignLhsChild == null) {
assignLhsChild = lhs;
}
} else {
// Only traverse the right side if it's not an assignment to a prototype
// property or subproperty.
if (lhs.getType() == Token.GETPROP &&
lhs.getLastChild().getString().equals(""prototype"")) {
return false;
}
if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) {
return false;
}
}
}

return true;
}"
Closure_101b_1,/path/to/defects4j_buggy/Closure_101_buggy/src/com/google/javascript/jscomp/CommandLineRunner.java,"private void initConfigFromFlags(
String[] args, PrintStream err)"
Closure_102b_1,/path/to/defects4j_buggy/Closure_102_buggy/src/com/google/javascript/jscomp/Normalize.java,"private void splitVarDeclarations(Node n) {
for (Node next, c = n.getFirstChild(); c != null; c = next) {
next = c.getNext();
if (c.getType() == Token.VAR) {
if (assertOnChange && !c.hasChildren()) {
throw new IllegalStateException(""Empty VAR node."");
}

while (c.getFirstChild() != c.getLastChild()) {
Node name = c.getFirstChild();
c.removeChild(name);
Node newVar = new Node(Token.VAR, name, n.getLineno(), n.getCharno());
n.addChildBefore(newVar, c);
reportCodeChange(""VAR with multiple children"");
}
}
}
}"
Closure_104b_1,/path/to/defects4j_buggy/Closure_104_buggy/src/com/google/javascript/rhino/jstype/UnionType.java,"JSType meet(JSType that) {
UnionTypeBuilder builder = new UnionTypeBuilder(registry);
for (JSType alternate : alternates) {
if (alternate.isSubtype(that)) {
builder.addAlternate(alternate);
}
}

if (that instanceof UnionType) {
for (JSType otherAlternate : ((UnionType) that).alternates) {
if (otherAlternate.isSubtype(this)) {
builder.addAlternate(otherAlternate);
}
}
} else if (that.isSubtype(this)) {
builder.addAlternate(that);
}
JSType result = builder.build();
if (result != null) {
return result;
} else if (this.isObject() && that.isObject()) {
return getNativeType(JSTypeNative.NO_OBJECT_TYPE);
} else {
return getNativeType(JSTypeNative.NO_TYPE);
}
}"
Closure_105b_1,/path/to/defects4j_buggy/Closure_105_buggy/src/com/google/javascript/jscomp/FoldConstants.java,"void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,
Node parent) {
if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
return;
}

Node arrayNode = left.getFirstChild();
Node functionName = arrayNode.getNext();

if ((arrayNode.getType() != Token.ARRAYLIT) ||
!functionName.getString().equals(""join"")) {
return;
}

String joinString = NodeUtil.getStringValue(right);
List<Node> arrayFoldedChildren = Lists.newLinkedList();
StringBuilder sb = new StringBuilder();
int foldedSize = 0;
Node elem = arrayNode.getFirstChild();
// Merges adjacent String nodes.
while (elem != null) {
if (NodeUtil.isImmutableValue(elem)) {
if (sb.length() > 0) {
sb.append(joinString);
}
sb.append(NodeUtil.getStringValue(elem));
} else {
if (sb.length() > 0) {
// + 2 for the quotes.
foldedSize += sb.length() + 2;
arrayFoldedChildren.add(Node.newString(sb.toString()));
sb = new StringBuilder();
}
foldedSize += InlineCostEstimator.getCost(elem);
arrayFoldedChildren.add(elem);
}
elem = elem.getNext();
}

if (sb.length() > 0) {
// + 2 for the quotes.
foldedSize += sb.length() + 2;
arrayFoldedChildren.add(Node.newString(sb.toString()));
}
// one for each comma.
foldedSize += arrayFoldedChildren.size() - 1;

int originalSize = InlineCostEstimator.getCost(n);
switch (arrayFoldedChildren.size()) {
case 0:
Node emptyStringNode = Node.newString("""");
parent.replaceChild(n, emptyStringNode);
break;

case 1:
Node foldedStringNode = arrayFoldedChildren.remove(0);
if (foldedSize > originalSize) {
return;
}
arrayNode.detachChildren();
if (foldedStringNode.getType() != Token.STRING) {
// If the Node is not a string literal, ensure that
// it is coerced to a string.
Node replacement = new Node(Token.ADD,
Node.newString(""""), foldedStringNode);
foldedStringNode = replacement;
}
parent.replaceChild(n, foldedStringNode);
break;

default:
// No folding could actually be performed.
if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
return;
}
int kJoinOverhead = ""[].join()"".length();
foldedSize += kJoinOverhead;
foldedSize += InlineCostEstimator.getCost(right);
if (foldedSize > originalSize) {
return;
}
arrayNode.detachChildren();
for (Node node : arrayFoldedChildren) {
arrayNode.addChildToBack(node);
}
break;
}
t.getCompiler().reportCodeChange();
}"
Closure_107b_1,/path/to/defects4j_buggy/Closure_107_buggy/src/com/google/javascript/jscomp/CommandLineRunner.java,"protected CompilerOptions createOptions() {
CompilerOptions options = new CompilerOptions();
if (flags.processJqueryPrimitives) {
options.setCodingConvention(new JqueryCodingConvention());
} else {
options.setCodingConvention(new ClosureCodingConvention());
}

options.setExtraAnnotationNames(flags.extraAnnotationName);

CompilationLevel level = flags.compilationLevel;
level.setOptionsForCompilationLevel(options);

if (flags.debug) {
level.setDebugOptionsForCompilationLevel(options);
}

if (flags.useTypesForOptimization) {
level.setTypeBasedOptimizationOptions(options);
}

if (flags.generateExports) {
options.setGenerateExports(flags.generateExports);
}

WarningLevel wLevel = flags.warningLevel;
wLevel.setOptionsForWarningLevel(options);
for (FormattingOption formattingOption : flags.formatting) {
formattingOption.applyToOptions(options);
}

options.closurePass = flags.processClosurePrimitives;

options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&
flags.processJqueryPrimitives;

options.angularPass = flags.angularPass;

if (!flags.translationsFile.isEmpty()) {
try {
options.messageBundle = new XtbMessageBundle(
new FileInputStream(flags.translationsFile),
flags.translationsProject);
} catch (IOException e) {
throw new RuntimeException(""Reading XTB file"", e);
}
} else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {
// In SIMPLE or WHITESPACE mode, if the user hasn't specified a
// translations file, they might reasonably try to write their own
// implementation of goog.getMsg that makes the substitution at
// run-time.
//
// In ADVANCED mode, goog.getMsg is going to be renamed anyway,
// so we might as well inline it. But shut off the i18n warnings,
// because the user didn't really ask for i18n.
options.messageBundle = new EmptyMessageBundle();
}

return options;
}"
Closure_109b_1,/path/to/defects4j_buggy/Closure_109_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,"private Node parseTypeName(JsDocToken token) {
if (token != JsDocToken.STRING) {
return reportGenericTypeSyntaxWarning();
}

String typeName = stream.getString();
int lineno = stream.getLineno();
int charno = stream.getCharno();
while (match(JsDocToken.EOL) &&
typeName.charAt(typeName.length() - 1) == '.') {
skipEOLs();
if (match(JsDocToken.STRING)) {
next();
typeName += stream.getString();
}
}

Node typeNameNode = newStringNode(typeName, lineno, charno);

if (match(JsDocToken.LT)) {
next();
skipEOLs();
Node memberType = parseTypeExpressionList(next());
if (memberType != null) {
typeNameNode.addChildToFront(memberType);

skipEOLs();
if (!match(JsDocToken.GT)) {
return reportTypeSyntaxWarning(""msg.jsdoc.missing.gt"");
}

next();
}
}
return typeNameNode;
}"
Closure_111b_1,/path/to/defects4j_buggy/Closure_111_buggy/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java,"public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,
FlowScope blindScope, boolean outcome) {
if (condition.isCall() && condition.getChildCount() == 2) {
Node callee = condition.getFirstChild();
Node param = condition.getLastChild();
if (callee.isGetProp() && param.isQualifiedName()) {
JSType paramType =  getTypeIfRefinable(param, blindScope);
Node left = callee.getFirstChild();
Node right = callee.getLastChild();
if (left.isName() && ""goog"".equals(left.getString()) &&
right.isString()) {
Function<TypeRestriction, JSType> restricter =
restricters.get(right.getString());
if (restricter != null) {
return restrictParameter(param, paramType, blindScope, restricter,
outcome);
}
}
}
}
return nextPreciserScopeKnowingConditionOutcome(
condition, blindScope, outcome);
}"
Closure_112b_1,/path/to/defects4j_buggy/Closure_112_buggy/src/com/google/javascript/jscomp/TypeInference.java,"private JSType getPropertyType(JSType objType, String propName,
Node n, FlowScope scope) {
// We often have a couple of different types to choose from for the
// property. Ordered by accuracy, we have
// 1) A locally inferred qualified name (which is in the FlowScope)
// 2) A globally declared qualified name (which is in the FlowScope)
// 3) A property on the owner type (which is on objType)
// 4) A name in the type registry (as a last resort)
JSType propertyType = null;
boolean isLocallyInferred = false;

// Scopes sometimes contain inferred type info about qualified names.
String qualifiedName = n.getQualifiedName();
StaticSlot<JSType> var = scope.getSlot(qualifiedName);
if (var != null) {
JSType varType = var.getType();
if (varType != null) {
boolean isDeclared = !var.isTypeInferred();
isLocallyInferred = (var != syntacticScope.getSlot(qualifiedName));
if (isDeclared || isLocallyInferred) {
propertyType = varType;
}
}
}

if (propertyType == null && objType != null) {
JSType foundType = objType.findPropertyType(propName);
if (foundType != null) {
propertyType = foundType;
}
}

if (propertyType != null && objType != null) {
JSType restrictedObjType = objType.restrictByNotNullOrUndefined();
if (!restrictedObjType.getTemplateTypeMap().isEmpty()
&& propertyType.hasAnyTemplateTypes()) {
TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();
TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(
registry, typeMap);
propertyType = propertyType.visit(replacer);
}
}

if ((propertyType == null || propertyType.isUnknownType())
&& qualifiedName != null) {
// If we find this node in the registry, then we can infer its type.
ObjectType regType = ObjectType.cast(registry.getType(qualifiedName));
if (regType != null) {
propertyType = regType.getConstructor();
}
}

if (propertyType == null) {
return unknownType;
} else if (propertyType.isEquivalentTo(unknownType) && isLocallyInferred) {
// If the type has been checked in this scope,
// then use CHECKED_UNKNOWN_TYPE instead to indicate that.
return getNativeType(CHECKED_UNKNOWN_TYPE);
} else {
return propertyType;
}
}"
Closure_113b_1,/path/to/defects4j_buggy/Closure_113_buggy/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java,"public void process(Node externs, Node root) {
new NodeTraversal(compiler, this).traverse(root);

for (Node n : defineCalls) {
replaceGoogDefines(n);
}

for (ProvidedName pn : providedNames.values()) {
pn.replace();
}

if (requiresLevel.isOn()) {
for (UnrecognizedRequire r : unrecognizedRequires) {
DiagnosticType error;
ProvidedName expectedName = providedNames.get(r.namespace);
if (expectedName != null && expectedName.firstNode != null) {
// The namespace ended up getting provided after it was required.
error = LATE_PROVIDE_ERROR;
} else {
error = MISSING_PROVIDE_ERROR;
}

compiler.report(JSError.make(
r.inputName, r.requireNode, requiresLevel, error, r.namespace));
}
}
}"
Closure_114b_1,/path/to/defects4j_buggy/Closure_114_buggy/src/com/google/javascript/jscomp/NameAnalyzer.java,"private void replaceWithRhs(Node parent, Node n) {
if (valueConsumedByParent(n, parent)) {
// parent reads from n directly; replace it with n's rhs + lhs
// subexpressions with side effects.
List<Node> replacements = getRhsSubexpressions(n);
List<Node> newReplacements = Lists.newArrayList();
for (int i = 0; i < replacements.size() - 1; i++) {
newReplacements.addAll(getSideEffectNodes(replacements.get(i)));
}
Node valueExpr = replacements.get(replacements.size() - 1);
valueExpr.detachFromParent();
newReplacements.add(valueExpr);
changeProxy.replaceWith(
parent, n, collapseReplacements(newReplacements));
} else if (n.isAssign() && !parent.isFor()) {
// assignment appears in a RHS expression.  we have already
// considered names in the assignment's RHS as being referenced;
// replace the assignment with its RHS.
// TODO(user) make the pass smarter about these cases and/or run
// this pass and RemoveConstantExpressions together in a loop.
Node replacement = n.getLastChild();
replacement.detachFromParent();
changeProxy.replaceWith(parent, n, replacement);
} else {
replaceTopLevelExpressionWithRhs(parent, n);
}
}"
Closure_115b_1,/path/to/defects4j_buggy/Closure_115_buggy/src/com/google/javascript/jscomp/FunctionInjector.java,"private CanInlineResult canInlineReferenceDirectly(
Node callNode, Node fnNode) {
if (!isDirectCallNodeReplacementPossible(fnNode)) {
return CanInlineResult.NO;
}

Node block = fnNode.getLastChild();

boolean hasSideEffects = false;
if (block.hasChildren()) {
Preconditions.checkState(block.hasOneChild());
Node stmt = block.getFirstChild();
if (stmt.isReturn()) {
hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
}
}
// CALL NODE: [ NAME, ARG1, ARG2, ... ]
Node cArg = callNode.getFirstChild().getNext();

// Functions called via 'call' and 'apply' have a this-object as
// the first parameter, but this is not part of the called function's
// parameter list.
if (!callNode.getFirstChild().isName()) {
if (NodeUtil.isFunctionObjectCall(callNode)) {
// TODO(johnlenz): Support replace this with a value.
if (cArg == null || !cArg.isThis()) {
return CanInlineResult.NO;
}
cArg = cArg.getNext();
} else {
// "".apply"" call should be filtered before this.
Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
}
}

// FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]
Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
while (cArg != null || fnParam != null) {
// For each named parameter check if a mutable argument use more than one.
if (fnParam != null) {
if (cArg != null) {
if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
return CanInlineResult.NO;
}
// Check for arguments that are evaluated more than once.
// Note: Unlike block inlining, there it is not possible that a
// parameter reference will be in a loop.
if (NodeUtil.mayEffectMutableState(cArg, compiler)
&& NodeUtil.getNameReferenceCount(
block, fnParam.getString()) > 1) {
return CanInlineResult.NO;
}
}

// Move to the next name.
fnParam = fnParam.getNext();
}

// For every call argument check for side-effects, even if there
// isn't a named parameter to match.
if (cArg != null) {
if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
return CanInlineResult.NO;
}
cArg = cArg.getNext();
}
}

return CanInlineResult.YES;
}"
Closure_117b_1,/path/to/defects4j_buggy/Closure_117_buggy/src/com/google/javascript/jscomp/TypeValidator.java,"String getReadableJSTypeName(Node n, boolean dereference) {

// The best type name is the actual type name.

// If we're analyzing a GETPROP, the property may be inherited by the
// prototype chain. So climb the prototype chain and find out where
// the property was originally defined.
if (n.isGetProp()) {
ObjectType objectType = getJSType(n.getFirstChild()).dereference();
if (objectType != null) {
String propName = n.getLastChild().getString();
if (objectType.getConstructor() != null &&
objectType.getConstructor().isInterface()) {
objectType = FunctionType.getTopDefiningInterface(
objectType, propName);
} else {
// classes
while (objectType != null && !objectType.hasOwnProperty(propName)) {
objectType = objectType.getImplicitPrototype();
}
}

// Don't show complex function names or anonymous types.
// Instead, try to get a human-readable type name.
if (objectType != null &&
(objectType.getConstructor() != null ||
objectType.isFunctionPrototypeType())) {
return objectType.toString() + ""."" + propName;
}
}
}

JSType type = getJSType(n);
if (dereference) {
ObjectType dereferenced = type.dereference();
if (dereferenced != null) {
type = dereferenced;
}
}
if (type.isFunctionPrototypeType() ||
(type.toObjectType() != null &&
type.toObjectType().getConstructor() != null)) {
return type.toString();
}
String qualifiedName = n.getQualifiedName();
if (qualifiedName != null) {
return qualifiedName;
} else if (type.isFunctionType()) {
// Don't show complex function names.
return ""function"";
} else {
return type.toString();
}
}"
Closure_118b_1,/path/to/defects4j_buggy/Closure_118_buggy/src/com/google/javascript/jscomp/DisambiguateProperties.java,"void renameProperties() {
int propsRenamed = 0, propsSkipped = 0, instancesRenamed = 0,
instancesSkipped = 0, singleTypeProps = 0;

Set<String> reported = Sets.newHashSet();
for (Property prop : properties.values()) {
if (prop.shouldRename()) {
Map<T, String> propNames = buildPropNames(prop.getTypes(), prop.name);

++propsRenamed;
prop.expandTypesToSkip();
for (Node node : prop.renameNodes) {
T rootType = prop.rootTypes.get(node);
if (prop.shouldRename(rootType)) {
String newName = propNames.get(rootType);
node.setString(newName);
compiler.reportCodeChange();
++instancesRenamed;
} else {
++instancesSkipped;

CheckLevel checkLevelForProp = propertiesToErrorFor.get(prop.name);
if (checkLevelForProp != null &&
checkLevelForProp != CheckLevel.OFF &&
!reported.contains(prop.name)) {
reported.add(prop.name);
compiler.report(JSError.make(
NodeUtil.getSourceName(node), node,
checkLevelForProp,
Warnings.INVALIDATION_ON_TYPE, prop.name,
rootType.toString(), """"));
}
}
}
} else {
if (prop.skipRenaming) {
++propsSkipped;
} else {
++singleTypeProps;
}
}
}
logger.fine(""Renamed "" + instancesRenamed + "" instances of ""
+ propsRenamed + "" properties."");
logger.fine(""Skipped renaming "" + instancesSkipped + "" invalidated ""
+ ""properties, "" + propsSkipped + "" instances of properties ""
+ ""that were skipped for specific types and "" + singleTypeProps
+ "" properties that were referenced from only one type."");
}"
Closure_119b_1,/path/to/defects4j_buggy/Closure_119_buggy/src/com/google/javascript/jscomp/GlobalNamespace.java,"private boolean isGlobalVarReference(String name, Scope s) {
Scope.Var v = s.getVar(name);
if (v == null && externsScope != null) {
v = externsScope.getVar(name);
}
return v != null && !v.isLocal();
}"
Closure_120b_1,/path/to/defects4j_buggy/Closure_120_buggy/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java,"public void exitScope(NodeTraversal t) {
blockStack.pop();
if (t.getScope().isGlobal()) {
// Update global scope reference lists when we are done with it.
compiler.updateGlobalVarReferences(referenceMap, t.getScopeRoot());
behavior.afterExitScope(t, compiler.getGlobalVarReferences());
} else {
behavior.afterExitScope(t, new ReferenceMapWrapper(referenceMap));
}
}"
Closure_121b_1,/path/to/defects4j_buggy/Closure_121_buggy/src/com/google/javascript/jscomp/InlineVariables.java,"private Predicate<Var> getFilterForMode() {
switch (mode) {
case ALL:
return Predicates.<Var>alwaysTrue();
case LOCALS_ONLY:
return new IdentifyLocals();
case CONSTANTS_ONLY:
return new IdentifyConstants();
default:
throw new IllegalStateException();
}
}"
Closure_122b_1,/path/to/defects4j_buggy/Closure_122_buggy/src/com/google/javascript/jscomp/parsing/IRFactory.java,"public static Node transformTree(AstRoot node,
StaticSourceFile sourceFile,"
Closure_123b_1,/path/to/defects4j_buggy/Closure_123_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"private boolean isOneExactlyFunctionOrDo(Node n) {
if (n.isLabel()) {
Node labeledStatement = n.getLastChild();
if (!labeledStatement.isBlock()) {
return isOneExactlyFunctionOrDo(labeledStatement);
} else {
// For labels with block children, we need to ensure that a
// labeled FUNCTION or DO isn't generated when extraneous BLOCKs
// are skipped.
if (getNonEmptyChildCount(n, 2) == 1) {
return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));
} else {
// Either a empty statement or an block with more than one child,
// way it isn't a FUNCTION or DO.
return false;
}
}
} else {
return (n.isFunction() || n.isDo());
}
}"
Closure_124b_1,/path/to/defects4j_buggy/Closure_124_buggy/src/com/google/javascript/jscomp/ExploitAssigns.java,"private boolean collapseAssignEqualTo(Node expr, Node exprParent,
Node value) {
Node assign = expr.getFirstChild();
Node parent = exprParent;
Node next = expr.getNext();
while (next != null) {
switch (next.getType()) {
case Token.AND:
case Token.OR:
case Token.HOOK:
case Token.IF:
case Token.RETURN:
case Token.EXPR_RESULT:
// Dive down the left side
parent = next;
next = next.getFirstChild();
break;

case Token.VAR:
if (next.getFirstChild().hasChildren()) {
parent = next.getFirstChild();
next = parent.getFirstChild();
break;
}
return false;

case Token.GETPROP:
case Token.NAME:
if (next.isQualifiedName()) {
String nextName = next.getQualifiedName();
if (value.isQualifiedName() &&
nextName.equals(value.getQualifiedName())) {
// If the previous expression evaluates to value of a
// qualified name, and that qualified name is used again
// shortly, then we can exploit the assign here.

// Verify the assignment doesn't change its own value.
if (!isSafeReplacement(next, assign)) {
return false;
}

exprParent.removeChild(expr);
expr.removeChild(assign);
parent.replaceChild(next, assign);
return true;
}
}
return false;

case Token.ASSIGN:
// Assigns are really tricky. In lots of cases, we want to inline
// into the right side of the assign. But the left side of the
// assign is evaluated first, and it may have convoluted logic:
//   a = null;
//   (a = b).c = null;
// We don't want to exploit the first assign. Similarly:
//   a.b = null;
//   a.b.c = null;
// We don't want to exploit the first assign either.
//
// To protect against this, we simply only inline when the left side
// is guaranteed to evaluate to the same L-value no matter what.
Node leftSide = next.getFirstChild();
if (leftSide.isName() ||
leftSide.isGetProp() &&
leftSide.getFirstChild().isThis()) {
// Dive down the right side of the assign.
parent = next;
next = leftSide.getNext();
break;
} else {
return false;
}

default:
if (NodeUtil.isImmutableValue(next)
&& next.isEquivalentTo(value)) {
// If the r-value of the expr assign is an immutable value,
// and the value is used again shortly, then we can exploit
// the assign here.
exprParent.removeChild(expr);
expr.removeChild(assign);
parent.replaceChild(next, assign);
return true;
}
// Return without inlining a thing
return false;
}
}

return false;
}"
Closure_125b_1,/path/to/defects4j_buggy/Closure_125_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"public void visit(NodeTraversal t, Node n, Node parent) {
JSType childType;
JSType leftType, rightType;
Node left, right;
// To be explicitly set to false if the node is not typeable.
boolean typeable = true;

switch (n.getType()) {
case Token.CAST:
Node expr = n.getFirstChild();
JSType exprType = getJSType(expr);
JSType castType = getJSType(n);

// TODO(johnlenz): determine if we can limit object literals in some
// way.
if (!expr.isObjectLit()) {
validator.expectCanCast(t, n, castType, exprType);
}
ensureTyped(t, n, castType);

if (castType.isSubtype(exprType) || expr.isObjectLit()) {
expr.setJSType(castType);
}
break;

case Token.NAME:
typeable = visitName(t, n, parent);
break;

case Token.PARAM_LIST:
typeable = false;
break;

case Token.COMMA:
ensureTyped(t, n, getJSType(n.getLastChild()));
break;

case Token.TRUE:
case Token.FALSE:
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.THIS:
ensureTyped(t, n, t.getScope().getTypeOfThis());
break;

case Token.NULL:
ensureTyped(t, n, NULL_TYPE);
break;

case Token.NUMBER:
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.STRING:
ensureTyped(t, n, STRING_TYPE);
break;

case Token.STRING_KEY:
typeable = false;
break;

case Token.GETTER_DEF:
case Token.SETTER_DEF:
// Object literal keys are handled with OBJECTLIT
break;

case Token.ARRAYLIT:
ensureTyped(t, n, ARRAY_TYPE);
break;

case Token.REGEXP:
ensureTyped(t, n, REGEXP_TYPE);
break;

case Token.GETPROP:
visitGetProp(t, n, parent);
typeable = !(parent.isAssign() &&
parent.getFirstChild() == n);
break;

case Token.GETELEM:
visitGetElem(t, n);
// The type of GETELEM is always unknown, so no point counting that.
// If that unknown leaks elsewhere (say by an assignment to another
// variable), then it will be counted.
typeable = false;
break;

case Token.VAR:
visitVar(t, n);
typeable = false;
break;

case Token.NEW:
visitNew(t, n);
break;

case Token.CALL:
visitCall(t, n);
typeable = !parent.isExprResult();
break;

case Token.RETURN:
visitReturn(t, n);
typeable = false;
break;

case Token.DEC:
case Token.INC:
left = n.getFirstChild();
checkPropCreation(t, left);
validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.NOT:
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.VOID:
ensureTyped(t, n, VOID_TYPE);
break;

case Token.TYPEOF:
ensureTyped(t, n, STRING_TYPE);
break;

case Token.BITNOT:
childType = getJSType(n.getFirstChild());
if (!childType.matchesInt32Context()) {
report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),
childType.toString());
}
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.POS:
case Token.NEG:
left = n.getFirstChild();
validator.expectNumber(t, left, getJSType(left), ""sign operator"");
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.EQ:
case Token.NE:
case Token.SHEQ:
case Token.SHNE: {
left = n.getFirstChild();
right = n.getLastChild();

if (left.isTypeOf()) {
if (right.isString()) {
checkTypeofString(t, right, right.getString());
}
} else if (right.isTypeOf() && left.isString()) {
checkTypeofString(t, left, left.getString());
}

leftType = getJSType(left);
rightType = getJSType(right);

// We do not want to warn about explicit comparisons to VOID. People
// often do this if they think their type annotations screwed up.
//
// We do want to warn about cases where people compare things like
// (Array|null) == (Function|null)
// because it probably means they screwed up.
//
// This heuristic here is not perfect, but should catch cases we
// care about without too many false negatives.
JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();

TernaryValue result = TernaryValue.UNKNOWN;
if (n.getType() == Token.EQ || n.getType() == Token.NE) {
result = leftTypeRestricted.testForEquality(rightTypeRestricted);
if (n.isNE()) {
result = result.not();
}
} else {
// SHEQ or SHNE
if (!leftTypeRestricted.canTestForShallowEqualityWith(
rightTypeRestricted)) {
result = n.getType() == Token.SHEQ ?
TernaryValue.FALSE : TernaryValue.TRUE;
}
}

if (result != TernaryValue.UNKNOWN) {
report(t, n, DETERMINISTIC_TEST, leftType.toString(),
rightType.toString(), result.toString());
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;
}

case Token.LT:
case Token.LE:
case Token.GT:
case Token.GE:
leftType = getJSType(n.getFirstChild());
rightType = getJSType(n.getLastChild());
if (rightType.isNumber()) {
validator.expectNumber(
t, n, leftType, ""left side of numeric comparison"");
} else if (leftType.isNumber()) {
validator.expectNumber(
t, n, rightType, ""right side of numeric comparison"");
} else if (leftType.matchesNumberContext() &&
rightType.matchesNumberContext()) {
// OK.
} else {
// Whether the comparison is numeric will be determined at runtime
// each time the expression is evaluated. Regardless, both operands
// should match a string context.
String message = ""left side of comparison"";
validator.expectString(t, n, leftType, message);
validator.expectNotNullOrUndefined(
t, n, leftType, message, getNativeType(STRING_TYPE));
message = ""right side of comparison"";
validator.expectString(t, n, rightType, message);
validator.expectNotNullOrUndefined(
t, n, rightType, message, getNativeType(STRING_TYPE));
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.IN:
left = n.getFirstChild();
right = n.getLastChild();
rightType = getJSType(right);
validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
validator.expectObject(t, n, rightType, ""'in' requires an object"");
if (rightType.isStruct()) {
report(t, right, IN_USED_WITH_STRUCT);
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.INSTANCEOF:
left = n.getFirstChild();
right = n.getLastChild();
rightType = getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(
t, left, getJSType(left), ""deterministic instanceof yields false"");
validator.expectActualObject(
t, right, rightType, ""instanceof requires an object"");
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.ASSIGN:
visitAssign(t, n);
typeable = false;
break;

case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_SUB:
case Token.ASSIGN_ADD:
case Token.ASSIGN_MUL:
checkPropCreation(t, n.getFirstChild());
// fall through

case Token.LSH:
case Token.RSH:
case Token.URSH:
case Token.DIV:
case Token.MOD:
case Token.BITOR:
case Token.BITXOR:
case Token.BITAND:
case Token.SUB:
case Token.ADD:
case Token.MUL:
visitBinaryOperator(n.getType(), t, n);
break;

case Token.DELPROP:
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.CASE:
JSType switchType = getJSType(parent.getFirstChild());
JSType caseType = getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t, n, switchType, caseType);
typeable = false;
break;

case Token.WITH: {
Node child = n.getFirstChild();
childType = getJSType(child);
validator.expectObject(t, child, childType, ""with requires an object"");
typeable = false;
break;
}

case Token.FUNCTION:
visitFunction(t, n);
break;

// These nodes have no interesting type behavior.
case Token.LABEL:
case Token.LABEL_NAME:
case Token.SWITCH:
case Token.BREAK:
case Token.CATCH:
case Token.TRY:
case Token.SCRIPT:
case Token.EXPR_RESULT:
case Token.BLOCK:
case Token.EMPTY:
case Token.DEFAULT_CASE:
case Token.CONTINUE:
case Token.DEBUGGER:
case Token.THROW:
typeable = false;
break;

// These nodes require data flow analysis.
case Token.DO:
case Token.IF:
case Token.WHILE:
typeable = false;
break;

case Token.FOR:
if (NodeUtil.isForIn(n)) {
Node obj = n.getChildAtIndex(1);
if (getJSType(obj).isStruct()) {
report(t, obj, IN_USED_WITH_STRUCT);
}
}
typeable = false;
break;

// These nodes are typed during the type inference.
case Token.AND:
case Token.HOOK:
case Token.OBJECTLIT:
case Token.OR:
if (n.getJSType() != null) { // If we didn't run type inference.
ensureTyped(t, n);
} else {
// If this is an enum, then give that type to the objectlit as well.
if ((n.isObjectLit())
&& (parent.getJSType() instanceof EnumType)) {
ensureTyped(t, n, parent.getJSType());
} else {
ensureTyped(t, n);
}
}
if (n.isObjectLit()) {
JSType typ = getJSType(n);
for (Node key : n.children()) {
visitObjLitKey(t, key, n, typ);
}
}
break;

default:
report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
ensureTyped(t, n);
break;
}

// Don't count externs since the user's code may not even use that part.
typeable = typeable && !inExterns;

if (typeable) {
doPercentTypedAccounting(t, n);
}

checkNoTypeCheckSection(n, false);
}"
Closure_126b_1,/path/to/defects4j_buggy/Closure_126_buggy/src/com/google/javascript/jscomp/MinimizeExitPoints.java,"void tryMinimizeExits(Node n, int exitType, String labelName) {

// Just an 'exit'.
if (matchingExitNode(n, exitType, labelName)) {
NodeUtil.removeChild(n.getParent(), n);
compiler.reportCodeChange();
return;
}

// Just an 'if'.
if (n.isIf()) {
Node ifBlock = n.getFirstChild().getNext();
tryMinimizeExits(ifBlock, exitType, labelName);
Node elseBlock = ifBlock.getNext();
if (elseBlock != null) {
tryMinimizeExits(elseBlock, exitType, labelName);
}
return;
}

// Just a 'try/catch/finally'.
if (n.isTry()) {
Node tryBlock = n.getFirstChild();
tryMinimizeExits(tryBlock, exitType, labelName);
Node allCatchNodes = NodeUtil.getCatchBlock(n);
if (NodeUtil.hasCatchHandler(allCatchNodes)) {
Preconditions.checkState(allCatchNodes.hasOneChild());
Node catchNode = allCatchNodes.getFirstChild();
Node catchCodeBlock = catchNode.getLastChild();
tryMinimizeExits(catchCodeBlock, exitType, labelName);
}
/* Don't try to minimize the exits of finally blocks, as this
* can cause problems if it changes the completion type of the finally
* block. See ECMA 262 Sections 8.9 & 12.14
*/
if (NodeUtil.hasFinally(n)) {
Node finallyBlock = n.getLastChild();
tryMinimizeExits(finallyBlock, exitType, labelName);
}
}

// Just a 'label'.
if (n.isLabel()) {
Node labelBlock = n.getLastChild();
tryMinimizeExits(labelBlock, exitType, labelName);
}

// TODO(johnlenz): The last case of SWITCH statement?

// The rest assumes a block with at least one child, bail on anything else.
if (!n.isBlock() || n.getLastChild() == null) {
return;
}

// Multiple if-exits can be converted in a single pass.
// Convert ""if (blah) break;  if (blah2) break; other_stmt;"" to
// become ""if (blah); else { if (blah2); else { other_stmt; } }""
// which will get converted to ""if (!blah && !blah2) { other_stmt; }"".
for (Node c : n.children()) {

// An 'if' block to process below.
if (c.isIf()) {
Node ifTree = c;
Node trueBlock, falseBlock;

// First, the true condition block.
trueBlock = ifTree.getFirstChild().getNext();
falseBlock = trueBlock.getNext();
tryMinimizeIfBlockExits(trueBlock, falseBlock,
ifTree, exitType, labelName);

// Now the else block.
// The if blocks may have changed, get them again.
trueBlock = ifTree.getFirstChild().getNext();
falseBlock = trueBlock.getNext();
if (falseBlock != null) {
tryMinimizeIfBlockExits(falseBlock, trueBlock,
ifTree, exitType, labelName);
}
}

if (c == n.getLastChild()) {
break;
}
}

// Now try to minimize the exits of the last child, if it is removed
// look at what has become the last child.
for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {
tryMinimizeExits(c, exitType, labelName);
// If the node is still the last child, we are done.
if (c == n.getLastChild()) {
break;
}
}
}"
Closure_128b_1,/path/to/defects4j_buggy/Closure_128_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"static boolean isSimpleNumber(String s) {
int len = s.length();
for (int index = 0; index < len; index++) {
char c = s.charAt(index);
if (c < '0' || c > '9') {
return false;
}
}
return len > 0 && s.charAt(0) != '0';
}"
Closure_129b_1,/path/to/defects4j_buggy/Closure_129_buggy/src/com/google/javascript/jscomp/PrepareAst.java,"PrepareAst(AbstractCompiler compiler) {
this(compiler, false);
}"
Closure_130b_1,/path/to/defects4j_buggy/Closure_130_buggy/src/com/google/javascript/jscomp/CollapseProperties.java,"public void process(Node externs, Node root) {
GlobalNamespace namespace;
if (collapsePropertiesOnExternTypes) {
namespace = new GlobalNamespace(compiler, externs, root);
} else {
namespace = new GlobalNamespace(compiler, root);
}

if (inlineAliases) {
inlineAliases(namespace);
}
nameMap = namespace.getNameIndex();
globalNames = namespace.getNameForest();
checkNamespaces();

for (Name n : globalNames) {
flattenReferencesToCollapsibleDescendantNames(n, n.getBaseName());
}

// We collapse property definitions after collapsing property references
// because this step can alter the parse tree above property references,
// invalidating the node ancestry stored with each reference.
for (Name n : globalNames) {
collapseDeclarationOfNameAndDescendants(n, n.getBaseName());
}
}"
Closure_131b_1,/path/to/defects4j_buggy/Closure_131_buggy/src/com/google/javascript/rhino/TokenStream.java,"public static boolean isJSIdentifier(String s) {
int length = s.length();

if (length == 0 ||
!Character.isJavaIdentifierStart(s.charAt(0))) {
return false;
}

for (int i = 1; i < length; i++) {
if (
!Character.isJavaIdentifierPart(s.charAt(i))) {
return false;
}
}

return true;
}"
Closure_132b_1,/path/to/defects4j_buggy/Closure_132_buggy/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,"private Node tryMinimizeIf(Node n) {

Node parent = n.getParent();

Node cond = n.getFirstChild();

/* If the condition is a literal, we'll let other
* optimizations try to remove useless code.
*/
if (NodeUtil.isLiteralValue(cond, true)) {
return n;
}

Node thenBranch = cond.getNext();
Node elseBranch = thenBranch.getNext();

if (elseBranch == null) {
if (isFoldableExpressBlock(thenBranch)) {
Node expr = getBlockExpression(thenBranch);
if (!late && isPropertyAssignmentInExpression(expr)) {
// Keep opportunities for CollapseProperties such as
// a.longIdentifier || a.longIdentifier = ... -> var a = ...;
// until CollapseProperties has been run.
return n;
}

if (cond.isNot()) {
// if(!x)bar(); -> x||bar();
if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&
isLowerPrecedenceInExpression(expr.getFirstChild(),
OR_PRECEDENCE)) {
// It's not okay to add two sets of parentheses.
return n;
}

Node or = IR.or(
cond.removeFirstChild(),
expr.removeFirstChild()).srcref(n);
Node newExpr = NodeUtil.newExpr(or);
parent.replaceChild(n, newExpr);
reportCodeChange();

return newExpr;
}

// if(x)foo(); -> x&&foo();
if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&
isLowerPrecedenceInExpression(expr.getFirstChild(),
AND_PRECEDENCE)) {
// One additional set of parentheses is worth the change even if
// there is no immediate code size win. However, two extra pair of
// {}, we would have to think twice. (unless we know for sure the
// we can further optimize its parent.
return n;
}

n.removeChild(cond);
Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);
Node newExpr = NodeUtil.newExpr(and);
parent.replaceChild(n, newExpr);
reportCodeChange();

return newExpr;
} else {

// Try to combine two IF-ELSE
if (NodeUtil.isStatementBlock(thenBranch) &&
thenBranch.hasOneChild()) {
Node innerIf = thenBranch.getFirstChild();

if (innerIf.isIf()) {
Node innerCond = innerIf.getFirstChild();
Node innerThenBranch = innerCond.getNext();
Node innerElseBranch = innerThenBranch.getNext();

if (innerElseBranch == null &&
!(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&
isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {
n.detachChildren();
n.addChildToBack(
IR.and(
cond,
innerCond.detachFromParent())
.srcref(cond));
n.addChildrenToBack(innerThenBranch.detachFromParent());
reportCodeChange();
// Not worth trying to fold the current IF-ELSE into && because
// the inner IF-ELSE wasn't able to be folded into && anyways.
return n;
}
}
}
}

return n;
}

/* TODO(dcc) This modifies the siblings of n, which is undesirable for a
* peephole optimization. This should probably get moved to another pass.
*/
tryRemoveRepeatedStatements(n);

// if(!x)foo();else bar(); -> if(x)bar();else foo();
// An additional set of curly braces isn't worth it.
if (cond.isNot() && !consumesDanglingElse(elseBranch)) {
n.replaceChild(cond, cond.removeFirstChild());
n.removeChild(thenBranch);
n.addChildToBack(thenBranch);
reportCodeChange();
return n;
}

// if(x)return 1;else return 2; -> return x?1:2;
if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
Node thenExpr = getBlockReturnExpression(thenBranch);
Node elseExpr = getBlockReturnExpression(elseBranch);
n.removeChild(cond);
thenExpr.detachFromParent();
elseExpr.detachFromParent();

// note - we ignore any cases with ""return;"", technically this
// can be converted to ""return undefined;"" or some variant, but
// that does not help code size.
Node returnNode = IR.returnNode(
IR.hook(cond, thenExpr, elseExpr)
.srcref(n));
parent.replaceChild(n, returnNode);
reportCodeChange();
return returnNode;
}

boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);

if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
Node thenOp = getBlockExpression(thenBranch).getFirstChild();
Node elseOp = getBlockExpression(elseBranch).getFirstChild();
if (thenOp.getType() == elseOp.getType()) {
// if(x)a=1;else a=2; -> a=x?1:2;
if (NodeUtil.isAssignmentOp(thenOp)) {
Node lhs = thenOp.getFirstChild();
if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&
// if LHS has side effects, don't proceed [since the optimization
// evaluates LHS before cond]
// NOTE - there are some circumstances where we can
// proceed even if there are side effects...
!mayEffectMutableState(lhs)) {

n.removeChild(cond);
Node assignName = thenOp.removeFirstChild();
Node thenExpr = thenOp.removeFirstChild();
Node elseExpr = elseOp.getLastChild();
elseOp.removeChild(elseExpr);

Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
Node assign = new Node(thenOp.getType(), assignName, hookNode)
.srcref(thenOp);
Node expr = NodeUtil.newExpr(assign);
parent.replaceChild(n, expr);
reportCodeChange();

return expr;
}
}
}
// if(x)foo();else bar(); -> x?foo():bar()
n.removeChild(cond);
thenOp.detachFromParent();
elseOp.detachFromParent();
Node expr = IR.exprResult(
IR.hook(cond, thenOp, elseOp).srcref(n));
parent.replaceChild(n, expr);
reportCodeChange();
return expr;
}

boolean thenBranchIsVar = isVarBlock(thenBranch);
boolean elseBranchIsVar = isVarBlock(elseBranch);

// if(x)var y=1;else y=2  ->  var y=x?1:2
if (thenBranchIsVar && elseBranchIsExpressionBlock &&
getBlockExpression(elseBranch).getFirstChild().isAssign()) {

Node var = getBlockVar(thenBranch);
Node elseAssign = getBlockExpression(elseBranch).getFirstChild();

Node name1 = var.getFirstChild();
Node maybeName2 = elseAssign.getFirstChild();

if (name1.hasChildren()
&& maybeName2.isName()
&& name1.getString().equals(maybeName2.getString())) {
Node thenExpr = name1.removeChildren();
Node elseExpr = elseAssign.getLastChild().detachFromParent();
cond.detachFromParent();
Node hookNode = IR.hook(cond, thenExpr, elseExpr)
.srcref(n);
var.detachFromParent();
name1.addChildrenToBack(hookNode);
parent.replaceChild(n, var);
reportCodeChange();
return var;
}

// if(x)y=1;else var y=2  ->  var y=x?1:2
} else if (elseBranchIsVar && thenBranchIsExpressionBlock &&
getBlockExpression(thenBranch).getFirstChild().isAssign()) {

Node var = getBlockVar(elseBranch);
Node thenAssign = getBlockExpression(thenBranch).getFirstChild();

Node maybeName1 = thenAssign.getFirstChild();
Node name2 = var.getFirstChild();

if (name2.hasChildren()
&& maybeName1.isName()
&& maybeName1.getString().equals(name2.getString())) {
Node thenExpr = thenAssign.getLastChild().detachFromParent();
Node elseExpr = name2.removeChildren();
cond.detachFromParent();
Node hookNode = IR.hook(cond, thenExpr, elseExpr)
.srcref(n);
var.detachFromParent();
name2.addChildrenToBack(hookNode);
parent.replaceChild(n, var);
reportCodeChange();

return var;
}
}

return n;
}"
Closure_133b_1,/path/to/defects4j_buggy/Closure_133_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,"boolean parse() {
int lineno;
int charno;

// JSTypes are represented as Rhino AST nodes, and then resolved later.
JSTypeExpression type;

state = State.SEARCHING_ANNOTATION;
skipEOLs();

JsDocToken token = next();

List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();

// Always record that we have a comment.
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo blockInfo = extractBlockComment(token);
token = blockInfo.token;
if (!blockInfo.string.isEmpty()) {
jsdocBuilder.recordBlockDescription(blockInfo.string);
}
} else {
if (token != JsDocToken.ANNOTATION &&
token != JsDocToken.EOC) {
// Mark that there was a description, but don't bother marking
// what it was.
jsdocBuilder.recordBlockDescription("""");
}
}

// Parse the actual JsDoc.
retry: for (;;) {
switch (token) {
case ANNOTATION:
if (state == State.SEARCHING_ANNOTATION) {
state = State.SEARCHING_NEWLINE;
lineno = stream.getLineno();
charno = stream.getCharno();

String annotationName = stream.getString();
Annotation annotation = annotationNames.get(annotationName);
if (annotation == null) {
parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName,
stream.getLineno(), stream.getCharno());
} else {
// Mark the beginning of the annotation.
jsdocBuilder.markAnnotation(annotationName, lineno, charno);

switch (annotation) {
case NG_INJECT:
if (jsdocBuilder.isNgInjectRecorded()) {
parser.addParserWarning(""msg.jsdoc.nginject.extra"",
stream.getLineno(), stream.getCharno());
} else {
jsdocBuilder.recordNgInject(true);
}
token = eatTokensUntilEOL();
continue retry;

case AUTHOR:
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo authorInfo = extractSingleLineBlock();
String author = authorInfo.string;

if (author.length() == 0) {
parser.addParserWarning(""msg.jsdoc.authormissing"",
stream.getLineno(), stream.getCharno());
} else {
jsdocBuilder.addAuthor(author);
}
token = authorInfo.token;
} else {
token = eatTokensUntilEOL(token);
}
continue retry;

case CONSISTENTIDGENERATOR:
if (!jsdocBuilder.recordConsistentIdGenerator()) {
parser.addParserWarning(""msg.jsdoc.consistidgen"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case STRUCT:
if (!jsdocBuilder.recordStruct()) {
parser.addTypeWarning(""msg.jsdoc.incompat.type"",
stream.getLineno(),
stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case DICT:
if (!jsdocBuilder.recordDict()) {
parser.addTypeWarning(""msg.jsdoc.incompat.type"",
stream.getLineno(),
stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case CONSTRUCTOR:
if (!jsdocBuilder.recordConstructor()) {
if (jsdocBuilder.isInterfaceRecorded()) {
parser.addTypeWarning(""msg.jsdoc.interface.constructor"",
stream.getLineno(), stream.getCharno());
} else {
parser.addTypeWarning(""msg.jsdoc.incompat.type"",
stream.getLineno(), stream.getCharno());
}
}
token = eatTokensUntilEOL();
continue retry;

case DEPRECATED:
if (!jsdocBuilder.recordDeprecated()) {
parser.addParserWarning(""msg.jsdoc.deprecated"",
stream.getLineno(), stream.getCharno());
}

// Find the reason/description, if any.
ExtractionInfo reasonInfo =
extractMultilineTextualBlock(token);

String reason = reasonInfo.string;

if (reason.length() > 0) {
jsdocBuilder.recordDeprecationReason(reason);
}

token = reasonInfo.token;
continue retry;

case INTERFACE:
if (!jsdocBuilder.recordInterface()) {
if (jsdocBuilder.isConstructorRecorded()) {
parser.addTypeWarning(""msg.jsdoc.interface.constructor"",
stream.getLineno(), stream.getCharno());
} else {
parser.addTypeWarning(""msg.jsdoc.incompat.type"",
stream.getLineno(), stream.getCharno());
}
}
token = eatTokensUntilEOL();
continue retry;

case DESC:
if (jsdocBuilder.isDescriptionRecorded()) {
parser.addParserWarning(""msg.jsdoc.desc.extra"",
stream.getLineno(), stream.getCharno());
token = eatTokensUntilEOL();
continue retry;
} else {
ExtractionInfo descriptionInfo =
extractMultilineTextualBlock(token);

String description = descriptionInfo.string;

jsdocBuilder.recordDescription(description);
token = descriptionInfo.token;
continue retry;
}

case FILE_OVERVIEW:
String fileOverview = """";
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo fileOverviewInfo =
extractMultilineTextualBlock(token,
WhitespaceOption.TRIM);

fileOverview = fileOverviewInfo.string;

token = fileOverviewInfo.token;
} else {
token = eatTokensUntilEOL(token);
}

if (!jsdocBuilder.recordFileOverview(fileOverview)) {
parser.addParserWarning(""msg.jsdoc.fileoverview.extra"",
stream.getLineno(), stream.getCharno());
}
continue retry;

case LICENSE:
case PRESERVE:
ExtractionInfo preserveInfo =
extractMultilineTextualBlock(token,
WhitespaceOption.PRESERVE);

String preserve = preserveInfo.string;

if (preserve.length() > 0) {
if (fileLevelJsDocBuilder != null) {
fileLevelJsDocBuilder.append(preserve);
}
}

token = preserveInfo.token;
continue retry;

case ENUM:
token = next();
lineno = stream.getLineno();
charno = stream.getCharno();

type = null;
if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
type = createJSTypeExpression(
parseAndRecordTypeNode(token));
}

if (type == null) {
type = createJSTypeExpression(newStringNode(""number""));
}
if (!jsdocBuilder.recordEnumParameterType(type)) {
parser.addTypeWarning(
""msg.jsdoc.incompat.type"", lineno, charno);
}
token = eatTokensUntilEOL(token);
continue retry;

case EXPORT:
if (!jsdocBuilder.recordExport()) {
parser.addParserWarning(""msg.jsdoc.export"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case EXPOSE:
if (!jsdocBuilder.recordExpose()) {
parser.addParserWarning(""msg.jsdoc.expose"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case EXTERNS:
if (!jsdocBuilder.recordExterns()) {
parser.addParserWarning(""msg.jsdoc.externs"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case JAVA_DISPATCH:
if (!jsdocBuilder.recordJavaDispatch()) {
parser.addParserWarning(""msg.jsdoc.javadispatch"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case EXTENDS:
case IMPLEMENTS:
skipEOLs();
token = next();
lineno = stream.getLineno();
charno = stream.getCharno();
boolean matchingRc = false;

if (token == JsDocToken.LC) {
token = next();
matchingRc = true;
}

if (token == JsDocToken.STRING) {
Node typeNode = parseAndRecordTypeNameNode(
token, lineno, charno, matchingRc);

lineno = stream.getLineno();
charno = stream.getCharno();

typeNode = wrapNode(Token.BANG, typeNode);
type = createJSTypeExpression(typeNode);

if (annotation == Annotation.EXTENDS) {
// record the extended type, check later
extendedTypes.add(new ExtendedTypeInfo(
type, stream.getLineno(), stream.getCharno()));
} else {
Preconditions.checkState(
annotation == Annotation.IMPLEMENTS);
if (!jsdocBuilder.recordImplementedInterface(type)) {
parser.addTypeWarning(""msg.jsdoc.implements.duplicate"",
lineno, charno);
}
}
token = next();
if (matchingRc) {
if (token != JsDocToken.RC) {
parser.addTypeWarning(""msg.jsdoc.missing.rc"",
stream.getLineno(), stream.getCharno());
}
} else if (token != JsDocToken.EOL &&
token != JsDocToken.EOF && token != JsDocToken.EOC) {
parser.addTypeWarning(""msg.end.annotation.expected"",
stream.getLineno(), stream.getCharno());
}
} else {
parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
}
token = eatTokensUntilEOL(token);
continue retry;

case HIDDEN:
if (!jsdocBuilder.recordHiddenness()) {
parser.addParserWarning(""msg.jsdoc.hidden"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case LENDS:
skipEOLs();

matchingRc = false;
if (match(JsDocToken.LC)) {
token = next();
matchingRc = true;
}

if (match(JsDocToken.STRING)) {
token = next();
if (!jsdocBuilder.recordLends(stream.getString())) {
parser.addTypeWarning(""msg.jsdoc.lends.incompatible"",
stream.getLineno(), stream.getCharno());
}
} else {
parser.addTypeWarning(""msg.jsdoc.lends.missing"",
stream.getLineno(), stream.getCharno());
}

if (matchingRc && !match(JsDocToken.RC)) {
parser.addTypeWarning(""msg.jsdoc.missing.rc"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case MEANING:
ExtractionInfo meaningInfo =
extractMultilineTextualBlock(token);
String meaning = meaningInfo.string;
token = meaningInfo.token;
if (!jsdocBuilder.recordMeaning(meaning)) {
parser.addParserWarning(""msg.jsdoc.meaning.extra"",
stream.getLineno(), stream.getCharno());
}
continue retry;

case NO_ALIAS:
if (!jsdocBuilder.recordNoAlias()) {
parser.addParserWarning(""msg.jsdoc.noalias"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case NO_COMPILE:
if (!jsdocBuilder.recordNoCompile()) {
parser.addParserWarning(""msg.jsdoc.nocompile"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case NO_TYPE_CHECK:
if (!jsdocBuilder.recordNoTypeCheck()) {
parser.addParserWarning(""msg.jsdoc.nocheck"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case NOT_IMPLEMENTED:
token = eatTokensUntilEOL();
continue retry;

case INHERIT_DOC:
case OVERRIDE:
if (!jsdocBuilder.recordOverride()) {
parser.addTypeWarning(""msg.jsdoc.override"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case THROWS:
skipEOLs();
token = next();
lineno = stream.getLineno();
charno = stream.getCharno();
type = null;

if (token == JsDocToken.LC) {
type = createJSTypeExpression(
parseAndRecordTypeNode(token));

if (type == null) {
// parsing error reported during recursive descent
// recovering parsing
token = eatTokensUntilEOL();
continue retry;
}
}

// *Update* the token to that after the type annotation.
token = current();

// Save the throw type.
jsdocBuilder.recordThrowType(type);

// Find the throw's description (if applicable).
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo descriptionInfo =
extractMultilineTextualBlock(token);

String description = descriptionInfo.string;

if (description.length() > 0) {
jsdocBuilder.recordThrowDescription(type, description);
}

token = descriptionInfo.token;
} else {
token = eatTokensUntilEOL(token);
}
continue retry;

case PARAM:
skipEOLs();
token = next();
lineno = stream.getLineno();
charno = stream.getCharno();
type = null;

if (token == JsDocToken.LC) {
type = createJSTypeExpression(
parseAndRecordParamTypeNode(token));

if (type == null) {
// parsing error reported during recursive descent
// recovering parsing
token = eatTokensUntilEOL();
continue retry;
}
skipEOLs();
token = next();
lineno = stream.getLineno();
charno = stream.getCharno();
}

String name = null;
boolean isBracketedParam = JsDocToken.LB == token;
if (isBracketedParam) {
token = next();
}

if (JsDocToken.STRING != token) {
parser.addTypeWarning(""msg.missing.variable.name"",
lineno, charno);
} else {
name = stream.getString();

if (isBracketedParam) {
token = next();

// Throw out JsDocToolkit's ""default"" parameter
// annotation.  It makes no sense under our type
// system.
if (JsDocToken.EQUALS == token) {
token = next();
if (JsDocToken.STRING == token) {
token = next();
}
}

if (JsDocToken.RB != token) {
reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
} else if (type != null) {
// Make the type expression optional, if it isn't
// already.
type = JSTypeExpression.makeOptionalArg(type);
}
}

// If the param name has a DOT in it, just throw it out
// quietly. We do not handle the JsDocToolkit method
// for handling properties of params.
if (name.indexOf('.') > -1) {
name = null;
} else if (!jsdocBuilder.recordParameter(name, type)) {
if (jsdocBuilder.hasParameter(name)) {
parser.addTypeWarning(""msg.dup.variable.name"", name,
lineno, charno);
} else {
parser.addTypeWarning(""msg.jsdoc.incompat.type"", name,
lineno, charno);
}
}
}

if (name == null) {
token = eatTokensUntilEOL(token);
continue retry;
}

jsdocBuilder.markName(name, sourceFile, lineno, charno);

// Find the parameter's description (if applicable).
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo paramDescriptionInfo =
extractMultilineTextualBlock(token);

String paramDescription = paramDescriptionInfo.string;

if (paramDescription.length() > 0) {
jsdocBuilder.recordParameterDescription(name,
paramDescription);
}

token = paramDescriptionInfo.token;
} else {
token = eatTokensUntilEOL(token);
}
continue retry;

case PRESERVE_TRY:
if (!jsdocBuilder.recordPreserveTry()) {
parser.addParserWarning(""msg.jsdoc.preservertry"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case NO_SHADOW:
if (!jsdocBuilder.recordNoShadow()) {
parser.addParserWarning(""msg.jsdoc.noshadow"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case NO_SIDE_EFFECTS:
if (!jsdocBuilder.recordNoSideEffects()) {
parser.addParserWarning(""msg.jsdoc.nosideeffects"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case MODIFIES:
token = parseModifiesTag(next());
continue retry;

case IMPLICIT_CAST:
if (!jsdocBuilder.recordImplicitCast()) {
parser.addTypeWarning(""msg.jsdoc.implicitcast"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case SEE:
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo referenceInfo = extractSingleLineBlock();
String reference = referenceInfo.string;

if (reference.length() == 0) {
parser.addParserWarning(""msg.jsdoc.seemissing"",
stream.getLineno(), stream.getCharno());
} else {
jsdocBuilder.addReference(reference);
}

token = referenceInfo.token;
} else {
token = eatTokensUntilEOL(token);
}
continue retry;

case STABLEIDGENERATOR:
if (!jsdocBuilder.recordStableIdGenerator()) {
parser.addParserWarning(""msg.jsdoc.stableidgen"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case SUPPRESS:
token = parseSuppressTag(next());
continue retry;

case TEMPLATE: {
ExtractionInfo templateInfo = extractSingleLineBlock();
List<String> names = Lists.newArrayList(
Splitter.on(',')
.trimResults()
.split(templateInfo.string));

if (names.size() == 0 || names.get(0).length() == 0) {
parser.addTypeWarning(""msg.jsdoc.templatemissing"",
stream.getLineno(), stream.getCharno());
} else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
parser.addTypeWarning(""msg.jsdoc.template.at.most.once"",
stream.getLineno(), stream.getCharno());
}

token = templateInfo.token;
continue retry;
}

case CLASS_TEMPLATE: {
ExtractionInfo classTemplateInfo = extractSingleLineBlock();
List<String> names = Lists.newArrayList(
Splitter.on(',')
.trimResults()
.split(classTemplateInfo.string));

if (names.size() == 0 || names.get(0).length() == 0) {
parser.addTypeWarning(
""msg.jsdoc.classtemplate.missing.type.name"",
stream.getLineno(), stream.getCharno());
} else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
parser.addTypeWarning(
""msg.jsdoc.classtemplate.at.most.once"",
stream.getLineno(), stream.getCharno());
}

token = classTemplateInfo.token;
continue retry;
}

case IDGENERATOR:
if (!jsdocBuilder.recordIdGenerator()) {
parser.addParserWarning(""msg.jsdoc.idgen"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case VERSION:
ExtractionInfo versionInfo = extractSingleLineBlock();
String version = versionInfo.string;

if (version.length() == 0) {
parser.addParserWarning(""msg.jsdoc.versionmissing"",
stream.getLineno(), stream.getCharno());
} else {
if (!jsdocBuilder.recordVersion(version)) {
parser.addParserWarning(""msg.jsdoc.extraversion"",
stream.getLineno(), stream.getCharno());
}
}

token = versionInfo.token;
continue retry;

case CONSTANT:
case DEFINE:
case RETURN:
case PRIVATE:
case PROTECTED:
case PUBLIC:
case THIS:
case TYPE:
case TYPEDEF:
lineno = stream.getLineno();
charno = stream.getCharno();

Node typeNode = null;
boolean hasType = lookAheadForTypeAnnotation();
boolean isAlternateTypeAnnotation =
(annotation == Annotation.PRIVATE ||
annotation == Annotation.PROTECTED ||
annotation == Annotation.PUBLIC ||
annotation == Annotation.CONSTANT);
boolean canSkipTypeAnnotation =
(isAlternateTypeAnnotation ||
annotation == Annotation.RETURN);
type = null;
if (hasType || !canSkipTypeAnnotation) {
skipEOLs();
token = next();
typeNode = parseAndRecordTypeNode(token);

if (annotation == Annotation.THIS) {
typeNode = wrapNode(Token.BANG, typeNode);
}
type = createJSTypeExpression(typeNode);
}

// The error was reported during recursive descent
// recovering parsing
boolean hasError = type == null && !canSkipTypeAnnotation;
if (!hasError) {
// Record types for @type.
// If the @private, @protected, or @public annotations
// have a type attached, pretend that they actually wrote:
// @type {type}\n@private
// This will have some weird behavior in some cases
// (for example, @private can now be used as a type-cast),
// but should be mostly OK.
if ((type != null && isAlternateTypeAnnotation)
|| annotation == Annotation.TYPE) {
if (!jsdocBuilder.recordType(type)) {
parser.addTypeWarning(
""msg.jsdoc.incompat.type"", lineno, charno);
}
}

switch (annotation) {
case CONSTANT:
if (!jsdocBuilder.recordConstancy()) {
parser.addParserWarning(""msg.jsdoc.const"",
stream.getLineno(), stream.getCharno());
}
break;

case DEFINE:
if (!jsdocBuilder.recordDefineType(type)) {
parser.addParserWarning(""msg.jsdoc.define"",
lineno, charno);
}
break;

case PRIVATE:
if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
parser.addParserWarning(
""msg.jsdoc.visibility.private"",
lineno, charno);
}
break;

case PROTECTED:
if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
parser.addParserWarning(
""msg.jsdoc.visibility.protected"",
lineno, charno);
}
break;

case PUBLIC:
if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
parser.addParserWarning(
""msg.jsdoc.visibility.public"",
lineno, charno);
}
break;

case RETURN:
if (type == null) {
type = createJSTypeExpression(newNode(Token.QMARK));
}

if (!jsdocBuilder.recordReturnType(type)) {
parser.addTypeWarning(
""msg.jsdoc.incompat.type"", lineno, charno);
break;
}

// Find the return's description (if applicable).
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo returnDescriptionInfo =
extractMultilineTextualBlock(token);

String returnDescription =
returnDescriptionInfo.string;

if (returnDescription.length() > 0) {
jsdocBuilder.recordReturnDescription(
returnDescription);
}

token = returnDescriptionInfo.token;
} else {
token = eatTokensUntilEOL(token);
}
continue retry;

case THIS:
if (!jsdocBuilder.recordThisType(type)) {
parser.addTypeWarning(
""msg.jsdoc.incompat.type"", lineno, charno);
}
break;

case TYPEDEF:
if (!jsdocBuilder.recordTypedef(type)) {
parser.addTypeWarning(
""msg.jsdoc.incompat.type"", lineno, charno);
}
break;
}
}

token = eatTokensUntilEOL();
continue retry;
}
}
}
break;

case EOC:
if (hasParsedFileOverviewDocInfo()) {
fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
}
checkExtendedTypes(extendedTypes);
return true;

case EOF:
// discard any accumulated information
jsdocBuilder.build(null);
parser.addParserWarning(""msg.unexpected.eof"",
stream.getLineno(), stream.getCharno());
checkExtendedTypes(extendedTypes);
return false;

case EOL:
if (state == State.SEARCHING_NEWLINE) {
state = State.SEARCHING_ANNOTATION;
}
token = next();
continue retry;

default:
if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
token = next();
continue retry;
} else {
state = State.SEARCHING_NEWLINE;
token = eatTokensUntilEOL();
continue retry;
}
}

// next token
token = next();
}
}"
Lang_1b_1,/path/to/defects4j_buggy/Lang_1_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static Number createNumber(final String str) throws NumberFormatException {
if (str == null) {
return null;
}
if (StringUtils.isBlank(str)) {
throw new NumberFormatException(""A blank string is not a valid number"");
}
// Need to deal with all possible hex prefixes here
final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
int pfxLen = 0;
for(final String pfx : hex_prefixes) {
if (str.startsWith(pfx)) {
pfxLen += pfx.length();
break;
}
}
if (pfxLen > 0) { // we have a hex number
final int hexDigits = str.length() - pfxLen;
if (hexDigits > 16) { // too many for Long
return createBigInteger(str);
}
if (hexDigits > 8) { // too many for an int
return createLong(str);
}
return createInteger(str);
}
final char lastChar = str.charAt(str.length() - 1);
String mant;
String dec;
String exp;
final int decPos = str.indexOf('.');
final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present
// if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
// and the parsing which will detect if e or E appear in a number due to using the wrong offset

int numDecimals = 0; // Check required precision (LANG-693)
if (decPos > -1) { // there is a decimal point

if (expPos > -1) { // there is an exponent
if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
throw new NumberFormatException(str + "" is not a valid number."");
}
dec = str.substring(decPos + 1, expPos);
} else {
dec = str.substring(decPos + 1);
}
mant = str.substring(0, decPos);
numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
} else {
if (expPos > -1) {
if (expPos > str.length()) { // prevents double exponent causing IOOBE
throw new NumberFormatException(str + "" is not a valid number."");
}
mant = str.substring(0, expPos);
} else {
mant = str;
}
dec = null;
}
if (!Character.isDigit(lastChar) && lastChar != '.') {
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length() - 1);
} else {
exp = null;
}
//Requesting a specific type..
final String numeric = str.substring(0, str.length() - 1);
final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
switch (lastChar) {
case 'l' :
case 'L' :
if (dec == null
&& exp == null
&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
try {
return createLong(numeric);
} catch (final NumberFormatException nfe) { // NOPMD
// Too big for a long
}
return createBigInteger(numeric);

}
throw new NumberFormatException(str + "" is not a valid number."");
case 'f' :
case 'F' :
try {
final Float f = NumberUtils.createFloat(numeric);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
//If it's too big for a float or the float value = 0 and the string
//has non-zeros in it, then float does not have the precision we want
return f;
}

} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
//$FALL-THROUGH$
case 'd' :
case 'D' :
try {
final Double d = NumberUtils.createDouble(numeric);
if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
return d;
}
} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
try {
return createBigDecimal(numeric);
} catch (final NumberFormatException e) { // NOPMD
// ignore the bad number
}
//$FALL-THROUGH$
default :
throw new NumberFormatException(str + "" is not a valid number."");

}
}
//User doesn't have a preference on the return type, so let's start
//small and go from there...
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length());
} else {
exp = null;
}
if (dec == null && exp == null) { // no decimal point and no exponent
//Must be an Integer, Long, Biginteger
try {
return createInteger(str);
} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
try {
return createLong(str);
} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
return createBigInteger(str);
}

//Must be a Float, Double, BigDecimal
final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
try {
if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float
final Float f = createFloat(str);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
return f;
}
}
} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
try {
if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double
final Double d = createDouble(str);
if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
return d;
}
}
} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}

return createBigDecimal(str);
}"
Lang_3b_1,/path/to/defects4j_buggy/Lang_3_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static Number createNumber(final String str) throws NumberFormatException {
if (str == null) {
return null;
}
if (StringUtils.isBlank(str)) {
throw new NumberFormatException(""A blank string is not a valid number"");
}
// Need to deal with all possible hex prefixes here
final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
int pfxLen = 0;
for(final String pfx : hex_prefixes) {
if (str.startsWith(pfx)) {
pfxLen += pfx.length();
break;
}
}
if (pfxLen > 0) { // we have a hex number
final int hexDigits = str.length() - pfxLen;
if (hexDigits > 16) { // too many for Long
return createBigInteger(str);
}
if (hexDigits > 8) { // too many for an int
return createLong(str);
}
return createInteger(str);
}
final char lastChar = str.charAt(str.length() - 1);
String mant;
String dec;
String exp;
final int decPos = str.indexOf('.');
final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present
// if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
// and the parsing which will detect if e or E appear in a number due to using the wrong offset

int numDecimals = 0; // Check required precision (LANG-693)
if (decPos > -1) { // there is a decimal point

if (expPos > -1) { // there is an exponent
if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
throw new NumberFormatException(str + "" is not a valid number."");
}
dec = str.substring(decPos + 1, expPos);
} else {
dec = str.substring(decPos + 1);
}
mant = str.substring(0, decPos);
numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
} else {
if (expPos > -1) {
if (expPos > str.length()) { // prevents double exponent causing IOOBE
throw new NumberFormatException(str + "" is not a valid number."");
}
mant = str.substring(0, expPos);
} else {
mant = str;
}
dec = null;
}
if (!Character.isDigit(lastChar) && lastChar != '.') {
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length() - 1);
} else {
exp = null;
}
//Requesting a specific type..
final String numeric = str.substring(0, str.length() - 1);
final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
switch (lastChar) {
case 'l' :
case 'L' :
if (dec == null
&& exp == null
&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
try {
return createLong(numeric);
} catch (final NumberFormatException nfe) { // NOPMD
// Too big for a long
}
return createBigInteger(numeric);

}
throw new NumberFormatException(str + "" is not a valid number."");
case 'f' :
case 'F' :
try {
final Float f = NumberUtils.createFloat(numeric);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
//If it's too big for a float or the float value = 0 and the string
//has non-zeros in it, then float does not have the precision we want
return f;
}

} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
//$FALL-THROUGH$
case 'd' :
case 'D' :
try {
final Double d = NumberUtils.createDouble(numeric);
if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
return d;
}
} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
try {
return createBigDecimal(numeric);
} catch (final NumberFormatException e) { // NOPMD
// ignore the bad number
}
//$FALL-THROUGH$
default :
throw new NumberFormatException(str + "" is not a valid number."");

}
}
//User doesn't have a preference on the return type, so let's start
//small and go from there...
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length());
} else {
exp = null;
}
if (dec == null && exp == null) { // no decimal point and no exponent
//Must be an Integer, Long, Biginteger
try {
return createInteger(str);
} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
try {
return createLong(str);
} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
return createBigInteger(str);
}

//Must be a Float, Double, BigDecimal
final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
try {
final Float f = createFloat(str);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
return f;
}
} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
try {
final Double d = createDouble(str);
if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
return d;
}
} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}

return createBigDecimal(str);
}"
Lang_5b_1,/path/to/defects4j_buggy/Lang_5_buggy/src/main/java/org/apache/commons/lang3/LocaleUtils.java,"public static Locale toLocale(final String str) {
if (str == null) {
return null;
}
final int len = str.length();
if (len < 2) {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
final char ch0 = str.charAt(0);
final char ch1 = str.charAt(1);
if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
if (len == 2) {
return new Locale(str);
}
if (len < 5) {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
if (str.charAt(2) != '_') {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
final char ch3 = str.charAt(3);
if (ch3 == '_') {
return new Locale(str.substring(0, 2), """", str.substring(4));
}
final char ch4 = str.charAt(4);
if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
if (len == 5) {
return new Locale(str.substring(0, 2), str.substring(3, 5));
}
if (len < 7) {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
if (str.charAt(5) != '_') {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
}"
Lang_6b_1,/path/to/defects4j_buggy/Lang_6_buggy/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java,"public final String translate(CharSequence input) {
if (input == null) {
return null;
}
try {
StringWriter writer = new StringWriter(input.length() * 2);
translate(input, writer);
return writer.toString();
} catch (IOException ioe) {
// this should never ever happen while writing to a StringWriter
throw new RuntimeException(ioe);
}
}"
Lang_9b_1,/path/to/defects4j_buggy/Lang_9_buggy/src/main/java/org/apache/commons/lang3/time/FastDateParser.java,"Pattern getParsePattern() {
return parsePattern;
}"
Lang_10b_1,/path/to/defects4j_buggy/Lang_10_buggy/src/main/java/org/apache/commons/lang3/time/FastDateParser.java,"Pattern getParsePattern() {
return parsePattern;
}"
Lang_11b_1,/path/to/defects4j_buggy/Lang_11_buggy/src/main/java/org/apache/commons/lang3/RandomStringUtils.java,"return random(count, start, end, letters, numbers, null, RANDOM);
}

/**
* <p>Creates a random string based on a variety of options, using
* default source of randomness.</p>
*
* <p>This method has exactly the same semantics as
* {@link #random(int,int,int,boolean,boolean,char[],Random)}, but
* instead of using an externally supplied source of randomness, it uses
* the internal static {@link Random} instance.</p>
*
* @param count  the length of random string to create
* @param start  the position in set of chars to start at
* @param end  the position in set of chars to end before
* @param letters  only allow letters?
* @param numbers  only allow numbers?
* @param chars  the set of chars to choose randoms from.
*  If {@code null}, then it will use the set of all chars.
* @return the random string
* @throws ArrayIndexOutOfBoundsException if there are not
*  {@code (end - start) + 1} characters in the set array.
*/
public static String random(int count, int start, int end, boolean letters, boolean numbers, char... chars) {"
Lang_12b_1,/path/to/defects4j_buggy/Lang_12_buggy/src/main/java/org/apache/commons/lang3/RandomStringUtils.java,"return random(count, false, false);
}

/**
* <p>Creates a random string whose length is the number of characters
* specified.</p>
*
* <p>Characters will be chosen from the set of characters whose
* ASCII value is between {@code 32} and {@code 126} (inclusive).</p>
*
* @param count  the length of random string to create
* @return the random string
*/
public static String randomAscii(int count) {"
Lang_14b_1,/path/to/defects4j_buggy/Lang_14_buggy/src/main/java/org/apache/commons/lang3/StringUtils.java,"public static boolean equals(CharSequence cs1, CharSequence cs2) {
if (cs1 == cs2) {
return true;
}
if (cs1 == null || cs2 == null) {
return false;
}
return cs1.equals(cs2);
}"
Lang_16b_1,/path/to/defects4j_buggy/Lang_16_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static Number createNumber(String str) throws NumberFormatException {
if (str == null) {
return null;
}
if (StringUtils.isBlank(str)) {
throw new NumberFormatException(""A blank string is not a valid number"");
}
if (str.startsWith(""--"")) {
// this is protection for poorness in java.lang.BigDecimal.
// it accepts this as a legal value, but it does not appear
// to be in specification of class. OS X Java parses it to
// a wrong value.
return null;
}
if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
return createInteger(str);
}
char lastChar = str.charAt(str.length() - 1);
String mant;
String dec;
String exp;
int decPos = str.indexOf('.');
int expPos = str.indexOf('e') + str.indexOf('E') + 1;

if (decPos > -1) {

if (expPos > -1) {
if (expPos < decPos || expPos > str.length()) {
throw new NumberFormatException(str + "" is not a valid number."");
}
dec = str.substring(decPos + 1, expPos);
} else {
dec = str.substring(decPos + 1);
}
mant = str.substring(0, decPos);
} else {
if (expPos > -1) {
if (expPos > str.length()) {
throw new NumberFormatException(str + "" is not a valid number."");
}
mant = str.substring(0, expPos);
} else {
mant = str;
}
dec = null;
}
if (!Character.isDigit(lastChar) && lastChar != '.') {
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length() - 1);
} else {
exp = null;
}
//Requesting a specific type..
String numeric = str.substring(0, str.length() - 1);
boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
switch (lastChar) {
case 'l' :
case 'L' :
if (dec == null
&& exp == null
&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
try {
return createLong(numeric);
} catch (NumberFormatException nfe) { // NOPMD
// Too big for a long
}
return createBigInteger(numeric);

}
throw new NumberFormatException(str + "" is not a valid number."");
case 'f' :
case 'F' :
try {
Float f = NumberUtils.createFloat(numeric);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
//If it's too big for a float or the float value = 0 and the string
//has non-zeros in it, then float does not have the precision we want
return f;
}

} catch (NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
//$FALL-THROUGH$
case 'd' :
case 'D' :
try {
Double d = NumberUtils.createDouble(numeric);
if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
return d;
}
} catch (NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
try {
return createBigDecimal(numeric);
} catch (NumberFormatException e) { // NOPMD
// ignore the bad number
}
//$FALL-THROUGH$
default :
throw new NumberFormatException(str + "" is not a valid number."");

}
} else {
//User doesn't have a preference on the return type, so let's start
//small and go from there...
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length());
} else {
exp = null;
}
if (dec == null && exp == null) {
//Must be an int,long,bigint
try {
return createInteger(str);
} catch (NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
try {
return createLong(str);
} catch (NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
return createBigInteger(str);

} else {
//Must be a float,double,BigDec
boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
try {
Float f = createFloat(str);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
return f;
}
} catch (NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
try {
Double d = createDouble(str);
if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
return d;
}
} catch (NumberFormatException nfe) { // NOPMD
// ignore the bad number
}

return createBigDecimal(str);

}
}
}"
Lang_17b_1,/path/to/defects4j_buggy/Lang_17_buggy/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java,"public final String translate(CharSequence input) {
if (input == null) {
return null;
}
try {
StringWriter writer = new StringWriter(input.length() * 2);
translate(input, writer);
return writer.toString();
} catch (IOException ioe) {
// this should never ever happen while writing to a StringWriter
throw new RuntimeException(ioe);
}
}"
Lang_19b_1,/path/to/defects4j_buggy/Lang_19_buggy/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java,"public int translate(CharSequence input, int index, Writer out) throws IOException {
int seqEnd = input.length();
// Uses -2 to ensure there is something after the &#
if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
int start = index + 2;
boolean isHex = false;

char firstChar = input.charAt(start);
if(firstChar == 'x' || firstChar == 'X') {
start++;
isHex = true;

// Check there's more than just an x after the &#
}

int end = start;
// Note that this supports character codes without a ; on the end
while(input.charAt(end) != ';')
{
end++;
}

int entityValue;
try {
if(isHex) {
entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
} else {
entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
}
} catch(NumberFormatException nfe) {
System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
return 0;
}

if(entityValue > 0xFFFF) {
char[] chrs = Character.toChars(entityValue);
out.write(chrs[0]);
out.write(chrs[1]);
} else {
out.write(entityValue);
}


return 2 + (end - start) + (isHex ? 1 : 0) + 1;
}
return 0;
}"
Lang_21b_1,/path/to/defects4j_buggy/Lang_21_buggy/src/main/java/org/apache/commons/lang3/time/DateUtils.java,"public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {
if (cal1 == null || cal2 == null) {
throw new IllegalArgumentException(""The date must not be null"");
}
return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&
cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&
cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&
cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&
cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&
cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&
cal1.getClass() == cal2.getClass());
}"
Lang_22b_1,/path/to/defects4j_buggy/Lang_22_buggy/src/main/java/org/apache/commons/lang3/math/Fraction.java,"public static Fraction getReducedFraction(int numerator, int denominator) {
if (denominator == 0) {
throw new ArithmeticException(""The denominator must not be zero"");
}
if (numerator==0) {
return ZERO; // normalize zero.
}
// allow 2^k/-2^31 as a valid fraction (where k>0)
if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {
numerator/=2; denominator/=2;
}
if (denominator < 0) {
if (numerator==Integer.MIN_VALUE ||
denominator==Integer.MIN_VALUE) {
throw new ArithmeticException(""overflow: can't negate"");
}
numerator = -numerator;
denominator = -denominator;
}
// simplify fraction.
int gcd = greatestCommonDivisor(numerator, denominator);
numerator /= gcd;
denominator /= gcd;
return new Fraction(numerator, denominator);
}"
Lang_24b_1,/path/to/defects4j_buggy/Lang_24_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static Number createNumber(String str) throws NumberFormatException {
if (str == null) {
return null;
}
if (StringUtils.isBlank(str)) {
throw new NumberFormatException(""A blank string is not a valid number"");
}
if (str.startsWith(""--"")) {
// this is protection for poorness in java.lang.BigDecimal.
// it accepts this as a legal value, but it does not appear
// to be in specification of class. OS X Java parses it to
// a wrong value.
return null;
}
if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
return createInteger(str);
}
char lastChar = str.charAt(str.length() - 1);
String mant;
String dec;
String exp;
int decPos = str.indexOf('.');
int expPos = str.indexOf('e') + str.indexOf('E') + 1;

if (decPos > -1) {

if (expPos > -1) {
if (expPos < decPos || expPos > str.length()) {
throw new NumberFormatException(str + "" is not a valid number."");
}
dec = str.substring(decPos + 1, expPos);
} else {
dec = str.substring(decPos + 1);
}
mant = str.substring(0, decPos);
} else {
if (expPos > -1) {
if (expPos > str.length()) {
throw new NumberFormatException(str + "" is not a valid number."");
}
mant = str.substring(0, expPos);
} else {
mant = str;
}
dec = null;
}
if (!Character.isDigit(lastChar) && lastChar != '.') {
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length() - 1);
} else {
exp = null;
}
//Requesting a specific type..
String numeric = str.substring(0, str.length() - 1);
boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
switch (lastChar) {
case 'l' :
case 'L' :
if (dec == null
&& exp == null
&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
try {
return createLong(numeric);
} catch (NumberFormatException nfe) {
//Too big for a long
}
return createBigInteger(numeric);

}
throw new NumberFormatException(str + "" is not a valid number."");
case 'f' :
case 'F' :
try {
Float f = NumberUtils.createFloat(numeric);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
//If it's too big for a float or the float value = 0 and the string
//has non-zeros in it, then float does not have the precision we want
return f;
}

} catch (NumberFormatException nfe) {
// ignore the bad number
}
//$FALL-THROUGH$
case 'd' :
case 'D' :
try {
Double d = NumberUtils.createDouble(numeric);
if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
return d;
}
} catch (NumberFormatException nfe) {
// ignore the bad number
}
try {
return createBigDecimal(numeric);
} catch (NumberFormatException e) {
// ignore the bad number
}
//$FALL-THROUGH$
default :
throw new NumberFormatException(str + "" is not a valid number."");

}
} else {
//User doesn't have a preference on the return type, so let's start
//small and go from there...
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length());
} else {
exp = null;
}
if (dec == null && exp == null) {
//Must be an int,long,bigint
try {
return createInteger(str);
} catch (NumberFormatException nfe) {
// ignore the bad number
}
try {
return createLong(str);
} catch (NumberFormatException nfe) {
// ignore the bad number
}
return createBigInteger(str);

} else {
//Must be a float,double,BigDec
boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
try {
Float f = createFloat(str);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
return f;
}
} catch (NumberFormatException nfe) {
// ignore the bad number
}
try {
Double d = createDouble(str);
if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
return d;
}
} catch (NumberFormatException nfe) {
// ignore the bad number
}

return createBigDecimal(str);

}
}
}"
Lang_26b_1,/path/to/defects4j_buggy/Lang_26_buggy/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java,"protected List<Rule> parsePattern() {
DateFormatSymbols symbols = new DateFormatSymbols(mLocale);
List<Rule> rules = new ArrayList<Rule>();

String[] ERAs = symbols.getEras();
String[] months = symbols.getMonths();
String[] shortMonths = symbols.getShortMonths();
String[] weekdays = symbols.getWeekdays();
String[] shortWeekdays = symbols.getShortWeekdays();
String[] AmPmStrings = symbols.getAmPmStrings();

int length = mPattern.length();
int[] indexRef = new int[1];

for (int i = 0; i < length; i++) {
indexRef[0] = i;
String token = parseToken(mPattern, indexRef);
i = indexRef[0];

int tokenLen = token.length();
if (tokenLen == 0) {
break;
}

Rule rule;
char c = token.charAt(0);

switch (c) {
case 'G': // era designator (text)
rule = new TextField(Calendar.ERA, ERAs);
break;
case 'y': // year (number)
if (tokenLen >= 4) {
rule = selectNumberRule(Calendar.YEAR, tokenLen);
} else {
rule = TwoDigitYearField.INSTANCE;
}
break;
case 'M': // month in year (text and number)
if (tokenLen >= 4) {
rule = new TextField(Calendar.MONTH, months);
} else if (tokenLen == 3) {
rule = new TextField(Calendar.MONTH, shortMonths);
} else if (tokenLen == 2) {
rule = TwoDigitMonthField.INSTANCE;
} else {
rule = UnpaddedMonthField.INSTANCE;
}
break;
case 'd': // day in month (number)
rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);
break;
case 'h': // hour in am/pm (number, 1..12)
rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));
break;
case 'H': // hour in day (number, 0..23)
rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);
break;
case 'm': // minute in hour (number)
rule = selectNumberRule(Calendar.MINUTE, tokenLen);
break;
case 's': // second in minute (number)
rule = selectNumberRule(Calendar.SECOND, tokenLen);
break;
case 'S': // millisecond (number)
rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);
break;
case 'E': // day in week (text)
rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);
break;
case 'D': // day in year (number)
rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);
break;
case 'F': // day of week in month (number)
rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);
break;
case 'w': // week in year (number)
rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);
break;
case 'W': // week in month (number)
rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);
break;
case 'a': // am/pm marker (text)
rule = new TextField(Calendar.AM_PM, AmPmStrings);
break;
case 'k': // hour in day (1..24)
rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));
break;
case 'K': // hour in am/pm (0..11)
rule = selectNumberRule(Calendar.HOUR, tokenLen);
break;
case 'z': // time zone (text)
if (tokenLen >= 4) {
rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);
} else {
rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);
}
break;
case 'Z': // time zone (value)
if (tokenLen == 1) {
rule = TimeZoneNumberRule.INSTANCE_NO_COLON;
} else {
rule = TimeZoneNumberRule.INSTANCE_COLON;
}
break;
case '\'': // literal text
String sub = token.substring(1);
if (sub.length() == 1) {
rule = new CharacterLiteral(sub.charAt(0));
} else {
rule = new StringLiteral(sub);
}
break;
default:
throw new IllegalArgumentException(""Illegal pattern component: "" + token);
}

rules.add(rule);
}

return rules;
}"
Lang_27b_1,/path/to/defects4j_buggy/Lang_27_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static Number createNumber(String str) throws NumberFormatException {
if (str == null) {
return null;
}
if (StringUtils.isBlank(str)) {
throw new NumberFormatException(""A blank string is not a valid number"");
}
if (str.startsWith(""--"")) {
// this is protection for poorness in java.lang.BigDecimal.
// it accepts this as a legal value, but it does not appear
// to be in specification of class. OS X Java parses it to
// a wrong value.
return null;
}
if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
return createInteger(str);
}
char lastChar = str.charAt(str.length() - 1);
String mant;
String dec;
String exp;
int decPos = str.indexOf('.');
int expPos = str.indexOf('e') + str.indexOf('E') + 1;

if (decPos > -1) {

if (expPos > -1) {
if (expPos < decPos) {
throw new NumberFormatException(str + "" is not a valid number."");
}
dec = str.substring(decPos + 1, expPos);
} else {
dec = str.substring(decPos + 1);
}
mant = str.substring(0, decPos);
} else {
if (expPos > -1) {
mant = str.substring(0, expPos);
} else {
mant = str;
}
dec = null;
}
if (!Character.isDigit(lastChar) && lastChar != '.') {
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length() - 1);
} else {
exp = null;
}
//Requesting a specific type..
String numeric = str.substring(0, str.length() - 1);
boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
switch (lastChar) {
case 'l' :
case 'L' :
if (dec == null
&& exp == null
&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
try {
return createLong(numeric);
} catch (NumberFormatException nfe) {
//Too big for a long
}
return createBigInteger(numeric);

}
throw new NumberFormatException(str + "" is not a valid number."");
case 'f' :
case 'F' :
try {
Float f = NumberUtils.createFloat(numeric);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
//If it's too big for a float or the float value = 0 and the string
//has non-zeros in it, then float does not have the precision we want
return f;
}

} catch (NumberFormatException nfe) {
// ignore the bad number
}
//$FALL-THROUGH$
case 'd' :
case 'D' :
try {
Double d = NumberUtils.createDouble(numeric);
if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
return d;
}
} catch (NumberFormatException nfe) {
// ignore the bad number
}
try {
return createBigDecimal(numeric);
} catch (NumberFormatException e) {
// ignore the bad number
}
//$FALL-THROUGH$
default :
throw new NumberFormatException(str + "" is not a valid number."");

}
} else {
//User doesn't have a preference on the return type, so let's start
//small and go from there...
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length());
} else {
exp = null;
}
if (dec == null && exp == null) {
//Must be an int,long,bigint
try {
return createInteger(str);
} catch (NumberFormatException nfe) {
// ignore the bad number
}
try {
return createLong(str);
} catch (NumberFormatException nfe) {
// ignore the bad number
}
return createBigInteger(str);

} else {
//Must be a float,double,BigDec
boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
try {
Float f = createFloat(str);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
return f;
}
} catch (NumberFormatException nfe) {
// ignore the bad number
}
try {
Double d = createDouble(str);
if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
return d;
}
} catch (NumberFormatException nfe) {
// ignore the bad number
}

return createBigDecimal(str);

}
}
}"
Lang_28b_1,/path/to/defects4j_buggy/Lang_28_buggy/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java,"public int translate(CharSequence input, int index, Writer out) throws IOException {
// TODO: Protect from ArrayIndexOutOfBounds
if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {
int start = index + 2;
boolean isHex = false;

char firstChar = input.charAt(start);
if(firstChar == 'x' || firstChar == 'X') {
start++;
isHex = true;
}

int end = start;
while(input.charAt(end) != ';') {
end++;
}

int entityValue;
try {
if(isHex) {
entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
} else {
entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
}
} catch(NumberFormatException nfe) {
return 0;
}

out.write(entityValue);
return 2 + (end - start) + (isHex ? 1 : 0) + 1;
}
return 0;
}"
Lang_29b_1,/path/to/defects4j_buggy/Lang_29_buggy/src/main/java/org/apache/commons/lang3/SystemUtils.java,"static float toJavaVersionInt(String version) {
return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));
}"
Lang_31b_1,/path/to/defects4j_buggy/Lang_31_buggy/src/main/java/org/apache/commons/lang3/StringUtils.java,"public static boolean containsAny(CharSequence cs, char[] searchChars) {
if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
return false;
}
int csLength = cs.length();
int searchLength = searchChars.length;
for (int i = 0; i < csLength; i++) {
char ch = cs.charAt(i);
for (int j = 0; j < searchLength; j++) {
if (searchChars[j] == ch) {
// ch is a supplementary character
// ch is in the Basic Multilingual Plane
return true;
}
}
}
return false;
}"
Lang_33b_1,/path/to/defects4j_buggy/Lang_33_buggy/src/main/java/org/apache/commons/lang3/ClassUtils.java,"public static Class<?>[] toClass(Object[] array) {
if (array == null) {
return null;
} else if (array.length == 0) {
return ArrayUtils.EMPTY_CLASS_ARRAY;
}
Class<?>[] classes = new Class[array.length];
for (int i = 0; i < array.length; i++) {
classes[i] = array[i].getClass();
}
return classes;
}"
Lang_37b_1,/path/to/defects4j_buggy/Lang_37_buggy/src/java/org/apache/commons/lang3/ArrayUtils.java,"public static <T> T[] addAll(T[] array1, T... array2) {
if (array1 == null) {
return clone(array2);
} else if (array2 == null) {
return clone(array1);
}
final Class<?> type1 = array1.getClass().getComponentType();
T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
// Check if problem is incompatible types
return joinedArray;
}"
Lang_38b_1,/path/to/defects4j_buggy/Lang_38_buggy/src/java/org/apache/commons/lang3/time/FastDateFormat.java,"protected List<Rule> parsePattern() {
DateFormatSymbols symbols = new DateFormatSymbols(mLocale);
List<Rule> rules = new ArrayList<Rule>();

String[] ERAs = symbols.getEras();
String[] months = symbols.getMonths();
String[] shortMonths = symbols.getShortMonths();
String[] weekdays = symbols.getWeekdays();
String[] shortWeekdays = symbols.getShortWeekdays();
String[] AmPmStrings = symbols.getAmPmStrings();

int length = mPattern.length();
int[] indexRef = new int[1];

for (int i = 0; i < length; i++) {
indexRef[0] = i;
String token = parseToken(mPattern, indexRef);
i = indexRef[0];

int tokenLen = token.length();
if (tokenLen == 0) {
break;
}

Rule rule;
char c = token.charAt(0);

switch (c) {
case 'G': // era designator (text)
rule = new TextField(Calendar.ERA, ERAs);
break;
case 'y': // year (number)
if (tokenLen >= 4) {
rule = selectNumberRule(Calendar.YEAR, tokenLen);
} else {
rule = TwoDigitYearField.INSTANCE;
}
break;
case 'M': // month in year (text and number)
if (tokenLen >= 4) {
rule = new TextField(Calendar.MONTH, months);
} else if (tokenLen == 3) {
rule = new TextField(Calendar.MONTH, shortMonths);
} else if (tokenLen == 2) {
rule = TwoDigitMonthField.INSTANCE;
} else {
rule = UnpaddedMonthField.INSTANCE;
}
break;
case 'd': // day in month (number)
rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);
break;
case 'h': // hour in am/pm (number, 1..12)
rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));
break;
case 'H': // hour in day (number, 0..23)
rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);
break;
case 'm': // minute in hour (number)
rule = selectNumberRule(Calendar.MINUTE, tokenLen);
break;
case 's': // second in minute (number)
rule = selectNumberRule(Calendar.SECOND, tokenLen);
break;
case 'S': // millisecond (number)
rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);
break;
case 'E': // day in week (text)
rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);
break;
case 'D': // day in year (number)
rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);
break;
case 'F': // day of week in month (number)
rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);
break;
case 'w': // week in year (number)
rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);
break;
case 'W': // week in month (number)
rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);
break;
case 'a': // am/pm marker (text)
rule = new TextField(Calendar.AM_PM, AmPmStrings);
break;
case 'k': // hour in day (1..24)
rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));
break;
case 'K': // hour in am/pm (0..11)
rule = selectNumberRule(Calendar.HOUR, tokenLen);
break;
case 'z': // time zone (text)
if (tokenLen >= 4) {
rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);
} else {
rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);
}
break;
case 'Z': // time zone (value)
if (tokenLen == 1) {
rule = TimeZoneNumberRule.INSTANCE_NO_COLON;
} else {
rule = TimeZoneNumberRule.INSTANCE_COLON;
}
break;
case '\'': // literal text
String sub = token.substring(1);
if (sub.length() == 1) {
rule = new CharacterLiteral(sub.charAt(0));
} else {
rule = new StringLiteral(sub);
}
break;
default:
throw new IllegalArgumentException(""Illegal pattern component: "" + token);
}

rules.add(rule);
}

return rules;
}"
Lang_39b_1,/path/to/defects4j_buggy/Lang_39_buggy/src/java/org/apache/commons/lang3/StringUtils.java,"return replaceEach(text, searchList, replacementList, false, 0);
}

/**
* <p>
* Replaces all occurrences of Strings within another String.
* </p>
*
* <p>
* A <code>null</code> reference passed to this method is a no-op, or if
* any ""search string"" or ""string to replace"" is null, that replace will be
* ignored. This will not repeat. For repeating replaces, call the
* overloaded method.
* </p>
*
* <pre>
*  StringUtils.replaceEach(null, *, *, *) = null
*  StringUtils.replaceEach("""", *, *, *) = """"
*  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
*  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
*  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
*  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
*  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
*  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
*  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
*  (example of how it repeats)
*  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
*  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
*  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, true) = IllegalArgumentException
*  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, false) = ""dcabe""
* </pre>
*
* @param text
*            text to search and replace in, no-op if null
* @param searchList
*            the Strings to search for, no-op if null
* @param replacementList
*            the Strings to replace them with, no-op if null
* @return the text with any replacements processed, <code>null</code> if
*         null String input
* @throws IllegalArgumentException
*             if the search is repeating and there is an endless loop due
*             to outputs of one being inputs to another
* @throws IndexOutOfBoundsException
*             if the lengths of the arrays are not the same (null is ok,
*             and/or size 0)
* @since 2.4
*/
public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {"
Lang_40b_1,/path/to/defects4j_buggy/Lang_40_buggy/src/java/org/apache/commons/lang/StringUtils.java,"public static boolean containsIgnoreCase(String str, String searchStr) {
if (str == null || searchStr == null) {
return false;
}
return contains(str.toUpperCase(), searchStr.toUpperCase());
}"
Lang_42b_1,/path/to/defects4j_buggy/Lang_42_buggy/src/java/org/apache/commons/lang/Entities.java,"public void escape(Writer writer, String str) throws IOException {
int len = str.length();
for (int i = 0; i < len; i++) {
char c = str.charAt(i);
String entityName = this.entityName(c);
if (entityName == null) {
if (c > 0x7F) {
writer.write(""&#"");
writer.write(Integer.toString(c, 10));
writer.write(';');
} else {
writer.write(c);
}
} else {
writer.write('&');
writer.write(entityName);
writer.write(';');
}
}
}"
Lang_43b_1,/path/to/defects4j_buggy/Lang_43_buggy/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java,"public final void applyPattern(String pattern) {
if (registry == null) {
super.applyPattern(pattern);
toPattern = super.toPattern();
return;
}
ArrayList foundFormats = new ArrayList();
ArrayList foundDescriptions = new ArrayList();
StringBuffer stripCustom = new StringBuffer(pattern.length());

ParsePosition pos = new ParsePosition(0);
char[] c = pattern.toCharArray();
int fmtCount = 0;
while (pos.getIndex() < pattern.length()) {
switch (c[pos.getIndex()]) {
case QUOTE:
appendQuotedString(pattern, pos, stripCustom, true);
break;
case START_FE:
fmtCount++;
seekNonWs(pattern, pos);
int start = pos.getIndex();
int index = readArgumentIndex(pattern, next(pos));
stripCustom.append(START_FE).append(index);
seekNonWs(pattern, pos);
Format format = null;
String formatDescription = null;
if (c[pos.getIndex()] == START_FMT) {
formatDescription = parseFormatDescription(pattern,
next(pos));
format = getFormat(formatDescription);
if (format == null) {
stripCustom.append(START_FMT).append(formatDescription);
}
}
foundFormats.add(format);
foundDescriptions.add(format == null ? null : formatDescription);
Validate.isTrue(foundFormats.size() == fmtCount);
Validate.isTrue(foundDescriptions.size() == fmtCount);
if (c[pos.getIndex()] != END_FE) {
throw new IllegalArgumentException(
""Unreadable format element at position "" + start);
}
// fall through
default:
stripCustom.append(c[pos.getIndex()]);
next(pos);
}
}
super.applyPattern(stripCustom.toString());
toPattern = insertFormats(super.toPattern(), foundDescriptions);
if (containsElements(foundFormats)) {
Format[] origFormats = getFormats();
// only loop over what we know we have, as MessageFormat on Java 1.3
// seems to provide an extra format element:
int i = 0;
for (Iterator it = foundFormats.iterator(); it.hasNext(); i++) {
Format f = (Format) it.next();
if (f != null) {
origFormats[i] = f;
}
}
super.setFormats(origFormats);
}
}"
Lang_44b_1,/path/to/defects4j_buggy/Lang_44_buggy/src/java/org/apache/commons/lang/NumberUtils.java,"public static Number createNumber(String val) throws NumberFormatException {
if (val == null) {
return null;
}
if (val.length() == 0) {
throw new NumberFormatException(""\""\"" is not a valid number."");
}
if (val.startsWith(""--"")) {
// this is protection for poorness in java.lang.BigDecimal.
// it accepts this as a legal value, but it does not appear
// to be in specification of class. OS X Java parses it to
// a wrong value.
return null;
}
if (val.startsWith(""0x"") || val.startsWith(""-0x"")) {
return createInteger(val);
}
char lastChar = val.charAt(val.length() - 1);
String mant;
String dec;
String exp;
int decPos = val.indexOf('.');
int expPos = val.indexOf('e') + val.indexOf('E') + 1;

if (decPos > -1) {

if (expPos > -1) {
if (expPos < decPos) {
throw new NumberFormatException(val + "" is not a valid number."");
}
dec = val.substring(decPos + 1, expPos);
} else {
dec = val.substring(decPos + 1);
}
mant = val.substring(0, decPos);
} else {
if (expPos > -1) {
mant = val.substring(0, expPos);
} else {
mant = val;
}
dec = null;
}
if (!Character.isDigit(lastChar)) {
if (expPos > -1 && expPos < val.length() - 1) {
exp = val.substring(expPos + 1, val.length() - 1);
} else {
exp = null;
}
//Requesting a specific type..
String numeric = val.substring(0, val.length() - 1);
boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
switch (lastChar) {
case 'l' :
case 'L' :
if (dec == null
&& exp == null
&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
try {
return createLong(numeric);
} catch (NumberFormatException nfe) {
//Too big for a long
}
return createBigInteger(numeric);

}
throw new NumberFormatException(val + "" is not a valid number."");
case 'f' :
case 'F' :
try {
Float f = NumberUtils.createFloat(numeric);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
//If it's too big for a float or the float value = 0 and the string
//has non-zeros in it, then float does not have the precision we want
return f;
}

} catch (NumberFormatException e) {
// ignore the bad number
}
//Fall through
case 'd' :
case 'D' :
try {
Double d = NumberUtils.createDouble(numeric);
if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
return d;
}
} catch (NumberFormatException nfe) {
// empty catch
}
try {
return createBigDecimal(numeric);
} catch (NumberFormatException e) {
// empty catch
}
//Fall through
default :
throw new NumberFormatException(val + "" is not a valid number."");

}
} else {
//User doesn't have a preference on the return type, so let's start
//small and go from there...
if (expPos > -1 && expPos < val.length() - 1) {
exp = val.substring(expPos + 1, val.length());
} else {
exp = null;
}
if (dec == null && exp == null) {
//Must be an int,long,bigint
try {
return createInteger(val);
} catch (NumberFormatException nfe) {
// empty catch
}
try {
return createLong(val);
} catch (NumberFormatException nfe) {
// empty catch
}
return createBigInteger(val);

} else {
//Must be a float,double,BigDec
boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
try {
Float f = createFloat(val);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
return f;
}
} catch (NumberFormatException nfe) {
// empty catch
}
try {
Double d = createDouble(val);
if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
return d;
}
} catch (NumberFormatException nfe) {
// empty catch
}

return createBigDecimal(val);

}

}
}"
Lang_45b_1,/path/to/defects4j_buggy/Lang_45_buggy/src/java/org/apache/commons/lang/WordUtils.java,"public static String abbreviate(String str, int lower, int upper, String appendToEnd) {
// initial parameter checks
if (str == null) {
return null;
}
if (str.length() == 0) {
return StringUtils.EMPTY;
}

// if the lower value is greater than the length of the string,
// set to the length of the string
// if the upper value is -1 (i.e. no limit) or is greater
// than the length of the string, set to the length of the string
if (upper == -1 || upper > str.length()) {
upper = str.length();
}
// if upper is less than lower, raise it to lower
if (upper < lower) {
upper = lower;
}

StringBuffer result = new StringBuffer();
int index = StringUtils.indexOf(str, "" "", lower);
if (index == -1) {
result.append(str.substring(0, upper));
// only if abbreviation has occured do we append the appendToEnd value
if (upper != str.length()) {
result.append(StringUtils.defaultString(appendToEnd));
}
} else if (index > upper) {
result.append(str.substring(0, upper));
result.append(StringUtils.defaultString(appendToEnd));
} else {
result.append(str.substring(0, index));
result.append(StringUtils.defaultString(appendToEnd));
}
return result.toString();
}"
Lang_49b_1,/path/to/defects4j_buggy/Lang_49_buggy/src/java/org/apache/commons/lang/math/Fraction.java,"public Fraction reduce() {
int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
if (gcd == 1) {
return this;
}
return Fraction.getFraction(numerator / gcd, denominator / gcd);
}"
Lang_51b_1,/path/to/defects4j_buggy/Lang_51_buggy/src/java/org/apache/commons/lang/BooleanUtils.java,"public static boolean toBoolean(String str) {
// Previously used equalsIgnoreCase, which was fast for interned 'true'.
// Non interned 'true' matched 15 times slower.
//
// Optimisation provides same performance as before for interned 'true'.
// Similar performance for null, 'false', and other strings not length 2/3/4.
// 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.
if (str == ""true"") {
return true;
}
if (str == null) {
return false;
}
switch (str.length()) {
case 2: {
char ch0 = str.charAt(0);
char ch1 = str.charAt(1);
return
(ch0 == 'o' || ch0 == 'O') &&
(ch1 == 'n' || ch1 == 'N');
}
case 3: {
char ch = str.charAt(0);
if (ch == 'y') {
return
(str.charAt(1) == 'e' || str.charAt(1) == 'E') &&
(str.charAt(2) == 's' || str.charAt(2) == 'S');
}
if (ch == 'Y') {
return
(str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
(str.charAt(2) == 'S' || str.charAt(2) == 's');
}
}
case 4: {
char ch = str.charAt(0);
if (ch == 't') {
return
(str.charAt(1) == 'r' || str.charAt(1) == 'R') &&
(str.charAt(2) == 'u' || str.charAt(2) == 'U') &&
(str.charAt(3) == 'e' || str.charAt(3) == 'E');
}
if (ch == 'T') {
return
(str.charAt(1) == 'R' || str.charAt(1) == 'r') &&
(str.charAt(2) == 'U' || str.charAt(2) == 'u') &&
(str.charAt(3) == 'E' || str.charAt(3) == 'e');
}
}
}
return false;
}"
Lang_52b_1,/path/to/defects4j_buggy/Lang_52_buggy/src/java/org/apache/commons/lang/StringEscapeUtils.java,"public static String escapeJavaScript(String str) {
return escapeJavaStyleString(str, true);
}"
Lang_53b_1,/path/to/defects4j_buggy/Lang_53_buggy/src/java/org/apache/commons/lang/time/DateUtils.java,"public static Date round(Date date, int field) {
if (date == null) {
throw new IllegalArgumentException(""The date must not be null"");
}
Calendar gval = Calendar.getInstance();
gval.setTime(date);
modify(gval, field, true);
return gval.getTime();
}"
Lang_54b_1,/path/to/defects4j_buggy/Lang_54_buggy/src/java/org/apache/commons/lang/LocaleUtils.java,"public static Locale toLocale(String str) {
if (str == null) {
return null;
}
int len = str.length();
if (len != 2 && len != 5 && len < 7) {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
char ch0 = str.charAt(0);
char ch1 = str.charAt(1);
if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
if (len == 2) {
return new Locale(str, """");
} else {
if (str.charAt(2) != '_') {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
char ch3 = str.charAt(3);
char ch4 = str.charAt(4);
if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
if (len == 5) {
return new Locale(str.substring(0, 2), str.substring(3, 5));
} else {
if (str.charAt(5) != '_') {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
}
}
}"
Lang_55b_1,/path/to/defects4j_buggy/Lang_55_buggy/src/java/org/apache/commons/lang/time/StopWatch.java,"public void suspend() {
if(this.runningState != STATE_RUNNING) {
throw new IllegalStateException(""Stopwatch must be running to suspend. "");
}
stopTime = System.currentTimeMillis();
this.runningState = STATE_SUSPENDED;
}"
Lang_57b_1,/path/to/defects4j_buggy/Lang_57_buggy/src/java/org/apache/commons/lang/LocaleUtils.java,"public static boolean isAvailableLocale(Locale locale) {
return cAvailableLocaleSet.contains(locale);
}"
Lang_58b_1,/path/to/defects4j_buggy/Lang_58_buggy/src/java/org/apache/commons/lang/math/NumberUtils.java,"public static Number createNumber(String str) throws NumberFormatException {
if (str == null) {
return null;
}
if (StringUtils.isBlank(str)) {
throw new NumberFormatException(""A blank string is not a valid number"");
}
if (str.startsWith(""--"")) {
// this is protection for poorness in java.lang.BigDecimal.
// it accepts this as a legal value, but it does not appear
// to be in specification of class. OS X Java parses it to
// a wrong value.
return null;
}
if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
return createInteger(str);
}
char lastChar = str.charAt(str.length() - 1);
String mant;
String dec;
String exp;
int decPos = str.indexOf('.');
int expPos = str.indexOf('e') + str.indexOf('E') + 1;

if (decPos > -1) {

if (expPos > -1) {
if (expPos < decPos) {
throw new NumberFormatException(str + "" is not a valid number."");
}
dec = str.substring(decPos + 1, expPos);
} else {
dec = str.substring(decPos + 1);
}
mant = str.substring(0, decPos);
} else {
if (expPos > -1) {
mant = str.substring(0, expPos);
} else {
mant = str;
}
dec = null;
}
if (!Character.isDigit(lastChar)) {
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length() - 1);
} else {
exp = null;
}
//Requesting a specific type..
String numeric = str.substring(0, str.length() - 1);
boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
switch (lastChar) {
case 'l' :
case 'L' :
if (dec == null
&& exp == null
&& isDigits(numeric.substring(1))
&& (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
try {
return createLong(numeric);
} catch (NumberFormatException nfe) {
//Too big for a long
}
return createBigInteger(numeric);

}
throw new NumberFormatException(str + "" is not a valid number."");
case 'f' :
case 'F' :
try {
Float f = NumberUtils.createFloat(numeric);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
//If it's too big for a float or the float value = 0 and the string
//has non-zeros in it, then float does not have the precision we want
return f;
}

} catch (NumberFormatException nfe) {
// ignore the bad number
}
//Fall through
case 'd' :
case 'D' :
try {
Double d = NumberUtils.createDouble(numeric);
if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
return d;
}
} catch (NumberFormatException nfe) {
// ignore the bad number
}
try {
return createBigDecimal(numeric);
} catch (NumberFormatException e) {
// ignore the bad number
}
//Fall through
default :
throw new NumberFormatException(str + "" is not a valid number."");

}
} else {
//User doesn't have a preference on the return type, so let's start
//small and go from there...
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length());
} else {
exp = null;
}
if (dec == null && exp == null) {
//Must be an int,long,bigint
try {
return createInteger(str);
} catch (NumberFormatException nfe) {
// ignore the bad number
}
try {
return createLong(str);
} catch (NumberFormatException nfe) {
// ignore the bad number
}
return createBigInteger(str);

} else {
//Must be a float,double,BigDec
boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
try {
Float f = createFloat(str);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
return f;
}
} catch (NumberFormatException nfe) {
// ignore the bad number
}
try {
Double d = createDouble(str);
if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
return d;
}
} catch (NumberFormatException nfe) {
// ignore the bad number
}

return createBigDecimal(str);

}
}
}"
Lang_59b_1,/path/to/defects4j_buggy/Lang_59_buggy/src/java/org/apache/commons/lang/text/StrBuilder.java,"public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {
if (width > 0) {
ensureCapacity(size + width);
String str = (obj == null ? getNullText() : obj.toString());
int strLen = str.length();
if (strLen >= width) {
str.getChars(0, strLen, buffer, size);
} else {
int padLen = width - strLen;
str.getChars(0, strLen, buffer, size);
for (int i = 0; i < padLen; i++) {
buffer[size + strLen + i] = padChar;
}
}
size += width;
}
return this;
}"
Lang_61b_1,/path/to/defects4j_buggy/Lang_61_buggy/src/java/org/apache/commons/lang/text/StrBuilder.java,"public StrBuilder deleteAll(String str) {
int len = (str == null ? 0 : str.length());
if (len > 0) {
int index = indexOf(str, 0);
while (index >= 0) {
deleteImpl(index, index + len, len);
index = indexOf(str, index);
}
}
return this;
}"
Lang_65b_1,/path/to/defects4j_buggy/Lang_65_buggy/src/java/org/apache/commons/lang/time/DateUtils.java,"public static Date truncate(Date date, int field) {
if (date == null) {
throw new IllegalArgumentException(""The date must not be null"");
}
Calendar gval = Calendar.getInstance();
gval.setTime(date);
modify(gval, field, false);
return gval.getTime();
}"
Math_2b_1,/path/to/defects4j_buggy/Math_2_buggy/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java,"public double getNumericalMean() {
return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();
}"
Math_3b_1,/path/to/defects4j_buggy/Math_3_buggy/src/main/java/org/apache/commons/math3/util/MathArrays.java,"public static double linearCombination(final double[] a, final double[] b)
throws DimensionMismatchException {
final int len = a.length;
if (len != b.length) {
throw new DimensionMismatchException(len, b.length);
}

// Revert to scalar multiplication.

final double[] prodHigh = new double[len];
double prodLowSum = 0;

for (int i = 0; i < len; i++) {
final double ai = a[i];
final double ca = SPLIT_FACTOR * ai;
final double aHigh = ca - (ca - ai);
final double aLow = ai - aHigh;

final double bi = b[i];
final double cb = SPLIT_FACTOR * bi;
final double bHigh = cb - (cb - bi);
final double bLow = bi - bHigh;
prodHigh[i] = ai * bi;
final double prodLow = aLow * bLow - (((prodHigh[i] -
aHigh * bHigh) -
aLow * bHigh) -
aHigh * bLow);
prodLowSum += prodLow;
}


final double prodHighCur = prodHigh[0];
double prodHighNext = prodHigh[1];
double sHighPrev = prodHighCur + prodHighNext;
double sPrime = sHighPrev - prodHighNext;
double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);

final int lenMinusOne = len - 1;
for (int i = 1; i < lenMinusOne; i++) {
prodHighNext = prodHigh[i + 1];
final double sHighCur = sHighPrev + prodHighNext;
sPrime = sHighCur - prodHighNext;
sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);
sHighPrev = sHighCur;
}

double result = sHighPrev + (prodLowSum + sLowSum);

if (Double.isNaN(result)) {
// either we have split infinite numbers or some coefficients were NaNs,
// just rely on the naive implementation and let IEEE754 handle this
result = 0;
for (int i = 0; i < len; ++i) {
result += a[i] * b[i];
}
}

return result;
}"
Math_5b_1,/path/to/defects4j_buggy/Math_5_buggy/src/main/java/org/apache/commons/math3/complex/Complex.java,"public Complex reciprocal() {
if (isNaN) {
return NaN;
}

if (real == 0.0 && imaginary == 0.0) {
return NaN;
}

if (isInfinite) {
return ZERO;
}

if (FastMath.abs(real) < FastMath.abs(imaginary)) {
double q = real / imaginary;
double scale = 1. / (real * q + imaginary);
return createComplex(scale * q, -scale);
} else {
double q = imaginary / real;
double scale = 1. / (imaginary * q + real);
return createComplex(scale, -scale * q);
}
}"
Math_7b_1,/path/to/defects4j_buggy/Math_7_buggy/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java,"protected double acceptStep(final AbstractStepInterpolator interpolator,
final double[] y, final double[] yDot, final double tEnd)"
Math_8b_1,/path/to/defects4j_buggy/Math_8_buggy/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java,"public DiscreteDistribution(final List<Pair<T, Double>> samples)
throws NotPositiveException, MathArithmeticException, MathIllegalArgumentException {
this(new Well19937c(), samples);
}"
Math_9b_1,/path/to/defects4j_buggy/Math_9_buggy/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java,"public Line revert() {
final Line reverted = new Line(zero, zero.subtract(direction));
return reverted;
}"
Math_10b_1,/path/to/defects4j_buggy/Math_10_buggy/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java,"public void atan2(final double[] y, final int yOffset,
final double[] x, final int xOffset,"
Math_11b_1,/path/to/defects4j_buggy/Math_11_buggy/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java,"public double density(final double[] vals) throws DimensionMismatchException {
final int dim = getDimension();
if (vals.length != dim) {
throw new DimensionMismatchException(vals.length, dim);
}

return FastMath.pow(2 * FastMath.PI, -dim / 2) *
FastMath.pow(covarianceMatrixDeterminant, -0.5) *
getExponentTerm(vals);
}"
Math_13b_1,/path/to/defects4j_buggy/Math_13_buggy/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java,"protected AbstractLeastSquaresOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {
super(checker);
}"
Math_17b_1,/path/to/defects4j_buggy/Math_17_buggy/src/main/java/org/apache/commons/math3/dfp/Dfp.java,"public Dfp multiply(final Dfp x) {

// make sure we don't mix number with different precision
if (field.getRadixDigits() != x.field.getRadixDigits()) {
field.setIEEEFlagsBits(DfpField.FLAG_INVALID);
final Dfp result = newInstance(getZero());
result.nans = QNAN;
return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);
}

Dfp result = newInstance(getZero());

/* handle special cases */
if (nans != FINITE || x.nans != FINITE) {
if (isNaN()) {
return this;
}

if (x.isNaN()) {
return x;
}

if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {
result = newInstance(this);
result.sign = (byte) (sign * x.sign);
return result;
}

if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {
result = newInstance(x);
result.sign = (byte) (sign * x.sign);
return result;
}

if (x.nans == INFINITE && nans == INFINITE) {
result = newInstance(this);
result.sign = (byte) (sign * x.sign);
return result;
}

if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||
(nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) {
field.setIEEEFlagsBits(DfpField.FLAG_INVALID);
result = newInstance(getZero());
result.nans = QNAN;
result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);
return result;
}
}

int[] product = new int[mant.length*2];  // Big enough to hold even the largest result

for (int i = 0; i < mant.length; i++) {
int rh = 0;  // acts as a carry
for (int j=0; j<mant.length; j++) {
int r = mant[i] * x.mant[j];    // multiply the 2 digits
r = r + product[i+j] + rh;  // add to the product digit with carry in

rh = r / RADIX;
product[i+j] = r - rh * RADIX;
}
product[i+mant.length] = rh;
}

// Find the most sig digit
int md = mant.length * 2 - 1;  // default, in case result is zero
for (int i = mant.length * 2 - 1; i >= 0; i--) {
if (product[i] != 0) {
md = i;
break;
}
}

// Copy the digits into the result
for (int i = 0; i < mant.length; i++) {
result.mant[mant.length - i - 1] = product[md - i];
}

// Fixup the exponent.
result.exp = exp + x.exp + md - 2 * mant.length + 1;
result.sign = (byte)((sign == x.sign)?1:-1);

if (result.mant[mant.length-1] == 0) {
// if result is zero, set exp to zero
result.exp = 0;
}

final int excp;
if (md > (mant.length-1)) {
excp = result.round(product[md-mant.length]);
} else {
excp = result.round(0); // has no effect except to check status
}

if (excp != 0) {
result = dotrap(excp, MULTIPLY_TRAP, x, result);
}

return result;

}"
Math_19b_1,/path/to/defects4j_buggy/Math_19_buggy/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java,"private void initializeCMA(double[] guess) {
if (lambda <= 0) {
lambda = 4 + (int) (3. * Math.log(dimension));
}
// initialize sigma
double[][] sigmaArray = new double[guess.length][1];
for (int i = 0; i < guess.length; i++) {
final double range =  (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];
sigmaArray[i][0]   = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;
}
RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);
sigma = max(insigma); // overall standard deviation

// initialize termination criteria
stopTolUpX = 1e3 * max(insigma);
stopTolX = 1e-11 * max(insigma);
stopTolFun = 1e-12;
stopTolHistFun = 1e-13;

// initialize selection strategy parameters
mu = lambda / 2; // number of parents/points for recombination
logMu2 = Math.log(mu + 0.5);
weights = log(sequence(1, mu, 1)).scalarMultiply(-1.).scalarAdd(logMu2);
double sumw = 0;
double sumwq = 0;
for (int i = 0; i < mu; i++) {
double w = weights.getEntry(i, 0);
sumw += w;
sumwq += w * w;
}
weights = weights.scalarMultiply(1. / sumw);
mueff = sumw * sumw / sumwq; // variance-effectiveness of sum w_i x_i

// initialize dynamic strategy parameters and constants
cc = (4. + mueff / dimension) /
(dimension + 4. + 2. * mueff / dimension);
cs = (mueff + 2.) / (dimension + mueff + 3.);
damps = (1. + 2. * Math.max(0, Math.sqrt((mueff - 1.) /
(dimension + 1.)) - 1.)) *
Math.max(0.3, 1. - dimension /
(1e-6 + Math.min(maxIterations, getMaxEvaluations() /
lambda))) + cs; // minor increment
ccov1 = 2. / ((dimension + 1.3) * (dimension + 1.3) + mueff);
ccovmu = Math.min(1 - ccov1, 2. * (mueff - 2. + 1. / mueff) /
((dimension + 2.) * (dimension + 2.) + mueff));
ccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) / 3.);
ccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3.);
chiN = Math.sqrt(dimension) *
(1. - 1. / (4. * dimension) + 1 / (21. * dimension * dimension));
// intialize CMA internal values - updated each generation
xmean = MatrixUtils.createColumnRealMatrix(guess); // objective
// variables
diagD = insigma.scalarMultiply(1. / sigma);
diagC = square(diagD);
pc = zeros(dimension, 1); // evolution paths for C and sigma
ps = zeros(dimension, 1); // B defines the coordinate system
normps = ps.getFrobeniusNorm();

B = eye(dimension, dimension);
D = ones(dimension, 1); // diagonal D defines the scaling
BD = times(B, repmat(diagD.transpose(), dimension, 1));
C = B.multiply(diag(square(D)).multiply(B.transpose())); // covariance
historySize = 10 + (int) (3. * 10. * dimension / lambda);
fitnessHistory = new double[historySize]; // history of fitness values
for (int i = 0; i < historySize; i++) {
fitnessHistory[i] = Double.MAX_VALUE;
}
}"
Math_20b_1,/path/to/defects4j_buggy/Math_20_buggy/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java,"protected PointValuePair doOptimize() {
checkParameters();
// -------------------- Initialization --------------------------------
isMinimize = getGoalType().equals(GoalType.MINIMIZE);
final FitnessFunction fitfun = new FitnessFunction();
final double[] guess = fitfun.encode(getStartPoint());
// number of objective variables/problem dimension
dimension = guess.length;
initializeCMA(guess);
iterations = 0;
double bestValue = fitfun.value(guess);
push(fitnessHistory, bestValue);
PointValuePair optimum = new PointValuePair(getStartPoint(),
isMinimize ? bestValue : -bestValue);
PointValuePair lastResult = null;

// -------------------- Generation Loop --------------------------------

generationLoop:
for (iterations = 1; iterations <= maxIterations; iterations++) {
// Generate and evaluate lambda offspring
RealMatrix arz = randn1(dimension, lambda);
RealMatrix arx = zeros(dimension, lambda);
double[] fitness = new double[lambda];
// generate random offspring
for (int k = 0; k < lambda; k++) {
RealMatrix arxk = null;
for (int i = 0; i < checkFeasableCount+1; i++) {
if (diagonalOnly <= 0) {
arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))
.scalarMultiply(sigma)); // m + sig * Normal(0,C)
} else {
arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))
.scalarMultiply(sigma));
}
if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {
break;
}
// regenerate random arguments for row
arz.setColumn(k, randn(dimension));
}
copyColumn(arxk, 0, arx, k);
try {
fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness
} catch (TooManyEvaluationsException e) {
break generationLoop;
}
}
// Sort by fitness and compute weighted mean into xmean
int[] arindex = sortedIndices(fitness);
// Calculate new xmean, this is selection and recombination
RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)
RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));
xmean = bestArx.multiply(weights);
RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));
RealMatrix zmean = bestArz.multiply(weights);
boolean hsig = updateEvolutionPaths(zmean, xold);
if (diagonalOnly <= 0) {
updateCovariance(hsig, bestArx, arz, arindex, xold);
} else {
updateCovarianceDiagonalOnly(hsig, bestArz, xold);
}
// Adapt step size sigma - Eq. (5)
sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps));
double bestFitness = fitness[arindex[0]];
double worstFitness = fitness[arindex[arindex.length-1]];
if (bestValue > bestFitness) {
bestValue = bestFitness;
lastResult = optimum;
optimum = new PointValuePair(
fitfun.repairAndDecode(bestArx.getColumn(0)),
isMinimize ? bestFitness : -bestFitness);
if (getConvergenceChecker() != null && lastResult != null) {
if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {
break generationLoop;
}
}
}
// handle termination criteria
// Break, if fitness is good enough
if (stopFitness != 0) { // only if stopFitness is defined
if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {
break generationLoop;
}
}
double[] sqrtDiagC = sqrt(diagC).getColumn(0);
double[] pcCol = pc.getColumn(0);
for (int i = 0; i < dimension; i++) {
if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {
break;
}
if (i >= dimension-1) {
break generationLoop;
}
}
for (int i = 0; i < dimension; i++) {
if (sigma*sqrtDiagC[i] > stopTolUpX) {
break generationLoop;
}
}
double historyBest = min(fitnessHistory);
double historyWorst = max(fitnessHistory);
if (iterations > 2 && Math.max(historyWorst, worstFitness) -
Math.min(historyBest, bestFitness) < stopTolFun) {
break generationLoop;
}
if (iterations > fitnessHistory.length &&
historyWorst-historyBest < stopTolHistFun) {
break generationLoop;
}
// condition number of the covariance matrix exceeds 1e14
if (max(diagD)/min(diagD) > 1e7) {
break generationLoop;
}
// user defined termination
if (getConvergenceChecker() != null) {
PointValuePair current =
new PointValuePair(bestArx.getColumn(0),
isMinimize ? bestFitness : -bestFitness);
if (lastResult != null &&
getConvergenceChecker().converged(iterations, current, lastResult)) {
break generationLoop;
}
lastResult = current;
}
// Adjust step size in case of equal function values (flat fitness)
if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {
sigma = sigma * Math.exp(0.2+cs/damps);
}
if (iterations > 2 && Math.max(historyWorst, bestFitness) -
Math.min(historyBest, bestFitness) == 0) {
sigma = sigma * Math.exp(0.2+cs/damps);
}
// store best in history
push(fitnessHistory,bestFitness);
fitfun.setValueRange(worstFitness-bestFitness);
if (generateStatistics) {
statisticsSigmaHistory.add(sigma);
statisticsFitnessHistory.add(bestFitness);
statisticsMeanHistory.add(xmean.transpose());
statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));
}
}
return optimum;
}"
Math_21b_1,/path/to/defects4j_buggy/Math_21_buggy/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java,"public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
throws NonPositiveDefiniteMatrixException {

final int order = matrix.getRowDimension();
final double[][] c = matrix.getData();
final double[][] b = new double[order][order];

int[] swap  = new int[order];
int[] index = new int[order];
for (int i = 0; i < order; ++i) {
index[i] = i;
}

int r = 0;
for (boolean loop = true; loop;) {

// find maximal diagonal element
swap[r] = r;
for (int i = r + 1; i < order; ++i) {
int ii  = index[i];
int isi = index[swap[i]];
if (c[ii][ii] > c[isi][isi]) {
swap[r] = i;
}
}


// swap elements
if (swap[r] != r) {
int tmp = index[r];
index[r] = index[swap[r]];
index[swap[r]] = tmp;
}

// check diagonal element
int ir = index[r];
if (c[ir][ir] < small) {

if (r == 0) {
throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);
}

// check remaining diagonal elements
for (int i = r; i < order; ++i) {
if (c[index[i]][index[i]] < -small) {
// there is at least one sufficiently negative diagonal element,
// the symmetric positive semidefinite matrix is wrong
throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);
}
}

// all remaining diagonal elements are close to zero, we consider we have
// found the rank of the symmetric positive semidefinite matrix
++r;
loop = false;

} else {

// transform the matrix
final double sqrt = FastMath.sqrt(c[ir][ir]);
b[r][r] = sqrt;
final double inverse  = 1 / sqrt;
for (int i = r + 1; i < order; ++i) {
final int ii = index[i];
final double e = inverse * c[ii][ir];
b[i][r] = e;
c[ii][ii] -= e * e;
for (int j = r + 1; j < i; ++j) {
final int ij = index[j];
final double f = c[ii][ij] - e * b[j][r];
c[ii][ij] = f;
c[ij][ii] = f;
}
}

// prepare next iteration
loop = ++r < order;
}
}

// build the root matrix
rank = r;
root = MatrixUtils.createRealMatrix(order, r);
for (int i = 0; i < order; ++i) {
for (int j = 0; j < r; ++j) {
root.setEntry(index[i], j, b[i][j]);
}
}

}"
Math_23b_1,/path/to/defects4j_buggy/Math_23_buggy/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java,"protected UnivariatePointValuePair doOptimize() {
final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
final double lo = getMin();
final double mid = getStartValue();
final double hi = getMax();

// Optional additional convergence criteria.
final ConvergenceChecker<UnivariatePointValuePair> checker
= getConvergenceChecker();

double a;
double b;
if (lo < hi) {
a = lo;
b = hi;
} else {
a = hi;
b = lo;
}

double x = mid;
double v = x;
double w = x;
double d = 0;
double e = 0;
double fx = computeObjectiveValue(x);
if (!isMinim) {
fx = -fx;
}
double fv = fx;
double fw = fx;

UnivariatePointValuePair previous = null;
UnivariatePointValuePair current
= new UnivariatePointValuePair(x, isMinim ? fx : -fx);
// Best point encountered so far (which is the initial guess).

int iter = 0;
while (true) {
final double m = 0.5 * (a + b);
final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
final double tol2 = 2 * tol1;

// Default stopping criterion.
final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
if (!stop) {
double p = 0;
double q = 0;
double r = 0;
double u = 0;

if (FastMath.abs(e) > tol1) { // Fit parabola.
r = (x - w) * (fx - fv);
q = (x - v) * (fx - fw);
p = (x - v) * q - (x - w) * r;
q = 2 * (q - r);

if (q > 0) {
p = -p;
} else {
q = -q;
}

r = e;
e = d;

if (p > q * (a - x) &&
p < q * (b - x) &&
FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
// Parabolic interpolation step.
d = p / q;
u = x + d;

// f must not be evaluated too close to a or b.
if (u - a < tol2 || b - u < tol2) {
if (x <= m) {
d = tol1;
} else {
d = -tol1;
}
}
} else {
// Golden section step.
if (x < m) {
e = b - x;
} else {
e = a - x;
}
d = GOLDEN_SECTION * e;
}
} else {
// Golden section step.
if (x < m) {
e = b - x;
} else {
e = a - x;
}
d = GOLDEN_SECTION * e;
}

// Update by at least ""tol1"".
if (FastMath.abs(d) < tol1) {
if (d >= 0) {
u = x + tol1;
} else {
u = x - tol1;
}
} else {
u = x + d;
}

double fu = computeObjectiveValue(u);
if (!isMinim) {
fu = -fu;
}

// User-defined convergence checker.
previous = current;
current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

if (checker != null) {
if (checker.converged(iter, previous, current)) {
return best(current, previous, isMinim);
}
}

// Update a, b, v, w and x.
if (fu <= fx) {
if (u < x) {
b = x;
} else {
a = x;
}
v = w;
fv = fw;
w = x;
fw = fx;
x = u;
fx = fu;
} else {
if (u < x) {
a = u;
} else {
b = u;
}
if (fu <= fw ||
Precision.equals(w, x)) {
v = w;
fv = fw;
w = u;
fw = fu;
} else if (fu <= fv ||
Precision.equals(v, x) ||
Precision.equals(v, w)) {
v = u;
fv = fu;
}
}
} else { // Default termination (Brent's criterion).
return
best(current,
previous,
isMinim);
}
++iter;
}
}"
Math_24b_1,/path/to/defects4j_buggy/Math_24_buggy/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java,"protected UnivariatePointValuePair doOptimize() {
final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
final double lo = getMin();
final double mid = getStartValue();
final double hi = getMax();

// Optional additional convergence criteria.
final ConvergenceChecker<UnivariatePointValuePair> checker
= getConvergenceChecker();

double a;
double b;
if (lo < hi) {
a = lo;
b = hi;
} else {
a = hi;
b = lo;
}

double x = mid;
double v = x;
double w = x;
double d = 0;
double e = 0;
double fx = computeObjectiveValue(x);
if (!isMinim) {
fx = -fx;
}
double fv = fx;
double fw = fx;

UnivariatePointValuePair previous = null;
UnivariatePointValuePair current
= new UnivariatePointValuePair(x, isMinim ? fx : -fx);

int iter = 0;
while (true) {
final double m = 0.5 * (a + b);
final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
final double tol2 = 2 * tol1;

// Default stopping criterion.
final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
if (!stop) {
double p = 0;
double q = 0;
double r = 0;
double u = 0;

if (FastMath.abs(e) > tol1) { // Fit parabola.
r = (x - w) * (fx - fv);
q = (x - v) * (fx - fw);
p = (x - v) * q - (x - w) * r;
q = 2 * (q - r);

if (q > 0) {
p = -p;
} else {
q = -q;
}

r = e;
e = d;

if (p > q * (a - x) &&
p < q * (b - x) &&
FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
// Parabolic interpolation step.
d = p / q;
u = x + d;

// f must not be evaluated too close to a or b.
if (u - a < tol2 || b - u < tol2) {
if (x <= m) {
d = tol1;
} else {
d = -tol1;
}
}
} else {
// Golden section step.
if (x < m) {
e = b - x;
} else {
e = a - x;
}
d = GOLDEN_SECTION * e;
}
} else {
// Golden section step.
if (x < m) {
e = b - x;
} else {
e = a - x;
}
d = GOLDEN_SECTION * e;
}

// Update by at least ""tol1"".
if (FastMath.abs(d) < tol1) {
if (d >= 0) {
u = x + tol1;
} else {
u = x - tol1;
}
} else {
u = x + d;
}

double fu = computeObjectiveValue(u);
if (!isMinim) {
fu = -fu;
}

// User-defined convergence checker.
previous = current;
current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

if (checker != null) {
if (checker.converged(iter, previous, current)) {
return current;
}
}

// Update a, b, v, w and x.
if (fu <= fx) {
if (u < x) {
b = x;
} else {
a = x;
}
v = w;
fv = fw;
w = x;
fw = fx;
x = u;
fx = fu;
} else {
if (u < x) {
a = u;
} else {
b = u;
}
if (fu <= fw ||
Precision.equals(w, x)) {
v = w;
fv = fw;
w = u;
fw = fu;
} else if (fu <= fv ||
Precision.equals(v, x) ||
Precision.equals(v, w)) {
v = u;
fv = fu;
}
}
} else { // Default termination (Brent's criterion).
return current;
}
++iter;
}
}"
Math_25b_1,/path/to/defects4j_buggy/Math_25_buggy/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java,"private void guessAOmega() {
            // initialize the sums for the linear model between the two integrals
            double sx2 = 0;
            double sy2 = 0;
            double sxy = 0;
            double sxz = 0;
            double syz = 0;

            double currentX = observations[0].getX();
            double currentY = observations[0].getY();
            double f2Integral = 0;
            double fPrime2Integral = 0;
            final double startX = currentX;
            for (int i = 1; i < observations.length; ++i) {
                // one step forward
                final double previousX = currentX;
                final double previousY = currentY;
                currentX = observations[i].getX();
                currentY = observations[i].getY();

                // update the integrals of f<sup>2</sup> and f'<sup>2</sup>
                // considering a linear model for f (and therefore constant f')
                final double dx = currentX - previousX;
                final double dy = currentY - previousY;
                final double f2StepIntegral =
                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
                final double fPrime2StepIntegral = dy * dy / dx;

                final double x = currentX - startX;
                f2Integral += f2StepIntegral;
                fPrime2Integral += fPrime2StepIntegral;

                sx2 += x * x;
                sy2 += f2Integral * f2Integral;
                sxy += x * f2Integral;
                sxz += x * fPrime2Integral;
                syz += f2Integral * fPrime2Integral;
            }

            // compute the amplitude and pulsation coefficients
            double c1 = sy2 * sxz - sxy * syz;
            double c2 = sxy * sxz - sx2 * syz;
            double c3 = sx2 * sy2 - sxy * sxy;
            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {
                final int last = observations.length - 1;
                // Range of the observations, assuming that the
                // observations are sorted.
                final double xRange = observations[last].getX() - observations[0].getX();
                if (xRange == 0) {
                    throw new ZeroException();
                }
                omega = 2 * Math.PI / xRange;

                double yMin = Double.POSITIVE_INFINITY;
                double yMax = Double.NEGATIVE_INFINITY;
                for (int i = 1; i < observations.length; ++i) {
                    final double y = observations[i].getY();
                    if (y < yMin) {
                        yMin = y;
                    }
                    if (y > yMax) {
                        yMax = y;
                    }
                }
                a = 0.5 * (yMax - yMin);
            } else {
                    // In some ill-conditioned cases (cf. MATH-844), the guesser
                    // procedure cannot produce sensible results.

                a = FastMath.sqrt(c1 / c2);
                omega = FastMath.sqrt(c2 / c3);
            }
        }"
Math_26b_1,/path/to/defects4j_buggy/Math_26_buggy/src/main/java/org/apache/commons/math3/fraction/Fraction.java,"public Fraction(double value, double epsilon, int maxIterations)
throws FractionConversionException"
Math_27b_1,/path/to/defects4j_buggy/Math_27_buggy/src/main/java/org/apache/commons/math3/fraction/Fraction.java,"public double percentageValue() {
return multiply(100).doubleValue();
}"
Math_28b_1,/path/to/defects4j_buggy/Math_28_buggy/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java,"private Integer getPivotRow(SimplexTableau tableau, final int col) {
// create a list of all the rows that tie for the lowest score in the minimum ratio test
List<Integer> minRatioPositions = new ArrayList<Integer>();
double minRatio = Double.MAX_VALUE;
for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
final double entry = tableau.getEntry(i, col);

if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
final double ratio = rhs / entry;
// check if the entry is strictly equal to the current min ratio
// do not use a ulp/epsilon check
final int cmp = Double.compare(ratio, minRatio);
if (cmp == 0) {
minRatioPositions.add(i);
} else if (cmp < 0) {
minRatio = ratio;
minRatioPositions = new ArrayList<Integer>();
minRatioPositions.add(i);
}
}
}

if (minRatioPositions.size() == 0) {
return null;
} else if (minRatioPositions.size() > 1) {
// there's a degeneracy as indicated by a tie in the minimum ratio test

// 1. check if there's an artificial variable that can be forced out of the basis
for (Integer row : minRatioPositions) {
for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
int column = i + tableau.getArtificialVariableOffset();
final double entry = tableau.getEntry(row, column);
if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {
return row;
}
}
}

// 2. apply Bland's rule to prevent cycling:
//    take the row for which the corresponding basic variable has the smallest index
//
// see http://www.stanford.edu/class/msande310/blandrule.pdf
// see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)
//
// Additional heuristic: if we did not get a solution after half of maxIterations
//                       revert to the simple case of just returning the top-most row
// This heuristic is based on empirical data gathered while investigating MATH-828.
Integer minRow = null;
int minIndex = tableau.getWidth();
for (Integer row : minRatioPositions) {
int i = tableau.getNumObjectiveFunctions();
for (; i < tableau.getWidth() - 1 && minRow != row; i++) {
if (row == tableau.getBasicRow(i)) {
if (i < minIndex) {
minIndex = i;
minRow = row;
}
}
}
}
return minRow;
}
return minRatioPositions.get(0);
}"
Math_30b_1,/path/to/defects4j_buggy/Math_30_buggy/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java,"private void ensureDataConformance(final double[] x, final double[] y)
throws NullArgumentException, NoDataException {

if (x == null ||
y == null) {
throw new NullArgumentException();
}
if (x.length == 0 ||
y.length == 0) {
throw new NoDataException();
}
}"
Math_31b_1,/path/to/defects4j_buggy/Math_31_buggy/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java,"public double evaluate(double x, double epsilon, int maxIterations) {
final double small = 1e-50;
double hPrev = getA(0, x);

// use the value of small as epsilon criteria for zero checks
if (Precision.equals(hPrev, 0.0, small)) {
hPrev = small;
}

int n = 1;
double dPrev = 0.0;
double p0 = 1.0;
double q1 = 1.0;
double cPrev = hPrev;
double hN = hPrev;

while (n < maxIterations) {
final double a = getA(n, x);
final double b = getB(n, x);

double cN = a * hPrev + b * p0;
double q2 = a * q1 + b * dPrev;
if (Double.isInfinite(cN) || Double.isInfinite(q2)) {
double scaleFactor = 1d;
double lastScaleFactor = 1d;
final int maxPower = 5;
final double scale = FastMath.max(a,b);
if (scale <= 0) {  // Can't scale
throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
}
for (int i = 0; i < maxPower; i++) {
lastScaleFactor = scaleFactor;
scaleFactor *= scale;
if (a != 0.0 && a > b) {
cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);
q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);
} else if (b != 0) {
cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;
q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;
}
if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {
break;
}
}
}

final double deltaN = cN / q2 / cPrev;
hN = cPrev * deltaN;

if (Double.isInfinite(hN)) {
throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,
x);
}
if (Double.isNaN(hN)) {
throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,
x);
}

if (FastMath.abs(deltaN - 1.0) < epsilon) {
break;
}

dPrev = q1;
cPrev = cN / q2;
p0 = hPrev;
hPrev = cN;
q1 = q2;
n++;
}

if (n >= maxIterations) {
throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,
maxIterations, x);
}

return hN;
}"
Math_32b_1,/path/to/defects4j_buggy/Math_32_buggy/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java,"public PolygonsSet() {
super();
}"
Math_33b_1,/path/to/defects4j_buggy/Math_33_buggy/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java,"protected PointValuePair getSolution() {
int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);
Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;
double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());

Set<Integer> basicRows = new HashSet<Integer>();
double[] coefficients = new double[getOriginalNumDecisionVariables()];
for (int i = 0; i < coefficients.length; i++) {
int colIndex = columnLabels.indexOf(""x"" + i);
if (colIndex < 0) {
coefficients[i] = 0;
continue;
}
Integer basicRow = getBasicRow(colIndex);
if (basicRow != null && basicRow == 0) {
// if the basic row is found to be the objective function row
// set the coefficient to 0 -> this case handles unconstrained
// variables that are still part of the objective function
coefficients[i] = 0;
} else if (basicRows.contains(basicRow)) {
// if multiple variables can take a given value
// then we choose the first and set the rest equal to 0
coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
} else {
basicRows.add(basicRow);
coefficients[i] =
(basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
(restrictToNonNegative ? 0 : mostNegative);
}
}
return new PointValuePair(coefficients, f.getValue(coefficients));
}"
Math_34b_1,/path/to/defects4j_buggy/Math_34_buggy/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java,Incomplete method body detected.
Math_38b_1,/path/to/defects4j_buggy/Math_38_buggy/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java,"private void prelim(double[] lowerBound,
double[] upperBound) {
printMethod(); // XXX

final int n = currentBest.getDimension();
final int npt = numberOfInterpolationPoints;
final int ndim = bMatrix.getRowDimension();

final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;
final double recip = 1d / rhosq;
final int np = n + 1;

// Set XBASE to the initial vector of variables, and set the initial
// elements of XPT, BMAT, HQ, PQ and ZMAT to zero.

for (int j = 0; j < n; j++) {
originShift.setEntry(j, currentBest.getEntry(j));
for (int k = 0; k < npt; k++) {
interpolationPoints.setEntry(k, j, ZERO);
}
for (int i = 0; i < ndim; i++) {
bMatrix.setEntry(i, j, ZERO);
}
}
for (int i = 0, max = n * np / 2; i < max; i++) {
modelSecondDerivativesValues.setEntry(i, ZERO);
}
for (int k = 0; k < npt; k++) {
modelSecondDerivativesParameters.setEntry(k, ZERO);
for (int j = 0, max = npt - np; j < max; j++) {
zMatrix.setEntry(k, j, ZERO);
}
}

// Begin the initialization procedure. NF becomes one more than the number
// of function values so far. The coordinates of the displacement of the
// next initial interpolation point from XBASE are set in XPT(NF+1,.).

int ipt = 0;
int jpt = 0;
double fbeg = Double.NaN;
do {
final int nfm = getEvaluations();
final int nfx = nfm - n;
final int nfmm = nfm - 1;
final int nfxm = nfx - 1;
double stepa = 0;
double stepb = 0;
if (nfm <= 2 * n) {
if (nfm >= 1 &&
nfm <= n) {
stepa = initialTrustRegionRadius;
if (upperDifference.getEntry(nfmm) == ZERO) {
stepa = -stepa;
throw new PathIsExploredException(); // XXX
}
interpolationPoints.setEntry(nfm, nfmm, stepa);
} else if (nfm > n) {
stepa = interpolationPoints.getEntry(nfx, nfxm);
stepb = -initialTrustRegionRadius;
if (lowerDifference.getEntry(nfxm) == ZERO) {
stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));
throw new PathIsExploredException(); // XXX
}
if (upperDifference.getEntry(nfxm) == ZERO) {
stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));
throw new PathIsExploredException(); // XXX
}
interpolationPoints.setEntry(nfm, nfxm, stepb);
}
} else {
final int tmp1 = (nfm - np) / n;
jpt = nfm - tmp1 * n - n;
ipt = jpt + tmp1;
if (ipt > n) {
final int tmp2 = jpt;
jpt = ipt - n;
ipt = tmp2;
throw new PathIsExploredException(); // XXX
}
final int iptMinus1 = ipt;
final int jptMinus1 = jpt;
interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
}

// Calculate the next value of F. The least function value so far and
// its index are required.

for (int j = 0; j < n; j++) {
currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],
originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),
upperBound[j]));
if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {
currentBest.setEntry(j, lowerBound[j]);
}
if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {
currentBest.setEntry(j, upperBound[j]);
}
}

final double objectiveValue = computeObjectiveValue(currentBest.toArray());
final double f = isMinimize ? objectiveValue : -objectiveValue;
final int numEval = getEvaluations(); // nfm + 1
fAtInterpolationPoints.setEntry(nfm, f);

if (numEval == 1) {
fbeg = f;
trustRegionCenterInterpolationPointIndex = 0;
} else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {
trustRegionCenterInterpolationPointIndex = nfm;
}

// Set the nonzero initial elements of BMAT and the quadratic model in the
// cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions
// of the NF-th and (NF-N)-th interpolation points may be switched, in
// order that the function value at the first of them contributes to the
// off-diagonal second derivative terms of the initial quadratic model.

if (numEval <= 2 * n + 1) {
if (numEval >= 2 &&
numEval <= n + 1) {
gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);
if (npt < numEval + n) {
final double oneOverStepA = ONE / stepa;
bMatrix.setEntry(0, nfmm, -oneOverStepA);
bMatrix.setEntry(nfm, nfmm, oneOverStepA);
bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);
throw new PathIsExploredException(); // XXX
}
} else if (numEval >= n + 2) {
final int ih = nfx * (nfx + 1) / 2 - 1;
final double tmp = (f - fbeg) / stepb;
final double diff = stepb - stepa;
modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);
gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);
if (stepa * stepb < ZERO) {
if (f < fAtInterpolationPoints.getEntry(nfm - n)) {
fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));
fAtInterpolationPoints.setEntry(nfm - n, f);
if (trustRegionCenterInterpolationPointIndex == nfm) {
trustRegionCenterInterpolationPointIndex = nfm - n;
}
interpolationPoints.setEntry(nfm - n, nfxm, stepb);
interpolationPoints.setEntry(nfm, nfxm, stepa);
}
}
bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));
bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));
bMatrix.setEntry(nfm - n, nfxm,
-bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));
zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));
zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);
// zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX ""testAckley"" and ""testDiffPow"" fail.
zMatrix.setEntry(nfm - n, nfxm,
-zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));
}

// Set the off-diagonal second derivatives of the Lagrange functions and
// the initial quadratic model.

} else {
zMatrix.setEntry(0, nfxm, recip);
zMatrix.setEntry(nfm, nfxm, recip);
zMatrix.setEntry(ipt, nfxm, -recip);
zMatrix.setEntry(jpt, nfxm, -recip);

final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
throw new PathIsExploredException(); // XXX
}
} while (getEvaluations() < npt);
} // prelim"
Math_39b_1,/path/to/defects4j_buggy/Math_39_buggy/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java,"public void integrate(final ExpandableStatefulODE equations, final double t)
throws MathIllegalStateException, MathIllegalArgumentException {

sanityChecks(equations, t);
setEquations(equations);
final boolean forward = t > equations.getTime();

// create some internal working arrays
final double[] y0  = equations.getCompleteState();
final double[] y = y0.clone();
final int stages = c.length + 1;
final double[][] yDotK = new double[stages][y.length];
final double[] yTmp    = y0.clone();
final double[] yDotTmp = new double[y.length];

// set up an interpolator sharing the integrator arrays
final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
interpolator.reinitialize(this, yTmp, yDotK, forward,
equations.getPrimaryMapper(), equations.getSecondaryMappers());
interpolator.storeTime(equations.getTime());

// set up integration control objects
stepStart         = equations.getTime();
double  hNew      = 0;
boolean firstTime = true;
initIntegration(equations.getTime(), y0, t);

// main integration loop
isLastStep = false;
do {

interpolator.shift();

// iterate over step size, ensuring local normalized error is smaller than 1
double error = 10;
while (error >= 1.0) {

if (firstTime || !fsal) {
// first stage
computeDerivatives(stepStart, y, yDotK[0]);
}

if (firstTime) {
final double[] scale = new double[mainSetDimension];
if (vecAbsoluteTolerance == null) {
for (int i = 0; i < scale.length; ++i) {
scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
}
} else {
for (int i = 0; i < scale.length; ++i) {
scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
}
}
hNew = initializeStep(forward, getOrder(), scale,
stepStart, y, yDotK[0], yTmp, yDotK[1]);
firstTime = false;
}

stepSize = hNew;

// next stages
for (int k = 1; k < stages; ++k) {

for (int j = 0; j < y0.length; ++j) {
double sum = a[k-1][0] * yDotK[0][j];
for (int l = 1; l < k; ++l) {
sum += a[k-1][l] * yDotK[l][j];
}
yTmp[j] = y[j] + stepSize * sum;
}

computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);

}

// estimate the state at the end of the step
for (int j = 0; j < y0.length; ++j) {
double sum    = b[0] * yDotK[0][j];
for (int l = 1; l < stages; ++l) {
sum    += b[l] * yDotK[l][j];
}
yTmp[j] = y[j] + stepSize * sum;
}

// estimate the error at the end of the step
error = estimateError(yDotK, y, yTmp, stepSize);
if (error >= 1.0) {
// reject the step and attempt to reduce error by stepsize control
final double factor =
FastMath.min(maxGrowth,
FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
hNew = filterStep(stepSize * factor, forward, false);
}

}

// local error is small enough: accept the step, trigger events and step handlers
interpolator.storeTime(stepStart + stepSize);
System.arraycopy(yTmp, 0, y, 0, y0.length);
System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
stepStart = acceptStep(interpolator, y, yDotTmp, t);
System.arraycopy(y, 0, yTmp, 0, y.length);

if (!isLastStep) {

// prepare next step
interpolator.storeTime(stepStart);

if (fsal) {
// save the last evaluation for the next step
System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
}

// stepsize control for next step
final double factor =
FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
final double  scaledH    = stepSize * factor;
final double  nextT      = stepStart + scaledH;
final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
hNew = filterStep(scaledH, forward, nextIsLast);

final double  filteredNextT      = stepStart + hNew;
final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
if (filteredNextIsLast) {
hNew = t - stepStart;
}

}

} while (!isLastStep);

// dispatch results
equations.setTime(stepStart);
equations.setCompleteState(y);

resetInternalState();

}"
Math_40b_1,/path/to/defects4j_buggy/Math_40_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java,"public double solve(int maxEval, UnivariateFunction f, double min,
double max, double startValue,"
Math_41b_1,/path/to/defects4j_buggy/Math_41_buggy/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java,"public double evaluate(final double[] values, final double[] weights,
final int begin, final int length) {

double var = Double.NaN;

if (test(values, weights,begin, length)) {
clear();
if (length == 1) {
var = 0.0;
} else if (length > 1) {
Mean mean = new Mean();
double m = mean.evaluate(values, weights, begin, length);
var = evaluate(values, weights, m, begin, length);
}
}
return var;
}"
Math_42b_1,/path/to/defects4j_buggy/Math_42_buggy/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,"protected void dropPhase1Objective() {
if (getNumObjectiveFunctions() == 1) {
return;
}

List<Integer> columnsToDrop = new ArrayList<Integer>();
columnsToDrop.add(0);

// positive cost non-artificial variables
for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
final double entry = tableau.getEntry(0, i);
if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
columnsToDrop.add(i);
}
}

// non-basic artificial variables
for (int i = 0; i < getNumArtificialVariables(); i++) {
int col = i + getArtificialVariableOffset();
if (getBasicRow(col) == null) {
columnsToDrop.add(col);
}
}

double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
for (int i = 1; i < getHeight(); i++) {
int col = 0;
for (int j = 0; j < getWidth(); j++) {
if (!columnsToDrop.contains(j)) {
matrix[i - 1][col++] = tableau.getEntry(i, j);
}
}
}

for (int i = columnsToDrop.size() - 1; i >= 0; i--) {
columnLabels.remove((int) columnsToDrop.get(i));
}

this.tableau = new Array2DRowRealMatrix(matrix);
this.numArtificialVariables = 0;
}"
Math_43b_1,/path/to/defects4j_buggy/Math_43_buggy/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java,"private void checkEmpty() {
if (n > 0) {
throw new MathIllegalStateException(
LocalizedFormats.VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC, n);
}
}"
Math_44b_1,/path/to/defects4j_buggy/Math_44_buggy/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java,"public AbstractIntegrator(final String name) {
this.name = name;
stepHandlers = new ArrayList<StepHandler>();
stepStart = Double.NaN;
stepSize  = Double.NaN;
eventsStates = new ArrayList<EventState>();
statesInitialized = false;
evaluations = new Incrementor();
setMaxEvaluations(-1);
resetEvaluations();
}"
Math_45b_1,/path/to/defects4j_buggy/Math_45_buggy/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java,"public OpenMapRealMatrix(int rowDimension, int columnDimension) {
super(rowDimension, columnDimension);
this.rows = rowDimension;
this.columns = columnDimension;
this.entries = new OpenIntToDoubleHashMap(0.0);
}"
Math_48b_1,/path/to/defects4j_buggy/Math_48_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java,"public double solve(final int maxEval, final UnivariateRealFunction f,
final double min, final double max, final double startValue,"
Math_50b_1,/path/to/defects4j_buggy/Math_50_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java,"protected final double doSolve() {
// Get initial solution
double x0 = getMin();
double x1 = getMax();
double f0 = computeObjectiveValue(x0);
double f1 = computeObjectiveValue(x1);

// If one of the bounds is the exact root, return it. Since these are
// not under-approximations or over-approximations, we can return them
// regardless of the allowed solutions.
if (f0 == 0.0) {
return x0;
}
if (f1 == 0.0) {
return x1;
}

// Verify bracketing of initial solution.
verifyBracketing(x0, x1);

// Get accuracies.
final double ftol = getFunctionValueAccuracy();
final double atol = getAbsoluteAccuracy();
final double rtol = getRelativeAccuracy();

// Keep track of inverted intervals, meaning that the left bound is
// larger than the right bound.
boolean inverted = false;

// Keep finding better approximations.
while (true) {
// Calculate the next approximation.
final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
final double fx = computeObjectiveValue(x);

// If the new approximation is the exact root, return it. Since
// this is not an under-approximation or an over-approximation,
// we can return it regardless of the allowed solutions.
if (fx == 0.0) {
return x;
}

// Update the bounds with the new approximation.
if (f1 * fx < 0) {
// The value of x1 has switched to the other bound, thus inverting
// the interval.
x0 = x1;
f0 = f1;
inverted = !inverted;
} else {
switch (method) {
case ILLINOIS:
f0 *= 0.5;
break;
case PEGASUS:
f0 *= f1 / (f1 + fx);
break;
case REGULA_FALSI:
// Nothing.
if (x == x1) {
x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
f0 = computeObjectiveValue(x0);
}
break;
default:
// Should never happen.
throw new MathInternalError();
}
}
// Update from [x0, x1] to [x0, x].
x1 = x;
f1 = fx;

// If the function value of the last approximation is too small,
// given the function value accuracy, then we can't get closer to
// the root than we already are.
if (FastMath.abs(f1) <= ftol) {
switch (allowed) {
case ANY_SIDE:
return x1;
case LEFT_SIDE:
if (inverted) {
return x1;
}
break;
case RIGHT_SIDE:
if (!inverted) {
return x1;
}
break;
case BELOW_SIDE:
if (f1 <= 0) {
return x1;
}
break;
case ABOVE_SIDE:
if (f1 >= 0) {
return x1;
}
break;
default:
throw new MathInternalError();
}
}

// If the current interval is within the given accuracies, we
// are satisfied with the current approximation.
if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
atol)) {
switch (allowed) {
case ANY_SIDE:
return x1;
case LEFT_SIDE:
return inverted ? x1 : x0;
case RIGHT_SIDE:
return inverted ? x0 : x1;
case BELOW_SIDE:
return (f1 <= 0) ? x1 : x0;
case ABOVE_SIDE:
return (f1 >= 0) ? x1 : x0;
default:
throw new MathInternalError();
}
}
}
}"
Math_51b_1,/path/to/defects4j_buggy/Math_51_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java,"public double solve(final int maxEval, final UnivariateRealFunction f,
final double min, final double max, final double startValue,"
Math_52b_1,/path/to/defects4j_buggy/Math_52_buggy/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java,"public Rotation(double q0, double q1, double q2, double q3,
boolean needsNormalization) {

if (needsNormalization) {
// normalization preprocessing
double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
q0 *= inv;
q1 *= inv;
q2 *= inv;
q3 *= inv;
}

this.q0 = q0;
this.q1 = q1;
this.q2 = q2;
this.q3 = q3;

}"
Math_53b_1,/path/to/defects4j_buggy/Math_53_buggy/src/main/java/org/apache/commons/math/complex/Complex.java,"public Complex add(Complex rhs)
throws NullArgumentException {
MathUtils.checkNotNull(rhs);
return createComplex(real + rhs.getReal(),
imaginary + rhs.getImaginary());
}"
Math_55b_1,/path/to/defects4j_buggy/Math_55_buggy/src/main/java/org/apache/commons/math/geometry/Vector3D.java,"public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {


// rescale both vectors without losing precision,
// to ensure their norm are the same order of magnitude

// we reduce cancellation errors by preconditioning,
// we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute
// v3 without loss of precision. See Kahan lecture
// ""Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces""
// available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf

// compute rho as an 8 bits approximation of v1.v2 / v2.v2


// compute cross product from v3 and v2 instead of v1 and v2
return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);

}"
Math_56b_1,/path/to/defects4j_buggy/Math_56_buggy/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java,"public int[] getCounts(int index) {
if (index < 0 ||
index >= totalSize) {
throw new OutOfRangeException(index, 0, totalSize);
}

final int[] indices = new int[dimension];

int count = 0;
for (int i = 0; i < last; i++) {
int idx = 0;
final int offset = uniCounterOffset[i];
while (count <= index) {
count += offset;
++idx;
}
--idx;
count -= offset;
indices[i] = idx;
}

int idx = 1;
while (count < index) {
count += idx;
++idx;
}
--idx;
indices[last] = idx;

return indices;
}"
Math_57b_1,/path/to/defects4j_buggy/Math_57_buggy/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,"public KMeansPlusPlusClusterer(final Random random) {
this(random, EmptyClusterStrategy.LARGEST_VARIANCE);
}"
Math_58b_1,/path/to/defects4j_buggy/Math_58_buggy/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java,"public double[] fit() {
final double[] guess = (new ParameterGuesser(getObservations())).guess();
return fit(new Gaussian.Parametric(), guess);
}"
Math_59b_1,/path/to/defects4j_buggy/Math_59_buggy/src/main/java/org/apache/commons/math/util/FastMath.java,"public static float min(final float a, final float b) {
return (a <= b) ? a : (Float.isNaN(a + b) ? Float.NaN : b);
}"
Math_60b_1,/path/to/defects4j_buggy/Math_60_buggy/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java,"public double cumulativeProbability(double x) throws MathException {
final double dev = x - mean;
try {
return 0.5 * (1.0 + Erf.erf((dev) /
(standardDeviation * FastMath.sqrt(2.0))));
} catch (MaxIterationsExceededException ex) {
if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
return 0;
} else if (x > (mean + 20 * standardDeviation)) {
return 1;
} else {
throw ex;
}
}
}"
Math_63b_1,/path/to/defects4j_buggy/Math_63_buggy/src/main/java/org/apache/commons/math/util/MathUtils.java,"public static boolean equals(double x, double y) {
return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
}"
Math_64b_1,/path/to/defects4j_buggy/Math_64_buggy/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java,"private void determineLMParameter(double[] qy, double delta, double[] diag,
double[] work1, double[] work2, double[] work3) {

// compute and store in x the gauss-newton direction, if the
// jacobian is rank-deficient, obtain a least squares solution
for (int j = 0; j < rank; ++j) {
lmDir[permutation[j]] = qy[j];
}
for (int j = rank; j < cols; ++j) {
lmDir[permutation[j]] = 0;
}
for (int k = rank - 1; k >= 0; --k) {
int pk = permutation[k];
double ypk = lmDir[pk] / diagR[pk];
for (int i = 0; i < k; ++i) {
lmDir[permutation[i]] -= ypk * jacobian[i][pk];
}
lmDir[pk] = ypk;
}

// evaluate the function at the origin, and test
// for acceptance of the Gauss-Newton direction
double dxNorm = 0;
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
double s = diag[pj] * lmDir[pj];
work1[pj] = s;
dxNorm += s * s;
}
dxNorm = Math.sqrt(dxNorm);
double fp = dxNorm - delta;
if (fp <= 0.1 * delta) {
lmPar = 0;
return;
}

// if the jacobian is not rank deficient, the Newton step provides
// a lower bound, parl, for the zero of the function,
// otherwise set this bound to zero
double sum2;
double parl = 0;
if (rank == solvedCols) {
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
work1[pj] *= diag[pj] / dxNorm;
}
sum2 = 0;
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
double sum = 0;
for (int i = 0; i < j; ++i) {
sum += jacobian[i][pj] * work1[permutation[i]];
}
double s = (work1[pj] - sum) / diagR[pj];
work1[pj] = s;
sum2 += s * s;
}
parl = fp / (delta * sum2);
}

// calculate an upper bound, paru, for the zero of the function
sum2 = 0;
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
double sum = 0;
for (int i = 0; i <= j; ++i) {
sum += jacobian[i][pj] * qy[i];
}
sum /= diag[pj];
sum2 += sum * sum;
}
double gNorm = Math.sqrt(sum2);
double paru = gNorm / delta;
if (paru == 0) {
// 2.2251e-308 is the smallest positive real for IEE754
paru = 2.2251e-308 / Math.min(delta, 0.1);
}

// if the input par lies outside of the interval (parl,paru),
// set par to the closer endpoint
lmPar = Math.min(paru, Math.max(lmPar, parl));
if (lmPar == 0) {
lmPar = gNorm / dxNorm;
}

for (int countdown = 10; countdown >= 0; --countdown) {

// evaluate the function at the current value of lmPar
if (lmPar == 0) {
lmPar = Math.max(2.2251e-308, 0.001 * paru);
}
double sPar = Math.sqrt(lmPar);
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
work1[pj] = sPar * diag[pj];
}
determineLMDirection(qy, work1, work2, work3);

dxNorm = 0;
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
double s = diag[pj] * lmDir[pj];
work3[pj] = s;
dxNorm += s * s;
}
dxNorm = Math.sqrt(dxNorm);
double previousFP = fp;
fp = dxNorm - delta;

// if the function is small enough, accept the current value
// of lmPar, also test for the exceptional cases where parl is zero
if ((Math.abs(fp) <= 0.1 * delta) ||
((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {
return;
}

// compute the Newton correction
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
work1[pj] = work3[pj] * diag[pj] / dxNorm;
}
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
work1[pj] /= work2[j];
double tmp = work1[pj];
for (int i = j + 1; i < solvedCols; ++i) {
work1[permutation[i]] -= jacobian[i][pj] * tmp;
}
}
sum2 = 0;
for (int j = 0; j < solvedCols; ++j) {
double s = work1[permutation[j]];
sum2 += s * s;
}
double correction = fp / (delta * sum2);

// depending on the sign of the function, update parl or paru.
if (fp > 0) {
parl = Math.max(parl, lmPar);
} else if (fp < 0) {
paru = Math.min(paru, lmPar);
}

// compute an improved estimate for lmPar
lmPar = Math.max(parl, lmPar + correction);

}
}"
Math_69b_1,/path/to/defects4j_buggy/Math_69_buggy/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java,"public PearsonsCorrelation(double[][] data) {
this(new BlockRealMatrix(data));
}"
Math_70b_1,/path/to/defects4j_buggy/Math_70_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java,"return solve(f, min, max);
}

/** {@inheritDoc} */
public double solve(final UnivariateRealFunction f, double min, double max, double initial)
throws MaxIterationsExceededException, FunctionEvaluationException {"
Math_72b_1,/path/to/defects4j_buggy/Math_72_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java,"public double solve(final UnivariateRealFunction f,
final double min, final double max, final double initial)"
Math_73b_1,/path/to/defects4j_buggy/Math_73_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java,"public double solve(final UnivariateRealFunction f,
final double min, final double max, final double initial)"
Math_74b_1,/path/to/defects4j_buggy/Math_74_buggy/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java,"public double integrate(final FirstOrderDifferentialEquations equations,
final double t0, final double[] y0,"
Math_75b_1,/path/to/defects4j_buggy/Math_75_buggy/src/main/java/org/apache/commons/math/stat/Frequency.java,"public double getPct(Object v) {
return getCumPct((Comparable<?>) v);
}"
Math_78b_1,/path/to/defects4j_buggy/Math_78_buggy/src/main/java/org/apache/commons/math/ode/events/EventState.java,"public EventState(final EventHandler handler, final double maxCheckInterval,
final double convergence, final int maxIterationCount) {
this.handler           = handler;
this.maxCheckInterval  = maxCheckInterval;
this.convergence       = Math.abs(convergence);
this.maxIterationCount = maxIterationCount;

// some dummy values ...
t0                = Double.NaN;
g0                = Double.NaN;
g0Positive        = true;
pendingEvent      = false;
pendingEventTime  = Double.NaN;
previousEventTime = Double.NaN;
increasing        = true;
nextAction        = EventHandler.CONTINUE;

}"
Math_79b_1,/path/to/defects4j_buggy/Math_79_buggy/src/main/java/org/apache/commons/math/util/MathUtils.java,"public static double distance(int[] p1, int[] p2) {
int sum = 0;
for (int i = 0; i < p1.length; i++) {
final int dp = p1[i] - p2[i];
sum += dp * dp;
}
return Math.sqrt(sum);
}"
Math_80b_1,/path/to/defects4j_buggy/Math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java,"private void processGeneralBlock(final int n)
throws InvalidMatrixException {

// check decomposed matrix data range
double sumOffDiag = 0;
for (int i = 0; i < n - 1; ++i) {
final int fourI = 4 * i;
final double ei = work[fourI + 2];
sumOffDiag += ei;
}

if (sumOffDiag == 0) {
// matrix is already diagonal
return;
}

// initial checks for splits (see Parlett & Marques section 3.3)
flipIfWarranted(n, 2);

// two iterations with Li's test for initial splits
initialSplits(n);

// initialize parameters used by goodStep
tType = 0;
dMin1 = 0;
dMin2 = 0;
dN    = 0;
dN1   = 0;
dN2   = 0;
tau   = 0;

// process split segments
int i0 = 0;
int n0 = n;
while (n0 > 0) {

// retrieve shift that was temporarily stored as a negative off-diagonal element
sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];
sigmaLow = 0;

// find start of a new split segment to process
double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];
double offDiagMax = 0;
double diagMax    = work[4 * n0 - 4];
double diagMin    = diagMax;
i0 = 0;
for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {
if (work[i + 2] <= 0) {
i0 = 1 + i / 4;
break;
}
if (diagMin >= 4 * offDiagMax) {
diagMin    = Math.min(diagMin, work[i + 4]);
offDiagMax = Math.max(offDiagMax, work[i + 2]);
}
diagMax    = Math.max(diagMax, work[i] + work[i + 2]);
offDiagMin = Math.min(offDiagMin, work[i + 2]);
}
work[4 * n0 - 2] = offDiagMin;

// lower bound of Gershgorin disk
dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));

pingPong = 0;
int maxIter = 30 * (n0 - i0);
for (int k = 0; i0 < n0; ++k) {
if (k >= maxIter) {
throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
}

// perform one step
n0 = goodStep(i0, n0);
pingPong = 1 - pingPong;

// check for new splits after ""ping"" steps
// when the last elements of qd array are very small
if ((pingPong == 0) && (n0 - i0 > 3) &&
(work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) &&
(work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {
int split  = i0 - 1;
diagMax    = work[4 * i0];
offDiagMin = work[4 * i0 + 2];
double previousEMin = work[4 * i0 + 3];
for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {
if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||
(work[i + 2] <= TOLERANCE_2 * sigma)) {
// insert a split
work[i + 2]  = -sigma;
split        = i / 4;
diagMax      = 0;
offDiagMin   = work[i + 6];
previousEMin = work[i + 7];
} else {
diagMax      = Math.max(diagMax, work[i + 4]);
offDiagMin   = Math.min(offDiagMin, work[i + 2]);
previousEMin = Math.min(previousEMin, work[i + 3]);
}
}
work[4 * n0 - 2] = offDiagMin;
work[4 * n0 - 1] = previousEMin;
i0 = split + 1;
}
}

}

}"
Math_82b_1,/path/to/defects4j_buggy/Math_82_buggy/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java,"protected void solvePhase1(final SimplexTableau tableau)
throws OptimizationException {
// make sure we're in Phase 1
if (tableau.getNumArtificialVariables() == 0) {
return;
}

while (!isPhase1Solved(tableau)) {
doIteration(tableau);
}

// if W is not zero then we have no feasible solution
if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon)) {
throw new NoFeasibleSolutionException();
}
}"
Math_84b_1,/path/to/defects4j_buggy/Math_84_buggy/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java,"public MultiDirectional() {
this.khi   = 2.0;
this.gamma = 0.5;
}"
Math_85b_1,/path/to/defects4j_buggy/Math_85_buggy/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java,"return bracket( function, initial, lowerBound, upperBound,
Integer.MAX_VALUE ) ;"
Math_86b_1,/path/to/defects4j_buggy/Math_86_buggy/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java,"public CholeskyDecompositionImpl(final RealMatrix matrix)
throws NonSquareMatrixException,"
Math_87b_1,/path/to/defects4j_buggy/Math_87_buggy/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,"protected void discardArtificialVariables() {
if (numArtificialVariables == 0) {
return;
}
int width = getWidth() - numArtificialVariables - 1;
int height = getHeight() - 1;
double[][] matrix = new double[height][width];
for (int i = 0; i < height; i++) {
for (int j = 0; j < width - 1; j++) {
matrix[i][j] = getEntry(i + 1, j + 1);
}
matrix[i][width - 1] = getEntry(i + 1, getRhsOffset());
}
this.tableau = new RealMatrixImpl(matrix);
this.numArtificialVariables = 0;
}"
Math_88b_1,/path/to/defects4j_buggy/Math_88_buggy/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,"protected RealPointValuePair getSolution() {
double[] coefficients = new double[getOriginalNumDecisionVariables()];
Integer basicRow =
getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
for (int i = 0; i < coefficients.length; i++) {
basicRow = getBasicRow(getNumObjectiveFunctions() + i);
// if multiple variables can take a given value
// then we choose the first and set the rest equal to 0
coefficients[i] =
(basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
(restrictToNonNegative ? 0 : mostNegative);
if (basicRow != null) {
for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {
if (tableau.getEntry(basicRow, j) == 1) {
coefficients[i] = 0;
}
}
}
}
return new RealPointValuePair(coefficients, f.getValue(coefficients));
}"
Math_89b_1,/path/to/defects4j_buggy/Math_89_buggy/src/java/org/apache/commons/math/stat/Frequency.java,"addValue((Comparable<?>) v);
}

/**
* Adds 1 to the frequency count for v.
* <p>
* If other objects have already been added to this Frequency, v must
* be comparable to those that have already been added.
* </p>
*
* @param v the value to add.
* @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries
*/
public void addValue(Comparable<?>v){"
Math_91b_1,/path/to/defects4j_buggy/Math_91_buggy/src/java/org/apache/commons/math/fraction/Fraction.java,"public int compareTo(Fraction object) {
double nOd = doubleValue();
double dOn = object.doubleValue();
return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
}"
Math_94b_1,/path/to/defects4j_buggy/Math_94_buggy/src/java/org/apache/commons/math/util/MathUtils.java,"public static int gcd(int u, int v) {
if (u * v == 0) {
return (Math.abs(u) + Math.abs(v));
}
// keep u and v negative, as negative integers range down to
// -2^31, while positive numbers can only be as large as 2^31-1
// (i.e. we can't necessarily negate a negative number without
// overflow)
/* assert u!=0 && v!=0; */
if (u > 0) {
u = -u;
} // make u negative
if (v > 0) {
v = -v;
} // make v negative
// B1. [Find power of 2]
int k = 0;
while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
// both even...
u /= 2;
v /= 2;
k++; // cast out twos.
}
if (k == 31) {
throw new ArithmeticException(""overflow: gcd is 2^31"");
}
// B2. Initialize: u and v have been divided by 2^k and at least
// one is odd.
int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
// t negative: u was odd, v may be even (t replaces v)
// t positive: u was even, v is odd (t replaces u)
do {
/* assert u<0 && v<0; */
// B4/B3: cast out twos from t.
while ((t & 1) == 0) { // while t is even..
t /= 2; // cast out twos
}
// B5 [reset max(u,v)]
if (t > 0) {
u = -t;
} else {
v = t;
}
// B6/B3. at this point both u and v should be odd.
t = (v - u) / 2;
// |u| larger: t positive (replace u)
// |v| larger: t negative (replace v)
} while (t != 0);
return -u * (1 << k); // gcd is u*2^k
}"
Math_95b_1,/path/to/defects4j_buggy/Math_95_buggy/src/java/org/apache/commons/math/distribution/FDistributionImpl.java,"protected double getDomainLowerBound(double p) {
return 0.0;
}"
Math_96b_1,/path/to/defects4j_buggy/Math_96_buggy/src/java/org/apache/commons/math/complex/Complex.java,"public int hashCode() {
if (isNaN()) {
return 7;
}
return 37 * (17 * MathUtils.hash(imaginary) +
MathUtils.hash(real));
}"
Math_97b_1,/path/to/defects4j_buggy/Math_97_buggy/src/java/org/apache/commons/math/analysis/BrentSolver.java,"public double solve(double min, double max) throws MaxIterationsExceededException,
FunctionEvaluationException {

clearResult();
verifyInterval(min, max);

double ret = Double.NaN;

double yMin = f.value(min);
double yMax = f.value(max);

// Verify bracketing
double sign = yMin * yMax;
if (sign >= 0) {
// check if either value is close to a zero
// neither value is close to zero and min and max do not bracket root.
throw new IllegalArgumentException
(""Function values at endpoints do not have different signs."" +
""  Endpoints: ["" + min + "","" + max + ""]"" +
""  Values: ["" + yMin + "","" + yMax + ""]"");
} else {
// solve using only the first endpoint as initial guess
ret = solve(min, yMin, max, yMax, min, yMin);
// either min or max is a root
}

return ret;
}"
Math_101b_1,/path/to/defects4j_buggy/Math_101_buggy/src/java/org/apache/commons/math/complex/ComplexFormat.java,"public Complex parse(String source, ParsePosition pos) {
int initialIndex = pos.getIndex();

// parse whitespace
parseAndIgnoreWhitespace(source, pos);

// parse real
Number re = parseNumber(source, getRealFormat(), pos);
if (re == null) {
// invalid real number
// set index back to initial, error index should already be set
// character examined.
pos.setIndex(initialIndex);
return null;
}

// parse sign
int startIndex = pos.getIndex();
char c = parseNextCharacter(source, pos);
int sign = 0;
switch (c) {
case 0 :
// no sign
// return real only complex number
return new Complex(re.doubleValue(), 0.0);
case '-' :
sign = -1;
break;
case '+' :
sign = 1;
break;
default :
// invalid sign
// set index back to initial, error index should be the last
// character examined.
pos.setIndex(initialIndex);
pos.setErrorIndex(startIndex);
return null;
}

// parse whitespace
parseAndIgnoreWhitespace(source, pos);

// parse imaginary
Number im = parseNumber(source, getRealFormat(), pos);
if (im == null) {
// invalid imaginary number
// set index back to initial, error index should already be set
// character examined.
pos.setIndex(initialIndex);
return null;
}

// parse imaginary character
int n = getImaginaryCharacter().length();
startIndex = pos.getIndex();
int endIndex = startIndex + n;
if (
source.substring(startIndex, endIndex).compareTo(
getImaginaryCharacter()) != 0) {
// set index back to initial, error index should be the start index
// character examined.
pos.setIndex(initialIndex);
pos.setErrorIndex(startIndex);
return null;
}
pos.setIndex(endIndex);

return new Complex(re.doubleValue(), im.doubleValue() * sign);
}"
Math_102b_1,/path/to/defects4j_buggy/Math_102_buggy/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java,"public double chiSquare(double[] expected, long[] observed)
throws IllegalArgumentException {
if ((expected.length < 2) || (expected.length != observed.length)) {
throw new IllegalArgumentException(
""observed, expected array lengths incorrect"");
}
if (!isPositive(expected) || !isNonNegative(observed)) {
throw new IllegalArgumentException(
""observed counts must be non-negative and expected counts must be postive"");
}
double sumSq = 0.0d;
double dev = 0.0d;
for (int i = 0; i < observed.length; i++) {
dev = ((double) observed[i] - expected[i]);
sumSq += dev * dev / expected[i];
}
return sumSq;
}"
Math_103b_1,/path/to/defects4j_buggy/Math_103_buggy/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java,"public double cumulativeProbability(double x) throws MathException {
return 0.5 * (1.0 + Erf.erf((x - mean) /
(standardDeviation * Math.sqrt(2.0))));
}"
Math_105b_1,/path/to/defects4j_buggy/Math_105_buggy/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java,"public void addData(double x, double y) {
if (n == 0) {
xbar = x;
ybar = y;
} else {
double dx = x - xbar;
double dy = y - ybar;
sumXX += dx * dx * (double) n / (double) (n + 1.0);
sumYY += dy * dy * (double) n / (double) (n + 1.0);
sumXY += dx * dy * (double) n / (double) (n + 1.0);
xbar += dx / (double) (n + 1.0);
ybar += dy / (double) (n + 1.0);
}
sumX += x;
sumY += y;
n++;
}"
Math_106b_1,/path/to/defects4j_buggy/Math_106_buggy/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java,"Fraction ret = super.parse(source, pos);
if (ret != null) {
return ret;
}"
Mockito_1b_1,/path/to/defects4j_buggy/Mockito_1_buggy/src/org/mockito/internal/invocation/InvocationMatcher.java,"public void captureArgumentsFrom(Invocation invocation) {
        if (invocation.getMethod().isVarArgs()) {
            int indexOfVararg = invocation.getRawArguments().length - 1;
            throw new UnsupportedOperationException();

        } else {
            for (int position = 0; position < matchers.size(); position++) {
                Matcher m = matchers.get(position);
                if (m instanceof CapturesArguments) {
                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
                }
            }
        }"
Mockito_5b_1,/path/to/defects4j_buggy/Mockito_5_buggy/src/org/mockito/internal/verification/VerificationOverTimeImpl.java,"public void verify(VerificationData data) {
        AssertionError error = null;

        timer.start();
        while (timer.isCounting()) {
            try {
                delegate.verify(data);

                if (returnOnSuccess) {
                    return;
                } else {
                    error = null;
                }
            } catch (MockitoAssertionError e) {
                error = handleVerifyException(e);
            }
            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {
                error = handleVerifyException(e);
            }
        }

        if (error != null) {
            throw error;
        }
    }"
Mockito_7b_1,/path/to/defects4j_buggy/Mockito_7_buggy/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java,"private void readTypeVariables() {
            for (Type type : typeVariable.getBounds()) {
                registerTypeVariablesOn(type);
            }
            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));
        }"
Mockito_8b_1,/path/to/defects4j_buggy/Mockito_8_buggy/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java,"protected void registerTypeVariablesOn(Type classType) {
if (!(classType instanceof ParameterizedType)) {
return;
}
ParameterizedType parameterizedType = (ParameterizedType) classType;
TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
for (int i = 0; i < actualTypeArguments.length; i++) {
TypeVariable typeParameter = typeParameters[i];
Type actualTypeArgument = actualTypeArguments[i];

if (actualTypeArgument instanceof WildcardType) {
contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
} else {
contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
}
// logger.log(""For '"" + parameterizedType + ""' found type variable : { '"" + typeParameter + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' : '"" + actualTypeArgument + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' }"");
}
}"
Mockito_12b_1,/path/to/defects4j_buggy/Mockito_12_buggy/src/org/mockito/internal/util/reflection/GenericMaster.java,"Type generic = field.getGenericType();
if (generic != null && generic instanceof ParameterizedType) {
Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];
return (Class) actual;
//in case of nested generics we don't go deep
}"
Mockito_13b_1,/path/to/defects4j_buggy/Mockito_13_buggy/src/org/mockito/internal/MockHandler.java,"public Object handle(Invocation invocation) throws Throwable {
        if (invocationContainerImpl.hasAnswersForStubbing()) {
            // stubbing voids with stubVoid() or doAnswer() style
            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress
                            .getArgumentMatcherStorage(), invocation);
            invocationContainerImpl.setMethodForStubbing(invocationMatcher);
            return null;
        }
        VerificationMode verificationMode = mockingProgress.pullVerificationMode();

        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),
                        invocation);

        mockingProgress.validateState();

        //if verificationMode is not null then someone is doing verify()        
        if (verificationMode != null) {
            //We need to check if verification was started on the correct mock 
            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                
                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            
                verificationMode.verify(data);
                return null;
                // this means there is an invocation on a different mock. Re-adding verification mode 
                // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
            }
        }
        
        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
        mockingProgress.reportOngoingStubbing(ongoingStubbing);

        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);

        if (stubbedInvocation != null) {
            stubbedInvocation.captureArgumentsFrom(invocation);
            return stubbedInvocation.answer(invocation);
        } else {
            Object ret = mockSettings.getDefaultAnswer().answer(invocation);

            // redo setting invocation for potential stubbing in case of partial
            // mocks / spies.
            // Without it, the real method inside 'when' might have delegated
            // to other self method and overwrite the intended stubbed method
            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.
            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
            return ret;
        }
    }"
Mockito_18b_1,/path/to/defects4j_buggy/Mockito_18_buggy/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java,"Object returnValueFor(Class<?> type) {
        if (Primitives.isPrimitiveOrWrapper(type)) {
            return Primitives.defaultValueForPrimitiveOrWrapper(type);
            //new instances are used instead of Collections.emptyList(), etc.
            //to avoid UnsupportedOperationException if code under test modifies returned collection
        } else if (type == Collection.class) {
            return new LinkedList<Object>();
        } else if (type == Set.class) {
            return new HashSet<Object>();
        } else if (type == HashSet.class) {
            return new HashSet<Object>();
        } else if (type == SortedSet.class) {
            return new TreeSet<Object>();
        } else if (type == TreeSet.class) {
            return new TreeSet<Object>();
        } else if (type == LinkedHashSet.class) {
            return new LinkedHashSet<Object>();
        } else if (type == List.class) {
            return new LinkedList<Object>();
        } else if (type == LinkedList.class) {
            return new LinkedList<Object>();
        } else if (type == ArrayList.class) {
            return new ArrayList<Object>();
        } else if (type == Map.class) {
            return new HashMap<Object, Object>();
        } else if (type == HashMap.class) {
            return new HashMap<Object, Object>();
        } else if (type == SortedMap.class) {
            return new TreeMap<Object, Object>();
        } else if (type == TreeMap.class) {
            return new TreeMap<Object, Object>();
        } else if (type == LinkedHashMap.class) {
            return new LinkedHashMap<Object, Object>();
        }
        //Let's not care about the rest of collections.
        return null;
    }"
Mockito_20b_1,/path/to/defects4j_buggy/Mockito_20_buggy/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java,"public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
            throw new MockitoException(""Serialization across classloaders not yet supported with ByteBuddyMockMaker"");
        }
        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(
                settings.getTypeToMock(),
                settings.getExtraInterfaces()
        );
        T mockInstance = null;
        try {
            mockInstance = classInstantiator.instantiate(mockedProxyType);
            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));

            return ensureMockIsAssignableToMockedType(settings, mockInstance);
        } catch (ClassCastException cce) {
            throw new MockitoException(join(
                    ""ClassCastException occurred while creating the mockito mock :"",
                    ""  class to mock : "" + describeClass(mockedProxyType),
                    ""  created class : "" + describeClass(settings.getTypeToMock()),
                    ""  proxy instance class : "" + describeClass(mockInstance),
                    ""  instance creation by : "" + classInstantiator.getClass().getSimpleName(),
                    """",
                    ""You might experience classloading issues, please ask the mockito mailing-list."",
                    """"
            ),cce);
        } catch (org.mockito.internal.creation.instance.InstantiationException e) {
            throw new MockitoException(""Unable to create mock instance of type '"" + mockedProxyType.getSuperclass().getSimpleName() + ""'"", e);
        }
    }"
Mockito_22b_1,/path/to/defects4j_buggy/Mockito_22_buggy/src/org/mockito/internal/matchers/Equality.java,"public static boolean areEqual(Object o1, Object o2) {
        if (o1 == null || o2 == null) {
            return o1 == null && o2 == null;
        } else if (isArray(o1)) {
            return isArray(o2) && areArraysEqual(o1, o2);
        } else {
            return o1.equals(o2);
        }
    }"
Mockito_24b_1,/path/to/defects4j_buggy/Mockito_24_buggy/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java,"public Object answer(InvocationOnMock invocation) {
        if (methodsGuru.isToString(invocation.getMethod())) {
            Object mock = invocation.getMock();
            MockName name = mockUtil.getMockName(mock);
            if (name.isDefault()) {
                return ""Mock for "" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + "", hashCode: "" + mock.hashCode();
            } else {
                return name.toString();
            }
        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {
            //see issue 184.
            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).
            //Only for compareTo() method by the Comparable interface
            return 1;
        }
        
        Class<?> returnType = invocation.getMethod().getReturnType();
        return returnValueFor(returnType);
    }"
Mockito_26b_1,/path/to/defects4j_buggy/Mockito_26_buggy/src/org/mockito/internal/util/Primitives.java,"public static <T> T primitiveValueOrNullFor(Class<T> primitiveType) {
return (T) primitiveValues.get(primitiveType);
}"
Mockito_27b_1,/path/to/defects4j_buggy/Mockito_27_buggy/src/org/mockito/internal/util/MockUtil.java,"public <T> void resetMock(T mock) {
        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);
        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);
        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));
        ((Factory) mock).setCallback(0, newFilter);
    }"
Mockito_28b_1,/path/to/defects4j_buggy/Mockito_28_buggy/src/org/mockito/internal/configuration/DefaultInjectionEngine.java,"private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
        }
    }"
Mockito_29b_1,/path/to/defects4j_buggy/Mockito_29_buggy/src/org/mockito/internal/matchers/Same.java,"public void describeTo(Description description) {
        description.appendText(""same("");
        appendQuoting(description);
        description.appendText(wanted.toString());
        appendQuoting(description);
        description.appendText("")"");
    }"
Mockito_33b_1,/path/to/defects4j_buggy/Mockito_33_buggy/src/org/mockito/internal/invocation/InvocationMatcher.java,"public boolean hasSameMethod(Invocation candidate) {        
        //not using method.equals() for 1 good reason:
        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest
        Method m1 = invocation.getMethod();
        Method m2 = candidate.getMethod();
        
         /* Avoid unnecessary cloning */
        return m1.equals(m2);
    }"
Mockito_34b_1,/path/to/defects4j_buggy/Mockito_34_buggy/src/org/mockito/internal/invocation/InvocationMatcher.java,"public void captureArgumentsFrom(Invocation i) {
        int k = 0;
        for (Matcher m : matchers) {
            if (m instanceof CapturesArguments) {
                ((CapturesArguments) m).captureFrom(i.getArguments()[k]);
            }
            k++;
        }
    }"
Mockito_38b_1,/path/to/defects4j_buggy/Mockito_38_buggy/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java,"public Integer[] getSuspiciouslyNotMatchingArgsIndexes(List<Matcher> matchers, Object[] arguments) {
if (matchers.size() != arguments.length) {
return new Integer[0];
}

List<Integer> suspicious = new LinkedList<Integer>();
int i = 0;
for (Matcher m : matchers) {
if (m instanceof ContainsExtraTypeInformation
&& !safelyMatches(m, arguments[i])
&& toStringEquals(m, arguments[i])
&& !((ContainsExtraTypeInformation) m).typeMatches(arguments[i])) {
suspicious.add(i);
}
i++;
}
return suspicious.toArray(new Integer[0]);
}"
Time_4b_1,/path/to/defects4j_buggy/Time_4_buggy/src/main/java/org/joda/time/Partial.java,"public Partial with(DateTimeFieldType fieldType, int value) {
if (fieldType == null) {
throw new IllegalArgumentException(""The field type must not be null"");
}
int index = indexOf(fieldType);
if (index == -1) {
DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
int[] newValues = new int[newTypes.length];

// find correct insertion point to keep largest-smallest order
int i = 0;
DurationField unitField = fieldType.getDurationType().getField(iChronology);
if (unitField.isSupported()) {
for (; i < iTypes.length; i++) {
DateTimeFieldType loopType = iTypes[i];
DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
if (loopUnitField.isSupported()) {
int compare = unitField.compareTo(loopUnitField);
if (compare > 0) {
break;
} else if (compare == 0) {
DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
if (rangeField.compareTo(loopRangeField) > 0) {
break;
}
}
}
}
}
System.arraycopy(iTypes, 0, newTypes, 0, i);
System.arraycopy(iValues, 0, newValues, 0, i);
newTypes[i] = fieldType;
newValues[i] = value;
System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
// use public constructor to ensure full validation
// this isn't overly efficient, but is safe
Partial newPartial = new Partial(iChronology, newTypes, newValues);
iChronology.validate(newPartial, newValues);
return newPartial;
}
if (value == getValue(index)) {
return this;
}
int[] newValues = getValues();
newValues = getField(index).set(this, index, newValues, value);
return new Partial(this, newValues);
}"
Time_5b_1,/path/to/defects4j_buggy/Time_5_buggy/src/main/java/org/joda/time/Period.java,"public Period normalizedStandard(PeriodType type) {
type = DateTimeUtils.getPeriodType(type);
long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs
millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));
Period result = new Period(millis, type, ISOChronology.getInstanceUTC());
int years = getYears();
int months = getMonths();
if (years != 0 || months != 0) {
years = FieldUtils.safeAdd(years, months / 12);
months = months % 12;
if (years != 0) {
result = result.withYears(years);
}
if (months != 0) {
result = result.withMonths(months);
}
}
return result;
}"
Time_7b_1,/path/to/defects4j_buggy/Time_7_buggy/src/main/java/org/joda/time/format/DateTimeFormatter.java,"public DateTimeFormatter withLocale(Locale locale) {
if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {
return this;
}
return new DateTimeFormatter(iPrinter, iParser, locale,
iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);
}"
Time_8b_1,/path/to/defects4j_buggy/Time_8_buggy/src/main/java/org/joda/time/DateTimeZone.java,"public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
if (hoursOffset == 0 && minutesOffset == 0) {
return DateTimeZone.UTC;
}
if (hoursOffset < -23 || hoursOffset > 23) {
throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
}
if (minutesOffset < 0 || minutesOffset > 59) {
throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
}
int offset = 0;
try {
int hoursInMinutes = hoursOffset * 60;
if (hoursInMinutes < 0) {
minutesOffset = hoursInMinutes - minutesOffset;
} else {
minutesOffset = hoursInMinutes + minutesOffset;
}
offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
} catch (ArithmeticException ex) {
throw new IllegalArgumentException(""Offset is too large"");
}
return forOffsetMillis(offset);
}"
Time_11b_1,/path/to/defects4j_buggy/Time_11_buggy/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java,"public static boolean verbose() {
return cVerbose.get();
}"
Time_14b_1,/path/to/defects4j_buggy/Time_14_buggy/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java,"public long add(long instant, int months) {
if (months == 0) {
return instant; // the easy case
}
//
// Save time part first.
//
long timePart = iChronology.getMillisOfDay(instant);
//
//
// Get this year and month.
//
int thisYear = iChronology.getYear(instant);
int thisMonth = iChronology.getMonthOfYear(instant, thisYear);
// ----------------------------------------------------------
//
// Do not refactor without careful consideration.
// Order of calculation is important.
//
int yearToUse;
// Initially, monthToUse is zero-based
int monthToUse = thisMonth - 1 + months;
if (monthToUse >= 0) {
yearToUse = thisYear + (monthToUse / iMax);
monthToUse = (monthToUse % iMax) + 1;
} else {
yearToUse = thisYear + (monthToUse / iMax) - 1;
monthToUse = Math.abs(monthToUse);
int remMonthToUse = monthToUse % iMax;
// Take care of the boundary condition
if (remMonthToUse == 0) {
remMonthToUse = iMax;
}
monthToUse = iMax - remMonthToUse + 1;
// Take care of the boundary condition
if (monthToUse == 1) {
yearToUse += 1;
}
}
// End of do not refactor.
// ----------------------------------------------------------

//
// Quietly force DOM to nearest sane value.
//
int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);
int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);
if (dayToUse > maxDay) {
dayToUse = maxDay;
}
//
// get proper date part, and return result
//
long datePart =
iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse);
return datePart + timePart;
}"
Time_15b_1,/path/to/defects4j_buggy/Time_15_buggy/src/main/java/org/joda/time/field/FieldUtils.java,"public static long safeMultiply(long val1, int val2) {
switch (val2) {
case -1:
return -val1;
case 0:
return 0L;
case 1:
return val1;
}
long total = val1 * val2;
if (total / val2 != val1) {
throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
}
return total;
}"
Time_16b_1,/path/to/defects4j_buggy/Time_16_buggy/src/main/java/org/joda/time/format/DateTimeFormatter.java,"public String print(ReadableInstant instant) {
StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
printTo(buf, instant);
return buf.toString();
}"
Time_17b_1,/path/to/defects4j_buggy/Time_17_buggy/src/main/java/org/joda/time/DateTimeZone.java,"public long adjustOffset(long instant, boolean earlierOrLater) {
// a bit messy, but will work in all non-pathological cases

// evaluate 3 hours before and after to work out if anything is happening
long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);
if (instantBefore == instantAfter) {
return instant;  // not an overlap (less than is a gap, equal is normal case)
}

// work out range of instants that have duplicate local times
long local = convertUTCToLocal(instant);
return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);

// calculate result
// currently in later offset
// currently in earlier offset
}"
Time_18b_1,/path/to/defects4j_buggy/Time_18_buggy/src/main/java/org/joda/time/chrono/GJChronology.java,"public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
int hourOfDay, int minuteOfHour,"
Time_19b_1,/path/to/defects4j_buggy/Time_19_buggy/src/main/java/org/joda/time/DateTimeZone.java,"public int getOffsetFromLocal(long instantLocal) {
// get the offset at instantLocal (first estimate)
final int offsetLocal = getOffset(instantLocal);
// adjust instantLocal using the estimate and recalc the offset
final long instantAdjusted = instantLocal - offsetLocal;
final int offsetAdjusted = getOffset(instantAdjusted);
// if the offsets differ, we must be near a DST boundary
if (offsetLocal != offsetAdjusted) {
// we need to ensure that time is always after the DST gap
// this happens naturally for positive offsets, but not for negative
if ((offsetLocal - offsetAdjusted) < 0) {
// if we just return offsetAdjusted then the time is pushed
// back before the transition, whereas it should be
// on or after the transition
long nextLocal = nextTransition(instantAdjusted);
long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
if (nextLocal != nextAdjusted) {
return offsetLocal;
}
}
} else if (offsetLocal > 0) {
long prev = previousTransition(instantAdjusted);
if (prev < instantAdjusted) {
int offsetPrev = getOffset(prev);
int diff = offsetPrev - offsetLocal;
if (instantAdjusted - prev <= diff) {
return offsetPrev;
}
}
}
return offsetAdjusted;
}"
Time_20b_1,/path/to/defects4j_buggy/Time_20_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java,"public DateTimeFormatterBuilder appendTimeZoneId() {
return append0(TimeZoneId.INSTANCE, TimeZoneId.INSTANCE);
}"
Time_22b_1,/path/to/defects4j_buggy/Time_22_buggy/src/main/java/org/joda/time/base/BasePeriod.java,"protected BasePeriod(long duration) {
this(duration, null, null);
// bug [3264409]
}"
Time_23b_1,/path/to/defects4j_buggy/Time_23_buggy/src/main/java/org/joda/time/DateTimeZone.java,"public static DateTimeZone forTimeZone(TimeZone zone) {
if (zone == null) {
return getDefault();
}
final String id = zone.getID();
if (id.equals(""UTC"")) {
return DateTimeZone.UTC;
}

// Convert from old alias before consulting provider since they may differ.
DateTimeZone dtz = null;
String convId = getConvertedId(id);
if (convId != null) {
dtz = cProvider.getZone(convId);
}
if (dtz == null) {
dtz = cProvider.getZone(id);
}
if (dtz != null) {
return dtz;
}

// Support GMT+/-hh:mm formats
if (convId == null) {
convId = zone.getDisplayName();
if (convId.startsWith(""GMT+"") || convId.startsWith(""GMT-"")) {
convId = convId.substring(3);
int offset = parseOffset(convId);
if (offset == 0L) {
return DateTimeZone.UTC;
} else {
convId = printOffset(offset);
return fixedOffsetZone(convId, offset);
}
}
}
throw new IllegalArgumentException(""The datetime zone id '"" + id + ""' is not recognised"");
}"
Time_24b_1,/path/to/defects4j_buggy/Time_24_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java,"public DateTimeZone getZone() {
return iZone;
}"
Time_25b_1,/path/to/defects4j_buggy/Time_25_buggy/src/main/java/org/joda/time/DateTimeZone.java,"public int getOffsetFromLocal(long instantLocal) {
// get the offset at instantLocal (first estimate)
final int offsetLocal = getOffset(instantLocal);
// adjust instantLocal using the estimate and recalc the offset
final long instantAdjusted = instantLocal - offsetLocal;
final int offsetAdjusted = getOffset(instantAdjusted);
// if the offsets differ, we must be near a DST boundary
if (offsetLocal != offsetAdjusted) {
// we need to ensure that time is always after the DST gap
// this happens naturally for positive offsets, but not for negative
if ((offsetLocal - offsetAdjusted) < 0) {
// if we just return offsetAdjusted then the time is pushed
// back before the transition, whereas it should be
// on or after the transition
long nextLocal = nextTransition(instantAdjusted);
long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
if (nextLocal != nextAdjusted) {
return offsetLocal;
}
}
}
return offsetAdjusted;
}"
Time_27b_1,/path/to/defects4j_buggy/Time_27_buggy/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java,"public PeriodFormatterBuilder append(PeriodFormatter formatter) {
if (formatter == null) {
throw new IllegalArgumentException(""No formatter supplied"");
}
clearPrefix();
append0(formatter.getPrinter(), formatter.getParser());
return this;
}"
