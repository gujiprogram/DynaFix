slug,class_path,buggy_code
Chart_1b_1,/home/common/huangzhili/defects4j_buggy_3/Chart_1_buggy/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java,"public void setPlot(CategoryPlot plot) {
if (plot == null) {
throw new IllegalArgumentException(""Null 'plot' argument."");
}
this.plot = plot;
}"
Chart_1b_2,/home/common/huangzhili/defects4j_buggy_3/Chart_1_buggy/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java,"public LegendItemCollection getLegendItems() {
LegendItemCollection result = new LegendItemCollection();
if (this.plot == null) {
return result;
}
int index = this.plot.getIndexOf(this);
CategoryDataset dataset = this.plot.getDataset(index);
if (dataset != null) {
return result;
}
int seriesCount = dataset.getRowCount();
if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {
for (int i = 0; i < seriesCount; i++) {
if (isSeriesVisibleInLegend(i)) {
LegendItem item = getLegendItem(index, i);
if (item != null) {
result.add(item);
}
}
}
}
else {
for (int i = seriesCount - 1; i >= 0; i--) {
if (isSeriesVisibleInLegend(i)) {
LegendItem item = getLegendItem(index, i);
if (item != null) {
result.add(item);
}
}
}
}
return result;
}"
Chart_1b_3,/home/common/huangzhili/defects4j_buggy_3/Chart_1_buggy/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java,"protected AbstractCategoryItemRenderer() {
this.itemLabelGeneratorList = new ObjectList();
this.toolTipGeneratorList = new ObjectList();
this.urlGeneratorList = new ObjectList();
this.legendItemLabelGenerator
= new StandardCategorySeriesLabelGenerator();
this.backgroundAnnotations = new ArrayList();
this.foregroundAnnotations = new ArrayList();
}"
Chart_3b_1,/home/common/huangzhili/defects4j_buggy_3/Chart_3_buggy/source/org/jfree/data/time/TimeSeries.java,"public TimeSeries createCopy(int start, int end)
throws CloneNotSupportedException {
if (start < 0) {
throw new IllegalArgumentException(""Requires start >= 0."");
}
if (end < start) {
throw new IllegalArgumentException(""Requires start <= end."");
}
TimeSeries copy = (TimeSeries) super.clone();
copy.data = new java.util.ArrayList();
if (this.data.size() > 0) {
for (int index = start; index <= end; index++) {
TimeSeriesDataItem item
= (TimeSeriesDataItem) this.data.get(index);
TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();
try {
copy.add(clone);
}
catch (SeriesException e) {
e.printStackTrace();
}
}
}
return copy;
}"
Chart_3b_2,/home/common/huangzhili/defects4j_buggy_3/Chart_3_buggy/source/org/jfree/data/time/TimeSeries.java,"add(item, true);
}

/**
* Adds a data item to the series and sends a {@link SeriesChangeEvent} to
* all registered listeners.
*
* @param item  the (timeperiod, value) pair (<code>null</code> not
*              permitted).
* @param notify  notify listeners?
*/
public void add(TimeSeriesDataItem item, boolean notify) {"
Chart_3b_3,/home/common/huangzhili/defects4j_buggy_3/Chart_3_buggy/source/org/jfree/data/time/TimeSeries.java,"public double getMinY() {
return this.minY;
}"
Chart_3b_4,/home/common/huangzhili/defects4j_buggy_3/Chart_3_buggy/source/org/jfree/data/time/TimeSeries.java,"public double getMaxY() {
return this.maxY;
}"
Chart_3b_5,/home/common/huangzhili/defects4j_buggy_3/Chart_3_buggy/source/org/jfree/data/time/TimeSeries.java,"public TimeSeries(Comparable name) {
this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION);
}"
Chart_4b_1,/home/common/huangzhili/defects4j_buggy_3/Chart_4_buggy/source/org/jfree/chart/plot/XYPlot.java,"public Range getDataRange(ValueAxis axis) {

Range result = null;
List mappedDatasets = new ArrayList();
List includedAnnotations = new ArrayList();
boolean isDomainAxis = true;

// is it a domain axis?
int domainIndex = getDomainAxisIndex(axis);
if (domainIndex >= 0) {
isDomainAxis = true;
mappedDatasets.addAll(getDatasetsMappedToDomainAxis(
new Integer(domainIndex)));
if (domainIndex == 0) {
// grab the plot's annotations
Iterator iterator = this.annotations.iterator();
while (iterator.hasNext()) {
XYAnnotation annotation = (XYAnnotation) iterator.next();
if (annotation instanceof XYAnnotationBoundsInfo) {
includedAnnotations.add(annotation);
}
}
}
}

// or is it a range axis?
int rangeIndex = getRangeAxisIndex(axis);
if (rangeIndex >= 0) {
isDomainAxis = false;
mappedDatasets.addAll(getDatasetsMappedToRangeAxis(
new Integer(rangeIndex)));
if (rangeIndex == 0) {
Iterator iterator = this.annotations.iterator();
while (iterator.hasNext()) {
XYAnnotation annotation = (XYAnnotation) iterator.next();
if (annotation instanceof XYAnnotationBoundsInfo) {
includedAnnotations.add(annotation);
}
}
}
}

// iterate through the datasets that map to the axis and get the union
// of the ranges.
Iterator iterator = mappedDatasets.iterator();
while (iterator.hasNext()) {
XYDataset d = (XYDataset) iterator.next();
if (d != null) {
XYItemRenderer r = getRendererForDataset(d);
if (isDomainAxis) {
if (r != null) {
result = Range.combine(result, r.findDomainBounds(d));
}
else {
result = Range.combine(result,
DatasetUtilities.findDomainBounds(d));
}
}
else {
if (r != null) {
result = Range.combine(result, r.findRangeBounds(d));
}
else {
result = Range.combine(result,
DatasetUtilities.findRangeBounds(d));
}
}

Collection c = r.getAnnotations();
Iterator i = c.iterator();
while (i.hasNext()) {
XYAnnotation a = (XYAnnotation) i.next();
if (a instanceof XYAnnotationBoundsInfo) {
includedAnnotations.add(a);
}
}
}
}

Iterator it = includedAnnotations.iterator();
while (it.hasNext()) {
XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();
if (xyabi.getIncludeInDataBounds()) {
if (isDomainAxis) {
result = Range.combine(result, xyabi.getXRange());
}
else {
result = Range.combine(result, xyabi.getYRange());
}
}
}

return result;

}"
Chart_4b_2,/home/common/huangzhili/defects4j_buggy_3/Chart_4_buggy/source/org/jfree/chart/plot/XYPlot.java,"public XYItemRenderer getRendererForDataset(XYDataset dataset) {
XYItemRenderer result = null;
for (int i = 0; i < this.datasets.size(); i++) {
if (this.datasets.get(i) == dataset) {
result = (XYItemRenderer) this.renderers.get(i);
if (result == null) {
result = getRenderer();
}
break;
}
}
return result;
}"
Chart_4b_3,/home/common/huangzhili/defects4j_buggy_3/Chart_4_buggy/source/org/jfree/chart/plot/XYPlot.java,"return getRenderer(0);
}

/**
* Returns the renderer for a dataset, or <code>null</code>.
*
* @param index  the renderer index.
*
* @return The renderer (possibly <code>null</code>).
*
* @see #setRenderer(int, XYItemRenderer)
*/
public XYItemRenderer getRenderer(int index) {"
Chart_4b_4,/home/common/huangzhili/defects4j_buggy_3/Chart_4_buggy/source/org/jfree/chart/plot/XYPlot.java,"public void configureDomainAxes() {
for (int i = 0; i < this.domainAxes.size(); i++) {
ValueAxis axis = (ValueAxis) this.domainAxes.get(i);
if (axis != null) {
axis.configure();
}
}
}"
Chart_4b_5,/home/common/huangzhili/defects4j_buggy_3/Chart_4_buggy/source/org/jfree/chart/plot/XYPlot.java,"private List getDatasetsMappedToDomainAxis(Integer axisIndex) {
if (axisIndex == null) {
throw new IllegalArgumentException(""Null 'axisIndex' argument."");
}
List result = new ArrayList();
for (int i = 0; i < this.datasets.size(); i++) {
List mappedAxes = (List) this.datasetToDomainAxesMap.get(
new Integer(i));
if (mappedAxes == null) {
if (axisIndex.equals(ZERO)) {
result.add(this.datasets.get(i));
}
}
else {
if (mappedAxes.contains(axisIndex)) {
result.add(this.datasets.get(i));
}
}
}
return result;
}"
Chart_5b_1,/home/common/huangzhili/defects4j_buggy_3/Chart_5_buggy/source/org/jfree/data/xy/XYSeries.java,"return addOrUpdate(new Double(x), new Double(y));
}

/**
* Adds or updates an item in the series and sends a
* {@link SeriesChangeEvent} to all registered listeners.
*
* @param x  the x-value (<code>null</code> not permitted).
* @param y  the y-value (<code>null</code> permitted).
*
* @return A copy of the overwritten data item, or <code>null</code> if no
*         item was overwritten.
*/
public XYDataItem addOrUpdate(Number x, Number y) {"
Chart_5b_2,/home/common/huangzhili/defects4j_buggy_3/Chart_5_buggy/source/org/jfree/data/xy/XYSeries.java,"public int indexOf(Number x) {
if (this.autoSort) {
return Collections.binarySearch(this.data, new XYDataItem(x, null));
}
else {
for (int i = 0; i < this.data.size(); i++) {
XYDataItem item = (XYDataItem) this.data.get(i);
if (item.getX().equals(x)) {
return i;
}
}
return -1;
}
}"
Chart_5b_3,/home/common/huangzhili/defects4j_buggy_3/Chart_5_buggy/source/org/jfree/data/xy/XYSeries.java,"public int getItemCount() {
return this.data.size();
}"
Chart_6b_1,/home/common/huangzhili/defects4j_buggy_3/Chart_6_buggy/source/org/jfree/chart/util/ShapeList.java,"public ShapeList() {
super();
}"
Chart_6b_2,/home/common/huangzhili/defects4j_buggy_3/Chart_6_buggy/source/org/jfree/chart/util/ShapeList.java,"public void setShape(int index, Shape shape) {
set(index, shape);
}"
Chart_6b_3,/home/common/huangzhili/defects4j_buggy_3/Chart_6_buggy/source/org/jfree/chart/util/ShapeList.java,"public boolean equals(Object obj) {

if (obj == this) {
return true;
}
if (!(obj instanceof ShapeList)) {
return false;
}
return super.equals(obj);

}"
Chart_6b_4,/home/common/huangzhili/defects4j_buggy_3/Chart_6_buggy/source/org/jfree/chart/util/ShapeList.java,"public Shape getShape(int index) {
return (Shape) get(index);
}"
Chart_6b_5,/home/common/huangzhili/defects4j_buggy_3/Chart_6_buggy/source/org/jfree/chart/util/ShapeList.java,"return super.hashCode();
}

/**
* Provides serialization support.
*
* @param stream  the output stream.
*
* @throws IOException  if there is an I/O error.
*/
private void writeObject(ObjectOutputStream stream) throws IOException {"
Chart_7b_1,/home/common/huangzhili/defects4j_buggy_3/Chart_7_buggy/source/org/jfree/data/time/TimePeriodValues.java,"public int getMaxMiddleIndex() {
return this.maxMiddleIndex;
}"
Chart_7b_2,/home/common/huangzhili/defects4j_buggy_3/Chart_7_buggy/source/org/jfree/data/time/TimePeriodValues.java,"private void updateBounds(TimePeriod period, int index) {

long start = period.getStart().getTime();
long end = period.getEnd().getTime();
long middle = start + ((end - start) / 2);

if (this.minStartIndex >= 0) {
long minStart = getDataItem(this.minStartIndex).getPeriod()
.getStart().getTime();
if (start < minStart) {
this.minStartIndex = index;
}
}
else {
this.minStartIndex = index;
}

if (this.maxStartIndex >= 0) {
long maxStart = getDataItem(this.maxStartIndex).getPeriod()
.getStart().getTime();
if (start > maxStart) {
this.maxStartIndex = index;
}
}
else {
this.maxStartIndex = index;
}

if (this.minMiddleIndex >= 0) {
long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()
.getTime();
long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()
.getTime();
long minMiddle = s + (e - s) / 2;
if (middle < minMiddle) {
this.minMiddleIndex = index;
}
}
else {
this.minMiddleIndex = index;
}

if (this.maxMiddleIndex >= 0) {
long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()
.getTime();
long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()
.getTime();
long maxMiddle = s + (e - s) / 2;
if (middle > maxMiddle) {
this.maxMiddleIndex = index;
}
}
else {
this.maxMiddleIndex = index;
}

if (this.minEndIndex >= 0) {
long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()
.getTime();
if (end < minEnd) {
this.minEndIndex = index;
}
}
else {
this.minEndIndex = index;
}

if (this.maxEndIndex >= 0) {
long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()
.getTime();
if (end > maxEnd) {
this.maxEndIndex = index;
}
}
else {
this.maxEndIndex = index;
}

}"
Chart_7b_3,/home/common/huangzhili/defects4j_buggy_3/Chart_7_buggy/source/org/jfree/data/time/TimePeriodValues.java,"public void add(TimePeriodValue item) {
if (item == null) {
throw new IllegalArgumentException(""Null item not allowed."");
}
this.data.add(item);
updateBounds(item.getPeriod(), this.data.size() - 1);
fireSeriesChanged();
}"
Chart_7b_4,/home/common/huangzhili/defects4j_buggy_3/Chart_7_buggy/source/org/jfree/data/time/TimePeriodValues.java,"public TimePeriodValue getDataItem(int index) {
return (TimePeriodValue) this.data.get(index);
}"
Chart_8b_1,/home/common/huangzhili/defects4j_buggy_3/Chart_8_buggy/source/org/jfree/data/time/Week.java,"public Week(Date time, TimeZone zone) {
        // defer argument checking...
        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());
    }"
Chart_9b_1,/home/common/huangzhili/defects4j_buggy_3/Chart_9_buggy/source/org/jfree/data/time/TimeSeries.java,"public TimeSeries createCopy(int start, int end)
throws CloneNotSupportedException {

if (start < 0) {
throw new IllegalArgumentException(""Requires start >= 0."");
}
if (end < start) {
throw new IllegalArgumentException(""Requires start <= end."");
}
TimeSeries copy = (TimeSeries) super.clone();

copy.data = new java.util.ArrayList();
if (this.data.size() > 0) {
for (int index = start; index <= end; index++) {
TimeSeriesDataItem item
= (TimeSeriesDataItem) this.data.get(index);
TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();
try {
copy.add(clone);
}
catch (SeriesException e) {
e.printStackTrace();
}
}
}
return copy;
}"
Chart_9b_2,/home/common/huangzhili/defects4j_buggy_3/Chart_9_buggy/source/org/jfree/data/time/TimeSeries.java,"public TimeSeries(Comparable name) {
this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION,
Day.class);
}"
Chart_9b_3,/home/common/huangzhili/defects4j_buggy_3/Chart_9_buggy/source/org/jfree/data/time/TimeSeries.java,"public int getIndex(RegularTimePeriod period) {
if (period == null) {
throw new IllegalArgumentException(""Null 'period' argument."");
}
TimeSeriesDataItem dummy = new TimeSeriesDataItem(
period, Integer.MIN_VALUE);
return Collections.binarySearch(this.data, dummy);
}"
Chart_9b_4,/home/common/huangzhili/defects4j_buggy_3/Chart_9_buggy/source/org/jfree/data/time/TimeSeries.java,"public void add(TimeSeriesDataItem item, boolean notify) {
if (item == null) {
throw new IllegalArgumentException(""Null 'item' argument."");
}
if (!item.getPeriod().getClass().equals(this.timePeriodClass)) {
StringBuffer b = new StringBuffer();
b.append(""You are trying to add data where the time period class "");
b.append(""is "");
b.append(item.getPeriod().getClass().getName());
b.append("", but the TimeSeries is expecting an instance of "");
b.append(this.timePeriodClass.getName());
b.append(""."");
throw new SeriesException(b.toString());
}

// make the change (if it's not a duplicate time period)...
boolean added = false;
int count = getItemCount();
if (count == 0) {
this.data.add(item);
added = true;
}
else {
RegularTimePeriod last = getTimePeriod(getItemCount() - 1);
if (item.getPeriod().compareTo(last) > 0) {
this.data.add(item);
added = true;
}
else {
int index = Collections.binarySearch(this.data, item);
if (index < 0) {
this.data.add(-index - 1, item);
added = true;
}
else {
StringBuffer b = new StringBuffer();
b.append(""You are attempting to add an observation for "");
b.append(""the time period "");
b.append(item.getPeriod().toString());
b.append("" but the series already contains an observation"");
b.append("" for that time period. Duplicates are not "");
b.append(""permitted.  Try using the addOrUpdate() method."");
throw new SeriesException(b.toString());
}
}
}
if (added) {
// check if this addition will exceed the maximum item count...
if (getItemCount() > this.maximumItemCount) {
this.data.remove(0);
}

removeAgedItems(false);  // remove old items if necessary, but
// don't notify anyone, because that
// happens next anyway...
if (notify) {
fireSeriesChanged();
}
}

}"
Chart_9b_5,/home/common/huangzhili/defects4j_buggy_3/Chart_9_buggy/source/org/jfree/data/time/TimeSeries.java,"public int getItemCount() {
return this.data.size();
}"
Chart_10b_1,/home/common/huangzhili/defects4j_buggy_3/Chart_10_buggy/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java,"public StandardToolTipTagFragmentGenerator() {
super();
}"
Chart_10b_2,/home/common/huangzhili/defects4j_buggy_3/Chart_10_buggy/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java,"public String generateToolTipFragment(String toolTipText) {
return "" title=\"""" + toolTipText
+ ""\"" alt=\""\"""";
}"
Chart_11b_1,/home/common/huangzhili/defects4j_buggy_3/Chart_11_buggy/source/org/jfree/chart/util/ShapeUtilities.java,"public static boolean equal(GeneralPath p1, GeneralPath p2) {
if (p1 == null) {
return (p2 == null);
}
if (p2 == null) {
return false;
}
if (p1.getWindingRule() != p2.getWindingRule()) {
return false;
}
PathIterator iterator1 = p1.getPathIterator(null);
PathIterator iterator2 = p1.getPathIterator(null);
double[] d1 = new double[6];
double[] d2 = new double[6];
boolean done = iterator1.isDone() && iterator2.isDone();
while (!done) {
if (iterator1.isDone() != iterator2.isDone()) {
return false;
}
int seg1 = iterator1.currentSegment(d1);
int seg2 = iterator2.currentSegment(d2);
if (seg1 != seg2) {
return false;
}
if (!Arrays.equals(d1, d2)) {
return false;
}
iterator1.next();
iterator2.next();
done = iterator1.isDone() && iterator2.isDone();
}
return true;
}"
Chart_12b_1,/home/common/huangzhili/defects4j_buggy_3/Chart_12_buggy/source/org/jfree/chart/plot/MultiplePiePlot.java,"public CategoryDataset getDataset() {
return this.dataset;
}"
Chart_13b_1,/home/common/huangzhili/defects4j_buggy_3/Chart_13_buggy/source/org/jfree/chart/block/BorderArrangement.java,"public Size2D arrange(BlockContainer container,
Graphics2D g2,"
Chart_13b_2,/home/common/huangzhili/defects4j_buggy_3/Chart_13_buggy/source/org/jfree/chart/block/BorderArrangement.java,"protected Size2D arrangeFN(BlockContainer container, Graphics2D g2,
double width) {
double[] w = new double[5];
double[] h = new double[5];
RectangleConstraint c1 = new RectangleConstraint(width, null,
LengthConstraintType.FIXED, 0.0, null,
LengthConstraintType.NONE);
if (this.topBlock != null) {
Size2D size = this.topBlock.arrange(g2, c1);
w[0] = size.width;
h[0] = size.height;
}
if (this.bottomBlock != null) {
Size2D size = this.bottomBlock.arrange(g2, c1);
w[1] = size.width;
h[1] = size.height;
}
RectangleConstraint c2 = new RectangleConstraint(0.0,
new Range(0.0, width), LengthConstraintType.RANGE,
0.0, null, LengthConstraintType.NONE);
if (this.leftBlock != null) {
Size2D size = this.leftBlock.arrange(g2, c2);
w[2] = size.width;
h[2] = size.height;
}
if (this.rightBlock != null) {
double maxW = Math.max(width - w[2], 0.0);
RectangleConstraint c3 = new RectangleConstraint(0.0,
new Range(Math.min(w[2], maxW), maxW),
LengthConstraintType.RANGE, 0.0, null,
LengthConstraintType.NONE);
Size2D size = this.rightBlock.arrange(g2, c3);
w[3] = size.width;
h[3] = size.height;
}

h[2] = Math.max(h[2], h[3]);
h[3] = h[2];

if (this.centerBlock != null) {
RectangleConstraint c4 = new RectangleConstraint(width - w[2]
- w[3], null, LengthConstraintType.FIXED, 0.0, null,
LengthConstraintType.NONE);
Size2D size = this.centerBlock.arrange(g2, c4);
w[4] = size.width;
h[4] = size.height;
}
double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));
return arrange(container, g2, new RectangleConstraint(width, height));
}"
Chart_13b_3,/home/common/huangzhili/defects4j_buggy_3/Chart_13_buggy/source/org/jfree/chart/block/BorderArrangement.java,"protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,
RectangleConstraint constraint) {
double[] w = new double[5];
double[] h = new double[5];
w[0] = constraint.getWidth();
if (this.topBlock != null) {
RectangleConstraint c1 = new RectangleConstraint(w[0], null,
LengthConstraintType.FIXED, 0.0,
new Range(0.0, constraint.getHeight()),
LengthConstraintType.RANGE);
Size2D size = this.topBlock.arrange(g2, c1);
h[0] = size.height;
}
w[1] = w[0];
if (this.bottomBlock != null) {
RectangleConstraint c2 = new RectangleConstraint(w[0], null,
LengthConstraintType.FIXED, 0.0, new Range(0.0,
constraint.getHeight() - h[0]), LengthConstraintType.RANGE);
Size2D size = this.bottomBlock.arrange(g2, c2);
h[1] = size.height;
}
h[2] = constraint.getHeight() - h[1] - h[0];
if (this.leftBlock != null) {
RectangleConstraint c3 = new RectangleConstraint(0.0,
new Range(0.0, constraint.getWidth()),
LengthConstraintType.RANGE, h[2], null,
LengthConstraintType.FIXED);
Size2D size = this.leftBlock.arrange(g2, c3);
w[2] = size.width;
}
h[3] = h[2];
if (this.rightBlock != null) {
RectangleConstraint c4 = new RectangleConstraint(0.0,
new Range(0.0, constraint.getWidth() - w[2]),
LengthConstraintType.RANGE, h[2], null,
LengthConstraintType.FIXED);
Size2D size = this.rightBlock.arrange(g2, c4);
w[3] = size.width;
}
h[4] = h[2];
w[4] = constraint.getWidth() - w[3] - w[2];
RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);
if (this.centerBlock != null) {
this.centerBlock.arrange(g2, c5);
}

if (this.topBlock != null) {
this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],
h[0]));
}
if (this.bottomBlock != null) {
this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],
w[1], h[1]));
}
if (this.leftBlock != null) {
this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],
h[2]));
}
if (this.rightBlock != null) {
this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],
w[3], h[3]));
}
if (this.centerBlock != null) {
this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],
h[4]));
}
return new Size2D(constraint.getWidth(), constraint.getHeight());
}"
Chart_13b_4,/home/common/huangzhili/defects4j_buggy_3/Chart_13_buggy/source/org/jfree/chart/block/BorderArrangement.java,"public void clear() {
this.centerBlock = null;
this.topBlock = null;
this.bottomBlock = null;
this.leftBlock = null;
this.rightBlock = null;
}"
Chart_13b_5,/home/common/huangzhili/defects4j_buggy_3/Chart_13_buggy/source/org/jfree/chart/block/BorderArrangement.java,"public void add(Block block, Object key) {

if (key == null) {
this.centerBlock = block;
}
else {
RectangleEdge edge = (RectangleEdge) key;
if (edge == RectangleEdge.TOP) {
this.topBlock = block;
}
else if (edge == RectangleEdge.BOTTOM) {
this.bottomBlock = block;
}
else if (edge == RectangleEdge.LEFT) {
this.leftBlock = block;
}
else if (edge == RectangleEdge.RIGHT) {
this.rightBlock = block;
}
}
}"
Chart_17b_1,/home/common/huangzhili/defects4j_buggy_3/Chart_17_buggy/source/org/jfree/data/time/TimeSeries.java,"public TimeSeries createCopy(int start, int end)
throws CloneNotSupportedException {

if (start < 0) {
throw new IllegalArgumentException(""Requires start >= 0."");
}
if (end < start) {
throw new IllegalArgumentException(""Requires start <= end."");
}
TimeSeries copy = (TimeSeries) super.clone();

copy.data = new java.util.ArrayList();
if (this.data.size() > 0) {
for (int index = start; index <= end; index++) {
TimeSeriesDataItem item
= (TimeSeriesDataItem) this.data.get(index);
TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();
try {
copy.add(clone);
}
catch (SeriesException e) {
e.printStackTrace();
}
}
}
return copy;
}"
Chart_17b_2,/home/common/huangzhili/defects4j_buggy_3/Chart_17_buggy/source/org/jfree/data/time/TimeSeries.java,"public Object clone() throws CloneNotSupportedException {
Object clone = createCopy(0, getItemCount() - 1);
return clone;
}"
Chart_17b_3,/home/common/huangzhili/defects4j_buggy_3/Chart_17_buggy/source/org/jfree/data/time/TimeSeries.java,"public TimeSeries(Comparable name) {
this(name, DEFAULT_DOMAIN_DESCRIPTION, DEFAULT_RANGE_DESCRIPTION,
Day.class);
}"
Chart_17b_4,/home/common/huangzhili/defects4j_buggy_3/Chart_17_buggy/source/org/jfree/data/time/TimeSeries.java,"public int getItemCount() {
return this.data.size();
}"
Chart_17b_5,/home/common/huangzhili/defects4j_buggy_3/Chart_17_buggy/source/org/jfree/data/time/TimeSeries.java,"public TimeSeriesDataItem getDataItem(int index) {
return (TimeSeriesDataItem) this.data.get(index);
}"
Chart_20b_1,/home/common/huangzhili/defects4j_buggy_3/Chart_20_buggy/source/org/jfree/chart/plot/ValueMarker.java,"public ValueMarker(double value, Paint paint, Stroke stroke,
Paint outlinePaint, Stroke outlineStroke, float alpha) {
super(paint, stroke, paint, stroke, alpha);
this.value = value;
}"
Chart_20b_2,/home/common/huangzhili/defects4j_buggy_3/Chart_20_buggy/source/org/jfree/chart/plot/ValueMarker.java,"public double getValue() {
return this.value;
}"
Chart_24b_1,/home/common/huangzhili/defects4j_buggy_3/Chart_24_buggy/source/org/jfree/chart/renderer/GrayPaintScale.java,"public Paint getPaint(double value) {
double v = Math.max(value, this.lowerBound);
v = Math.min(v, this.upperBound);
int g = (int) ((value - this.lowerBound) / (this.upperBound
- this.lowerBound) * 255.0);
return new Color(g, g, g);
}"
Chart_24b_2,/home/common/huangzhili/defects4j_buggy_3/Chart_24_buggy/source/org/jfree/chart/renderer/GrayPaintScale.java,"public GrayPaintScale() {
this(0.0, 1.0);
}"
Chart_26b_1,/home/common/huangzhili/defects4j_buggy_3/Chart_26_buggy/source/org/jfree/chart/axis/Axis.java,"public boolean isVisible() {
return this.visible;
}"
Chart_26b_2,/home/common/huangzhili/defects4j_buggy_3/Chart_26_buggy/source/org/jfree/chart/axis/Axis.java,"public String getLabel() {
return this.label;
}"
Chart_26b_3,/home/common/huangzhili/defects4j_buggy_3/Chart_26_buggy/source/org/jfree/chart/axis/Axis.java,"public Font getLabelFont() {
return this.labelFont;
}"
Chart_26b_4,/home/common/huangzhili/defects4j_buggy_3/Chart_26_buggy/source/org/jfree/chart/axis/Axis.java,"public Paint getLabelPaint() {
return this.labelPaint;
}"
Chart_26b_5,/home/common/huangzhili/defects4j_buggy_3/Chart_26_buggy/source/org/jfree/chart/axis/Axis.java,"public RectangleInsets getLabelInsets() {
return this.labelInsets;
}"
Closure_1b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_1_buggy/src/com/google/javascript/jscomp/RemoveUnusedVars.java,"private void removeUnreferencedFunctionArgs(Scope fnScope) {
// Notice that removing unreferenced function args breaks
// Function.prototype.length. In advanced mode, we don't really care
// about this: we consider ""length"" the equivalent of reflecting on
// the function's lexical source.
//
// Rather than create a new option for this, we assume that if the user
// is removing globals, then it's OK to remove unused function args.
//
// See http://code.google.com/p/closure-compiler/issues/detail?id=253

Node function = fnScope.getRootNode();

Preconditions.checkState(function.isFunction());
if (NodeUtil.isGetOrSetKey(function.getParent())) {
// The parameters object literal setters can not be removed.
return;
}

Node argList = getFunctionArgList(function);
boolean modifyCallers = modifyCallSites
&& callSiteOptimizer.canModifyCallers(function);
if (!modifyCallers) {
// Strip unreferenced args off the end of the function declaration.
Node lastArg;
while ((lastArg = argList.getLastChild()) != null) {
Var var = fnScope.getVar(lastArg.getString());
if (!referenced.contains(var)) {
argList.removeChild(lastArg);
compiler.reportCodeChange();
} else {
break;
}
}
} else {
callSiteOptimizer.optimize(fnScope, referenced);
}
}"
Closure_1b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_1_buggy/src/com/google/javascript/jscomp/RemoveUnusedVars.java,"private void removeUnreferencedVars() {
CodingConvention convention = codingConvention;

for (Iterator<Var> it = maybeUnreferenced.iterator(); it.hasNext(); ) {
Var var = it.next();

// Remove calls to inheritance-defining functions where the unreferenced
// class is the subclass.
for (Node exprCallNode : classDefiningCalls.get(var)) {
NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);
compiler.reportCodeChange();
}

// Regardless of what happens to the original declaration,
// we need to remove all assigns, because they may contain references
// to other unreferenced variables.
removeAllAssigns(var);

compiler.addToDebugLog(""Unreferenced var: "" + var.name);
Node nameNode = var.nameNode;
Node toRemove = nameNode.getParent();
Node parent = toRemove.getParent();

Preconditions.checkState(
toRemove.isVar() ||
toRemove.isFunction() ||
toRemove.isParamList() &&
parent.isFunction(),
""We should only declare vars and functions and function args"");

if (toRemove.isParamList() &&
parent.isFunction()) {
// Don't remove function arguments here. That's a special case
// that's taken care of in removeUnreferencedFunctionArgs.
} else if (NodeUtil.isFunctionExpression(toRemove)) {
if (!preserveFunctionExpressionNames) {
toRemove.getFirstChild().setString("""");
compiler.reportCodeChange();
}
// Don't remove bleeding functions.
} else if (parent != null &&
parent.isFor() &&
parent.getChildCount() < 4) {
// foreach iterations have 3 children. Leave them alone.
} else if (toRemove.isVar() &&
nameNode.hasChildren() &&
NodeUtil.mayHaveSideEffects(nameNode.getFirstChild(), compiler)) {
// If this is a single var declaration, we can at least remove the
// declaration itself and just leave the value, e.g.,
// var a = foo(); => foo();
if (toRemove.getChildCount() == 1) {
parent.replaceChild(toRemove,
IR.exprResult(nameNode.removeFirstChild()));
compiler.reportCodeChange();
}
} else if (toRemove.isVar() &&
toRemove.getChildCount() > 1) {
// For var declarations with multiple names (i.e. var a, b, c),
// only remove the unreferenced name
toRemove.removeChild(nameNode);
compiler.reportCodeChange();
} else if (parent != null) {
NodeUtil.removeChild(parent, toRemove);
compiler.reportCodeChange();
}
}
}"
Closure_1b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_1_buggy/src/com/google/javascript/jscomp/RemoveUnusedVars.java,"private void traverseNode(Node n, Node parent, Scope scope) {
int type = n.getType();
Var var = null;
switch (type) {
case Token.FUNCTION:
// If this function is a removable var, then create a continuation
// for it instead of traversing immediately.
if (NodeUtil.isFunctionDeclaration(n)) {
var = scope.getVar(n.getFirstChild().getString());
}

if (var != null && isRemovableVar(var)) {
continuations.put(var, new Continuation(n, scope));
} else {
traverseFunction(n, scope);
}
return;

case Token.ASSIGN:
Assign maybeAssign = Assign.maybeCreateAssign(n);
if (maybeAssign != null) {
// Put this in the assign map. It might count as a reference,
// but we won't know that until we have an index of all assigns.
var = scope.getVar(maybeAssign.nameNode.getString());
if (var != null) {
assignsByVar.put(var, maybeAssign);
assignsByNode.put(maybeAssign.nameNode, maybeAssign);

if (isRemovableVar(var) &&
!maybeAssign.mayHaveSecondarySideEffects) {
// If the var is unreferenced and performing this assign has
// no secondary side effects, then we can create a continuation
// for it instead of traversing immediately.
continuations.put(var, new Continuation(n, scope));
return;
}
}
}
break;

case Token.CALL:
Var modifiedVar = null;

// Look for calls to inheritance-defining calls (such as goog.inherits).
SubclassRelationship subclassRelationship =
codingConvention.getClassesDefinedByCall(n);
if (subclassRelationship != null) {
modifiedVar = scope.getVar(subclassRelationship.subclassName);
} else {
// Look for calls to addSingletonGetter calls.
String className = codingConvention.getSingletonGetterClassName(n);
if (className != null) {
modifiedVar = scope.getVar(className);
}
}

// Don't try to track the inheritance calls for non-globals. It would
// be more correct to only not track when the subclass does not
// reference a constructor, but checking that it is a global is
// easier and mostly the same.
if (modifiedVar != null && modifiedVar.isGlobal()
&& !referenced.contains(modifiedVar)) {
// Save a reference to the EXPR node.
classDefiningCalls.put(modifiedVar, parent);
continuations.put(modifiedVar, new Continuation(n, scope));
return;
}
break;

case Token.NAME:
var = scope.getVar(n.getString());
if (parent.isVar()) {
Node value = n.getFirstChild();
if (value != null && var != null && isRemovableVar(var) &&
!NodeUtil.mayHaveSideEffects(value, compiler)) {
// If the var is unreferenced and creating its value has no side
// effects, then we can create a continuation for it instead
// of traversing immediately.
continuations.put(var, new Continuation(n, scope));
return;
}
} else {

// If arguments is escaped, we just assume the worst and continue
// on all the parameters.
if (""arguments"".equals(n.getString()) && scope.isLocal()) {
Node lp = scope.getRootNode().getFirstChild().getNext();
for (Node a = lp.getFirstChild(); a != null; a = a.getNext()) {
markReferencedVar(scope.getVar(a.getString()));
}
}

// All name references that aren't declarations or assigns
// are references to other vars.
if (var != null) {
// If that var hasn't already been marked referenced, then
// start tracking it.  If this is an assign, do nothing
// for now.
if (isRemovableVar(var)) {
if (!assignsByNode.containsKey(n)) {
markReferencedVar(var);
}
} else {
markReferencedVar(var);
}
}
}
break;
}

for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
traverseNode(c, n, scope);
}
}"
Closure_1b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_1_buggy/src/com/google/javascript/jscomp/RemoveUnusedVars.java,"private void interpretAssigns() {
boolean changes = false;
do {
changes = false;

// We can't use traditional iterators and iterables for this list,
// because our lazily-evaluated continuations will modify it while
// we traverse it.
for (int current = 0; current < maybeUnreferenced.size(); current++) {
Var var = maybeUnreferenced.get(current);
if (referenced.contains(var)) {
maybeUnreferenced.remove(current);
current--;
} else {
boolean assignedToUnknownValue = false;
boolean hasPropertyAssign = false;

if (var.getParentNode().isVar() &&
!NodeUtil.isForIn(var.getParentNode().getParent())) {
Node value = var.getInitialValue();
assignedToUnknownValue = value != null &&
!NodeUtil.isLiteralValue(value, true);
} else {
// This was initialized to a function arg or a catch param
// or a for...in variable.
assignedToUnknownValue = true;
}

boolean maybeEscaped = false;
for (Assign assign : assignsByVar.get(var)) {
if (assign.isPropertyAssign) {
hasPropertyAssign = true;
} else if (!NodeUtil.isLiteralValue(
assign.assignNode.getLastChild(), true)) {
assignedToUnknownValue = true;
}
if (assign.maybeAliased) {
maybeEscaped = true;
}
}

if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {
changes = markReferencedVar(var) || changes;
maybeUnreferenced.remove(current);
current--;
}
}
}
} while (changes);
}"
Closure_1b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_1_buggy/src/com/google/javascript/jscomp/RemoveUnusedVars.java,"private static Node getFunctionArgList(Node function) {
return function.getFirstChild().getNext();
}"
Closure_2b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"private void checkInterfaceConflictProperties(NodeTraversal t, Node n,
String functionName, HashMap<String, ObjectType> properties,"
Closure_2b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"private void visitFunction(NodeTraversal t, Node n) {
FunctionType functionType = JSType.toMaybeFunctionType(n.getJSType());
String functionPrivateName = n.getFirstChild().getString();
if (functionType.isConstructor()) {
FunctionType baseConstructor = functionType.getSuperClassConstructor();
if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) &&
baseConstructor != null &&
baseConstructor.isInterface()) {
compiler.report(
t.makeError(n, CONFLICTING_EXTENDED_TYPE,
""constructor"", functionPrivateName));
} else {
if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE)) {
ObjectType proto = functionType.getPrototype();
if (functionType.makesStructs() && !proto.isStruct()) {
compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE,
""struct"", functionPrivateName));
} else if (functionType.makesDicts() && !proto.isDict()) {
compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE,
""dict"", functionPrivateName));
}
}
// All interfaces are properly implemented by a class
for (JSType baseInterface : functionType.getImplementedInterfaces()) {
boolean badImplementedType = false;
ObjectType baseInterfaceObj = ObjectType.cast(baseInterface);
if (baseInterfaceObj != null) {
FunctionType interfaceConstructor =
baseInterfaceObj.getConstructor();
if (interfaceConstructor != null &&
!interfaceConstructor.isInterface()) {
badImplementedType = true;
}
} else {
badImplementedType = true;
}
if (badImplementedType) {
report(t, n, BAD_IMPLEMENTED_TYPE, functionPrivateName);
}
}
// check properties
validator.expectAllInterfaceProperties(t, n, functionType);
}
} else if (functionType.isInterface()) {
// Interface must extend only interfaces
for (ObjectType extInterface : functionType.getExtendedInterfaces()) {
if (extInterface.getConstructor() != null
&& !extInterface.getConstructor().isInterface()) {
compiler.report(
t.makeError(n, CONFLICTING_EXTENDED_TYPE,
""interface"", functionPrivateName));
}
}

// Check whether the extended interfaces have any conflicts
if (functionType.getExtendedInterfacesCount() > 1) {
// Only check when extending more than one interfaces
HashMap<String, ObjectType> properties
= new HashMap<String, ObjectType>();
HashMap<String, ObjectType> currentProperties
= new HashMap<String, ObjectType>();
for (ObjectType interfaceType : functionType.getExtendedInterfaces()) {
currentProperties.clear();
checkInterfaceConflictProperties(t, n, functionPrivateName,
properties, currentProperties, interfaceType);
properties.putAll(currentProperties);
}
}
}
}"
Closure_2b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"public boolean shouldTraverse(
NodeTraversal t, Node n, Node parent) {
checkNoTypeCheckSection(n, true);
switch (n.getType()) {
case Token.FUNCTION:
// normal type checking
final Scope outerScope = t.getScope();
final String functionPrivateName = n.getFirstChild().getString();
if (functionPrivateName != null && functionPrivateName.length() > 0 &&
outerScope.isDeclared(functionPrivateName, false) &&
// Ideally, we would want to check whether the type in the scope
// differs from the type being defined, but then the extern
// redeclarations of built-in types generates spurious warnings.
!(outerScope.getVar(
functionPrivateName).getType() instanceof FunctionType)) {
report(t, n, FUNCTION_MASKS_VARIABLE, functionPrivateName);
}

// TODO(user): Only traverse the function's body. The function's
// name and arguments are traversed by the scope creator, and ideally
// should not be traversed by the type checker.
break;
}
return true;
}"
Closure_2b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"public void visit(NodeTraversal t, Node n, Node parent) {
JSType childType;
JSType leftType, rightType;
Node left, right;
// To be explicitly set to false if the node is not typeable.
boolean typeable = true;

switch (n.getType()) {
case Token.CAST:
Node expr = n.getFirstChild();
ensureTyped(t, n, getJSType(expr));

// If the cast, tightens the type apply it, so it is available post
// normalization.
JSType castType = getJSType(n);
JSType exprType = getJSType(expr);
if (castType.isSubtype(exprType)) {
expr.setJSType(castType);
}
break;

case Token.NAME:
typeable = visitName(t, n, parent);
break;

case Token.PARAM_LIST:
typeable = false;
break;

case Token.COMMA:
ensureTyped(t, n, getJSType(n.getLastChild()));
break;

case Token.TRUE:
case Token.FALSE:
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.THIS:
ensureTyped(t, n, t.getScope().getTypeOfThis());
break;

case Token.NULL:
ensureTyped(t, n, NULL_TYPE);
break;

case Token.NUMBER:
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.STRING:
ensureTyped(t, n, STRING_TYPE);
break;

case Token.STRING_KEY:
typeable = false;
break;

case Token.GETTER_DEF:
case Token.SETTER_DEF:
// Object literal keys are handled with OBJECTLIT
break;

case Token.ARRAYLIT:
ensureTyped(t, n, ARRAY_TYPE);
break;

case Token.REGEXP:
ensureTyped(t, n, REGEXP_TYPE);
break;

case Token.GETPROP:
visitGetProp(t, n, parent);
typeable = !(parent.isAssign() &&
parent.getFirstChild() == n);
break;

case Token.GETELEM:
visitGetElem(t, n);
// The type of GETELEM is always unknown, so no point counting that.
// If that unknown leaks elsewhere (say by an assignment to another
// variable), then it will be counted.
typeable = false;
break;

case Token.VAR:
visitVar(t, n);
typeable = false;
break;

case Token.NEW:
visitNew(t, n);
break;

case Token.CALL:
visitCall(t, n);
typeable = !parent.isExprResult();
break;

case Token.RETURN:
visitReturn(t, n);
typeable = false;
break;

case Token.DEC:
case Token.INC:
left = n.getFirstChild();
checkPropCreation(t, left);
validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.NOT:
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.VOID:
ensureTyped(t, n, VOID_TYPE);
break;

case Token.TYPEOF:
ensureTyped(t, n, STRING_TYPE);
break;

case Token.BITNOT:
childType = getJSType(n.getFirstChild());
if (!childType.matchesInt32Context()) {
report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),
childType.toString());
}
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.POS:
case Token.NEG:
left = n.getFirstChild();
validator.expectNumber(t, left, getJSType(left), ""sign operator"");
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.EQ:
case Token.NE:
case Token.SHEQ:
case Token.SHNE: {
left = n.getFirstChild();
right = n.getLastChild();

if (left.isTypeOf()) {
if (right.isString()) {
checkTypeofString(t, right, right.getString());
}
} else if (right.isTypeOf() && left.isString()) {
checkTypeofString(t, left, left.getString());
}

leftType = getJSType(left);
rightType = getJSType(right);

// We do not want to warn about explicit comparisons to VOID. People
// often do this if they think their type annotations screwed up.
//
// We do want to warn about cases where people compare things like
// (Array|null) == (Function|null)
// because it probably means they screwed up.
//
// This heuristic here is not perfect, but should catch cases we
// care about without too many false negatives.
JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();

TernaryValue result = TernaryValue.UNKNOWN;
if (n.getType() == Token.EQ || n.getType() == Token.NE) {
result = leftTypeRestricted.testForEquality(rightTypeRestricted);
if (n.isNE()) {
result = result.not();
}
} else {
// SHEQ or SHNE
if (!leftTypeRestricted.canTestForShallowEqualityWith(
rightTypeRestricted)) {
result = n.getType() == Token.SHEQ ?
TernaryValue.FALSE : TernaryValue.TRUE;
}
}

if (result != TernaryValue.UNKNOWN) {
report(t, n, DETERMINISTIC_TEST, leftType.toString(),
rightType.toString(), result.toString());
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;
}

case Token.LT:
case Token.LE:
case Token.GT:
case Token.GE:
leftType = getJSType(n.getFirstChild());
rightType = getJSType(n.getLastChild());
if (rightType.isNumber()) {
validator.expectNumber(
t, n, leftType, ""left side of numeric comparison"");
} else if (leftType.isNumber()) {
validator.expectNumber(
t, n, rightType, ""right side of numeric comparison"");
} else if (leftType.matchesNumberContext() &&
rightType.matchesNumberContext()) {
// OK.
} else {
// Whether the comparison is numeric will be determined at runtime
// each time the expression is evaluated. Regardless, both operands
// should match a string context.
String message = ""left side of comparison"";
validator.expectString(t, n, leftType, message);
validator.expectNotNullOrUndefined(
t, n, leftType, message, getNativeType(STRING_TYPE));
message = ""right side of comparison"";
validator.expectString(t, n, rightType, message);
validator.expectNotNullOrUndefined(
t, n, rightType, message, getNativeType(STRING_TYPE));
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.IN:
left = n.getFirstChild();
right = n.getLastChild();
rightType = getJSType(right);
validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
validator.expectObject(t, n, rightType, ""'in' requires an object"");
if (rightType.isStruct()) {
report(t, right, IN_USED_WITH_STRUCT);
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.INSTANCEOF:
left = n.getFirstChild();
right = n.getLastChild();
rightType = getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(
t, left, getJSType(left), ""deterministic instanceof yields false"");
validator.expectActualObject(
t, right, rightType, ""instanceof requires an object"");
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.ASSIGN:
visitAssign(t, n);
typeable = false;
break;

case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_SUB:
case Token.ASSIGN_ADD:
case Token.ASSIGN_MUL:
checkPropCreation(t, n.getFirstChild());
// fall through

case Token.LSH:
case Token.RSH:
case Token.URSH:
case Token.DIV:
case Token.MOD:
case Token.BITOR:
case Token.BITXOR:
case Token.BITAND:
case Token.SUB:
case Token.ADD:
case Token.MUL:
visitBinaryOperator(n.getType(), t, n);
break;

case Token.DELPROP:
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.CASE:
JSType switchType = getJSType(parent.getFirstChild());
JSType caseType = getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t, n, switchType, caseType);
typeable = false;
break;

case Token.WITH: {
Node child = n.getFirstChild();
childType = getJSType(child);
validator.expectObject(t, child, childType, ""with requires an object"");
typeable = false;
break;
}

case Token.FUNCTION:
visitFunction(t, n);
break;

// These nodes have no interesting type behavior.
case Token.LABEL:
case Token.LABEL_NAME:
case Token.SWITCH:
case Token.BREAK:
case Token.CATCH:
case Token.TRY:
case Token.SCRIPT:
case Token.EXPR_RESULT:
case Token.BLOCK:
case Token.EMPTY:
case Token.DEFAULT_CASE:
case Token.CONTINUE:
case Token.DEBUGGER:
case Token.THROW:
typeable = false;
break;

// These nodes require data flow analysis.
case Token.DO:
case Token.IF:
case Token.WHILE:
typeable = false;
break;

case Token.FOR:
if (NodeUtil.isForIn(n)) {
Node obj = n.getChildAtIndex(1);
if (getJSType(obj).isStruct()) {
report(t, obj, IN_USED_WITH_STRUCT);
}
}
typeable = false;
break;

// These nodes are typed during the type inference.
case Token.AND:
case Token.HOOK:
case Token.OBJECTLIT:
case Token.OR:
if (n.getJSType() != null) { // If we didn't run type inference.
ensureTyped(t, n);
} else {
// If this is an enum, then give that type to the objectlit as well.
if ((n.isObjectLit())
&& (parent.getJSType() instanceof EnumType)) {
ensureTyped(t, n, parent.getJSType());
} else {
ensureTyped(t, n);
}
}
if (n.isObjectLit()) {
JSType typ = getJSType(n);
for (Node key : n.children()) {
visitObjLitKey(t, key, n, typ);
}
}
break;

default:
report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
ensureTyped(t, n);
break;
}

// Don't count externs since the user's code may not even use that part.
typeable = typeable && !inExterns;

if (typeable) {
doPercentTypedAccounting(t, n);
}

checkNoTypeCheckSection(n, false);
}"
Closure_2b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_2_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"boolean visitName(NodeTraversal t, Node n, Node parent) {
// At this stage, we need to determine whether this is a leaf
// node in an expression (which therefore needs to have a type
// assigned for it) versus some other decorative node that we
// can safely ignore.  Function names, arguments (children of LP nodes) and
// variable declarations are ignored.
// TODO(user): remove this short-circuiting in favor of a
// pre order traversal of the FUNCTION, CATCH, LP and VAR nodes.
int parentNodeType = parent.getType();
if (parentNodeType == Token.FUNCTION ||
parentNodeType == Token.CATCH ||
parentNodeType == Token.PARAM_LIST ||
parentNodeType == Token.VAR) {
return false;
}

JSType type = n.getJSType();
if (type == null) {
type = getNativeType(UNKNOWN_TYPE);
Var var = t.getScope().getVar(n.getString());
if (var != null) {
JSType varType = var.getType();
if (varType != null) {
type = varType;
}
}
}
ensureTyped(t, n, type);
return true;
}"
Closure_4b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_4_buggy/src/com/google/javascript/rhino/jstype/NamedType.java,"private void setReferencedAndResolvedType(JSType type, ErrorReporter t,
StaticScope<JSType> enclosing) {
if (validator != null) {
validator.apply(type);
}
setReferencedType(type);
checkEnumElementCycle(t);
setResolvedTypeInternal(getReferencedType());
}"
Closure_4b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_4_buggy/src/com/google/javascript/rhino/jstype/NamedType.java,"public boolean setValidator(Predicate<JSType> validator) {
// If the type is already resolved, we can validate it now. If
// the type has not been resolved yet, we need to wait till its
// resolved before we can validate it.
if (this.isResolved()) {
return super.setValidator(validator);
} else {
this.validator = validator;
return true;
}
}"
Closure_4b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_4_buggy/src/com/google/javascript/rhino/jstype/NamedType.java,"public String getReferenceName() {
return reference;
}"
Closure_4b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_4_buggy/src/com/google/javascript/rhino/jstype/NamedType.java,"JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
// TODO(user): Investigate whether it is really necessary to keep two
// different mechanisms for resolving named types, and if so, which order
// makes more sense. Now, resolution via registry is first in order to
// avoid triggering the warnings built into the resolution via properties.
boolean resolved = resolveViaRegistry(t, enclosing);
if (detectImplicitPrototypeCycle()) {
handleTypeCycle(t);
}

if (resolved) {
super.resolveInternal(t, enclosing);
finishPropertyContinuations();
return registry.isLastGeneration() ?
getReferencedType() : this;
}

resolveViaProperties(t, enclosing);
if (detectImplicitPrototypeCycle()) {
handleTypeCycle(t);
}

super.resolveInternal(t, enclosing);
if (isResolved()) {
finishPropertyContinuations();
}
return registry.isLastGeneration() ?
getReferencedType() : this;
}"
Closure_4b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_4_buggy/src/com/google/javascript/rhino/jstype/NamedType.java,"private boolean resolveViaRegistry(
ErrorReporter t, StaticScope<JSType> enclosing) {
JSType type = registry.getType(reference);
if (type != null) {
setReferencedAndResolvedType(type, t, enclosing);
return true;
}
return false;
}"
Closure_5b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_5_buggy/src/com/google/javascript/jscomp/InlineObjectLiterals.java,"InlineObjectLiterals(
AbstractCompiler compiler,"
Closure_5b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_5_buggy/src/com/google/javascript/jscomp/InlineObjectLiterals.java,"public void process(Node externs, Node root) {
ReferenceCollectingCallback callback = new ReferenceCollectingCallback(
compiler, new InliningBehavior());
callback.process(externs, root);
}"
Closure_7b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_7_buggy/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java,"JSType getRestrictedByTypeOfResult(JSType type, String value,
boolean resultEqualsValue) {
if (type == null) {
if (resultEqualsValue) {
JSType result = getNativeTypeForTypeOf(value);
return result == null ? getNativeType(CHECKED_UNKNOWN_TYPE) : result;
} else {
return null;
}
}
return type.visit(
new RestrictByOneTypeOfResultVisitor(value, resultEqualsValue));
}"
Closure_7b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_7_buggy/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java,"return typeRegistry.getNativeType(typeId);
}

/**
* If we definitely know what a type is based on the typeof result,
* return it.  Otherwise, return null.
*
* The typeof operation in JS is poorly defined, and this function works
* for both the native typeof and goog.typeOf. It should not be made public,
* because its semantics are informally defined, and would be wrong in
* the general case.
*/
private JSType getNativeTypeForTypeOf(String value) {"
Closure_7b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_7_buggy/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java,"public ChainableReverseAbstractInterpreter(CodingConvention convention,
JSTypeRegistry typeRegistry) {
Preconditions.checkNotNull(convention);
this.convention = convention;
this.typeRegistry = typeRegistry;
firstLink = this;
nextLink = null;
}"
Closure_7b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_7_buggy/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java,"protected JSType getTypeIfRefinable(Node node, FlowScope scope) {
switch (node.getType()) {
case Token.NAME:
StaticSlot<JSType> nameVar = scope.getSlot(node.getString());
if (nameVar != null) {
JSType nameVarType = nameVar.getType();
if (nameVarType == null) {
nameVarType = node.getJSType();
}
return nameVarType;
}
return null;

case Token.GETPROP:
String qualifiedName = node.getQualifiedName();
if (qualifiedName == null) {
return null;
}
StaticSlot<JSType> propVar = scope.getSlot(qualifiedName);
JSType propVarType = null;
if (propVar != null) {
propVarType = propVar.getType();
}
if (propVarType == null) {
propVarType = node.getJSType();
}
if (propVarType == null) {
propVarType = getNativeType(UNKNOWN_TYPE);
}
return propVarType;
}
return null;
}"
Closure_7b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_7_buggy/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java,"protected void declareNameInScope(FlowScope scope, Node node, JSType type) {
switch (node.getType()) {
case Token.NAME:
scope.inferSlotType(node.getString(), type);
break;

case Token.GETPROP:
String qualifiedName = node.getQualifiedName();
Preconditions.checkNotNull(qualifiedName);

JSType origType = node.getJSType();
origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;
scope.inferQualifiedSlot(node, qualifiedName, origType, type);
break;

case Token.THIS:
// ""this"" references aren't currently modeled in the CFG.
break;

default:
throw new IllegalArgumentException(""Node cannot be refined. \n"" +
node.toStringTree());
}
}"
Closure_10b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_10_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static boolean allResultsMatch(Node n, Predicate<Node> p) {
switch (n.getType()) {
case Token.ASSIGN:
case Token.COMMA:
return allResultsMatch(n.getLastChild(), p);
case Token.AND:
case Token.OR:
return allResultsMatch(n.getFirstChild(), p)
&& allResultsMatch(n.getLastChild(), p);
case Token.HOOK:
return allResultsMatch(n.getFirstChild().getNext(), p)
&& allResultsMatch(n.getLastChild(), p);
default:
return p.apply(n);
}
}"
Closure_10b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_10_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static String opToStr(int operator) {
switch (operator) {
case Token.BITOR: return ""|"";
case Token.OR: return ""||"";
case Token.BITXOR: return ""^"";
case Token.AND: return ""&&"";
case Token.BITAND: return ""&"";
case Token.SHEQ: return ""==="";
case Token.EQ: return ""=="";
case Token.NOT: return ""!"";
case Token.NE: return ""!="";
case Token.SHNE: return ""!=="";
case Token.LSH: return ""<<"";
case Token.IN: return ""in"";
case Token.LE: return ""<="";
case Token.LT: return ""<"";
case Token.URSH: return "">>>"";
case Token.RSH: return "">>"";
case Token.GE: return "">="";
case Token.GT: return "">"";
case Token.MUL: return ""*"";
case Token.DIV: return ""/"";
case Token.MOD: return ""%"";
case Token.BITNOT: return ""~"";
case Token.ADD: return ""+"";
case Token.SUB: return ""-"";
case Token.POS: return ""+"";
case Token.NEG: return ""-"";
case Token.ASSIGN: return ""="";
case Token.ASSIGN_BITOR: return ""|="";
case Token.ASSIGN_BITXOR: return ""^="";
case Token.ASSIGN_BITAND: return ""&="";
case Token.ASSIGN_LSH: return ""<<="";
case Token.ASSIGN_RSH: return "">>="";
case Token.ASSIGN_URSH: return "">>>="";
case Token.ASSIGN_ADD: return ""+="";
case Token.ASSIGN_SUB: return ""-="";
case Token.ASSIGN_MUL: return ""*="";
case Token.ASSIGN_DIV: return ""/="";
case Token.ASSIGN_MOD: return ""%="";
case Token.VOID: return ""void"";
case Token.TYPEOF: return ""typeof"";
case Token.INSTANCEOF: return ""instanceof"";
default: return null;
}
}"
Closure_10b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_10_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static Double getStringNumberValue(String rawJsString) {
if (rawJsString.contains(""\u000b"")) {
// vertical tab is not always whitespace
return null;
}

String s = trimJsWhiteSpace(rawJsString);
// return ScriptRuntime.toNumber(s);
if (s.length() == 0) {
return 0.0;
}

if (s.length() > 2
&& s.charAt(0) == '0'
&& (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {
// Attempt to convert hex numbers.
try {
return Double.valueOf(Integer.parseInt(s.substring(2), 16));
} catch (NumberFormatException e) {
return Double.NaN;
}
}

if (s.length() > 3
&& (s.charAt(0) == '-' || s.charAt(0) == '+')
&& s.charAt(1) == '0'
&& (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {
// hex numbers with explicit signs vary between browsers.
return null;
}

// Firefox and IE treat the ""Infinity"" differently. Firefox is case
// insensitive, but IE treats ""infinity"" as NaN.  So leave it alone.
if (s.equals(""infinity"")
|| s.equals(""-infinity"")
|| s.equals(""+infinity"")) {
return null;
}

try {
return Double.parseDouble(s);
} catch (NumberFormatException e) {
return Double.NaN;
}
}"
Closure_10b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_10_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static String trimJsWhiteSpace(String s) {
int start = 0;
int end = s.length();
while (end > 0
&& isStrWhiteSpaceChar(s.charAt(end - 1)) == TernaryValue.TRUE) {
end--;
}
while (start < end
&& isStrWhiteSpaceChar(s.charAt(start)) == TernaryValue.TRUE) {
start++;
}
return s.substring(start, end);
}"
Closure_10b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_10_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"public static TernaryValue isStrWhiteSpaceChar(int c) {
switch (c) {
case '\u000B': // <VT>
return TernaryValue.UNKNOWN;  // IE says ""no"", ECMAScript says ""yes""
case ' ': // <SP>
case '\n': // <LF>
case '\r': // <CR>
case '\t': // <TAB>
case '\u00A0': // <NBSP>
case '\u000C': // <FF>
case '\u2028': // <LS>
case '\u2029': // <PS>
case '\uFEFF': // <BOM>
return TernaryValue.TRUE;
default:
return (Character.getType(c) == Character.SPACE_SEPARATOR)
? TernaryValue.TRUE : TernaryValue.FALSE;
}
}"
Closure_11b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_11_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"private void visitAssign(NodeTraversal t, Node assign) {
JSDocInfo info = assign.getJSDocInfo();
Node lvalue = assign.getFirstChild();
Node rvalue = assign.getLastChild();

// Check property sets to 'object.property' when 'object' is known.
if (lvalue.isGetProp()) {
Node object = lvalue.getFirstChild();
JSType objectJsType = getJSType(object);
String property = lvalue.getLastChild().getString();

// the first name in this getprop refers to an interface
// we perform checks in addition to the ones below
if (object.isGetProp()) {
JSType jsType = getJSType(object.getFirstChild());
if (jsType.isInterface() &&
object.getLastChild().getString().equals(""prototype"")) {
visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);
}
}

checkEnumAlias(t, info, rvalue);

// Prototype assignments are special, because they actually affect
// the definition of a class. These are mostly validated
// during TypedScopeCreator, and we only look for the ""dumb"" cases here.
// object.prototype = ...;
if (property.equals(""prototype"")) {
if (objectJsType != null && objectJsType.isFunctionType()) {
FunctionType functionType = objectJsType.toMaybeFunctionType();
if (functionType.isConstructor()) {
JSType rvalueType = rvalue.getJSType();
validator.expectObject(t, rvalue, rvalueType,
OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);
return;
}
}
}

// The generic checks for 'object.property' when 'object' is known,
// and 'property' is declared on it.
// object.property = ...;
ObjectType type = ObjectType.cast(
objectJsType.restrictByNotNullOrUndefined());
if (type != null) {
if (type.hasProperty(property) &&
!type.isPropertyTypeInferred(property) &&
!propertyIsImplicitCast(type, property)) {
JSType expectedType = type.getPropertyType(property);
if (!expectedType.isUnknownType()) {
validator.expectCanAssignToPropertyOf(
t, assign, getJSType(rvalue),
expectedType, object, property);
checkPropertyInheritanceOnGetpropAssign(
t, assign, object, property, info, expectedType);
return;
}
}
}

// If we couldn't get the property type with normal object property
// lookups, then check inheritance anyway with the unknown type.
checkPropertyInheritanceOnGetpropAssign(
t, assign, object, property, info, getNativeType(UNKNOWN_TYPE));
}

// Check qualified name sets to 'object' and 'object.property'.
// This can sometimes handle cases when the type of 'object' is not known.
// e.g.,
// var obj = createUnknownType();
// /** @type {number} */ obj.foo = true;
JSType leftType = getJSType(lvalue);
if (lvalue.isQualifiedName()) {
// variable with inferred type case
JSType rvalueType = getJSType(assign.getLastChild());
Var var = t.getScope().getVar(lvalue.getQualifiedName());
if (var != null) {
if (var.isTypeInferred()) {
return;
}

if (NodeUtil.getRootOfQualifiedName(lvalue).isThis() &&
t.getScope() != var.getScope()) {
// Don't look at ""this.foo"" variables from other scopes.
return;
}

if (var.getType() != null) {
leftType = var.getType();
}
}
}

// Fall through case for arbitrary LHS and arbitrary RHS.
Node rightChild = assign.getLastChild();
JSType rightType = getJSType(rightChild);
if (validator.expectCanAssignTo(
t, assign, rightType, leftType, ""assignment"")) {
ensureTyped(t, assign, rightType);
} else {
ensureTyped(t, assign);
}
}"
Closure_11b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_11_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"public void visit(NodeTraversal t, Node n, Node parent) {
JSType childType;
JSType leftType, rightType;
Node left, right;
// To be explicitly set to false if the node is not typeable.
boolean typeable = true;

switch (n.getType()) {
case Token.NAME:
typeable = visitName(t, n, parent);
break;

case Token.PARAM_LIST:
typeable = false;
break;

case Token.COMMA:
ensureTyped(t, n, getJSType(n.getLastChild()));
break;

case Token.TRUE:
case Token.FALSE:
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.THIS:
ensureTyped(t, n, t.getScope().getTypeOfThis());
break;

case Token.NULL:
ensureTyped(t, n, NULL_TYPE);
break;

case Token.NUMBER:
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.STRING:
ensureTyped(t, n, STRING_TYPE);
break;

case Token.STRING_KEY:
typeable = false;
break;

case Token.GETTER_DEF:
case Token.SETTER_DEF:
// Object literal keys are handled with OBJECTLIT
break;

case Token.ARRAYLIT:
ensureTyped(t, n, ARRAY_TYPE);
break;

case Token.REGEXP:
ensureTyped(t, n, REGEXP_TYPE);
break;

case Token.GETPROP:
visitGetProp(t, n, parent);
typeable = !(parent.isAssign() &&
parent.getFirstChild() == n);
break;

case Token.GETELEM:
visitGetElem(t, n);
// The type of GETELEM is always unknown, so no point counting that.
// If that unknown leaks elsewhere (say by an assignment to another
// variable), then it will be counted.
typeable = false;
break;

case Token.VAR:
visitVar(t, n);
typeable = false;
break;

case Token.NEW:
visitNew(t, n);
break;

case Token.CALL:
visitCall(t, n);
typeable = !parent.isExprResult();
break;

case Token.RETURN:
visitReturn(t, n);
typeable = false;
break;

case Token.DEC:
case Token.INC:
left = n.getFirstChild();
validator.expectNumber(
t, left, getJSType(left), ""increment/decrement"");
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.NOT:
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.VOID:
ensureTyped(t, n, VOID_TYPE);
break;

case Token.TYPEOF:
ensureTyped(t, n, STRING_TYPE);
break;

case Token.BITNOT:
childType = getJSType(n.getFirstChild());
if (!childType.matchesInt32Context()) {
report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),
childType.toString());
}
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.POS:
case Token.NEG:
left = n.getFirstChild();
validator.expectNumber(t, left, getJSType(left), ""sign operator"");
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.EQ:
case Token.NE:
case Token.SHEQ:
case Token.SHNE: {
left = n.getFirstChild();
right = n.getLastChild();

if (left.isTypeOf()) {
if (right.isString()) {
checkTypeofString(t, right, right.getString());
}
} else if (right.isTypeOf() && left.isString()) {
checkTypeofString(t, left, left.getString());
}

leftType = getJSType(left);
rightType = getJSType(right);

// We do not want to warn about explicit comparisons to VOID. People
// often do this if they think their type annotations screwed up.
//
// We do want to warn about cases where people compare things like
// (Array|null) == (Function|null)
// because it probably means they screwed up.
//
// This heuristic here is not perfect, but should catch cases we
// care about without too many false negatives.
JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();

TernaryValue result = TernaryValue.UNKNOWN;
if (n.getType() == Token.EQ || n.getType() == Token.NE) {
result = leftTypeRestricted.testForEquality(rightTypeRestricted);
if (n.isNE()) {
result = result.not();
}
} else {
// SHEQ or SHNE
if (!leftTypeRestricted.canTestForShallowEqualityWith(
rightTypeRestricted)) {
result = n.getType() == Token.SHEQ ?
TernaryValue.FALSE : TernaryValue.TRUE;
}
}

if (result != TernaryValue.UNKNOWN) {
report(t, n, DETERMINISTIC_TEST, leftType.toString(),
rightType.toString(), result.toString());
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;
}

case Token.LT:
case Token.LE:
case Token.GT:
case Token.GE:
leftType = getJSType(n.getFirstChild());
rightType = getJSType(n.getLastChild());
if (rightType.isNumber()) {
validator.expectNumber(
t, n, leftType, ""left side of numeric comparison"");
} else if (leftType.isNumber()) {
validator.expectNumber(
t, n, rightType, ""right side of numeric comparison"");
} else if (leftType.matchesNumberContext() &&
rightType.matchesNumberContext()) {
// OK.
} else {
// Whether the comparison is numeric will be determined at runtime
// each time the expression is evaluated. Regardless, both operands
// should match a string context.
String message = ""left side of comparison"";
validator.expectString(t, n, leftType, message);
validator.expectNotNullOrUndefined(
t, n, leftType, message, getNativeType(STRING_TYPE));
message = ""right side of comparison"";
validator.expectString(t, n, rightType, message);
validator.expectNotNullOrUndefined(
t, n, rightType, message, getNativeType(STRING_TYPE));
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.IN:
validator.expectObject(t, n, getJSType(n.getLastChild()),
""'in' requires an object"");
left = n.getFirstChild();
validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.INSTANCEOF:
left = n.getFirstChild();
right = n.getLastChild();
rightType = getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(
t, left, getJSType(left), ""deterministic instanceof yields false"");
validator.expectActualObject(
t, right, rightType, ""instanceof requires an object"");
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.ASSIGN:
visitAssign(t, n);
typeable = false;
break;

case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_SUB:
case Token.ASSIGN_ADD:
case Token.ASSIGN_MUL:
case Token.LSH:
case Token.RSH:
case Token.URSH:
case Token.DIV:
case Token.MOD:
case Token.BITOR:
case Token.BITXOR:
case Token.BITAND:
case Token.SUB:
case Token.ADD:
case Token.MUL:
visitBinaryOperator(n.getType(), t, n);
break;

case Token.DELPROP:
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.CASE:
JSType switchType = getJSType(parent.getFirstChild());
JSType caseType = getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t, n, switchType, caseType);
typeable = false;
break;

case Token.WITH: {
Node child = n.getFirstChild();
childType = getJSType(child);
validator.expectObject(t, child, childType, ""with requires an object"");
typeable = false;
break;
}

case Token.FUNCTION:
visitFunction(t, n);
break;

// These nodes have no interesting type behavior.
case Token.LABEL:
case Token.LABEL_NAME:
case Token.SWITCH:
case Token.BREAK:
case Token.CATCH:
case Token.TRY:
case Token.SCRIPT:
case Token.EXPR_RESULT:
case Token.BLOCK:
case Token.EMPTY:
case Token.DEFAULT_CASE:
case Token.CONTINUE:
case Token.DEBUGGER:
case Token.THROW:
typeable = false;
break;

// These nodes require data flow analysis.
case Token.DO:
case Token.FOR:
case Token.IF:
case Token.WHILE:
typeable = false;
break;

// These nodes are typed during the type inference.
case Token.AND:
case Token.HOOK:
case Token.OBJECTLIT:
case Token.OR:
if (n.getJSType() != null) { // If we didn't run type inference.
ensureTyped(t, n);
} else {
// If this is an enum, then give that type to the objectlit as well.
if ((n.isObjectLit())
&& (parent.getJSType() instanceof EnumType)) {
ensureTyped(t, n, parent.getJSType());
} else {
ensureTyped(t, n);
}
}
if (n.isObjectLit()) {
for (Node key : n.children()) {
visitObjLitKey(t, key, n);
}
}
break;

default:
report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
ensureTyped(t, n);
break;
}

// Don't count externs since the user's code may not even use that part.
typeable = typeable && !inExterns;

if (typeable) {
doPercentTypedAccounting(t, n);
}

checkNoTypeCheckSection(n, false);
}"
Closure_11b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_11_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"private void visitVar(NodeTraversal t, Node n) {
// TODO(nicksantos): Fix this so that the doc info always shows up
// on the NAME node. We probably want to wait for the parser
// merge to fix this.
JSDocInfo varInfo = n.hasOneChild() ? n.getJSDocInfo() : null;
for (Node name : n.children()) {
Node value = name.getFirstChild();
// A null var would indicate a bug in the scope creation logic.
Var var = t.getScope().getVar(name.getString());

if (value != null) {
JSType valueType = getJSType(value);
JSType nameType = var.getType();
nameType = (nameType == null) ? getNativeType(UNKNOWN_TYPE) : nameType;

JSDocInfo info = name.getJSDocInfo();
if (info == null) {
info = varInfo;
}

checkEnumAlias(t, info, value);
if (var.isTypeInferred()) {
ensureTyped(t, name, valueType);
} else {
validator.expectCanAssignTo(
t, value, valueType, nameType, ""initializing variable"");
}
}
}
}"
Closure_11b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_11_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"private void doPercentTypedAccounting(NodeTraversal t, Node n) {
JSType type = n.getJSType();
if (type == null) {
nullCount++;
} else if (type.isUnknownType()) {
if (reportUnknownTypes.isOn()) {
compiler.report(
t.makeError(n, reportUnknownTypes, UNKNOWN_EXPR_TYPE));
}
unknownCount++;
} else {
typedCount++;
}
}"
Closure_11b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_11_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"public void process(Node externsRoot, Node jsRoot) {
Preconditions.checkNotNull(scopeCreator);
Preconditions.checkNotNull(topScope);

Node externsAndJs = jsRoot.getParent();
Preconditions.checkState(externsAndJs != null);
Preconditions.checkState(
externsRoot == null || externsAndJs.hasChild(externsRoot));

if (externsRoot != null) {
check(externsRoot, true);
}
check(jsRoot, false);
}"
Closure_12b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_12_buggy/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java,"Collection<Node> getUses(String name, Node defNode) {
GraphNode<Node, Branch> n = getCfg().getNode(defNode);
Preconditions.checkNotNull(n);
FlowState<ReachingUses> state = n.getAnnotation();
return state.getOut().mayUseMap.get(jsScope.getVar(name));
}"
Closure_12b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_12_buggy/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java,"MaybeReachingVariableUse(
ControlFlowGraph<Node> cfg, Scope jsScope, AbstractCompiler compiler) {
super(cfg, new ReachingUsesJoinOp());
this.jsScope = jsScope;
this.escaped = Sets.newHashSet();

// TODO(user): Maybe compute it somewhere else and re-use the escape
// local set here.
computeEscaped(jsScope, escaped, compiler);
}"
Closure_12b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_12_buggy/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java,"boolean isForward() {
return false;
}"
Closure_12b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_12_buggy/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java,"ReachingUses createEntryLattice() {
return new ReachingUses();
}"
Closure_12b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_12_buggy/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java,"ReachingUses createInitialEstimateLattice() {
return new ReachingUses();
}"
Closure_13b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_13_buggy/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java,"private void traverse(Node node) {
// The goal here is to avoid retraversing
// the entire AST to catch newly created opportunities.
// So we track whether a ""unit of code"" has changed,
// and revisit immediately.
if (!shouldVisit(node)) {
return;
}

int visits = 0;
do {
Node c = node.getFirstChild();
while(c != null) {
traverse(c);
Node next = c.getNext();
c = next;
}

visit(node);
visits++;

Preconditions.checkState(visits < 10000, ""too many interations"");
} while (shouldRetraverse(node));

exitNode(node);
}"
Closure_13b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_13_buggy/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java,"private boolean shouldVisit(Node node) {
if (node.isFunction() || node.isScript()) {
ScopeState previous = traversalState.peek();
if (!previous.traverseChildScopes) {
return false;
}
traversalState.push();
}
return true;
}"
Closure_13b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_13_buggy/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java,"public void visit(Node n) {
Node currentVersionOfNode = n;
boolean somethingChanged = false;

do {
somethingChanged = false;
for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {
Node newVersionOfNode =
optimization.optimizeSubtree(currentVersionOfNode);

if (newVersionOfNode != currentVersionOfNode) {
somethingChanged = true;

currentVersionOfNode = newVersionOfNode;
}

if (currentVersionOfNode == null) {
return;
}
}
} while(somethingChanged);
}"
Closure_13b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_13_buggy/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java,"private boolean shouldRetraverse(Node node) {
if (node.getParent() != null && node.isFunction() || node.isScript()) {
ScopeState state = traversalState.peek();
if (state.changed) {
// prepare to re-visit the scope:
// when revisiting, only visit the immediate scope
// this reduces the cost of getting to a fixed
// point in global scope.
state.changed = false;
state.traverseChildScopes = false;
return true;
}
}
return false;
}"
Closure_13b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_13_buggy/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java,"public void process(Node externs, Node root) {
PeepholeChangeHandler handler = new PeepholeChangeHandler();
compiler.addChangeHandler(handler);
beginTraversal();
traverse(root);
endTraversal();
compiler.removeChangeHandler(handler);
}"
Closure_14b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_14_buggy/src/com/google/javascript/jscomp/ControlFlowAnalysis.java,"return computeFollowNode(node, node, cfa);
}

static Node computeFollowNode(Node node) {"
Closure_14b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_14_buggy/src/com/google/javascript/jscomp/ControlFlowAnalysis.java,"private void handleBreak(Node node) {
String label = null;
// See if it is a break with label.
if (node.hasChildren()) {
label = node.getFirstChild().getString();
}
Node cur;
Node previous = null;
Node lastJump;
Node parent = node.getParent();
/*
* Continuously look up the ancestor tree for the BREAK target or the target
* with the corresponding label and connect to it. If along the path we
* discover a FINALLY, we will connect the BREAK to that FINALLY. From then
* on, we will just record the control flow changes in the finallyMap. This
* is due to the fact that we need to connect any node that leaves its own
* FINALLY block to the outer FINALLY or the BREAK's target but those nodes
* are not known yet due to the way we traverse the nodes.
*/
for (cur = node, lastJump = node;
!isBreakTarget(cur, label);
cur = parent, parent = parent.getParent()) {
if (cur.isTry() && NodeUtil.hasFinally(cur)
&& cur.getLastChild() != previous) {
if (lastJump == node) {
createEdge(lastJump, Branch.UNCOND, computeFallThrough(
cur.getLastChild()));
} else {
finallyMap.put(lastJump, computeFallThrough(cur.getLastChild()));
}
lastJump = cur;
}
if (parent == null) {
if (compiler.isIdeMode()) {
// In IDE mode, we expect that the data flow graph may
// not be well-formed.
return;
} else {
throw new IllegalStateException(""Cannot find break target."");
}
}
previous = cur;
}
if (lastJump == node) {
createEdge(lastJump, Branch.UNCOND, computeFollowNode(cur, this));
} else {
finallyMap.put(lastJump, computeFollowNode(cur, this));
}
}"
Closure_14b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_14_buggy/src/com/google/javascript/jscomp/ControlFlowAnalysis.java,"private void connectToPossibleExceptionHandler(Node cfgNode, Node target) {
if (mayThrowException(target) && !exceptionHandler.isEmpty()) {
Node lastJump = cfgNode;
for (Node handler : exceptionHandler) {
if (handler.isFunction()) {
return;
}
Preconditions.checkState(handler.isTry());
Node catchBlock = NodeUtil.getCatchBlock(handler);

if (!NodeUtil.hasCatchHandler(catchBlock)) { // No catch but a FINALLY.
if (lastJump == cfgNode) {
createEdge(cfgNode, Branch.ON_EX, handler.getLastChild());
} else {
finallyMap.put(lastJump, handler.getLastChild());
}
} else { // Has a catch.
if (lastJump == cfgNode) {
createEdge(cfgNode, Branch.ON_EX, catchBlock);
return;
} else {
finallyMap.put(lastJump, catchBlock);
}
}
lastJump = handler;
}
}
}"
Closure_14b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_14_buggy/src/com/google/javascript/jscomp/ControlFlowAnalysis.java,"private void handleStmtList(Node node) {
Node parent = node.getParent();
// Special case, don't add a block of empty CATCH block to the graph.
if (node.isBlock() && parent != null &&
parent.isTry() &&
NodeUtil.getCatchBlock(parent) == node &&
!NodeUtil.hasCatchHandler(node)) {
return;
}

// A block transfer control to its first child if it is not empty.
Node child = node.getFirstChild();

// Function declarations are skipped since control doesn't go into that
// function (unless it is called)
while (child != null && child.isFunction()) {
child = child.getNext();
}

if (child != null) {
createEdge(node, Branch.UNCOND, computeFallThrough(child));
} else {
createEdge(node, Branch.UNCOND, computeFollowNode(node, this));
}

// Synthetic blocks
if (parent != null) {
switch (parent.getType()) {
case Token.DEFAULT_CASE:
case Token.CASE:
case Token.TRY:
break;
default:
if (node.isBlock() && node.isSyntheticBlock()) {
createEdge(node, Branch.SYN_BLOCK, computeFollowNode(node, this));
}
break;
}
}
}"
Closure_14b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_14_buggy/src/com/google/javascript/jscomp/ControlFlowAnalysis.java,"private void handleIf(Node node) {
Node thenBlock = node.getFirstChild().getNext();
Node elseBlock = thenBlock.getNext();
createEdge(node, Branch.ON_TRUE, computeFallThrough(thenBlock));

if (elseBlock == null) {
createEdge(node, Branch.ON_FALSE,
computeFollowNode(node, this)); // not taken branch
} else {
createEdge(node, Branch.ON_FALSE, computeFallThrough(elseBlock));
}
connectToPossibleExceptionHandler(
node, NodeUtil.getConditionExpression(node));
}"
Closure_15b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_15_buggy/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java,"public void enterScope(NodeTraversal t) {

if (t.inGlobalScope()) {
return; // Don't even brother. All global variables are likely escaped.
}

if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <
t.getScope().getVarCount()) {
return;
}

// Compute the forward reaching definition.
ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);
// Process the body of the function.
Preconditions.checkState(t.getScopeRoot().isFunction());
cfa.process(null, t.getScopeRoot().getLastChild());
cfg = cfa.getCfg();
reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);
reachingDef.analyze();
candidates = Lists.newLinkedList();

// Using the forward reaching definition search to find all the inline
// candidates
new NodeTraversal(compiler, new GatherCandiates()).traverse(
t.getScopeRoot().getLastChild());

// Compute the backward reaching use. The CFG can be reused.
reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);
reachingUses.analyze();
for (Candidate c : candidates) {
if (c.canInline()) {
c.inlineVariable();
}
}
}"
Closure_15b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_15_buggy/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java,"private static boolean checkRightOf(
Node n, Node expressionRoot, Predicate<Node> predicate) {
for (Node p = n; p != expressionRoot; p = p.getParent()) {
for (Node cur = p.getNext(); cur != null; cur = cur.getNext()) {
if (predicate.apply(cur)) {
return true;
}
}
}
return false;
}"
Closure_15b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_15_buggy/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java,"private static boolean checkLeftOf(
Node n, Node expressionRoot, Predicate<Node> predicate) {
for (Node p = n.getParent(); p != expressionRoot; p = p.getParent()) {
for (Node cur = p.getParent().getFirstChild(); cur != p;
cur = cur.getNext()) {
if (predicate.apply(cur)) {
return true;
}
}
}
return false;
}"
Closure_15b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_15_buggy/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java,"public FlowSensitiveInlineVariables(AbstractCompiler compiler) {
this.compiler = compiler;
}"
Closure_15b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_15_buggy/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java,public void exitScope(NodeTraversal t) {}
Closure_17b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_17_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"public Scope createScope(Node root, Scope parent) {
// Constructing the global scope is very different than constructing
// inner scopes, because only global scopes can contain named classes that
// show up in the type registry.
Scope newScope = null;
AbstractScopeBuilder scopeBuilder = null;
if (parent == null) {
// Run a first-order analysis over the syntax tree.
(new FirstOrderFunctionAnalyzer(compiler, functionAnalysisResults))
.process(root.getFirstChild(), root.getLastChild());

// Find all the classes in the global scope.
newScope = createInitialScope(root);

GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);
scopeBuilder = globalScopeBuilder;
NodeTraversal.traverse(compiler, root, scopeBuilder);
} else {
newScope = new Scope(parent, root);
LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);
scopeBuilder = localScopeBuilder;
localScopeBuilder.build();
}

scopeBuilder.resolveStubDeclarations();
scopeBuilder.resolveTypes();

// Gather the properties in each function that we found in the
// global scope, if that function has a @this type that we can
// build properties on.
for (Node functionNode : scopeBuilder.nonExternFunctions) {
JSType type = functionNode.getJSType();
if (type != null && type.isFunctionType()) {
FunctionType fnType = type.toMaybeFunctionType();
ObjectType fnThisType = fnType.getTypeOfThis();
if (!fnThisType.isUnknownType()) {
NodeTraversal.traverse(compiler, functionNode.getLastChild(),
scopeBuilder.new CollectProperties(fnThisType));
}
}
}

if (parent == null) {
codingConvention.defineDelegateProxyPrototypeProperties(
typeRegistry, newScope, delegateProxyPrototypes,
delegateCallingConventions);
}
return newScope;
}"
Closure_17b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_17_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"private AstFunctionContents getFunctionAnalysisResults(@Nullable Node n) {
if (n == null) {
return null;
}

// Sometimes this will return null in things like
// NameReferenceGraphConstruction that build partial scopes.
return functionAnalysisResults.get(n);
}"
Closure_17b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_17_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"return typeRegistry.getNativeType(nativeType);
}

private abstract class AbstractScopeBuilder
implements NodeTraversal.Callback {"
Closure_17b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_17_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"Scope createInitialScope(Node root) {

NodeTraversal.traverse(
compiler, root, new DiscoverEnumsAndTypedefs(typeRegistry));

Scope s = new Scope(root, compiler);
declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE);
declareNativeFunctionType(s, BOOLEAN_OBJECT_FUNCTION_TYPE);
declareNativeFunctionType(s, DATE_FUNCTION_TYPE);
declareNativeFunctionType(s, ERROR_FUNCTION_TYPE);
declareNativeFunctionType(s, EVAL_ERROR_FUNCTION_TYPE);
declareNativeFunctionType(s, FUNCTION_FUNCTION_TYPE);
declareNativeFunctionType(s, NUMBER_OBJECT_FUNCTION_TYPE);
declareNativeFunctionType(s, OBJECT_FUNCTION_TYPE);
declareNativeFunctionType(s, RANGE_ERROR_FUNCTION_TYPE);
declareNativeFunctionType(s, REFERENCE_ERROR_FUNCTION_TYPE);
declareNativeFunctionType(s, REGEXP_FUNCTION_TYPE);
declareNativeFunctionType(s, STRING_OBJECT_FUNCTION_TYPE);
declareNativeFunctionType(s, SYNTAX_ERROR_FUNCTION_TYPE);
declareNativeFunctionType(s, TYPE_ERROR_FUNCTION_TYPE);
declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE);
declareNativeValueType(s, ""undefined"", VOID_TYPE);

// ActiveXObject is uniquely special, because it can be used to construct
// any type (the type that it creates is related to the arguments you
// pass to it).
declareNativeValueType(s, ""ActiveXObject"", NO_OBJECT_TYPE);

return s;
}"
Closure_17b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_17_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"private void declareNativeFunctionType(Scope scope, JSTypeNative tId) {
FunctionType t = typeRegistry.getNativeFunctionType(tId);
declareNativeType(scope, t.getInstanceType().getReferenceName(), t);
declareNativeType(
scope, t.getPrototype().getReferenceName(), t.getPrototype());
}"
Closure_18b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_18_buggy/src/com/google/javascript/jscomp/Compiler.java,"public <T extends SourceFile> void initModules(
List<T> externs, List<JSModule> modules, CompilerOptions options) {
initOptions(options);

checkFirstModule(modules);
fillEmptyModules(modules);

this.externs = makeCompilerInput(externs, true);

// Generate the module graph, and report any errors in the module
// specification as errors.
this.modules = modules;
if (modules.size() > 1) {
try {
this.moduleGraph = new JSModuleGraph(modules);
} catch (JSModuleGraph.ModuleDependenceException e) {
// problems with the module format.  Report as an error.  The
// message gives all details.
report(JSError.make(MODULE_DEPENDENCY_ERROR,
e.getModule().getName(), e.getDependentModule().getName()));
return;
}
} else {
this.moduleGraph = null;
}

this.inputs = getAllInputsFromModules(modules);
initBasedOnOptions();

initInputsByIdMap();
}"
Closure_18b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_18_buggy/src/com/google/javascript/jscomp/Compiler.java,"CompilerInput getSynthesizedExternsInput() {
if (synthesizedExternsInput == null) {
synthesizedExternsInput = newExternInput(SYNTHETIC_EXTERNS);
}
return synthesizedExternsInput;
}"
Closure_18b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_18_buggy/src/com/google/javascript/jscomp/Compiler.java,"public CompilerInput newExternInput(String name) {
SourceAst ast = new SyntheticAst(name);
if (inputsById.containsKey(ast.getInputId())) {
throw new IllegalArgumentException(""Conflicting externs name: "" + name);
}
CompilerInput input = new CompilerInput(ast, true);
putCompilerInput(input.getInputId(), input);
externsRoot.addChildToFront(ast.getAstRoot(this));
externs.add(0, input);
return input;
}"
Closure_18b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_18_buggy/src/com/google/javascript/jscomp/Compiler.java,"public void report(JSError error) {
CheckLevel level = error.getDefaultLevel();
if (warningsGuard != null) {
CheckLevel newLevel = warningsGuard.level(error);
if (newLevel != null) {
level = newLevel;
}
}

if (level.isOn()) {
if (getOptions().errorHandler != null) {
getOptions().errorHandler.report(level, error);
}
errorManager.report(level, error);
}
}"
Closure_18b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_18_buggy/src/com/google/javascript/jscomp/Compiler.java,"boolean hasRegExpGlobalReferences() {
return hasRegExpGlobalReferences;
}"
Closure_19b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_19_buggy/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java,"protected void declareNameInScope(FlowScope scope, Node node, JSType type) {
switch (node.getType()) {
case Token.NAME:
scope.inferSlotType(node.getString(), type);
break;

case Token.GETPROP:
String qualifiedName = node.getQualifiedName();
Preconditions.checkNotNull(qualifiedName);

JSType origType = node.getJSType();
origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;
scope.inferQualifiedSlot(node, qualifiedName, origType, type);
break;

// ""this"" references aren't currently modeled in the CFG.

default:
throw new IllegalArgumentException(""Node cannot be refined. \n"" +
node.toStringTree());
}
}"
Closure_19b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_19_buggy/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java,"return typeRegistry.getNativeType(typeId);
}

/**
* If we definitely know what a type is based on the typeof result,
* return it.  Otherwise, return null.
*
* The typeof operation in JS is poorly defined, and this function works
* for both the native typeof and goog.typeOf. It should not be made public,
* because its semantics are informally defined, and would be wrong in
* the general case.
*/
private JSType getNativeTypeForTypeOf(String value) {"
Closure_19b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_19_buggy/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java,"protected JSType getTypeIfRefinable(Node node, FlowScope scope) {
switch (node.getType()) {
case Token.NAME:
StaticSlot<JSType> nameVar = scope.getSlot(node.getString());
if (nameVar != null) {
JSType nameVarType = nameVar.getType();
if (nameVarType == null) {
nameVarType = node.getJSType();
}
return nameVarType;
}
return null;

case Token.GETPROP:
String qualifiedName = node.getQualifiedName();
if (qualifiedName == null) {
return null;
}
StaticSlot<JSType> propVar = scope.getSlot(qualifiedName);
JSType propVarType = null;
if (propVar != null) {
propVarType = propVar.getType();
}
if (propVarType == null) {
propVarType = node.getJSType();
}
if (propVarType == null) {
propVarType = getNativeType(UNKNOWN_TYPE);
}
return propVarType;
}
return null;
}"
Closure_19b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_19_buggy/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java,"public ChainableReverseAbstractInterpreter(CodingConvention convention,
JSTypeRegistry typeRegistry) {
Preconditions.checkNotNull(convention);
this.convention = convention;
this.typeRegistry = typeRegistry;
firstLink = this;
nextLink = null;
}"
Closure_19b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_19_buggy/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java,"public ChainableReverseAbstractInterpreter append(
ChainableReverseAbstractInterpreter lastLink) {
Preconditions.checkArgument(lastLink.nextLink == null);
this.nextLink = lastLink;
lastLink.firstLink = this.firstLink;
return lastLink;
}"
Closure_20b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_20_buggy/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,"private Node tryFoldSimpleFunctionCall(Node n) {
Preconditions.checkState(n.isCall());
Node callTarget = n.getFirstChild();
if (callTarget != null && callTarget.isName() &&
callTarget.getString().equals(""String"")) {
// Fold String(a) to '' + (a) on immutable literals,
// which allows further optimizations
//
// We can't do this in the general case, because String(a) has
// slightly different semantics than '' + (a). See
// http://code.google.com/p/closure-compiler/issues/detail?id=759
Node value = callTarget.getNext();
if (value != null) {
Node addition = IR.add(
IR.string("""").srcref(callTarget),
value.detachFromParent());
n.getParent().replaceChild(n, addition);
reportCodeChange();
return addition;
}
}
return n;
}"
Closure_20b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_20_buggy/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,"private Node tryFoldLiteralConstructor(Node n) {
Preconditions.checkArgument(n.isCall()
|| n.isNew());

Node constructorNameNode = n.getFirstChild();

Node newLiteralNode = null;

// We require the AST to be normalized to ensure that, say,
// Object() really refers to the built-in Object constructor
// and not a user-defined constructor with the same name.

if (isASTNormalized() && Token.NAME == constructorNameNode.getType()) {

String className = constructorNameNode.getString();

if (""RegExp"".equals(className)) {
// ""RegExp(""boo"", ""g"")"" --> /boo/g
return tryFoldRegularExpressionConstructor(n);
} else {
boolean constructorHasArgs = constructorNameNode.getNext() != null;

if (""Object"".equals(className) && !constructorHasArgs) {
// ""Object()"" --> ""{}""
newLiteralNode = IR.objectlit();
} else if (""Array"".equals(className)) {
// ""Array(arg0, arg1, ...)"" --> ""[arg0, arg1, ...]""
Node arg0 = constructorNameNode.getNext();
FoldArrayAction action = isSafeToFoldArrayConstructor(arg0);

if (action == FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS ||
action == FoldArrayAction.SAFE_TO_FOLD_WITHOUT_ARGS) {
newLiteralNode = IR.arraylit();
n.removeChildren();
if (action == FoldArrayAction.SAFE_TO_FOLD_WITH_ARGS) {
newLiteralNode.addChildrenToFront(arg0);
}
}
}

if (newLiteralNode != null) {
n.getParent().replaceChild(n, newLiteralNode);
reportCodeChange();
return newLiteralNode;
}
}
}
return n;
}"
Closure_20b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_20_buggy/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,"public Node optimizeSubtree(Node node) {
switch(node.getType()) {
case Token.RETURN: {
Node result = tryRemoveRedundantExit(node);
if (result != node) {
return result;
}
result = tryReplaceExitWithBreak(node);
if (result != node) {
return result;
}
return tryReduceReturn(node);
}

case Token.THROW: {
Node result = tryRemoveRedundantExit(node);
if (result != node) {
return result;
}
return tryReplaceExitWithBreak(node);
}

// TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps
// with MinimizeExitPoints.

case Token.NOT:
tryMinimizeCondition(node.getFirstChild());
return tryMinimizeNot(node);

case Token.IF:
tryMinimizeCondition(node.getFirstChild());
return tryMinimizeIf(node);

case Token.EXPR_RESULT:
tryMinimizeCondition(node.getFirstChild());
return node;

case Token.HOOK:
tryMinimizeCondition(node.getFirstChild());
return node;

case Token.WHILE:
case Token.DO:
tryMinimizeCondition(NodeUtil.getConditionExpression(node));
return node;

case Token.FOR:
if (!NodeUtil.isForIn(node)) {
tryJoinForCondition(node);
tryMinimizeCondition(NodeUtil.getConditionExpression(node));
}
return node;

case Token.TRUE:
case Token.FALSE:
return reduceTrueFalse(node);

case Token.NEW:
node = tryFoldStandardConstructors(node);
if (!node.isCall()) {
return node;
}
// Fall through on purpose because tryFoldStandardConstructors() may
// convert a NEW node into a CALL node
case Token.CALL:
Node result =  tryFoldLiteralConstructor(node);
if (result == node) {
result = tryFoldSimpleFunctionCall(node);
if (result == node) {
result = tryFoldImmediateCallToBoundFunction(node);
}
}
return result;

case Token.COMMA:
return trySplitComma(node);

case Token.NAME:
return tryReplaceUndefined(node);

case Token.BLOCK:
return tryReplaceIf(node);

case Token.ARRAYLIT:
return tryMinimizeArrayLiteral(node);

default:
return node; //Nothing changed
}
}"
Closure_20b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_20_buggy/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,"private Node tryFoldImmediateCallToBoundFunction(Node n) {
// Rewriting ""(fn.bind(a,b))()"" to ""fn.call(a,b)"" makes it inlinable
Preconditions.checkState(n.isCall());
Node callTarget = n.getFirstChild();
Bind bind = getCodingConvention().describeFunctionBind(callTarget, false);
if (bind != null) {
// replace the call target
bind.target.detachFromParent();
n.replaceChild(callTarget, bind.target);
callTarget = bind.target;

// push the parameters
addParameterAfter(bind.parameters, callTarget);

// add the this value before the parameters if necessary
if (bind.thisValue != null && !NodeUtil.isUndefined(bind.thisValue)) {
// rewrite from ""fn(a, b)"" to ""fn.call(thisValue, a, b)""
Node newCallTarget = IR.getprop(
callTarget.cloneTree(),
IR.string(""call"").srcref(callTarget));
n.replaceChild(callTarget, newCallTarget);
n.addChildAfter(bind.thisValue.cloneTree(), newCallTarget);
n.putBooleanProp(Node.FREE_CALL, false);
} else {
n.putBooleanProp(Node.FREE_CALL, true);
}
reportCodeChange();
}
return n;
}"
Closure_20b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_20_buggy/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,"private Node tryReplaceUndefined(Node n) {
// TODO(johnlenz): consider doing this as a normalization.
if (isASTNormalized()
&& NodeUtil.isUndefined(n)
&& !NodeUtil.isLValue(n)) {
Node replacement = NodeUtil.newUndefinedNode(n);
n.getParent().replaceChild(n, replacement);
reportCodeChange();
return replacement;
}
return n;
}"
Closure_21b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_21_buggy/src/com/google/javascript/jscomp/CheckSideEffects.java,"public void visit(NodeTraversal t, Node n, Node parent) {
// VOID nodes appear when there are extra semicolons at the BLOCK level.
// I've been unable to think of any cases where this indicates a bug,
// and apparently some people like keeping these semicolons around,
// so we'll allow it.
if (n.isEmpty() ||
n.isComma()) {
return;
}

if (parent == null) {
return;
}

// Do not try to remove a block or an expr result. We already handle
// these cases when we visit the child, and the peephole passes will
// fix up the tree in more clever ways when these are removed.
if (n.isExprResult()) {
return;
}

// This no-op statement was there so that JSDoc information could
// be attached to the name. This check should not complain about it.
if (n.isQualifiedName() && n.getJSDocInfo() != null) {
return;
}

boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
if (parent.getType() == Token.COMMA) {
if (isResultUsed) {
return;
}
if (n == parent.getLastChild()) {
for (Node an : parent.getAncestors()) {
int ancestorType = an.getType();
if (ancestorType == Token.COMMA) continue;
if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;
else break;
}
}
} else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
return;
}
}
if (
(isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
String msg = ""This code lacks side-effects. Is there a bug?"";
if (n.isString()) {
msg = ""Is there a missing '+' on the previous line?"";
} else if (isSimpleOp) {
msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
""' operator is not being used."";
}

t.getCompiler().report(
t.makeError(n, level, USELESS_CODE_ERROR, msg));
// TODO(johnlenz): determine if it is necessary to
// try to protect side-effect free statements as well.
if (!NodeUtil.isStatement(n)) {
problemNodes.add(n);
}
}
}"
Closure_21b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_21_buggy/src/com/google/javascript/jscomp/CheckSideEffects.java,"public void process(Node externs, Node root) {
NodeTraversal.traverse(compiler, root, this);

// Code with hidden side-effect code is common, for example
// accessing ""el.offsetWidth"" forces a reflow in browsers, to allow this
// will still allowing local dead code removal in general,
// protect the ""side-effect free"" code in the source.
//
if (protectSideEffectFreeCode) {
protectSideEffects();
}
}"
Closure_21b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_21_buggy/src/com/google/javascript/jscomp/CheckSideEffects.java,"private void protectSideEffects() {
if (!problemNodes.isEmpty()) {
addExtern();
for (Node n : problemNodes) {
Node name = IR.name(PROTECTOR_FN).srcref(n);
name.putBooleanProp(Node.IS_CONSTANT_NAME, true);
Node replacement = IR.call(name).srcref(n);
replacement.putBooleanProp(Node.FREE_CALL, true);
n.getParent().replaceChild(n, replacement);
replacement.addChildToBack(n);
}
compiler.reportCodeChange();
}
}"
Closure_21b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_21_buggy/src/com/google/javascript/jscomp/CheckSideEffects.java,"private void addExtern() {
Node name = IR.name(PROTECTOR_FN);
name.putBooleanProp(Node.IS_CONSTANT_NAME, true);
Node var = IR.var(name);
// Add ""@noalias"" so we can strip the method when AliasExternals is enabled.
JSDocInfoBuilder builder = new JSDocInfoBuilder(false);
builder.recordNoAlias();
var.setJSDocInfo(builder.build(var));
CompilerInput input = compiler.getSynthesizedExternsInput();
input.getAstRoot(compiler).addChildrenToBack(var);
compiler.reportCodeChange();
}"
Closure_22b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_22_buggy/src/com/google/javascript/jscomp/CheckSideEffects.java,"public void visit(NodeTraversal t, Node n, Node parent) {
// VOID nodes appear when there are extra semicolons at the BLOCK level.
// I've been unable to think of any cases where this indicates a bug,
// and apparently some people like keeping these semicolons around,
// so we'll allow it.
if (n.isEmpty() ||
n.isComma()) {
return;
}

if (parent == null) {
return;
}

// Do not try to remove a block or an expr result. We already handle
// these cases when we visit the child, and the peephole passes will
// fix up the tree in more clever ways when these are removed.
if (parent.getType() == Token.COMMA) {
Node gramps = parent.getParent();
if (gramps.isCall() && parent == gramps.getFirstChild()) {
if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
return;
}
}

// This no-op statement was there so that JSDoc information could
// be attached to the name. This check should not complain about it.
if (n == parent.getLastChild()) {
for (Node an : parent.getAncestors()) {
int ancestorType = an.getType();
if (ancestorType == Token.COMMA)
continue;
if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)
return;
else
break;
}
}
} else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||
n == parent.getFirstChild().getNext().getNext())) {
} else {
return;
}
}

boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
if (!isResultUsed &&
(isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
if (n.isQualifiedName() && n.getJSDocInfo() != null) {
return;
} else if (n.isExprResult()) {
return;
}
String msg = ""This code lacks side-effects. Is there a bug?"";
if (n.isString()) {
msg = ""Is there a missing '+' on the previous line?"";
} else if (isSimpleOp) {
msg = ""The result of the '"" + Token.name(n.getType()).toLowerCase() +
""' operator is not being used."";
}

t.getCompiler().report(
t.makeError(n, level, USELESS_CODE_ERROR, msg));
// TODO(johnlenz): determine if it is necessary to
// try to protect side-effect free statements as well.
if (!NodeUtil.isStatement(n)) {
problemNodes.add(n);
}
}
}"
Closure_22b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_22_buggy/src/com/google/javascript/jscomp/CheckSideEffects.java,"public void process(Node externs, Node root) {
NodeTraversal.traverse(compiler, root, this);

// Code with hidden side-effect code is common, for example
// accessing ""el.offsetWidth"" forces a reflow in browsers, to allow this
// will still allowing local dead code removal in general,
// protect the ""side-effect free"" code in the source.
//
if (protectSideEffectFreeCode) {
protectSideEffects();
}
}"
Closure_22b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_22_buggy/src/com/google/javascript/jscomp/CheckSideEffects.java,"private void protectSideEffects() {
if (!problemNodes.isEmpty()) {
addExtern();
for (Node n : problemNodes) {
Node name = IR.name(PROTECTOR_FN).srcref(n);
name.putBooleanProp(Node.IS_CONSTANT_NAME, true);
Node replacement = IR.call(name).srcref(n);
replacement.putBooleanProp(Node.FREE_CALL, true);
n.getParent().replaceChild(n, replacement);
replacement.addChildToBack(n);
}
compiler.reportCodeChange();
}
}"
Closure_22b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_22_buggy/src/com/google/javascript/jscomp/CheckSideEffects.java,"private void addExtern() {
Node name = IR.name(PROTECTOR_FN);
name.putBooleanProp(Node.IS_CONSTANT_NAME, true);
Node var = IR.var(name);
// Add ""@noalias"" so we can strip the method when AliasExternals is enabled.
JSDocInfoBuilder builder = new JSDocInfoBuilder(false);
builder.recordNoAlias();
var.setJSDocInfo(builder.build(var));
CompilerInput input = compiler.getSynthesizedExternsInput();
input.getAstRoot(compiler).addChildrenToBack(var);
compiler.reportCodeChange();
}"
Closure_23b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_23_buggy/src/com/google/javascript/jscomp/PeepholeFoldConstants.java,"private Node tryFoldArrayAccess(Node n, Node left, Node right) {
Node parent = n.getParent();
// If GETPROP/GETELEM is used as assignment target the array literal is
// acting as a temporary we can't fold it here:
//    ""[][0] += 1""
if (isAssignmentTarget(n)) {
return n;
}

if (!right.isNumber()) {
// Sometimes people like to use complex expressions to index into
// arrays, or strings to index into array methods.
return n;
}

double index = right.getDouble();
int intIndex = (int) index;
if (intIndex != index) {
error(INVALID_GETELEM_INDEX_ERROR, right);
return n;
}

if (intIndex < 0) {
error(INDEX_OUT_OF_BOUNDS_ERROR, right);
return n;
}

Node current = left.getFirstChild();
Node elem = null;
for (int i = 0; current != null && i < intIndex; i++) {
elem = current;

current = current.getNext();
}

if (elem == null) {
error(INDEX_OUT_OF_BOUNDS_ERROR, right);
return n;
}

if (elem.isEmpty()) {
elem = NodeUtil.newUndefinedNode(elem);
} else {
left.removeChild(elem);
}

// Replace the entire GETELEM with the value
n.getParent().replaceChild(n, elem);
reportCodeChange();
return elem;
}"
Closure_23b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_23_buggy/src/com/google/javascript/jscomp/PeepholeFoldConstants.java,"private Node tryFoldGetElem(Node n, Node left, Node right) {
Preconditions.checkArgument(n.isGetElem());

if (left.isObjectLit()) {
return tryFoldObjectPropAccess(n, left, right);
}

if (left.isArrayLit()) {
return tryFoldArrayAccess(n, left, right);
}
return n;
}"
Closure_23b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_23_buggy/src/com/google/javascript/jscomp/PeepholeFoldConstants.java,"private Node tryFoldBinaryOperator(Node subtree) {
Node left = subtree.getFirstChild();

if (left == null) {
return subtree;
}

Node right = left.getNext();

if (right == null) {
return subtree;
}

// If we've reached here, node is truly a binary operator.
switch(subtree.getType()) {
case Token.GETPROP:
return tryFoldGetProp(subtree, left, right);

case Token.GETELEM:
return tryFoldGetElem(subtree, left, right);

case Token.INSTANCEOF:
return tryFoldInstanceof(subtree, left, right);

case Token.AND:
case Token.OR:
return tryFoldAndOr(subtree, left, right);

case Token.LSH:
case Token.RSH:
case Token.URSH:
return tryFoldShift(subtree, left, right);

case Token.ASSIGN:
return tryFoldAssign(subtree, left, right);

case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_ADD:
case Token.ASSIGN_SUB:
case Token.ASSIGN_MUL:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
return tryUnfoldAssignOp(subtree, left, right);

case Token.ADD:
return tryFoldAdd(subtree, left, right);

case Token.SUB:
case Token.DIV:
case Token.MOD:
return tryFoldArithmeticOp(subtree, left, right);

case Token.MUL:
case Token.BITAND:
case Token.BITOR:
case Token.BITXOR:
Node result = tryFoldArithmeticOp(subtree, left, right);
if (result != subtree) {
return result;
}
return tryFoldLeftChildOp(subtree, left, right);

case Token.LT:
case Token.GT:
case Token.LE:
case Token.GE:
case Token.EQ:
case Token.NE:
case Token.SHEQ:
case Token.SHNE:
return tryFoldComparison(subtree, left, right);

default:
return subtree;
}
}"
Closure_23b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_23_buggy/src/com/google/javascript/jscomp/PeepholeFoldConstants.java,"private boolean isAssignmentTarget(Node n) {
Node parent = n.getParent();
if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)
|| parent.isInc()
|| parent.isDec()) {
// If GETPROP/GETELEM is used as assignment target the object literal is
// acting as a temporary we can't fold it here:
//    ""{a:x}.a += 1"" is not ""x += 1""
return true;
}
return false;
}"
Closure_23b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_23_buggy/src/com/google/javascript/jscomp/PeepholeFoldConstants.java,"private Node tryFoldAssign(Node n, Node left, Node right) {
Preconditions.checkArgument(n.isAssign());

if (!late) {
return n;
}

// Tries to convert x = x + y -> x += y;
if (!right.hasChildren() ||
right.getFirstChild().getNext() != right.getLastChild()) {
// RHS must have two children.
return n;
}

if (mayHaveSideEffects(left)) {
return n;
}

Node newRight;
if (areNodesEqualForInlining(left, right.getFirstChild())) {
newRight = right.getLastChild();
} else if (NodeUtil.isCommutative(right.getType()) &&
areNodesEqualForInlining(left, right.getLastChild())) {
newRight = right.getFirstChild();
} else {
return n;
}

int newType = -1;
switch (right.getType()) {
case Token.ADD:
newType = Token.ASSIGN_ADD;
break;
case Token.BITAND:
newType = Token.ASSIGN_BITAND;
break;
case Token.BITOR:
newType = Token.ASSIGN_BITOR;
break;
case Token.BITXOR:
newType = Token.ASSIGN_BITXOR;
break;
case Token.DIV:
newType = Token.ASSIGN_DIV;
break;
case Token.LSH:
newType = Token.ASSIGN_LSH;
break;
case Token.MOD:
newType = Token.ASSIGN_MOD;
break;
case Token.MUL:
newType = Token.ASSIGN_MUL;
break;
case Token.RSH:
newType = Token.ASSIGN_RSH;
break;
case Token.SUB:
newType = Token.ASSIGN_SUB;
break;
case Token.URSH:
newType = Token.ASSIGN_URSH;
break;
default:
return n;
}

Node newNode = new Node(newType,
left.detachFromParent(), newRight.detachFromParent());
n.getParent().replaceChild(n, newNode);

reportCodeChange();

return newNode;
}"
Closure_24b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_24_buggy/src/com/google/javascript/jscomp/ScopedAliases.java,"public void hotSwapScript(Node root, Node originalRoot) {
Traversal traversal = new Traversal();
NodeTraversal.traverse(compiler, root, traversal);

if (!traversal.hasErrors()) {

// Apply the aliases.
for (AliasUsage aliasUsage : traversal.getAliasUsages()) {
aliasUsage.applyAlias();
}

// Remove the alias definitions.
for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) {
if (aliasDefinition.getParent().isVar() &&
aliasDefinition.getParent().hasOneChild()) {
aliasDefinition.getParent().detachFromParent();
} else {
aliasDefinition.detachFromParent();
}
}

// Collapse the scopes.
for (Node scopeCall : traversal.getScopeCalls()) {
Node expressionWithScopeCall = scopeCall.getParent();
Node scopeClosureBlock = scopeCall.getLastChild().getLastChild();
scopeClosureBlock.detachFromParent();
expressionWithScopeCall.getParent().replaceChild(
expressionWithScopeCall,
scopeClosureBlock);
NodeUtil.tryMergeBlock(scopeClosureBlock);
}

if (traversal.getAliasUsages().size() > 0 ||
traversal.getAliasDefinitionsInOrder().size() > 0 ||
traversal.getScopeCalls().size() > 0) {
compiler.reportCodeChange();
}
}
}"
Closure_24b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_24_buggy/src/com/google/javascript/jscomp/ScopedAliases.java,"public void process(Node externs, Node root) {
hotSwapScript(root, null);
}"
Closure_25b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_25_buggy/src/com/google/javascript/jscomp/TypeInference.java,"private FlowScope traverseNew(Node n, FlowScope scope) {

Node constructor = n.getFirstChild();
scope = traverse(constructor, scope);
JSType constructorType = constructor.getJSType();
JSType type = null;
if (constructorType != null) {
constructorType = constructorType.restrictByNotNullOrUndefined();
if (constructorType.isUnknownType()) {
type = getNativeType(UNKNOWN_TYPE);
} else {
FunctionType ct = constructorType.toMaybeFunctionType();
if (ct == null && constructorType instanceof FunctionType) {
// If constructorType is a NoObjectType, then toMaybeFunctionType will
// return null. But NoObjectType implements the FunctionType
// interface, precisely because it can validly construct objects.
ct = (FunctionType) constructorType;
}
if (ct != null && ct.isConstructor()) {
type = ct.getInstanceType();
}
}
}
n.setJSType(type);
for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
scope = traverse(arg, scope);
}
return scope;
}"
Closure_25b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_25_buggy/src/com/google/javascript/jscomp/TypeInference.java,"private FlowScope traverse(Node n, FlowScope scope) {
switch (n.getType()) {
case Token.ASSIGN:
scope = traverseAssign(n, scope);
break;

case Token.NAME:
scope = traverseName(n, scope);
break;

case Token.GETPROP:
scope = traverseGetProp(n, scope);
break;

case Token.AND:
scope = traverseAnd(n, scope).getJoinedFlowScope()
.createChildFlowScope();
break;

case Token.OR:
scope = traverseOr(n, scope).getJoinedFlowScope()
.createChildFlowScope();
break;

case Token.HOOK:
scope = traverseHook(n, scope);
break;

case Token.OBJECTLIT:
scope = traverseObjectLiteral(n, scope);
break;

case Token.CALL:
scope = traverseCall(n, scope);
break;

case Token.NEW:
scope = traverseNew(n, scope);
break;

case Token.ASSIGN_ADD:
case Token.ADD:
scope = traverseAdd(n, scope);
break;

case Token.POS:
case Token.NEG:
scope = traverse(n.getFirstChild(), scope);  // Find types.
n.setJSType(getNativeType(NUMBER_TYPE));
break;

case Token.ARRAYLIT:
scope = traverseArrayLiteral(n, scope);
break;

case Token.THIS:
n.setJSType(scope.getTypeOfThis());
break;

case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.LSH:
case Token.RSH:
case Token.ASSIGN_URSH:
case Token.URSH:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_MUL:
case Token.ASSIGN_SUB:
case Token.DIV:
case Token.MOD:
case Token.BITAND:
case Token.BITXOR:
case Token.BITOR:
case Token.MUL:
case Token.SUB:
case Token.DEC:
case Token.INC:
case Token.BITNOT:
scope = traverseChildren(n, scope);
n.setJSType(getNativeType(NUMBER_TYPE));
break;

case Token.PARAM_LIST:
scope = traverse(n.getFirstChild(), scope);
n.setJSType(getJSType(n.getFirstChild()));
break;

case Token.COMMA:
scope = traverseChildren(n, scope);
n.setJSType(getJSType(n.getLastChild()));
break;

case Token.TYPEOF:
scope = traverseChildren(n, scope);
n.setJSType(getNativeType(STRING_TYPE));
break;

case Token.DELPROP:
case Token.LT:
case Token.LE:
case Token.GT:
case Token.GE:
case Token.NOT:
case Token.EQ:
case Token.NE:
case Token.SHEQ:
case Token.SHNE:
case Token.INSTANCEOF:
case Token.IN:
scope = traverseChildren(n, scope);
n.setJSType(getNativeType(BOOLEAN_TYPE));
break;

case Token.GETELEM:
scope = traverseGetElem(n, scope);
break;

case Token.EXPR_RESULT:
scope = traverseChildren(n, scope);
if (n.getFirstChild().isGetProp()) {
ensurePropertyDeclared(n.getFirstChild());
}
break;

case Token.SWITCH:
scope = traverse(n.getFirstChild(), scope);
break;

case Token.RETURN:
scope = traverseReturn(n, scope);
break;

case Token.VAR:
case Token.THROW:
scope = traverseChildren(n, scope);
break;

case Token.CATCH:
scope = traverseCatch(n, scope);
break;
}
if (!n.isFunction()) {
JSDocInfo info = n.getJSDocInfo();
if (info != null && info.hasType()) {
JSType castType = info.getType().evaluate(syntacticScope, registry);

// A stubbed type cast on a qualified name should take
// effect for all subsequent accesses of that name,
// so treat it the same as an assign to that name.
if (n.isQualifiedName() &&
n.getParent().isExprResult()) {
updateScopeForTypeChange(scope, n, n.getJSType(), castType);
}

n.setJSType(castType);
}
}

return scope;
}"
Closure_25b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_25_buggy/src/com/google/javascript/jscomp/TypeInference.java,"private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {
JSType type = n.getJSType();
Preconditions.checkNotNull(type);

for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {
scope = traverse(name.getFirstChild(), scope);
}

// Object literals can be reflected on other types, or changed with
// type casts.
// See CodingConvention#getObjectLiteralCase and goog.object.reflect.
// Ignore these types of literals.
// TODO(nicksantos): There should be an ""anonymous object"" type that
// we can check for here.
ObjectType objectType = ObjectType.cast(type);
if (objectType == null) {
return scope;
}

boolean hasLendsName = n.getJSDocInfo() != null &&
n.getJSDocInfo().getLendsName() != null;
if (objectType.hasReferenceName() && !hasLendsName) {
return scope;
}

String qObjName = NodeUtil.getBestLValueName(
NodeUtil.getBestLValue(n));
for (Node name = n.getFirstChild(); name != null;
name = name.getNext()) {
Node value = name.getFirstChild();
String memberName = NodeUtil.getObjectLitKeyName(name);
if (memberName != null) {
JSType rawValueType =  name.getFirstChild().getJSType();
JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(
name, rawValueType);
if (valueType == null) {
valueType = getNativeType(UNKNOWN_TYPE);
}
objectType.defineInferredProperty(memberName, valueType, name);

// Do normal flow inference if this is a direct property assignment.
if (qObjName != null && name.isStringKey()) {
String qKeyName = qObjName + ""."" + memberName;
Var var = syntacticScope.getVar(qKeyName);
JSType oldType = var == null ? null : var.getType();
if (var != null && var.isTypeInferred()) {
var.setType(oldType == null ?
valueType : oldType.getLeastSupertype(oldType));
}

scope.inferQualifiedSlot(name, qKeyName,
oldType == null ? getNativeType(UNKNOWN_TYPE) : oldType,
valueType);
}
} else {
n.setJSType(getNativeType(UNKNOWN_TYPE));
}
}
return scope;
}"
Closure_25b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_25_buggy/src/com/google/javascript/jscomp/TypeInference.java,"private FlowScope traverseName(Node n, FlowScope scope) {
String varName = n.getString();
Node value = n.getFirstChild();
JSType type = n.getJSType();
if (value != null) {
scope = traverse(value, scope);
updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */,
getJSType(value));
return scope;
} else {
StaticSlot<JSType> var = scope.getSlot(varName);
if (var != null) {
// There are two situations where we don't want to use type information
// from the scope, even if we have it.

// 1) The var is escaped in a weird way, e.g.,
// function f() { var x = 3; function g() { x = null } (x); }
boolean isInferred = var.isTypeInferred();
boolean unflowable = isInferred &&
isUnflowable(syntacticScope.getVar(varName));

// 2) We're reading type information from another scope for an
// inferred variable.
// var t = null; function f() { (t); }
boolean nonLocalInferredSlot =
isInferred &&
syntacticScope.getParent() != null &&
var == syntacticScope.getParent().getSlot(varName);

if (!unflowable && !nonLocalInferredSlot) {
type = var.getType();
if (type == null) {
type = getNativeType(UNKNOWN_TYPE);
}
}
}
}
n.setJSType(type);
return scope;
}"
Closure_25b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_25_buggy/src/com/google/javascript/jscomp/TypeInference.java,"TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg,
ReverseAbstractInterpreter reverseInterpreter,"
Closure_28b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_28_buggy/src/com/google/javascript/jscomp/InlineCostEstimator.java,"return getCost(root, Integer.MAX_VALUE);
}

/**
* Determines the estimated size of the js snippet represented by the node.
*/
static int getCost(Node root, int costThreshhold) {"
Closure_29b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_29_buggy/src/com/google/javascript/jscomp/InlineObjectLiterals.java,"InlineObjectLiterals(
AbstractCompiler compiler,"
Closure_29b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_29_buggy/src/com/google/javascript/jscomp/InlineObjectLiterals.java,"public void process(Node externs, Node root) {
ReferenceCollectingCallback callback = new ReferenceCollectingCallback(
compiler, new InliningBehavior());
callback.process(externs, root);
}"
Closure_31b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_31_buggy/src/com/google/javascript/jscomp/Compiler.java,"Node parseInputs() {
    boolean devMode = options.devMode != DevMode.OFF;

    // If old roots exist (we are parsing a second time), detach each of the
    // individual file parse trees.
    if (externsRoot != null) {
      externsRoot.detachChildren();
    }
    if (jsRoot != null) {
      jsRoot.detachChildren();
    }

    // Parse main js sources.
    jsRoot = IR.block();
    jsRoot.setIsSyntheticBlock(true);

    externsRoot = IR.block();
    externsRoot.setIsSyntheticBlock(true);

    externAndJsRoot = IR.block(externsRoot, jsRoot);
    externAndJsRoot.setIsSyntheticBlock(true);

    if (options.tracer.isOn()) {
      tracker = new PerformanceTracker(jsRoot, options.tracer);
      addChangeHandler(tracker.getCodeChangeHandler());
    }

    Tracer tracer = newTracer(""parseInputs"");

    try {
      // Parse externs sources.
      for (CompilerInput input : externs) {
        Node n = input.getAstRoot(this);
        if (hasErrors()) {
          return null;
        }
        externsRoot.addChildToBack(n);
      }

      // Modules inferred in ProcessCommonJS pass.
      if (options.transformAMDToCJSModules || options.processCommonJSModules) {
        processAMDAndCommonJSModules();
      }

      // Check if inputs need to be rebuilt from modules.
      boolean staleInputs = false;

      // Check if the sources need to be re-ordered.
      if (options.dependencyOptions.needsManagement() &&
          !options.skipAllPasses &&
          options.closurePass) {
        for (CompilerInput input : inputs) {
          // Forward-declare all the provided types, so that they
          // are not flagged even if they are dropped from the process.
          for (String provide : input.getProvides()) {
            getTypeRegistry().forwardDeclareType(provide);
          }
        }

        try {
          inputs =
              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)
              .manageDependencies(options.dependencyOptions, inputs);
          staleInputs = true;
        } catch (CircularDependencyException e) {
          report(JSError.make(
              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        } catch (MissingProvideException e) {
          report(JSError.make(
              MISSING_ENTRY_ERROR, e.getMessage()));

          // If in IDE mode, we ignore the error and keep going.
          if (hasErrors()) {
            return null;
          }
        }
      }

      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);

        // Inputs can have a null AST during initial parse.
        if (n == null) {
          continue;
        }

        if (n.getJSDocInfo() != null) {
          JSDocInfo info = n.getJSDocInfo();
          if (info.isExterns()) {
            // If the input file is explicitly marked as an externs file, then
            // assume the programmer made a mistake and throw it into
            // the externs pile anyways.
            externsRoot.addChildToBack(n);
            input.setIsExtern(true);

            input.getModule().remove(input);

            externs.add(input);
            staleInputs = true;
          } else if (info.isNoCompile()) {
            input.getModule().remove(input);
            staleInputs = true;
          }
        }
      }

      if (staleInputs) {
        fillEmptyModules(modules);
        rebuildInputsFromModules();
      }

      // Build the AST.
      for (CompilerInput input : inputs) {
        Node n = input.getAstRoot(this);
        if (n == null) {
          continue;
        }

        if (devMode) {
          runSanityCheck();
          if (hasErrors()) {
            return null;
          }
        }

        if (options.sourceMapOutputPath != null ||
            options.nameReferenceReportPath != null) {

          // Annotate the nodes in the tree with information from the
          // input file. This information is used to construct the SourceMap.
          SourceInformationAnnotator sia =
              new SourceInformationAnnotator(
                  input.getName(), options.devMode != DevMode.OFF);
          NodeTraversal.traverse(this, n, sia);
        }

        jsRoot.addChildToBack(n);
      }

      if (hasErrors()) {
        return null;
      }
      return externAndJsRoot;
    } finally {
      stopTracer(tracer, ""parseInputs"");
    }
  }"
Closure_32b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_32_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,"boolean parse() {
int lineno;
int charno;

// JSTypes are represented as Rhino AST nodes, and then resolved later.
JSTypeExpression type;

state = State.SEARCHING_ANNOTATION;
skipEOLs();

JsDocToken token = next();

List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();

// Always record that we have a comment.
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo blockInfo = extractBlockComment(token);
token = blockInfo.token;
if (!blockInfo.string.isEmpty()) {
jsdocBuilder.recordBlockDescription(blockInfo.string);
}
} else {
if (token != JsDocToken.ANNOTATION &&
token != JsDocToken.EOC) {
// Mark that there was a description, but don't bother marking
// what it was.
jsdocBuilder.recordBlockDescription("""");
}
}

// Parse the actual JsDoc.
retry: for (;;) {
switch (token) {
case ANNOTATION:
if (state == State.SEARCHING_ANNOTATION) {
state = State.SEARCHING_NEWLINE;
lineno = stream.getLineno();
charno = stream.getCharno();

String annotationName = stream.getString();
Annotation annotation = annotationNames.get(annotationName);
if (annotation == null) {
parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName,
stream.getLineno(), stream.getCharno());
} else {
// Mark the beginning of the annotation.
jsdocBuilder.markAnnotation(annotationName, lineno, charno);

switch (annotation) {
case AUTHOR:
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo authorInfo = extractSingleLineBlock();
String author = authorInfo.string;

if (author.length() == 0) {
parser.addParserWarning(""msg.jsdoc.authormissing"",
stream.getLineno(), stream.getCharno());
} else {
jsdocBuilder.addAuthor(author);
}
token = authorInfo.token;
} else {
token = eatTokensUntilEOL(token);
}
continue retry;

case CONSISTENTIDGENERATOR:
if (!jsdocBuilder.recordConsistentIdGenerator()) {
parser.addParserWarning(""msg.jsdoc.consistidgen"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case CONSTANT:
if (!jsdocBuilder.recordConstancy()) {
parser.addParserWarning(""msg.jsdoc.const"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case CONSTRUCTOR:
if (!jsdocBuilder.recordConstructor()) {
if (jsdocBuilder.isInterfaceRecorded()) {
parser.addTypeWarning(""msg.jsdoc.interface.constructor"",
stream.getLineno(), stream.getCharno());
} else {
parser.addTypeWarning(""msg.jsdoc.incompat.type"",
stream.getLineno(), stream.getCharno());
}
}
token = eatTokensUntilEOL();
continue retry;

case DEPRECATED:
if (!jsdocBuilder.recordDeprecated()) {
parser.addParserWarning(""msg.jsdoc.deprecated"",
stream.getLineno(), stream.getCharno());
}

// Find the reason/description, if any.
ExtractionInfo reasonInfo =
extractMultilineTextualBlock(token);

String reason = reasonInfo.string;

if (reason.length() > 0) {
jsdocBuilder.recordDeprecationReason(reason);
}

token = reasonInfo.token;
continue retry;

case INTERFACE:
if (!jsdocBuilder.recordInterface()) {
if (jsdocBuilder.isConstructorRecorded()) {
parser.addTypeWarning(""msg.jsdoc.interface.constructor"",
stream.getLineno(), stream.getCharno());
} else {
parser.addTypeWarning(""msg.jsdoc.incompat.type"",
stream.getLineno(), stream.getCharno());
}
}
token = eatTokensUntilEOL();
continue retry;

case DESC:
if (jsdocBuilder.isDescriptionRecorded()) {
parser.addParserWarning(""msg.jsdoc.desc.extra"",
stream.getLineno(), stream.getCharno());
token = eatTokensUntilEOL();
continue retry;
} else {
ExtractionInfo descriptionInfo =
extractMultilineTextualBlock(token);

String description = descriptionInfo.string;

jsdocBuilder.recordDescription(description);
token = descriptionInfo.token;
continue retry;
}

case FILE_OVERVIEW:
String fileOverview = """";
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo fileOverviewInfo =
extractMultilineTextualBlock(token,
WhitespaceOption.TRIM);

fileOverview = fileOverviewInfo.string;

token = fileOverviewInfo.token;
} else {
token = eatTokensUntilEOL(token);
}

if (!jsdocBuilder.recordFileOverview(fileOverview) ||
fileOverviewJSDocInfo != null) {
parser.addParserWarning(""msg.jsdoc.fileoverview.extra"",
stream.getLineno(), stream.getCharno());
}
continue retry;

case LICENSE:
case PRESERVE:
ExtractionInfo preserveInfo =
extractMultilineTextualBlock(token,
WhitespaceOption.PRESERVE);

String preserve = preserveInfo.string;

if (preserve.length() > 0) {
if (fileLevelJsDocBuilder != null) {
fileLevelJsDocBuilder.append(preserve);
}
}

token = preserveInfo.token;
continue retry;

case ENUM:
token = next();
lineno = stream.getLineno();
charno = stream.getCharno();

type = null;
if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
type = createJSTypeExpression(
parseAndRecordTypeNode(token));
}

if (type == null) {
type = createJSTypeExpression(newStringNode(""number""));
}
if (!jsdocBuilder.recordEnumParameterType(type)) {
parser.addTypeWarning(
""msg.jsdoc.incompat.type"", lineno, charno);
}
token = eatTokensUntilEOL(token);
continue retry;

case EXPORT:
if (!jsdocBuilder.recordExport()) {
parser.addParserWarning(""msg.jsdoc.export"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case EXPOSE:
if (!jsdocBuilder.recordExpose()) {
parser.addParserWarning(""msg.jsdoc.expose"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case EXTERNS:
if (!jsdocBuilder.recordExterns()) {
parser.addParserWarning(""msg.jsdoc.externs"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case JAVA_DISPATCH:
if (!jsdocBuilder.recordJavaDispatch()) {
parser.addParserWarning(""msg.jsdoc.javadispatch"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case EXTENDS:
case IMPLEMENTS:
skipEOLs();
token = next();
lineno = stream.getLineno();
charno = stream.getCharno();
boolean matchingRc = false;

if (token == JsDocToken.LC) {
token = next();
matchingRc = true;
}

if (token == JsDocToken.STRING) {
Node typeNode = parseAndRecordTypeNameNode(
token, lineno, charno, matchingRc);

lineno = stream.getLineno();
charno = stream.getCharno();

typeNode = wrapNode(Token.BANG, typeNode);
if (typeNode != null && !matchingRc) {
typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
}
type = createJSTypeExpression(typeNode);

if (annotation == Annotation.EXTENDS) {
// record the extended type, check later
extendedTypes.add(new ExtendedTypeInfo(
type, stream.getLineno(), stream.getCharno()));
} else {
Preconditions.checkState(
annotation == Annotation.IMPLEMENTS);
if (!jsdocBuilder.recordImplementedInterface(type)) {
parser.addTypeWarning(""msg.jsdoc.implements.duplicate"",
lineno, charno);
}
}
token = next();
if (matchingRc) {
if (token != JsDocToken.RC) {
parser.addTypeWarning(""msg.jsdoc.missing.rc"",
stream.getLineno(), stream.getCharno());
}
} else if (token != JsDocToken.EOL &&
token != JsDocToken.EOF && token != JsDocToken.EOC) {
parser.addTypeWarning(""msg.end.annotation.expected"",
stream.getLineno(), stream.getCharno());
}
} else {
parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
}
token = eatTokensUntilEOL(token);
continue retry;

case HIDDEN:
if (!jsdocBuilder.recordHiddenness()) {
parser.addParserWarning(""msg.jsdoc.hidden"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case LENDS:
skipEOLs();

matchingRc = false;
if (match(JsDocToken.LC)) {
token = next();
matchingRc = true;
}

if (match(JsDocToken.STRING)) {
token = next();
if (!jsdocBuilder.recordLends(stream.getString())) {
parser.addTypeWarning(""msg.jsdoc.lends.incompatible"",
stream.getLineno(), stream.getCharno());
}
} else {
parser.addTypeWarning(""msg.jsdoc.lends.missing"",
stream.getLineno(), stream.getCharno());
}

if (matchingRc && !match(JsDocToken.RC)) {
parser.addTypeWarning(""msg.jsdoc.missing.rc"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case MEANING:
ExtractionInfo meaningInfo =
extractMultilineTextualBlock(token);
String meaning = meaningInfo.string;
token = meaningInfo.token;
if (!jsdocBuilder.recordMeaning(meaning)) {
parser.addParserWarning(""msg.jsdoc.meaning.extra"",
stream.getLineno(), stream.getCharno());
}
continue retry;

case NO_ALIAS:
if (!jsdocBuilder.recordNoAlias()) {
parser.addParserWarning(""msg.jsdoc.noalias"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case NO_COMPILE:
if (!jsdocBuilder.recordNoCompile()) {
parser.addParserWarning(""msg.jsdoc.nocompile"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case NO_TYPE_CHECK:
if (!jsdocBuilder.recordNoTypeCheck()) {
parser.addParserWarning(""msg.jsdoc.nocheck"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case NOT_IMPLEMENTED:
token = eatTokensUntilEOL();
continue retry;

case INHERIT_DOC:
case OVERRIDE:
if (!jsdocBuilder.recordOverride()) {
parser.addTypeWarning(""msg.jsdoc.override"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case THROWS:
skipEOLs();
token = next();
lineno = stream.getLineno();
charno = stream.getCharno();
type = null;

if (token == JsDocToken.LC) {
type = createJSTypeExpression(
parseAndRecordTypeNode(token));

if (type == null) {
// parsing error reported during recursive descent
// recovering parsing
token = eatTokensUntilEOL();
continue retry;
}
}

// *Update* the token to that after the type annotation.
token = current();

// Save the throw type.
jsdocBuilder.recordThrowType(type);

// Find the throw's description (if applicable).
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo descriptionInfo =
extractMultilineTextualBlock(token);

String description = descriptionInfo.string;

if (description.length() > 0) {
jsdocBuilder.recordThrowDescription(type, description);
}

token = descriptionInfo.token;
} else {
token = eatTokensUntilEOL(token);
}
continue retry;

case PARAM:
skipEOLs();
token = next();
lineno = stream.getLineno();
charno = stream.getCharno();
type = null;

if (token == JsDocToken.LC) {
type = createJSTypeExpression(
parseAndRecordParamTypeNode(token));

if (type == null) {
// parsing error reported during recursive descent
// recovering parsing
token = eatTokensUntilEOL();
continue retry;
}
skipEOLs();
token = next();
lineno = stream.getLineno();
charno = stream.getCharno();
}

String name = null;
boolean isBracketedParam = JsDocToken.LB == token;
if (isBracketedParam) {
token = next();
}

if (JsDocToken.STRING != token) {
parser.addTypeWarning(""msg.missing.variable.name"",
lineno, charno);
} else {
name = stream.getString();

if (isBracketedParam) {
token = next();

// Throw out JsDocToolkit's ""default"" parameter
// annotation.  It makes no sense under our type
// system.
if (JsDocToken.EQUALS == token) {
token = next();
if (JsDocToken.STRING == token) {
token = next();
}
}

if (JsDocToken.RB != token) {
reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
} else if (type != null) {
// Make the type expression optional, if it isn't
// already.
type = JSTypeExpression.makeOptionalArg(type);
}
}

// If the param name has a DOT in it, just throw it out
// quietly. We do not handle the JsDocToolkit method
// for handling properties of params.
if (name.indexOf('.') > -1) {
name = null;
} else if (!jsdocBuilder.recordParameter(name, type)) {
if (jsdocBuilder.hasParameter(name)) {
parser.addTypeWarning(""msg.dup.variable.name"", name,
lineno, charno);
} else {
parser.addTypeWarning(""msg.jsdoc.incompat.type"", name,
lineno, charno);
}
}
}

if (name == null) {
token = eatTokensUntilEOL(token);
continue retry;
}

jsdocBuilder.markName(name, sourceFile, lineno, charno);

// Find the parameter's description (if applicable).
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo paramDescriptionInfo =
extractMultilineTextualBlock(token);

String paramDescription = paramDescriptionInfo.string;

if (paramDescription.length() > 0) {
jsdocBuilder.recordParameterDescription(name,
paramDescription);
}

token = paramDescriptionInfo.token;
} else {
token = eatTokensUntilEOL(token);
}
continue retry;

case PRESERVE_TRY:
if (!jsdocBuilder.recordPreserveTry()) {
parser.addParserWarning(""msg.jsdoc.preservertry"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case PRIVATE:
if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
parser.addParserWarning(""msg.jsdoc.visibility.private"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case PROTECTED:
if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
parser.addParserWarning(""msg.jsdoc.visibility.protected"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case PUBLIC:
if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
parser.addParserWarning(""msg.jsdoc.visibility.public"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case NO_SHADOW:
if (!jsdocBuilder.recordNoShadow()) {
parser.addParserWarning(""msg.jsdoc.noshadow"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case NO_SIDE_EFFECTS:
if (!jsdocBuilder.recordNoSideEffects()) {
parser.addParserWarning(""msg.jsdoc.nosideeffects"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case MODIFIES:
token = parseModifiesTag(next());
continue retry;

case IMPLICIT_CAST:
if (!jsdocBuilder.recordImplicitCast()) {
parser.addTypeWarning(""msg.jsdoc.implicitcast"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case SEE:
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo referenceInfo = extractSingleLineBlock();
String reference = referenceInfo.string;

if (reference.length() == 0) {
parser.addParserWarning(""msg.jsdoc.seemissing"",
stream.getLineno(), stream.getCharno());
} else {
jsdocBuilder.addReference(reference);
}

token = referenceInfo.token;
} else {
token = eatTokensUntilEOL(token);
}
continue retry;

case SUPPRESS:
token = parseSuppressTag(next());
continue retry;

case TEMPLATE:
ExtractionInfo templateInfo = extractSingleLineBlock();
String templateTypeName = templateInfo.string;

if (templateTypeName.length() == 0) {
parser.addTypeWarning(""msg.jsdoc.templatemissing"",
stream.getLineno(), stream.getCharno());
} else if (!jsdocBuilder.recordTemplateTypeName(
templateTypeName)) {
parser.addTypeWarning(""msg.jsdoc.template.at.most.once"",
stream.getLineno(), stream.getCharno());
}

token = templateInfo.token;
continue retry;

case IDGENERATOR:
if (!jsdocBuilder.recordIdGenerator()) {
parser.addParserWarning(""msg.jsdoc.idgen"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case VERSION:
ExtractionInfo versionInfo = extractSingleLineBlock();
String version = versionInfo.string;

if (version.length() == 0) {
parser.addParserWarning(""msg.jsdoc.versionmissing"",
stream.getLineno(), stream.getCharno());
} else {
if (!jsdocBuilder.recordVersion(version)) {
parser.addParserWarning(""msg.jsdoc.extraversion"",
stream.getLineno(), stream.getCharno());
}
}

token = versionInfo.token;
continue retry;

case DEFINE:
case RETURN:
case THIS:
case TYPE:
case TYPEDEF:
lineno = stream.getLineno();
charno = stream.getCharno();

Node typeNode = null;
if (!lookAheadForTypeAnnotation() &&
annotation == Annotation.RETURN) {
// If RETURN doesn't have a type annotation, record
// it as the unknown type.
typeNode = newNode(Token.QMARK);
} else {
skipEOLs();
token = next();
typeNode = parseAndRecordTypeNode(token);
}

if (annotation == Annotation.THIS) {
typeNode = wrapNode(Token.BANG, typeNode);
if (typeNode != null && token != JsDocToken.LC) {
typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);
}
}
type = createJSTypeExpression(typeNode);

if (type == null) {
// error reported during recursive descent
// recovering parsing
} else {
switch (annotation) {
case DEFINE:
if (!jsdocBuilder.recordDefineType(type)) {
parser.addParserWarning(""msg.jsdoc.define"",
lineno, charno);
}
break;

case RETURN:
if (!jsdocBuilder.recordReturnType(type)) {
parser.addTypeWarning(
""msg.jsdoc.incompat.type"", lineno, charno);
break;
}

// Find the return's description (if applicable).
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo returnDescriptionInfo =
extractMultilineTextualBlock(token);

String returnDescription =
returnDescriptionInfo.string;

if (returnDescription.length() > 0) {
jsdocBuilder.recordReturnDescription(
returnDescription);
}

token = returnDescriptionInfo.token;
} else {
token = eatTokensUntilEOL(token);
}
continue retry;

case THIS:
if (!jsdocBuilder.recordThisType(type)) {
parser.addTypeWarning(
""msg.jsdoc.incompat.type"", lineno, charno);
}
break;

case TYPE:
if (!jsdocBuilder.recordType(type)) {
parser.addTypeWarning(
""msg.jsdoc.incompat.type"", lineno, charno);
}
break;

case TYPEDEF:
if (!jsdocBuilder.recordTypedef(type)) {
parser.addTypeWarning(
""msg.jsdoc.incompat.type"", lineno, charno);
}
break;
}
}

token = eatTokensUntilEOL();
continue retry;
}
}
}
break;

case EOC:
if (hasParsedFileOverviewDocInfo()) {
fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
}
checkExtendedTypes(extendedTypes);
return true;

case EOF:
// discard any accumulated information
jsdocBuilder.build(null);
parser.addParserWarning(""msg.unexpected.eof"",
stream.getLineno(), stream.getCharno());
checkExtendedTypes(extendedTypes);
return false;

case EOL:
if (state == State.SEARCHING_NEWLINE) {
state = State.SEARCHING_ANNOTATION;
}
token = next();
continue retry;

default:
if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
token = next();
continue retry;
} else {
state = State.SEARCHING_NEWLINE;
token = eatTokensUntilEOL();
continue retry;
}
}

// next token
token = next();
}
}"
Closure_32b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_32_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,"private String toString(JsDocToken token) {
switch (token) {
case ANNOTATION:
return ""@"" + stream.getString();

case BANG:
return ""!"";

case COMMA:
return "","";

case COLON:
return "":"";

case GT:
return "">"";

case LB:
return ""["";

case LC:
return ""{"";

case LP:
return ""("";

case LT:
return "".<"";

case QMARK:
return ""?"";

case PIPE:
return ""|"";

case RB:
return ""]"";

case RC:
return ""}"";

case RP:
return "")"";

case STAR:
return ""*"";

case ELLIPSIS:
return ""..."";

case EQUALS:
return ""="";

case STRING:
return stream.getString();

default:
throw new IllegalStateException(token.toString());
}
}"
Closure_32b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_32_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,"private void skipEOLs() {
while (match(JsDocToken.EOL)) {
next();
if (match(JsDocToken.STAR)) {
next();
}
}
}"
Closure_32b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_32_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,"private Node createTemplateNode() {
// The Node type choice is arbitrary.
Node templateNode = IR.script();
templateNode.setStaticSourceFile(
this.associatedNode != null ?
this.associatedNode.getStaticSourceFile() :
null);
return templateNode;
}"
Closure_32b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_32_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,"private boolean hasParsedFileOverviewDocInfo() {
return jsdocBuilder.isPopulatedWithFileOverview();
}"
Closure_33b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_33_buggy/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java,"String toStringHelper(boolean forAnnotations) {
if (hasReferenceName()) {
return getReferenceName();
} else if (prettyPrint) {
// Don't pretty print recursively.
prettyPrint = false;

// Use a tree set so that the properties are sorted.
Set<String> propertyNames = Sets.newTreeSet();
for (ObjectType current = this;
current != null && !current.isNativeObjectType() &&
propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;
current = current.getImplicitPrototype()) {
propertyNames.addAll(current.getOwnPropertyNames());
}

StringBuilder sb = new StringBuilder();
sb.append(""{"");

int i = 0;
for (String property : propertyNames) {
if (i > 0) {
sb.append("", "");
}

sb.append(property);
sb.append("": "");
sb.append(getPropertyType(property).toStringHelper(forAnnotations));

++i;
if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {
sb.append("", ..."");
break;
}
}

sb.append(""}"");

prettyPrint = true;
return sb.toString();
} else {
return forAnnotations ? ""?"" : ""{...}"";
}
}"
Closure_33b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_33_buggy/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java,"public void matchConstraint(ObjectType constraintObj) {
// We only want to match contraints on anonymous types.

// Handle the case where the constraint object is a record type.
//
// param constraintObj {{prop: (number|undefined)}}
// function f(constraintObj) {}
// f({});
//
// We want to modify the object literal to match the constraint, by
// taking any each property on the record and trying to match
// properties on this object.
if (constraintObj.isRecordType()) {
for (String prop : constraintObj.getOwnPropertyNames()) {
JSType propType = constraintObj.getPropertyType(prop);
if (!isPropertyTypeDeclared(prop)) {
JSType typeToInfer = propType;
if (!hasProperty(prop)) {
typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)
.getLeastSupertype(propType);
}
defineInferredProperty(prop, typeToInfer, null);
}
}
}
}"
Closure_33b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_33_buggy/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java,"boolean defineProperty(String name, JSType type, boolean inferred,
Node propertyNode) {
if (hasOwnDeclaredProperty(name)) {
return false;
}
Property newProp = new Property(
name, type, inferred, propertyNode);
Property oldProp = properties.get(name);
if (oldProp != null) {
// This is to keep previously inferred jsdoc info, e.g., in a
// replaceScript scenario.
newProp.setJSDocInfo(oldProp.getJSDocInfo());
}
properties.put(name, newProp);
return true;
}"
Closure_33b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_33_buggy/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java,"public boolean isSubtype(JSType that) {
if (JSType.isSubtypeHelper(this, that)) {
return true;
}

// Union types
if (that.isUnionType()) {
// The static {@code JSType.isSubtype} check already decomposed
// union types, so we don't need to check those again.
return false;
}

// record types
if (that.isRecordType()) {
return RecordType.isSubtype(this, that.toMaybeRecordType());
}

// Interfaces
// Find all the interfaces implemented by this class and compare each one
// to the interface instance.
ObjectType thatObj = that.toObjectType();
ObjectType thatCtor = thatObj == null ? null : thatObj.getConstructor();
if (thatCtor != null && thatCtor.isInterface()) {
Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces();
for (ObjectType thisInterface : thisInterfaces) {
if (thisInterface.isSubtype(that)) {
return true;
}
}
}

if (getConstructor() != null && getConstructor().isInterface()) {
for (ObjectType thisInterface : getCtorExtendedInterfaces()) {
if (thisInterface.isSubtype(that)) {
return true;
}
}
}

// other prototype based objects
if (isUnknownType() || implicitPrototypeChainIsUnknown()) {
// If unsure, say 'yes', to avoid spurious warnings.
// TODO(user): resolve the prototype chain completely in all cases,
// to avoid guessing.
return true;
}
return this.isImplicitPrototype(thatObj);
}"
Closure_33b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_33_buggy/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java,"public Set<String> getOwnPropertyNames() {
return properties.keySet();
}"
Closure_35b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_35_buggy/src/com/google/javascript/jscomp/TypeInference.java,"private void inferPropertyTypesToMatchConstraint(
JSType type, JSType constraint) {
if (type == null || constraint == null) {
return;
}

ObjectType constraintObj =
ObjectType.cast(constraint.restrictByNotNullOrUndefined());
if (constraintObj != null && constraintObj.isRecordType()) {
ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
if (objType != null) {
for (String prop : constraintObj.getOwnPropertyNames()) {
JSType propType = constraintObj.getPropertyType(prop);
if (!objType.isPropertyTypeDeclared(prop)) {
JSType typeToInfer = propType;
if (!objType.hasProperty(prop)) {
typeToInfer =
getNativeType(VOID_TYPE).getLeastSupertype(propType);
}
objType.defineInferredProperty(prop, typeToInfer, null);
}
}
}
}
}"
Closure_35b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_35_buggy/src/com/google/javascript/jscomp/TypeInference.java,"private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {
JSType type = n.getJSType();
Preconditions.checkNotNull(type);

for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {
scope = traverse(name.getFirstChild(), scope);
}

// Object literals can be reflected on other types, or changed with
// type casts.
// See CodingConvention#getObjectLiteralCase and goog.object.reflect.
// Ignore these types of literals.
// TODO(nicksantos): There should be an ""anonymous object"" type that
// we can check for here.
ObjectType objectType = ObjectType.cast(type);
if (objectType == null) {
return scope;
}

boolean hasLendsName = n.getJSDocInfo() != null &&
n.getJSDocInfo().getLendsName() != null;
if (objectType.hasReferenceName() && !hasLendsName) {
return scope;
}

String qObjName = NodeUtil.getBestLValueName(
NodeUtil.getBestLValue(n));
for (Node name = n.getFirstChild(); name != null;
name = name.getNext()) {
Node value = name.getFirstChild();
String memberName = NodeUtil.getObjectLitKeyName(name);
if (memberName != null) {
JSType rawValueType =  name.getFirstChild().getJSType();
JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(
name, rawValueType);
if (valueType == null) {
valueType = getNativeType(UNKNOWN_TYPE);
}
objectType.defineInferredProperty(memberName, valueType, name);

// Do normal flow inference if this is a direct property assignment.
if (qObjName != null && name.isString()) {
String qKeyName = qObjName + ""."" + memberName;
Var var = syntacticScope.getVar(qKeyName);
JSType oldType = var == null ? null : var.getType();
if (var != null && var.isTypeInferred()) {
var.setType(oldType == null ?
valueType : oldType.getLeastSupertype(oldType));
}

scope.inferQualifiedSlot(name, qKeyName,
oldType == null ? getNativeType(UNKNOWN_TYPE) : oldType,
valueType);
}
} else {
n.setJSType(getNativeType(UNKNOWN_TYPE));
}
}
return scope;
}"
Closure_35b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_35_buggy/src/com/google/javascript/jscomp/TypeInference.java,"List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {
// NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND
// edges. If we wanted to be perfect, we'd actually JOIN all the out
// lattices of this flow with the in lattice, and then make that the out
// lattice for the ON_EX edge. But it's probably to expensive to be
// worthwhile.
FlowScope output = flowThrough(source, input);
Node condition = null;
FlowScope conditionFlowScope = null;
BooleanOutcomePair conditionOutcomes = null;

List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);
List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());
for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {
Branch branch = branchEdge.getValue();
FlowScope newScope = output;

switch (branch) {
case ON_TRUE:
if (NodeUtil.isForIn(source)) {
// item is assigned a property name, so its type should be string.
Node item = source.getFirstChild();
Node obj = item.getNext();

FlowScope informed = traverse(obj, output.createChildFlowScope());

if (item.isVar()) {
item = item.getFirstChild();
}
if (item.isName()) {
JSType iterKeyType = getNativeType(STRING_TYPE);
ObjectType objType = getJSType(obj).dereference();
JSType objIndexType = objType == null ?
null : objType.getIndexType();
if (objIndexType != null && !objIndexType.isUnknownType()) {
JSType narrowedKeyType =
iterKeyType.getGreatestSubtype(objIndexType);
if (!narrowedKeyType.isEmptyType()) {
iterKeyType = narrowedKeyType;
}
}
redeclareSimpleVar(informed, item, iterKeyType);
}
newScope = informed;
break;
}

// FALL THROUGH

case ON_FALSE:
if (condition == null) {
condition = NodeUtil.getConditionExpression(source);
if (condition == null && source.isCase()) {
condition = source;

// conditionFlowScope is cached from previous iterations
// of the loop.
if (conditionFlowScope == null) {
conditionFlowScope = traverse(
condition.getFirstChild(), output.createChildFlowScope());
}
}
}

if (condition != null) {
if (condition.isAnd() ||
condition.isOr()) {
// When handling the short-circuiting binary operators,
// the outcome scope on true can be different than the outcome
// scope on false.
//
// TODO(nicksantos): The ""right"" way to do this is to
// carry the known outcome all the way through the
// recursive traversal, so that we can construct a
// different flow scope based on the outcome. However,
// this would require a bunch of code and a bunch of
// extra computation for an edge case. This seems to be
// a ""good enough"" approximation.

// conditionOutcomes is cached from previous iterations
// of the loop.
if (conditionOutcomes == null) {
conditionOutcomes = condition.isAnd() ?
traverseAnd(condition, output.createChildFlowScope()) :
traverseOr(condition, output.createChildFlowScope());
}
newScope =
reverseInterpreter.getPreciserScopeKnowingConditionOutcome(
condition,
conditionOutcomes.getOutcomeFlowScope(
condition.getType(), branch == Branch.ON_TRUE),
branch == Branch.ON_TRUE);
} else {
// conditionFlowScope is cached from previous iterations
// of the loop.
if (conditionFlowScope == null) {
conditionFlowScope =
traverse(condition, output.createChildFlowScope());
}
newScope =
reverseInterpreter.getPreciserScopeKnowingConditionOutcome(
condition, conditionFlowScope, branch == Branch.ON_TRUE);
}
}
break;
}

result.add(newScope.optimize());
}
return result;
}"
Closure_35b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_35_buggy/src/com/google/javascript/jscomp/TypeInference.java,"private void ensurePropertyDefined(Node getprop, JSType rightType) {
String propName = getprop.getLastChild().getString();
JSType nodeType = getJSType(getprop.getFirstChild());
ObjectType objectType = ObjectType.cast(
nodeType.restrictByNotNullOrUndefined());
if (objectType == null) {
registry.registerPropertyOnType(propName, nodeType);
} else {
if (ensurePropertyDeclaredHelper(getprop, objectType)) {
return;
}

if (!objectType.isPropertyTypeDeclared(propName)) {
// We do not want a ""stray"" assign to define an inferred property
// for every object of this type in the program. So we use a heuristic
// approach to determine whether to infer the propery.
//
// 1) If the property is already defined, join it with the previously
//    inferred type.
// 2) If this isn't an instance object, define it.
// 3) If the property of an object is being assigned in the constructor,
//    define it.
// 4) If this is a stub, define it.
// 5) Otherwise, do not define the type, but declare it in the registry
//    so that we can use it for missing property checks.
if (objectType.hasProperty(propName) ||
!objectType.isInstanceType()) {
if (""prototype"".equals(propName)) {
objectType.defineDeclaredProperty(
propName, rightType, getprop);
} else {
objectType.defineInferredProperty(
propName, rightType, getprop);
}
} else {
if (getprop.getFirstChild().isThis() &&
getJSType(syntacticScope.getRootNode()).isConstructor()) {
objectType.defineInferredProperty(
propName, rightType, getprop);
} else {
registry.registerPropertyOnType(propName, objectType);
}
}
}
}
}"
Closure_35b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_35_buggy/src/com/google/javascript/jscomp/TypeInference.java,"private JSType getPropertyType(JSType objType, String propName,
Node n, FlowScope scope) {
// Scopes sometimes contain inferred type info about qualified names.
String qualifiedName = n.getQualifiedName();
StaticSlot<JSType> var = scope.getSlot(qualifiedName);
if (var != null) {
JSType varType = var.getType();
if (varType != null) {
if (varType.equals(getNativeType(UNKNOWN_TYPE)) &&
var != syntacticScope.getSlot(qualifiedName)) {
// If the type of this qualified name has been checked in this scope,
// then use CHECKED_UNKNOWN_TYPE instead to indicate that.
return getNativeType(CHECKED_UNKNOWN_TYPE);
} else {
return varType;
}
}
}

JSType propertyType = null;
if (objType != null) {
propertyType = objType.findPropertyType(propName);
}

if ((propertyType == null || propertyType.isUnknownType()) &&
qualifiedName != null) {
// If we find this node in the registry, then we can infer its type.
ObjectType regType = ObjectType.cast(registry.getType(qualifiedName));
if (regType != null) {
propertyType = regType.getConstructor();
}
}

return propertyType;
}"
Closure_36b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_36_buggy/src/com/google/javascript/jscomp/InlineVariables.java,"private Predicate<Var> getFilterForMode() {
switch (mode) {
case ALL:
return Predicates.<Var>alwaysTrue();
case LOCALS_ONLY:
return new IdentifyLocals();
case CONSTANTS_ONLY:
return new IdentifyConstants();
default:
throw new IllegalStateException();
}
}"
Closure_36b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_36_buggy/src/com/google/javascript/jscomp/InlineVariables.java,"public void process(Node externs, Node root) {
ReferenceCollectingCallback callback = new ReferenceCollectingCallback(
compiler, new InliningBehavior(), getFilterForMode());
callback.process(externs, root);
}"
Closure_38b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_38_buggy/src/com/google/javascript/jscomp/CodeConsumer.java,"void addNumber(double x) {
// This is not pretty printing. This is to prevent misparsing of x- -4 as
// x--4 (which is a syntax error).
char prev = getLastChar();
boolean negativeZero = isNegativeZero(x);
if (x < 0 && prev == '-') {
add("" "");
}

if ((long) x == x && !negativeZero) {
long value = (long) x;
long mantissa = value;
int exp = 0;
if (Math.abs(x) >= 100) {
while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
mantissa /= 10;
exp++;
}
}
if (exp > 2) {
add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
} else {
add(Long.toString(value));
}
} else {
add(String.valueOf(x));
}
}"
Closure_38b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_38_buggy/src/com/google/javascript/jscomp/CodeConsumer.java,"void appendOp(String op, boolean binOp) {
append(op);
}"
Closure_38b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_38_buggy/src/com/google/javascript/jscomp/CodeConsumer.java,"static boolean isNegativeZero(double x) {
return x == 0.0 && Math.copySign(1, x) == -1.0;
}"
Closure_38b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_38_buggy/src/com/google/javascript/jscomp/CodeConsumer.java,Incomplete method body detected.
Closure_38b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_38_buggy/src/com/google/javascript/jscomp/CodeConsumer.java,"void addOp(String op, boolean binOp) {
maybeEndStatement();

char first = op.charAt(0);
char prev = getLastChar();

if ((first == '+' || first == '-') && prev == first) {
// This is not pretty printing. This is to prevent misparsing of
// things like ""x + ++y"" or ""x++ + ++y""
append("" "");
} else if (Character.isLetter(first) &&
isWordChar(prev)) {
// Make sure there is a space after e.g. instanceof , typeof
append("" "");
} else if (prev == '-' && first == '>') {
// Make sure that we don't emit -->
append("" "");
}

// Allow formating around the operator.
appendOp(op, binOp);

// Line breaking after an operator is always safe. Line breaking before an
// operator on the other hand is not. We only line break after a bin op
// because it looks strange.
if (binOp) {
maybeCutLine();
}
}"
Closure_39b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_39_buggy/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java,"public Property getSlot(String name) {
if (properties.containsKey(name)) {
return properties.get(name);
}
ObjectType implicitPrototype = getImplicitPrototype();
if (implicitPrototype != null) {
Property prop = implicitPrototype.getSlot(name);
if (prop != null) {
return prop;
}
}
for (ObjectType interfaceType : getCtorExtendedInterfaces()) {
Property prop = interfaceType.getSlot(name);
if (prop != null) {
return prop;
}
}
return null;
}"
Closure_39b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_39_buggy/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java,"public int getPropertiesCount() {
ObjectType implicitPrototype = getImplicitPrototype();
if (implicitPrototype == null) {
return this.properties.size();
}
int localCount = 0;
for (String property : properties.keySet()) {
if (!implicitPrototype.hasProperty(property)) {
localCount++;
}
}
return implicitPrototype.getPropertiesCount() + localCount;
}"
Closure_39b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_39_buggy/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java,"public boolean hasOwnProperty(String propertyName) {
return properties.get(propertyName) != null;
}"
Closure_39b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_39_buggy/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java,"public Set<String> getOwnPropertyNames() {
return properties.keySet();
}"
Closure_39b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_39_buggy/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java,"public JSType getPropertyType(String property) {
StaticSlot<JSType> slot = getSlot(property);
if (slot == null) {
return getNativeType(JSTypeNative.UNKNOWN_TYPE);
}
return slot.getType();
}"
Closure_40b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_40_buggy/src/com/google/javascript/jscomp/NameAnalyzer.java,"private NameInformation createNameInformation(NodeTraversal t, Node n,
Node parent) {
// Build the full name and find its root node by iterating down through all
// GETPROP/GETELEM nodes.
String name = """";
Node rootNameNode = n;
boolean bNameWasShortened = false;
while (true) {
if (NodeUtil.isGet(rootNameNode)) {
Node prop = rootNameNode.getLastChild();
if (rootNameNode.isGetProp()) {
name = ""."" + prop.getString() + name;
} else {
// We consider the name to be ""a.b"" in a.b['c'] or a.b[x].d.
bNameWasShortened = true;
name = """";
}
rootNameNode = rootNameNode.getFirstChild();
} else if (NodeUtil.isObjectLitKey(
rootNameNode, rootNameNode.getParent())) {
name = ""."" + rootNameNode.getString() + name;

// Check if this is an object literal assigned to something.
Node objLit = rootNameNode.getParent();
Node objLitParent = objLit.getParent();
if (objLitParent.isAssign()) {
// This must be the right side of the assign.
rootNameNode = objLitParent.getFirstChild();
} else if (objLitParent.isName()) {
// This must be a VAR initialization.
rootNameNode = objLitParent;
} else if (objLitParent.isString()) {
// This must be a object literal key initialization.
rootNameNode = objLitParent;
} else {
return null;
}
} else {
break;
}
}

// Check whether this is a class-defining call. Classes may only be defined
// in the global scope.
if (parent.isCall() && t.inGlobalScope()) {
CodingConvention convention = compiler.getCodingConvention();
SubclassRelationship classes = convention.getClassesDefinedByCall(parent);
if (classes != null) {
NameInformation nameInfo = new NameInformation();
nameInfo.name = classes.subclassName;
nameInfo.onlyAffectsClassDef = true;
nameInfo.superclass = classes.superclassName;
return nameInfo;
}

String singletonGetterClass =
convention.getSingletonGetterClassName(parent);
if (singletonGetterClass != null) {
NameInformation nameInfo = new NameInformation();
nameInfo.name = singletonGetterClass;
nameInfo.onlyAffectsClassDef = true;
return nameInfo;
}
}

switch (rootNameNode.getType()) {
case Token.NAME:
// Check whether this is an assignment to a prototype property
// of an object defined in the global scope.
if (!bNameWasShortened &&
n.isGetProp() &&
parent.isAssign() &&
""prototype"".equals(n.getLastChild().getString())) {
if (createNameInformation(t, n.getFirstChild(), n) != null) {
name = rootNameNode.getString() + name;
name = name.substring(0, name.length() - PROTOTYPE_SUFFIX_LEN);
NameInformation nameInfo = new NameInformation();
nameInfo.name = name;
return nameInfo;
} else {
return null;
}
}
return createNameInformation(
rootNameNode.getString() + name, t.getScope(), rootNameNode);
case Token.THIS:
if (t.inGlobalScope()) {
NameInformation nameInfo = new NameInformation();
if (name.indexOf('.') == 0) {
nameInfo.name = name.substring(1);  // strip leading "".""
} else {
nameInfo.name = name;
}
nameInfo.isExternallyReferenceable = true;
return nameInfo;
}
return null;
default:
return null;
}
}"
Closure_40b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_40_buggy/src/com/google/javascript/jscomp/NameAnalyzer.java,"private List<Node> getRhsSubexpressions(Node n) {
switch (n.getType()) {
case Token.EXPR_RESULT:
// process body
return getRhsSubexpressions(n.getFirstChild());
case Token.FUNCTION:
// function nodes have no rhs
return Collections.emptyList();
case Token.NAME:
{
// parent is a var node.  rhs is first child
Node rhs = n.getFirstChild();
if (rhs != null) {
return Lists.newArrayList(rhs);
} else {
return Collections.emptyList();
}
}
case Token.ASSIGN:
{
// add lhs and rhs expressions - lhs may be a complex expression
Node lhs = n.getFirstChild();
Node rhs = lhs.getNext();
return Lists.newArrayList(lhs, rhs);
}
case Token.VAR:
{
// recurse on all children
List<Node> nodes = Lists.newArrayList();
for (Node child : n.children()) {
nodes.addAll(getRhsSubexpressions(child));
}
return nodes;
}
default:
throw new IllegalArgumentException(""AstChangeProxy::getRhs "" + n);
}
}"
Closure_40b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_40_buggy/src/com/google/javascript/jscomp/NameAnalyzer.java,"private void referenceParentNames() {
// Duplicate set of nodes to process so we don't modify set we are
// currently iterating over
Set<JsName> allNamesCopy = Sets.newHashSet(allNames.values());

for (JsName name : allNamesCopy) {
String curName = name.name;
JsName curJsName = name;
while (curName.indexOf('.') != -1) {
String parentName = curName.substring(0, curName.lastIndexOf('.'));
if (!globalNames.contains(parentName)) {

JsName parentJsName = getName(parentName, true);

recordReference(curJsName.name, parentJsName.name, RefType.REGULAR);
recordReference(parentJsName.name, curJsName.name, RefType.REGULAR);

curJsName = parentJsName;
}
curName = parentName;
}
}
}"
Closure_40b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_40_buggy/src/com/google/javascript/jscomp/NameAnalyzer.java,"private void replaceTopLevelExpressionWithRhs(Node parent, Node n) {
// validate inputs
switch (parent.getType()) {
case Token.BLOCK:
case Token.SCRIPT:
case Token.FOR:
case Token.LABEL:
break;
default:
throw new IllegalArgumentException(
""Unsupported parent node type in replaceWithRhs "" +
Token.name(parent.getType()));
}

switch (n.getType()) {
case Token.EXPR_RESULT:
case Token.FUNCTION:
case Token.VAR:
break;
case Token.ASSIGN:
Preconditions.checkArgument(parent.isFor(),
""Unsupported assignment in replaceWithRhs. parent: %s"", Token.name(parent.getType()));
break;
default:
throw new IllegalArgumentException(
""Unsupported node type in replaceWithRhs "" +
Token.name(n.getType()));
}

// gather replacements
List<Node> replacements = Lists.newArrayList();
for (Node rhs : getRhsSubexpressions(n)) {
replacements.addAll(getSideEffectNodes(rhs));
}

if (parent.isFor()) {
// tweak replacements array s.t. it is a single expression node.
if (replacements.isEmpty()) {
replacements.add(IR.empty());
} else {
Node expr = collapseReplacements(replacements);
replacements.clear();
replacements.add(expr);
}
}

changeProxy.replaceWith(parent, n, replacements);
}"
Closure_40b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_40_buggy/src/com/google/javascript/jscomp/NameAnalyzer.java,"private List<Node> getSideEffectNodes(Node n) {
List<Node> subexpressions = Lists.newArrayList();
NodeTraversal.traverse(
compiler, n,
new GatherSideEffectSubexpressionsCallback(
compiler,
new CopySideEffectSubexpressions(compiler, subexpressions)));

List<Node> replacements =
Lists.newArrayListWithExpectedSize(subexpressions.size());
for (Node subexpression : subexpressions) {
replacements.add(NodeUtil.newExpr(subexpression));
}
return replacements;
}"
Closure_42b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_42_buggy/src/com/google/javascript/jscomp/parsing/IRFactory.java,"private static int transformTokenType(int token) {
switch (token) {
case com.google.javascript.rhino.head.Token.RETURN:
return Token.RETURN;
case com.google.javascript.rhino.head.Token.BITOR:
return Token.BITOR;
case com.google.javascript.rhino.head.Token.BITXOR:
return Token.BITXOR;
case com.google.javascript.rhino.head.Token.BITAND:
return Token.BITAND;
case com.google.javascript.rhino.head.Token.EQ:
return Token.EQ;
case com.google.javascript.rhino.head.Token.NE:
return Token.NE;
case com.google.javascript.rhino.head.Token.LT:
return Token.LT;
case com.google.javascript.rhino.head.Token.LE:
return Token.LE;
case com.google.javascript.rhino.head.Token.GT:
return Token.GT;
case com.google.javascript.rhino.head.Token.GE:
return Token.GE;
case com.google.javascript.rhino.head.Token.LSH:
return Token.LSH;
case com.google.javascript.rhino.head.Token.RSH:
return Token.RSH;
case com.google.javascript.rhino.head.Token.URSH:
return Token.URSH;
case com.google.javascript.rhino.head.Token.ADD:
return Token.ADD;
case com.google.javascript.rhino.head.Token.SUB:
return Token.SUB;
case com.google.javascript.rhino.head.Token.MUL:
return Token.MUL;
case com.google.javascript.rhino.head.Token.DIV:
return Token.DIV;
case com.google.javascript.rhino.head.Token.MOD:
return Token.MOD;
case com.google.javascript.rhino.head.Token.NOT:
return Token.NOT;
case com.google.javascript.rhino.head.Token.BITNOT:
return Token.BITNOT;
case com.google.javascript.rhino.head.Token.POS:
return Token.POS;
case com.google.javascript.rhino.head.Token.NEG:
return Token.NEG;
case com.google.javascript.rhino.head.Token.NEW:
return Token.NEW;
case com.google.javascript.rhino.head.Token.DELPROP:
return Token.DELPROP;
case com.google.javascript.rhino.head.Token.TYPEOF:
return Token.TYPEOF;
case com.google.javascript.rhino.head.Token.GETPROP:
return Token.GETPROP;
case com.google.javascript.rhino.head.Token.GETELEM:
return Token.GETELEM;
case com.google.javascript.rhino.head.Token.CALL:
return Token.CALL;
case com.google.javascript.rhino.head.Token.NAME:
return Token.NAME;
case com.google.javascript.rhino.head.Token.NUMBER:
return Token.NUMBER;
case com.google.javascript.rhino.head.Token.STRING:
return Token.STRING;
case com.google.javascript.rhino.head.Token.NULL:
return Token.NULL;
case com.google.javascript.rhino.head.Token.THIS:
return Token.THIS;
case com.google.javascript.rhino.head.Token.FALSE:
return Token.FALSE;
case com.google.javascript.rhino.head.Token.TRUE:
return Token.TRUE;
case com.google.javascript.rhino.head.Token.SHEQ:
return Token.SHEQ;
case com.google.javascript.rhino.head.Token.SHNE:
return Token.SHNE;
case com.google.javascript.rhino.head.Token.REGEXP:
return Token.REGEXP;
case com.google.javascript.rhino.head.Token.THROW:
return Token.THROW;
case com.google.javascript.rhino.head.Token.IN:
return Token.IN;
case com.google.javascript.rhino.head.Token.INSTANCEOF:
return Token.INSTANCEOF;
case com.google.javascript.rhino.head.Token.ARRAYLIT:
return Token.ARRAYLIT;
case com.google.javascript.rhino.head.Token.OBJECTLIT:
return Token.OBJECTLIT;
case com.google.javascript.rhino.head.Token.TRY:
return Token.TRY;
// The LP represents a parameter list
case com.google.javascript.rhino.head.Token.LP:
return Token.PARAM_LIST;
case com.google.javascript.rhino.head.Token.COMMA:
return Token.COMMA;
case com.google.javascript.rhino.head.Token.ASSIGN:
return Token.ASSIGN;
case com.google.javascript.rhino.head.Token.ASSIGN_BITOR:
return Token.ASSIGN_BITOR;
case com.google.javascript.rhino.head.Token.ASSIGN_BITXOR:
return Token.ASSIGN_BITXOR;
case com.google.javascript.rhino.head.Token.ASSIGN_BITAND:
return Token.ASSIGN_BITAND;
case com.google.javascript.rhino.head.Token.ASSIGN_LSH:
return Token.ASSIGN_LSH;
case com.google.javascript.rhino.head.Token.ASSIGN_RSH:
return Token.ASSIGN_RSH;
case com.google.javascript.rhino.head.Token.ASSIGN_URSH:
return Token.ASSIGN_URSH;
case com.google.javascript.rhino.head.Token.ASSIGN_ADD:
return Token.ASSIGN_ADD;
case com.google.javascript.rhino.head.Token.ASSIGN_SUB:
return Token.ASSIGN_SUB;
case com.google.javascript.rhino.head.Token.ASSIGN_MUL:
return Token.ASSIGN_MUL;
case com.google.javascript.rhino.head.Token.ASSIGN_DIV:
return Token.ASSIGN_DIV;
case com.google.javascript.rhino.head.Token.ASSIGN_MOD:
return Token.ASSIGN_MOD;
case com.google.javascript.rhino.head.Token.HOOK:
return Token.HOOK;
case com.google.javascript.rhino.head.Token.OR:
return Token.OR;
case com.google.javascript.rhino.head.Token.AND:
return Token.AND;
case com.google.javascript.rhino.head.Token.INC:
return Token.INC;
case com.google.javascript.rhino.head.Token.DEC:
return Token.DEC;
case com.google.javascript.rhino.head.Token.FUNCTION:
return Token.FUNCTION;
case com.google.javascript.rhino.head.Token.IF:
return Token.IF;
case com.google.javascript.rhino.head.Token.SWITCH:
return Token.SWITCH;
case com.google.javascript.rhino.head.Token.CASE:
return Token.CASE;
case com.google.javascript.rhino.head.Token.DEFAULT:
return Token.DEFAULT_CASE;
case com.google.javascript.rhino.head.Token.WHILE:
return Token.WHILE;
case com.google.javascript.rhino.head.Token.DO:
return Token.DO;
case com.google.javascript.rhino.head.Token.FOR:
return Token.FOR;
case com.google.javascript.rhino.head.Token.BREAK:
return Token.BREAK;
case com.google.javascript.rhino.head.Token.CONTINUE:
return Token.CONTINUE;
case com.google.javascript.rhino.head.Token.VAR:
return Token.VAR;
case com.google.javascript.rhino.head.Token.WITH:
return Token.WITH;
case com.google.javascript.rhino.head.Token.CATCH:
return Token.CATCH;
case com.google.javascript.rhino.head.Token.VOID:
return Token.VOID;
case com.google.javascript.rhino.head.Token.EMPTY:
return Token.EMPTY;
case com.google.javascript.rhino.head.Token.BLOCK:
return Token.BLOCK;
case com.google.javascript.rhino.head.Token.LABEL:
return Token.LABEL;
case com.google.javascript.rhino.head.Token.EXPR_VOID:
case com.google.javascript.rhino.head.Token.EXPR_RESULT:
return Token.EXPR_RESULT;
case com.google.javascript.rhino.head.Token.SCRIPT:
return Token.SCRIPT;
case com.google.javascript.rhino.head.Token.GET:
return Token.GETTER_DEF;
case com.google.javascript.rhino.head.Token.SET:
return Token.SETTER_DEF;
case com.google.javascript.rhino.head.Token.CONST:
return Token.CONST;
case com.google.javascript.rhino.head.Token.DEBUGGER:
return Token.DEBUGGER;
}

// Token without name
throw new IllegalStateException(String.valueOf(token));
}"
Closure_42b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_42_buggy/src/com/google/javascript/jscomp/parsing/IRFactory.java,"private Node newNode(int type) {
return new Node(type).clonePropsFrom(templateNode);
}"
Closure_42b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_42_buggy/src/com/google/javascript/jscomp/parsing/IRFactory.java,"private Node transformBlock(AstNode node) {
Node irNode = transform(node);
if (!irNode.isBlock()) {
if (irNode.isEmpty()) {
irNode.setType(Token.BLOCK);
irNode.setWasEmptyNode(true);
} else {
Node newBlock = newNode(Token.BLOCK, irNode);
newBlock.setLineno(irNode.getLineno());
newBlock.setCharno(irNode.getCharno());
maybeSetLengthFrom(newBlock, node);
irNode = newBlock;
}
}
return irNode;
}"
Closure_42b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_42_buggy/src/com/google/javascript/jscomp/parsing/IRFactory.java,"private int position2charno(int position) {
int lineIndex = sourceString.lastIndexOf('\n', position);
if (lineIndex == -1) {
return position;
} else {
// Subtract one for initial position being 0.
return position - lineIndex - 1;
}
}"
Closure_42b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_42_buggy/src/com/google/javascript/jscomp/parsing/IRFactory.java,"private Node transformNameAsString(Name node) {
Node irNode = transformDispatcher.processName(node, true);
JSDocInfo jsDocInfo = handleJsDoc(node, irNode);
if (jsDocInfo != null) {
irNode.setJSDocInfo(jsDocInfo);
}
setSourceInfo(irNode, node);
return irNode;
}"
Closure_44b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_44_buggy/src/com/google/javascript/jscomp/CodeConsumer.java,"void appendOp(String op, boolean binOp) {
append(op);
}"
Closure_44b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_44_buggy/src/com/google/javascript/jscomp/CodeConsumer.java,Incomplete method body detected.
Closure_44b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_44_buggy/src/com/google/javascript/jscomp/CodeConsumer.java,"void addOp(String op, boolean binOp) {
maybeEndStatement();

char first = op.charAt(0);
char prev = getLastChar();

if ((first == '+' || first == '-') && prev == first) {
// This is not pretty printing. This is to prevent misparsing of
// things like ""x + ++y"" or ""x++ + ++y""
append("" "");
} else if (Character.isLetter(first) &&
isWordChar(prev)) {
// Make sure there is a space after e.g. instanceof , typeof
append("" "");
} else if (prev == '-' && first == '>') {
// Make sure that we don't emit -->
append("" "");
}

// Allow formating around the operator.
appendOp(op, binOp);

// Line breaking after an operator is always safe. Line breaking before an
// operator on the other hand is not. We only line break after a bin op
// because it looks strange.
if (binOp) {
maybeCutLine();
}
}"
Closure_44b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_44_buggy/src/com/google/javascript/jscomp/CodeConsumer.java,"void addIdentifier(String identifier) {
add(identifier);
}"
Closure_44b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_44_buggy/src/com/google/javascript/jscomp/CodeConsumer.java,"endStatement(false);
}

void endStatement(boolean needSemiColon) {"
Closure_46b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_46_buggy/src/com/google/javascript/rhino/jstype/RecordType.java,"public JSType getLeastSupertype(JSType that) {
if (!that.isRecordType()) {
return super.getLeastSupertype(that);
}
RecordTypeBuilder builder = new RecordTypeBuilder(registry);
for (String property : properties.keySet()) {
if (that.toMaybeRecordType().hasProperty(property) &&
that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(
getPropertyType(property))) {
builder.addProperty(property, getPropertyType(property),
getPropertyNode(property));
}
}
return builder.build();
}"
Closure_46b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_46_buggy/src/com/google/javascript/rhino/jstype/RecordType.java,"public boolean isEquivalentTo(JSType other) {
if (!other.isRecordType()) {
return false;
}

// Compare properties.
RecordType otherRecord = other.toMaybeRecordType();
if (otherRecord == this) {
return true;
}

Set<String> keySet = properties.keySet();
Map<String, JSType> otherProps = otherRecord.properties;
if (!otherProps.keySet().equals(keySet)) {
return false;
}
for (String key : keySet) {
if (!otherProps.get(key).isEquivalentTo(properties.get(key))) {
return false;
}
}
return true;
}"
Closure_46b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_46_buggy/src/com/google/javascript/rhino/jstype/RecordType.java,"public boolean isSubtype(JSType that) {
if (JSType.isSubtypeHelper(this, that)) {
return true;
}

// Top of the record types is the empty record, or OBJECT_TYPE.
if (registry.getNativeObjectType(
JSTypeNative.OBJECT_TYPE).isSubtype(that)) {
return true;
}

// A type is a subtype of a record type if it itself is a record
// type and it has at least the same members as the parent record type
// with the same types.
if (!that.isRecordType()) {
return false;
}

return RecordType.isSubtype(this, that.toMaybeRecordType());
}"
Closure_46b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_46_buggy/src/com/google/javascript/rhino/jstype/RecordType.java,"JSType getGreatestSubtypeHelper(JSType that) {
if (that.isRecordType()) {
RecordType thatRecord = that.toMaybeRecordType();
RecordTypeBuilder builder = new RecordTypeBuilder(registry);

// The greatest subtype consists of those *unique* properties of both
// record types. If any property conflicts, then the NO_TYPE type
// is returned.
for (String property : properties.keySet()) {
if (thatRecord.hasProperty(property) &&
!thatRecord.getPropertyType(property).isEquivalentTo(
getPropertyType(property))) {
return registry.getNativeObjectType(JSTypeNative.NO_TYPE);
}

builder.addProperty(property, getPropertyType(property),
getPropertyNode(property));
}

for (String property : thatRecord.properties.keySet()) {
if (!hasProperty(property)) {
builder.addProperty(property, thatRecord.getPropertyType(property),
thatRecord.getPropertyNode(property));
}
}

return builder.build();
}

JSType greatestSubtype = registry.getNativeType(
JSTypeNative.NO_OBJECT_TYPE);
JSType thatRestrictedToObj =
registry.getNativeType(JSTypeNative.OBJECT_TYPE)
.getGreatestSubtype(that);
if (!thatRestrictedToObj.isEmptyType()) {
// In this branch, the other type is some object type. We find
// the greatest subtype with the following algorithm:
// 1) For each property ""x"" of this record type, take the union
//    of all classes with a property ""x"" with a compatible property type.
//    and which are a subtype of {@code that}.
// 2) Take the intersection of all of these unions.
for (Map.Entry<String, JSType> entry : properties.entrySet()) {
String propName = entry.getKey();
JSType propType = entry.getValue();
UnionTypeBuilder builder = new UnionTypeBuilder(registry);
for (ObjectType alt :
registry.getEachReferenceTypeWithProperty(propName)) {
JSType altPropType = alt.getPropertyType(propName);
if (altPropType != null && !alt.isEquivalentTo(this) &&
alt.isSubtype(that) &&
(propType.isUnknownType() || altPropType.isUnknownType() ||
altPropType.isEquivalentTo(propType))) {
builder.addAlternate(alt);
}
}
greatestSubtype = greatestSubtype.getLeastSupertype(builder.build());
}
}
return greatestSubtype;
}"
Closure_46b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_46_buggy/src/com/google/javascript/rhino/jstype/RecordType.java,"RecordType toMaybeRecordType() {
return this;
}"
Closure_48b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_48_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"public Scope createScope(Node root, Scope parent) {
// Constructing the global scope is very different than constructing
// inner scopes, because only global scopes can contain named classes that
// show up in the type registry.
Scope newScope = null;
AbstractScopeBuilder scopeBuilder = null;
if (parent == null) {
// Run a first-order analysis over the syntax tree.
(new FirstOrderFunctionAnalyzer(compiler, functionAnalysisResults))
.process(root.getFirstChild(), root.getLastChild());

// Find all the classes in the global scope.
newScope = createInitialScope(root);

GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);
scopeBuilder = globalScopeBuilder;
NodeTraversal.traverse(compiler, root, scopeBuilder);
} else {
newScope = new Scope(parent, root);
LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);
scopeBuilder = localScopeBuilder;
localScopeBuilder.build();
}

scopeBuilder.resolveStubDeclarations();
scopeBuilder.resolveTypes();

// Gather the properties in each function that we found in the
// global scope, if that function has a @this type that we can
// build properties on.
for (Node functionNode : scopeBuilder.nonExternFunctions) {
JSType type = functionNode.getJSType();
if (type != null && type.isFunctionType()) {
FunctionType fnType = type.toMaybeFunctionType();
ObjectType fnThisType = fnType.getTypeOfThis();
if (!fnThisType.isUnknownType()) {
NodeTraversal.traverse(compiler, functionNode.getLastChild(),
scopeBuilder.new CollectProperties(fnThisType));
}
}
}

if (parent == null) {
codingConvention.defineDelegateProxyPrototypeProperties(
typeRegistry, newScope, delegateProxyPrototypes,
delegateCallingConventions);
}
return newScope;
}"
Closure_48b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_48_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"private AstFunctionContents getFunctionAnalysisResults(@Nullable Node n) {
if (n == null) {
return null;
}

// Sometimes this will return null in things like
// NameReferenceGraphConstruction that build partial scopes.
return functionAnalysisResults.get(n);
}"
Closure_48b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_48_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"return typeRegistry.getNativeType(nativeType);
}

private abstract class AbstractScopeBuilder
implements NodeTraversal.Callback {"
Closure_48b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_48_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"Scope createInitialScope(Node root) {

NodeTraversal.traverse(
compiler, root, new DiscoverEnumsAndTypedefs(typeRegistry));

Scope s = new Scope(root, compiler);
declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE);
declareNativeFunctionType(s, BOOLEAN_OBJECT_FUNCTION_TYPE);
declareNativeFunctionType(s, DATE_FUNCTION_TYPE);
declareNativeFunctionType(s, ERROR_FUNCTION_TYPE);
declareNativeFunctionType(s, EVAL_ERROR_FUNCTION_TYPE);
declareNativeFunctionType(s, FUNCTION_FUNCTION_TYPE);
declareNativeFunctionType(s, NUMBER_OBJECT_FUNCTION_TYPE);
declareNativeFunctionType(s, OBJECT_FUNCTION_TYPE);
declareNativeFunctionType(s, RANGE_ERROR_FUNCTION_TYPE);
declareNativeFunctionType(s, REFERENCE_ERROR_FUNCTION_TYPE);
declareNativeFunctionType(s, REGEXP_FUNCTION_TYPE);
declareNativeFunctionType(s, STRING_OBJECT_FUNCTION_TYPE);
declareNativeFunctionType(s, SYNTAX_ERROR_FUNCTION_TYPE);
declareNativeFunctionType(s, TYPE_ERROR_FUNCTION_TYPE);
declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE);
declareNativeValueType(s, ""undefined"", VOID_TYPE);

// ActiveXObject is unqiuely special, because it can be used to construct
// any type (the type that it creates is related to the arguments you
// pass to it).
declareNativeValueType(s, ""ActiveXObject"", NO_OBJECT_TYPE);

return s;
}"
Closure_48b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_48_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"private void declareNativeFunctionType(Scope scope, JSTypeNative tId) {
FunctionType t = typeRegistry.getNativeFunctionType(tId);
declareNativeType(scope, t.getInstanceType().getReferenceName(), t);
declareNativeType(
scope, t.getPrototype().getReferenceName(), t.getPrototype());
}"
Closure_50b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_50_buggy/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java,"private Node tryFoldArrayJoin(Node n) {
Node callTarget = n.getFirstChild();

if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {
return n;
}

Node right = callTarget.getNext();
if (right != null) {
if (!NodeUtil.isImmutableValue(right)) {
return n;
}
}

Node arrayNode = callTarget.getFirstChild();
Node functionName = arrayNode.getNext();

if ((arrayNode.getType() != Token.ARRAYLIT) ||
!functionName.getString().equals(""join"")) {
return n;
}

// "","" is the default, it doesn't need to be explicit

String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
List<Node> arrayFoldedChildren = Lists.newLinkedList();
StringBuilder sb = null;
int foldedSize = 0;
Node prev = null;
Node elem = arrayNode.getFirstChild();
// Merges adjacent String nodes.
while (elem != null) {
if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {
if (sb == null) {
sb = new StringBuilder();
} else {
sb.append(joinString);
}
sb.append(NodeUtil.getArrayElementStringValue(elem));
} else {
if (sb != null) {
Preconditions.checkNotNull(prev);
// + 2 for the quotes.
foldedSize += sb.length() + 2;
arrayFoldedChildren.add(
Node.newString(sb.toString()).copyInformationFrom(prev));
sb = null;
}
foldedSize += InlineCostEstimator.getCost(elem);
arrayFoldedChildren.add(elem);
}
prev = elem;
elem = elem.getNext();
}

if (sb != null) {
Preconditions.checkNotNull(prev);
// + 2 for the quotes.
foldedSize += sb.length() + 2;
arrayFoldedChildren.add(
Node.newString(sb.toString()).copyInformationFrom(prev));
}
// one for each comma.
foldedSize += arrayFoldedChildren.size() - 1;

int originalSize = InlineCostEstimator.getCost(n);
switch (arrayFoldedChildren.size()) {
case 0:
Node emptyStringNode = Node.newString("""");
n.getParent().replaceChild(n, emptyStringNode);
reportCodeChange();
return emptyStringNode;
case 1:
Node foldedStringNode = arrayFoldedChildren.remove(0);
if (foldedSize > originalSize) {
return n;
}
arrayNode.detachChildren();
if (foldedStringNode.getType() != Token.STRING) {
// If the Node is not a string literal, ensure that
// it is coerced to a string.
Node replacement = new Node(Token.ADD,
Node.newString("""").copyInformationFrom(n),
foldedStringNode);
foldedStringNode = replacement;
}
n.getParent().replaceChild(n, foldedStringNode);
reportCodeChange();
return foldedStringNode;
default:
// No folding could actually be performed.
if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
return n;
}
int kJoinOverhead = ""[].join()"".length();
foldedSize += kJoinOverhead;
foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;
if (foldedSize > originalSize) {
return n;
}
arrayNode.detachChildren();
for (Node node : arrayFoldedChildren) {
arrayNode.addChildToBack(node);
}
reportCodeChange();
break;
}

return n;
}"
Closure_50b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_50_buggy/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java,"private Node tryFoldKnownStringMethods(Node subtree) {
Preconditions.checkArgument(subtree.getType() == Token.CALL);

// check if this is a call on a string method
// then dispatch to specific folding method.
Node callTarget = subtree.getFirstChild();
if (callTarget == null) {
return subtree;
}

if (!NodeUtil.isGet(callTarget)) {
return subtree;
}

Node stringNode = callTarget.getFirstChild();
Node functionName = stringNode.getNext();

if ((stringNode.getType() != Token.STRING) ||
(functionName.getType() != Token.STRING)) {
return subtree;
}

String functionNameString = functionName.getString();
Node firstArg = callTarget.getNext();
if (firstArg == null) {
if (functionNameString.equals(""toLowerCase"")) {
subtree = tryFoldStringToLowerCase(subtree, stringNode);
} else if (functionNameString.equals(""toUpperCase"")) {
subtree = tryFoldStringToUpperCase(subtree, stringNode);
}
return subtree;
} else if (NodeUtil.isImmutableValue(firstArg)) {
if (functionNameString.equals(""indexOf"") ||
functionNameString.equals(""lastIndexOf"")) {
subtree = tryFoldStringIndexOf(subtree, functionNameString,
stringNode, firstArg);
} else if (functionNameString.equals(""substr"")) {
subtree = tryFoldStringSubstr(subtree, stringNode, firstArg);
} else if (functionNameString.equals(""substring"")) {
subtree = tryFoldStringSubstring(subtree, stringNode, firstArg);
} else if (functionNameString.equals(""charAt"")) {
subtree = tryFoldStringCharAt(subtree, stringNode, firstArg);
} else if (functionNameString.equals(""charCodeAt"")) {
subtree = tryFoldStringCharCodeAt(subtree, stringNode, firstArg);
}
}

return subtree;
}"
Closure_50b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_50_buggy/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java,"Node optimizeSubtree(Node subtree) {
if (NodeUtil.isCall(subtree) ){
return tryFoldKnownMethods(subtree);
}
return subtree;
}"
Closure_50b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_50_buggy/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java,"private Node tryFoldKnownMethods(Node subtree) {
// For now we only support string methods .join(),
// .indexOf(), .substring() and .substr()
// and numeric methods parseInt() and parseFloat().

subtree = tryFoldArrayJoin(subtree);

if (subtree.getType() == Token.CALL) {
Node callTarget = subtree.getFirstChild();
if (callTarget == null) {
return subtree;
}

if (NodeUtil.isGet(callTarget)) {
subtree = tryFoldKnownStringMethods(subtree);
} else {
subtree = tryFoldKnownNumericMethods(subtree);
}
}

return subtree;
}"
Closure_51b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_51_buggy/src/com/google/javascript/jscomp/CodeConsumer.java,"void appendOp(String op, boolean binOp) {
append(op);
}"
Closure_51b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_51_buggy/src/com/google/javascript/jscomp/CodeConsumer.java,"void addNumber(double x) {
// This is not pretty printing. This is to prevent misparsing of x- -4 as
// x--4 (which is a syntax error).
char prev = getLastChar();
if (x < 0 && prev == '-') {
add("" "");
}

if ((long) x == x) {
long value = (long) x;
long mantissa = value;
int exp = 0;
if (Math.abs(x) >= 100) {
while (mantissa / 10 * Math.pow(10, exp + 1) == value) {
mantissa /= 10;
exp++;
}
}
if (exp > 2) {
add(Long.toString(mantissa) + ""E"" + Integer.toString(exp));
} else {
add(Long.toString(value));
}
} else {
add(String.valueOf(x));
}

}"
Closure_51b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_51_buggy/src/com/google/javascript/jscomp/CodeConsumer.java,Incomplete method body detected.
Closure_51b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_51_buggy/src/com/google/javascript/jscomp/CodeConsumer.java,"void addOp(String op, boolean binOp) {
maybeEndStatement();

char first = op.charAt(0);
char prev = getLastChar();

if ((first == '+' || first == '-') && prev == first) {
// This is not pretty printing. This is to prevent misparsing of
// things like ""x + ++y"" or ""x++ + ++y""
append("" "");
} else if (Character.isLetter(first) &&
isWordChar(prev)) {
// Make sure there is a space after e.g. instanceof , typeof
append("" "");
} else if (prev == '-' && first == '>') {
// Make sure that we don't emit -->
append("" "");
}

// Allow formating around the operator.
appendOp(op, binOp);

// Line breaking after an operator is always safe. Line breaking before an
// operator on the other hand is not. We only line break after a bin op
// because it looks strange.
if (binOp) {
maybeCutLine();
}
}"
Closure_51b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_51_buggy/src/com/google/javascript/jscomp/CodeConsumer.java,"void addIdentifier(String identifier) {
add(identifier);
}"
Closure_52b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_52_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"static double getSimpleNumber(String s) {
if (isSimpleNumber(s)) {
try {
long l = Long.parseLong(s);
if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) {
return l;
}
} catch (NumberFormatException e) {
// The number was too long to parse. Fall through to NaN.
}
}
return Double.NaN;
}"
Closure_52b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_52_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"static boolean isSimpleNumber(String s) {
int len = s.length();
for (int index = 0; index < len; index++) {
char c = s.charAt(index);
if (c < '0' || c > '9') {
return false;
}
}
return len > 0;
}"
Closure_52b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_52_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"addExpr(n, minPrecedence, Context.OTHER);
}

private void addExpr(Node n, int minPrecedence, Context context) {"
Closure_52b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_52_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"cc.add(str);
}

private void addIdentifier(String identifier) {"
Closure_52b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_52_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"cc.addIdentifier(identifierEscape(identifier));
}

void add(Node n) {"
Closure_53b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_53_buggy/src/com/google/javascript/jscomp/InlineObjectLiterals.java,"InlineObjectLiterals(
AbstractCompiler compiler,"
Closure_53b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_53_buggy/src/com/google/javascript/jscomp/InlineObjectLiterals.java,"public void process(Node externs, Node root) {
ReferenceCollectingCallback callback = new ReferenceCollectingCallback(
compiler, new InliningBehavior());
callback.process(externs, root);
}"
Closure_55b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_55_buggy/src/com/google/javascript/jscomp/FunctionRewriter.java,"public void process(Node externs, Node root) {
List<Reducer> reducers = ImmutableList.of(new ReturnConstantReducer(),
new GetterReducer(),
new SetterReducer(),
new EmptyFunctionReducer(),
new IdentityReducer());

Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();

// Accumulate possible reductions in the reduction multi map.  They
// will be applied in the loop below.
NodeTraversal.traverse(compiler, root,
new ReductionGatherer(reducers, reductionMap));

// Apply reductions iff they will provide some savings.
for (Reducer reducer : reducers) {
Collection<Reduction> reductions = reductionMap.get(reducer);
if (reductions.isEmpty()) {
continue;
}

Node helperCode = parseHelperCode(reducer);
if (helperCode == null) {
continue;
}

int helperCodeCost = InlineCostEstimator.getCost(helperCode);

// Estimate savings
int savings = 0;
for (Reduction reduction : reductions) {
savings += reduction.estimateSavings();
}

// Compare estimated savings against the helper cost.  Apply
// reductions if doing so will result in some savings.
if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) {
for (Reduction reduction : reductions) {
reduction.apply();
}

Node addingRoot = compiler.getNodeForCodeInsertion(null);
addingRoot.addChildrenToFront(helperCode);
compiler.reportCodeChange();
}
}
}"
Closure_55b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_55_buggy/src/com/google/javascript/jscomp/FunctionRewriter.java,"FunctionRewriter(AbstractCompiler compiler) {
this.compiler = compiler;
}"
Closure_55b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_55_buggy/src/com/google/javascript/jscomp/FunctionRewriter.java,"private static boolean isReduceableFunctionExpression(Node n) {
return NodeUtil.isFunctionExpression(n);
}"
Closure_56b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_56_buggy/src/com/google/javascript/jscomp/SourceFile.java,"public String getLine(int lineNumber) {
String js = """";
try {
// NOTE(nicksantos): Right now, this is optimized for few warnings.
// This is probably the right trade-off, but will be slow if there
// are lots of warnings in one file.
js = getCode();
} catch (IOException e) {
return null;
}

int pos = 0;
int startLine = 1;

// If we've saved a previous offset and it's for a line less than the
// one we're searching for, then start at that point.
if (lineNumber >= lastLine) {
pos = lastOffset;
startLine = lastLine;
}

for (int n = startLine; n < lineNumber; n++) {
int nextpos = js.indexOf('\n', pos);
if (nextpos == -1) {
return null;
}
pos = nextpos + 1;
}

// Remember this offset for the next search we do.
lastOffset = pos;
lastLine = lineNumber;

if (js.indexOf('\n', pos) == -1) {
// If next new line cannot be found, there are two cases
// 1. pos already reaches the end of file, then null should be returned
// 2. otherwise, return the contents between pos and the end of file.
return null;
} else {
return js.substring(pos, js.indexOf('\n', pos));
}
}"
Closure_56b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_56_buggy/src/com/google/javascript/jscomp/SourceFile.java,"public String getCode() throws IOException {
return code;
}"
Closure_56b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_56_buggy/src/com/google/javascript/jscomp/SourceFile.java,"private void setCode(String sourceCode) {
code = sourceCode;
}"
Closure_56b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_56_buggy/src/com/google/javascript/jscomp/SourceFile.java,"public void setOriginalPath(String originalPath) {
this.originalPath = originalPath;
}"
Closure_56b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_56_buggy/src/com/google/javascript/jscomp/SourceFile.java,"public String getName() {
return fileName;
}"
Closure_57b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_57_buggy/src/com/google/javascript/jscomp/ClosureCodingConvention.java,"public String extractClassNameIfRequire(Node node, Node parent){
return extractClassNameIfGoog(node, parent, ""goog.require"");
}"
Closure_57b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_57_buggy/src/com/google/javascript/jscomp/ClosureCodingConvention.java,"private static String extractClassNameIfGoog(Node node, Node parent,
String functionName){
String className = null;
if (NodeUtil.isExprCall(parent)) {
Node callee = node.getFirstChild();
if (callee != null && callee.getType() == Token.GETPROP) {
String qualifiedName = callee.getQualifiedName();
if (functionName.equals(qualifiedName)) {
Node target = callee.getNext();
if (target != null) {
className = target.getString();
}
}
}
}
return className;
}"
Closure_58b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_58_buggy/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java,"private void computeGenKill(Node n, BitSet gen, BitSet kill,
boolean conditional) {

switch (n.getType()) {
case Token.SCRIPT:
case Token.BLOCK:
case Token.FUNCTION:
return;

case Token.WHILE:
case Token.DO:
case Token.IF:
computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
conditional);
return;

case Token.FOR:
if (!NodeUtil.isForIn(n)) {
computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,
conditional);
} else {
// for(x in y) {...}
Node lhs = n.getFirstChild();
Node rhs = lhs.getNext();
if (NodeUtil.isVar(lhs)) {
// for(var x in y) {...}
lhs = lhs.getLastChild();
}
addToSetIfLocal(lhs, kill);
addToSetIfLocal(lhs, gen);
computeGenKill(rhs, gen, kill, conditional);
}
return;

case Token.VAR:
for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
if (c.hasChildren()) {
computeGenKill(c.getFirstChild(), gen, kill, conditional);
if (!conditional) {
addToSetIfLocal(c, kill);
}
}
}
return;

case Token.AND:
case Token.OR:
computeGenKill(n.getFirstChild(), gen, kill, conditional);
// May short circuit.
computeGenKill(n.getLastChild(), gen, kill, true);
return;

case Token.HOOK:
computeGenKill(n.getFirstChild(), gen, kill, conditional);
// Assume both sides are conditional.
computeGenKill(n.getFirstChild().getNext(), gen, kill, true);
computeGenKill(n.getLastChild(), gen, kill, true);
return;

case Token.NAME:
if (isArgumentsName(n)) {
markAllParametersEscaped();
} else {
addToSetIfLocal(n, gen);
}
return;

default:
if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {
Node lhs = n.getFirstChild();
if (!conditional) {
addToSetIfLocal(lhs, kill);
}
if (!NodeUtil.isAssign(n)) {
// assignments such as a += 1 reads a.
addToSetIfLocal(lhs, gen);
}
computeGenKill(lhs.getNext(), gen, kill, conditional);
} else {
for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
computeGenKill(c, gen, kill, conditional);
}
}
return;
}
}"
Closure_58b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_58_buggy/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java,"LiveVariablesAnalysis(ControlFlowGraph<Node> cfg, Scope jsScope,
AbstractCompiler compiler) {
super(cfg, new LiveVariableJoinOp());
this.jsScope = jsScope;
this.escaped = Sets.newHashSet();
computeEscaped(jsScope, escaped, compiler);
}"
Closure_58b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_58_buggy/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java,"boolean isForward() {
return false;
}"
Closure_58b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_58_buggy/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java,"LiveVariableLattice createInitialEstimateLattice() {
return new LiveVariableLattice(jsScope.getVarCount());
}"
Closure_58b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_58_buggy/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java,"private void addToSetIfLocal(Node node, BitSet set) {
Preconditions.checkState(NodeUtil.isName(node));
String name = node.getString();
if (!jsScope.isDeclared(name, false)) {
return;
}
Var var = jsScope.getVar(name);
if (!escaped.contains(var)) {
set.set(var.index);
}
}"
Closure_59b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_59_buggy/src/com/google/javascript/jscomp/Compiler.java,"public void initOptions(CompilerOptions options) {
    this.options = options;
    if (errorManager == null) {
      if (outStream == null) {
        setErrorManager(
            new LoggerErrorManager(createMessageFormatter(), logger));
      } else {
        PrintStreamErrorManager printer =
            new PrintStreamErrorManager(createMessageFormatter(), outStream);
        printer.setSummaryDetailLevel(options.summaryDetailLevel);
        setErrorManager(printer);
      }
    }

    // DiagnosticGroups override the plain checkTypes option.
    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {
      options.checkTypes = true;
    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {
      options.checkTypes = false;
    } else if (!options.checkTypes) {
      // If DiagnosticGroups did not override the plain checkTypes
      // option, and checkTypes is enabled, then turn off the
      // parser type warnings.
      options.setWarningLevel(
          DiagnosticGroup.forType(
              RhinoErrorReporter.TYPE_PARSE_ERROR),
          CheckLevel.OFF);
    }

    if (options.checkGlobalThisLevel.isOn()) {
      options.setWarningLevel(
          DiagnosticGroups.GLOBAL_THIS,
          options.checkGlobalThisLevel);
    }

    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {
      options.setWarningLevel(
          DiagnosticGroups.ES5_STRICT,
          CheckLevel.ERROR);
    }

    // Initialize the warnings guard.
    List<WarningsGuard> guards = Lists.newArrayList();
    guards.add(
        new SuppressDocWarningsGuard(
            getDiagnosticGroups().getRegisteredGroups()));
    guards.add(options.getWarningsGuard());

    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);

    // All passes must run the variable check. This synthesizes
    // variables later so that the compiler doesn't crash. It also
    // checks the externs file for validity. If you don't want to warn
    // about missing variable declarations, we shut that specific
    // error off.
    if (!options.checkSymbols &&
        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {
      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(
          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));
    }

    this.warningsGuard = composedGuards;
  }"
Closure_61b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_61_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static boolean functionCallHasSideEffects(
Node callNode, @Nullable AbstractCompiler compiler) {
if (callNode.getType() != Token.CALL) {
throw new IllegalStateException(
""Expected CALL node, got "" + Token.name(callNode.getType()));
}

if (callNode.isNoSideEffectsCall()) {
return false;
}

Node nameNode = callNode.getFirstChild();

// Built-in functions with no side effects.
if (nameNode.getType() == Token.NAME) {
String name = nameNode.getString();
if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {
return false;
}
} else if (nameNode.getType() == Token.GETPROP) {
if (callNode.hasOneChild()
&& OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(
nameNode.getLastChild().getString())) {
return false;
}

if (callNode.isOnlyModifiesThisCall()
&& evaluatesToLocalValue(nameNode.getFirstChild())) {
return false;
}

// Functions in the ""Math"" namespace have no side effects.

if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
if (nameNode.getFirstChild().getType() == Token.REGEXP
&& REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {
return false;
} else if (nameNode.getFirstChild().getType() == Token.STRING
&& STRING_REGEXP_METHODS.contains(
nameNode.getLastChild().getString())) {
Node param = nameNode.getNext();
if (param != null &&
(param.getType() == Token.STRING
|| param.getType() == Token.REGEXP))
return false;
}
}
}

return true;
}"
Closure_61b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_61_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"private static boolean checkForStateChangeHelper(
Node n, boolean checkForNewObjects, AbstractCompiler compiler) {
// Rather than id which ops may have side effects, id the ones
// that we know to be safe
switch (n.getType()) {
// other side-effect free statements and expressions
case Token.AND:
case Token.BLOCK:
case Token.EXPR_RESULT:
case Token.HOOK:
case Token.IF:
case Token.IN:
case Token.LP:
case Token.NUMBER:
case Token.OR:
case Token.THIS:
case Token.TRUE:
case Token.FALSE:
case Token.NULL:
case Token.STRING:
case Token.SWITCH:
case Token.TRY:
case Token.EMPTY:
break;

// Throws are by definition side effects
case Token.THROW:
return true;

case Token.OBJECTLIT:
if (checkForNewObjects) {
return true;
}
for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
if (checkForStateChangeHelper(
c.getFirstChild(), checkForNewObjects, compiler)) {
return true;
}
}
return false;

case Token.ARRAYLIT:
case Token.REGEXP:
if (checkForNewObjects) {
return true;
}
break;

case Token.VAR:    // empty var statement (no declaration)
case Token.NAME:   // variable by itself
if (n.getFirstChild() != null) {
return true;
}
break;

case Token.FUNCTION:
// Function expressions don't have side-effects, but function
// declarations change the namespace. Either way, we don't need to
// check the children, since they aren't executed at declaration time.
return checkForNewObjects || !isFunctionExpression(n);

case Token.NEW:
if (checkForNewObjects) {
return true;
}

if (!constructorCallHasSideEffects(n)) {
// loop below will see if the constructor parameters have
// side-effects
break;
}
return true;

case Token.CALL:
// calls to functions that have no side effects have the no
// side effect property set.
if (!functionCallHasSideEffects(n, compiler)) {
// loop below will see if the function parameters have
// side-effects
break;
}
return true;

default:
if (isSimpleOperatorType(n.getType())) {
break;
}

if (isAssignmentOp(n)) {
Node assignTarget = n.getFirstChild();
if (isName(assignTarget)) {
return true;
}

// Assignments will have side effects if
// a) The RHS has side effects, or
// b) The LHS has side effects, or
// c) A name on the LHS will exist beyond the life of this statement.
if (checkForStateChangeHelper(
n.getFirstChild(), checkForNewObjects, compiler) ||
checkForStateChangeHelper(
n.getLastChild(), checkForNewObjects, compiler)) {
return true;
}

if (isGet(assignTarget)) {
// If the object being assigned to is a local object, don't
// consider this a side-effect as it can't be referenced
// elsewhere.  Don't do this recursively as the property might
// be an alias of another object, unlike a literal below.
Node current = assignTarget.getFirstChild();
if (evaluatesToLocalValue(current)) {
return false;
}

// A literal value as defined by ""isLiteralValue"" is guaranteed
// not to be an alias, or any components which are aliases of
// other objects.
// If the root object is a literal don't consider this a
// side-effect.
while (isGet(current)) {
current = current.getFirstChild();
}

return !isLiteralValue(current, true);
} else {
// TODO(johnlenz): remove this code and make this an exception. This
// is here only for legacy reasons, the AST is not valid but
// preserve existing behavior.
return !isLiteralValue(assignTarget, true);
}
}

return true;
}

for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {
return true;
}
}

return false;
}"
Closure_61b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_61_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"return nodeTypeMayHaveSideEffects(n, null);
}

static boolean nodeTypeMayHaveSideEffects(Node n, AbstractCompiler compiler) {"
Closure_61b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_61_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static boolean isGet(Node n) {
return n.getType() == Token.GETPROP
|| n.getType() == Token.GETELEM;
}"
Closure_61b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_61_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static int precedence(int type) {
switch (type) {
case Token.COMMA:  return 0;
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_ADD:
case Token.ASSIGN_SUB:
case Token.ASSIGN_MUL:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
case Token.ASSIGN: return 1;
case Token.HOOK:   return 2;  // ?: operator
case Token.OR:     return 3;
case Token.AND:    return 4;
case Token.BITOR:  return 5;
case Token.BITXOR: return 6;
case Token.BITAND: return 7;
case Token.EQ:
case Token.NE:
case Token.SHEQ:
case Token.SHNE:   return 8;
case Token.LT:
case Token.GT:
case Token.LE:
case Token.GE:
case Token.INSTANCEOF:
case Token.IN:     return 9;
case Token.LSH:
case Token.RSH:
case Token.URSH:   return 10;
case Token.SUB:
case Token.ADD:    return 11;
case Token.MUL:
case Token.MOD:
case Token.DIV:    return 12;
case Token.INC:
case Token.DEC:
case Token.NEW:
case Token.DELPROP:
case Token.TYPEOF:
case Token.VOID:
case Token.NOT:
case Token.BITNOT:
case Token.POS:
case Token.NEG:    return 13;

case Token.CALL:
case Token.GETELEM:
case Token.GETPROP:
// Data values
case Token.ARRAYLIT:
case Token.EMPTY:  // TODO(johnlenz): remove this.
case Token.FALSE:
case Token.FUNCTION:
case Token.NAME:
case Token.NULL:
case Token.NUMBER:
case Token.OBJECTLIT:
case Token.REGEXP:
case Token.STRING:
case Token.THIS:
case Token.TRUE:
return 15;

default: throw new Error(""Unknown precedence for "" +
Node.tokenToName(type) +
"" (type "" + type + "")"");
}
}"
Closure_62b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_62_buggy/src/com/google/javascript/jscomp/LightweightMessageFormatter.java,"public LightweightMessageFormatter(SourceExcerptProvider source) {
this(source, LINE);
}"
Closure_62b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_62_buggy/src/com/google/javascript/jscomp/LightweightMessageFormatter.java,"public String formatError(JSError error) {
return format(error, false);
}"
Closure_62b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_62_buggy/src/com/google/javascript/jscomp/LightweightMessageFormatter.java,"private String format(JSError error, boolean warning) {
// extract source excerpt
SourceExcerptProvider source = getSource();
String sourceExcerpt = source == null ? null :
excerpt.get(
source, error.sourceName, error.lineNumber, excerptFormatter);

// formatting the message
StringBuilder b = new StringBuilder();
if (error.sourceName != null) {
b.append(error.sourceName);
if (error.lineNumber > 0) {
b.append(':');
b.append(error.lineNumber);
}
b.append("": "");
}

b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));
b.append("" - "");

b.append(error.description);
b.append('\n');
if (sourceExcerpt != null) {
b.append(sourceExcerpt);
b.append('\n');
int charno = error.getCharno();

// padding equal to the excerpt and arrow at the end
// charno == sourceExpert.length() means something is missing
// at the end of the line
if (excerpt.equals(LINE)
&& 0 <= charno && charno < sourceExcerpt.length()) {
for (int i = 0; i < charno; i++) {
char c = sourceExcerpt.charAt(i);
if (Character.isWhitespace(c)) {
b.append(c);
} else {
b.append(' ');
}
}
b.append(""^\n"");
}
}
return b.toString();
}"
Closure_65b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_65_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"static String strEscape(String s, char quote,
String doublequoteEscape,"
Closure_65b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_65_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"String jsString(String s) {
int singleq = 0, doubleq = 0;

// could count the quotes and pick the optimal quote character
for (int i = 0; i < s.length(); i++) {
switch (s.charAt(i)) {
case '""': doubleq++; break;
case '\'': singleq++; break;
}
}

String doublequote, singlequote;
char quote;
if (singleq < doubleq) {
// more double quotes so escape the single quotes
quote = '\'';
doublequote = ""\"""";
singlequote = ""\\\'"";
} else {
// more single quotes so escape the doubles
quote = '\""';
doublequote = ""\\\"""";
singlequote = ""\'"";
}

return strEscape(s, quote, doublequote, singlequote, ""\\\\"",
outputCharsetEncoder);
}"
Closure_65b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_65_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"void addJsString(String s) {
String cached = ESCAPED_JS_STRINGS.get(s);
if (cached == null) {
cached = jsString(s);
ESCAPED_JS_STRINGS.put(s, cached);
}
add(cached);
}"
Closure_65b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_65_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"cc.add(str);
}

private void addIdentifier(String identifier) {"
Closure_65b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_65_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"cc.addIdentifier(identifierEscape(identifier));
}

void add(Node n) {"
Closure_66b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_66_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"double getTypedPercent() {
int total = nullCount + unknownCount + typedCount;
if (total == 0) {
return 0.0;
} else {
return (100.0 * typedCount) / total;
}
}"
Closure_66b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_66_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"private void visitAssign(NodeTraversal t, Node assign) {
JSDocInfo info = assign.getJSDocInfo();
Node lvalue = assign.getFirstChild();
Node rvalue = assign.getLastChild();

if (lvalue.getType() == Token.GETPROP) {
Node object = lvalue.getFirstChild();
JSType objectJsType = getJSType(object);
String property = lvalue.getLastChild().getString();

// the first name in this getprop refers to an interface
// we perform checks in addition to the ones below
if (object.getType() == Token.GETPROP) {
JSType jsType = getJSType(object.getFirstChild());
if (jsType.isInterface() &&
object.getLastChild().getString().equals(""prototype"")) {
visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);
}
}

// /** @type ... */object.name = ...;
if (info != null && info.hasType()) {
visitAnnotatedAssignGetprop(t, assign,
info.getType().evaluate(t.getScope(), typeRegistry), object,
property, rvalue);
return;
}

// /** @enum ... */object.name = ...;
if (info != null && info.hasEnumParameterType()) {
checkEnumInitializer(
t, rvalue, info.getEnumParameterType().evaluate(
t.getScope(), typeRegistry));
return;
}

// object.prototype = ...;
if (property.equals(""prototype"")) {
if (objectJsType instanceof FunctionType) {
FunctionType functionType = (FunctionType) objectJsType;
if (functionType.isConstructor()) {
JSType rvalueType = rvalue.getJSType();
validator.expectObject(t, rvalue, rvalueType,
OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);
}
} else {
// TODO(user): might want to flag that
}
return;
}

// object.prototype.property = ...;
if (object.getType() == Token.GETPROP) {
Node object2 = object.getFirstChild();
String property2 = NodeUtil.getStringValue(object.getLastChild());

if (""prototype"".equals(property2)) {
JSType jsType = object2.getJSType();
if (jsType instanceof FunctionType) {
FunctionType functionType = (FunctionType) jsType;
if (functionType.isConstructor() || functionType.isInterface()) {
checkDeclaredPropertyInheritance(
t, assign, functionType, property, info, getJSType(rvalue));
}
} else {
// TODO(user): might want to flag that
}
return;
}
}

// object.property = ...;
ObjectType type = ObjectType.cast(
objectJsType.restrictByNotNullOrUndefined());
if (type != null) {
if (type.hasProperty(property) &&
!type.isPropertyTypeInferred(property) &&
!propertyIsImplicitCast(type, property)) {
validator.expectCanAssignToPropertyOf(
t, assign, getJSType(rvalue),
type.getPropertyType(property), object, property);
}
return;
}
} else if (lvalue.getType() == Token.NAME) {
// variable with inferred type case
JSType rvalueType = getJSType(assign.getLastChild());
Var var = t.getScope().getVar(lvalue.getString());
if (var != null) {
if (var.isTypeInferred()) {
return;
}
}
}

// fall through case
JSType leftType = getJSType(lvalue);
Node rightChild = assign.getLastChild();
JSType rightType = getJSType(rightChild);
if (validator.expectCanAssignTo(
t, assign, rightType, leftType, ""assignment"")) {
ensureTyped(t, assign, rightType);
} else {
ensureTyped(t, assign);
}
}"
Closure_66b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_66_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"private void doPercentTypedAccounting(NodeTraversal t, Node n) {
JSType type = n.getJSType();
if (type == null) {
nullCount++;
} else if (type.isUnknownType()) {
if (reportUnknownTypes.isOn()) {
compiler.report(
t.makeError(n, reportUnknownTypes, UNKNOWN_EXPR_TYPE));
}
unknownCount++;
} else {
typedCount++;
}
}"
Closure_66b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_66_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"private void visitObjLitKey(NodeTraversal t, Node key, Node objlit) {
// TODO(johnlenz): Validate get and set function declarations are valid
// as is the functions can have ""extraneous"" bits.

// For getter and setter property definitions the
// rvalue type != the property type.
Node rvalue = key.getFirstChild();
JSType rightType = NodeUtil.getObjectLitKeyTypeFromValueType(
key, getJSType(rvalue));
if (rightType == null) {
rightType = getNativeType(UNKNOWN_TYPE);
}

Node owner = objlit;

// Validate value is assignable to the key type.

JSType keyType = getJSType(key);
boolean valid = validator.expectCanAssignToPropertyOf(t, key,
rightType, keyType,
owner, NodeUtil.getObjectLitKeyName(key));
if (valid) {
ensureTyped(t, key, rightType);
} else {
ensureTyped(t, key);
}

// Validate that the key type is assignable to the object property type.
// This is necessary as the objlit may have been cast to a non-literal
// object type.
// TODO(johnlenz): consider introducing a CAST node to the AST (or
// perhaps a parentheses node).

JSType objlitType = getJSType(objlit);
ObjectType type = ObjectType.cast(
objlitType.restrictByNotNullOrUndefined());
if (type != null) {
String property = NodeUtil.getObjectLitKeyName(key);
if (type.hasProperty(property) &&
!type.isPropertyTypeInferred(property) &&
!propertyIsImplicitCast(type, property)) {
validator.expectCanAssignToPropertyOf(
t, key, keyType,
type.getPropertyType(property), owner, property);
}
return;
}
}"
Closure_66b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_66_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"public void visit(NodeTraversal t, Node n, Node parent) {
JSType childType;
JSType leftType, rightType;
Node left, right;
// To be explicitly set to false if the node is not typeable.
boolean typeable = true;

switch (n.getType()) {
case Token.NAME:
typeable = visitName(t, n, parent);
break;

case Token.LP:
// If this is under a FUNCTION node, it is a parameter list and can be
// ignored here.
if (parent.getType() != Token.FUNCTION) {
ensureTyped(t, n, getJSType(n.getFirstChild()));
} else {
typeable = false;
}
break;

case Token.COMMA:
ensureTyped(t, n, getJSType(n.getLastChild()));
break;

case Token.TRUE:
case Token.FALSE:
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.THIS:
ensureTyped(t, n, t.getScope().getTypeOfThis());
break;

case Token.REF_SPECIAL:
ensureTyped(t, n);
break;

case Token.GET_REF:
ensureTyped(t, n, getJSType(n.getFirstChild()));
break;

case Token.NULL:
ensureTyped(t, n, NULL_TYPE);
break;

case Token.NUMBER:
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.STRING:
// Object literal keys are handled with OBJECTLIT
if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
ensureTyped(t, n, STRING_TYPE);
// Object literal keys are not typeable
}
break;

case Token.GET:
case Token.SET:
// Object literal keys are handled with OBJECTLIT
break;

case Token.ARRAYLIT:
ensureTyped(t, n, ARRAY_TYPE);
break;

case Token.REGEXP:
ensureTyped(t, n, REGEXP_TYPE);
break;

case Token.GETPROP:
visitGetProp(t, n, parent);
typeable = !(parent.getType() == Token.ASSIGN &&
parent.getFirstChild() == n);
break;

case Token.GETELEM:
visitGetElem(t, n);
// The type of GETELEM is always unknown, so no point counting that.
// If that unknown leaks elsewhere (say by an assignment to another
// variable), then it will be counted.
typeable = false;
break;

case Token.VAR:
visitVar(t, n);
typeable = false;
break;

case Token.NEW:
visitNew(t, n);
typeable = true;
break;

case Token.CALL:
visitCall(t, n);
typeable = !NodeUtil.isExpressionNode(parent);
break;

case Token.RETURN:
visitReturn(t, n);
typeable = false;
break;

case Token.DEC:
case Token.INC:
left = n.getFirstChild();
validator.expectNumber(
t, left, getJSType(left), ""increment/decrement"");
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.NOT:
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.VOID:
ensureTyped(t, n, VOID_TYPE);
break;

case Token.TYPEOF:
ensureTyped(t, n, STRING_TYPE);
break;

case Token.BITNOT:
childType = getJSType(n.getFirstChild());
if (!childType.matchesInt32Context()) {
report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),
childType.toString());
}
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.POS:
case Token.NEG:
left = n.getFirstChild();
validator.expectNumber(t, left, getJSType(left), ""sign operator"");
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.EQ:
case Token.NE: {
leftType = getJSType(n.getFirstChild());
rightType = getJSType(n.getLastChild());

JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
TernaryValue result =
leftTypeRestricted.testForEquality(rightTypeRestricted);
if (result != TernaryValue.UNKNOWN) {
if (n.getType() == Token.NE) {
result = result.not();
}
report(t, n, DETERMINISTIC_TEST, leftType.toString(),
rightType.toString(), result.toString());
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;
}

case Token.SHEQ:
case Token.SHNE: {
leftType = getJSType(n.getFirstChild());
rightType = getJSType(n.getLastChild());

JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
if (!leftTypeRestricted.canTestForShallowEqualityWith(
rightTypeRestricted)) {
report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),
rightType.toString());
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;
}

case Token.LT:
case Token.LE:
case Token.GT:
case Token.GE:
leftType = getJSType(n.getFirstChild());
rightType = getJSType(n.getLastChild());
if (rightType.isNumber()) {
validator.expectNumber(
t, n, leftType, ""left side of numeric comparison"");
} else if (leftType.isNumber()) {
validator.expectNumber(
t, n, rightType, ""right side of numeric comparison"");
} else if (leftType.matchesNumberContext() &&
rightType.matchesNumberContext()) {
// OK.
} else {
// Whether the comparison is numeric will be determined at runtime
// each time the expression is evaluated. Regardless, both operands
// should match a string context.
String message = ""left side of comparison"";
validator.expectString(t, n, leftType, message);
validator.expectNotNullOrUndefined(
t, n, leftType, message, getNativeType(STRING_TYPE));
message = ""right side of comparison"";
validator.expectString(t, n, rightType, message);
validator.expectNotNullOrUndefined(
t, n, rightType, message, getNativeType(STRING_TYPE));
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.IN:
left = n.getFirstChild();
right = n.getLastChild();
leftType = getJSType(left);
rightType = getJSType(right);
validator.expectObject(t, n, rightType, ""'in' requires an object"");
validator.expectString(t, left, leftType, ""left side of 'in'"");
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.INSTANCEOF:
left = n.getFirstChild();
right = n.getLastChild();
leftType = getJSType(left);
rightType = getJSType(right).restrictByNotNullOrUndefined();

validator.expectAnyObject(
t, left, leftType, ""deterministic instanceof yields false"");
validator.expectActualObject(
t, right, rightType, ""instanceof requires an object"");
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.ASSIGN:
visitAssign(t, n);
typeable = false;
break;

case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_SUB:
case Token.ASSIGN_ADD:
case Token.ASSIGN_MUL:
case Token.LSH:
case Token.RSH:
case Token.URSH:
case Token.DIV:
case Token.MOD:
case Token.BITOR:
case Token.BITXOR:
case Token.BITAND:
case Token.SUB:
case Token.ADD:
case Token.MUL:
visitBinaryOperator(n.getType(), t, n);
break;

case Token.DELPROP:
if (!isReference(n.getFirstChild())) {
report(t, n, BAD_DELETE);
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.CASE:
JSType switchType = getJSType(parent.getFirstChild());
JSType caseType = getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t, n, switchType, caseType);
typeable = false;
break;

case Token.WITH: {
Node child = n.getFirstChild();
childType = getJSType(child);
validator.expectObject(
t, child, childType, ""with requires an object"");
typeable = false;
break;
}

case Token.FUNCTION:
visitFunction(t, n);
break;

// These nodes have no interesting type behavior.
case Token.LABEL:
case Token.LABEL_NAME:
case Token.SWITCH:
case Token.BREAK:
case Token.CATCH:
case Token.TRY:
case Token.SCRIPT:
case Token.EXPR_RESULT:
case Token.BLOCK:
case Token.EMPTY:
case Token.DEFAULT:
case Token.CONTINUE:
case Token.DEBUGGER:
case Token.THROW:
typeable = false;
break;

// These nodes require data flow analysis.
case Token.DO:
case Token.FOR:
case Token.IF:
case Token.WHILE:
typeable = false;
break;

// These nodes are typed during the type inference.
case Token.AND:
case Token.HOOK:
case Token.OBJECTLIT:
case Token.OR:
if (n.getJSType() != null) { // If we didn't run type inference.
ensureTyped(t, n);
} else {
// If this is an enum, then give that type to the objectlit as well.
if ((n.getType() == Token.OBJECTLIT)
&& (parent.getJSType() instanceof EnumType)) {
ensureTyped(t, n, parent.getJSType());
} else {
ensureTyped(t, n);
}
}
if (n.getType() == Token.OBJECTLIT) {
for (Node key : n.children()) {
visitObjLitKey(t, key, n);
}
}
break;

default:
report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
ensureTyped(t, n);
break;
}

// Don't count externs since the user's code may not even use that part.
typeable = typeable && !inExterns;

if (typeable) {
doPercentTypedAccounting(t, n);
}

checkNoTypeCheckSection(n, false);
}"
Closure_67b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_67_buggy/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java,"public void process(Node externRoot, Node root) {
if (!canModifyExterns) {
NodeTraversal.traverse(compiler, externRoot,
new ProcessExternProperties());
}

NodeTraversal.traverse(compiler, root, new ProcessProperties());

FixedPointGraphTraversal<NameInfo, JSModule> t =
FixedPointGraphTraversal.newTraversal(new PropagateReferences());
t.computeFixedPoint(symbolGraph,
Sets.newHashSet(externNode, globalNode));
}"
Closure_67b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_67_buggy/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java,"public Collection<NameInfo> getAllNameInfo() {
List<NameInfo> result = Lists.newArrayList(propertyNameInfo.values());
result.addAll(varNameInfo.values());
return result;
}"
Closure_69b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_69_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"public void visit(NodeTraversal t, Node n, Node parent) {
JSType childType;
JSType leftType, rightType;
Node left, right;
// To be explicitly set to false if the node is not typeable.
boolean typeable = true;

switch (n.getType()) {
case Token.NAME:
typeable = visitName(t, n, parent);
break;

case Token.LP:
// If this is under a FUNCTION node, it is a parameter list and can be
// ignored here.
if (parent.getType() != Token.FUNCTION) {
ensureTyped(t, n, getJSType(n.getFirstChild()));
} else {
typeable = false;
}
break;

case Token.COMMA:
ensureTyped(t, n, getJSType(n.getLastChild()));
break;

case Token.TRUE:
case Token.FALSE:
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.THIS:
ensureTyped(t, n, t.getScope().getTypeOfThis());
break;

case Token.REF_SPECIAL:
ensureTyped(t, n);
break;

case Token.GET_REF:
ensureTyped(t, n, getJSType(n.getFirstChild()));
break;

case Token.NULL:
ensureTyped(t, n, NULL_TYPE);
break;

case Token.NUMBER:
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.STRING:
// Object literal keys are handled with OBJECTLIT
if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
ensureTyped(t, n, STRING_TYPE);
}
break;

case Token.GET:
case Token.SET:
// Object literal keys are handled with OBJECTLIT
break;

case Token.ARRAYLIT:
ensureTyped(t, n, ARRAY_TYPE);
break;

case Token.REGEXP:
ensureTyped(t, n, REGEXP_TYPE);
break;

case Token.GETPROP:
visitGetProp(t, n, parent);
typeable = !(parent.getType() == Token.ASSIGN &&
parent.getFirstChild() == n);
break;

case Token.GETELEM:
visitGetElem(t, n);
// The type of GETELEM is always unknown, so no point counting that.
// If that unknown leaks elsewhere (say by an assignment to another
// variable), then it will be counted.
typeable = false;
break;

case Token.VAR:
visitVar(t, n);
typeable = false;
break;

case Token.NEW:
visitNew(t, n);
typeable = true;
break;

case Token.CALL:
visitCall(t, n);
typeable = !NodeUtil.isExpressionNode(parent);
break;

case Token.RETURN:
visitReturn(t, n);
typeable = false;
break;

case Token.DEC:
case Token.INC:
left = n.getFirstChild();
validator.expectNumber(
t, left, getJSType(left), ""increment/decrement"");
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.NOT:
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.VOID:
ensureTyped(t, n, VOID_TYPE);
break;

case Token.TYPEOF:
ensureTyped(t, n, STRING_TYPE);
break;

case Token.BITNOT:
childType = getJSType(n.getFirstChild());
if (!childType.matchesInt32Context()) {
report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),
childType.toString());
}
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.POS:
case Token.NEG:
left = n.getFirstChild();
validator.expectNumber(t, left, getJSType(left), ""sign operator"");
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.EQ:
case Token.NE: {
leftType = getJSType(n.getFirstChild());
rightType = getJSType(n.getLastChild());

JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
TernaryValue result =
leftTypeRestricted.testForEquality(rightTypeRestricted);
if (result != TernaryValue.UNKNOWN) {
if (n.getType() == Token.NE) {
result = result.not();
}
report(t, n, DETERMINISTIC_TEST, leftType.toString(),
rightType.toString(), result.toString());
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;
}

case Token.SHEQ:
case Token.SHNE: {
leftType = getJSType(n.getFirstChild());
rightType = getJSType(n.getLastChild());

JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
if (!leftTypeRestricted.canTestForShallowEqualityWith(
rightTypeRestricted)) {
report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),
rightType.toString());
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;
}

case Token.LT:
case Token.LE:
case Token.GT:
case Token.GE:
leftType = getJSType(n.getFirstChild());
rightType = getJSType(n.getLastChild());
if (rightType.isNumber()) {
validator.expectNumber(
t, n, leftType, ""left side of numeric comparison"");
} else if (leftType.isNumber()) {
validator.expectNumber(
t, n, rightType, ""right side of numeric comparison"");
} else if (leftType.matchesNumberContext() &&
rightType.matchesNumberContext()) {
// OK.
} else {
// Whether the comparison is numeric will be determined at runtime
// each time the expression is evaluated. Regardless, both operands
// should match a string context.
String message = ""left side of comparison"";
validator.expectString(t, n, leftType, message);
validator.expectNotNullOrUndefined(
t, n, leftType, message, getNativeType(STRING_TYPE));
message = ""right side of comparison"";
validator.expectString(t, n, rightType, message);
validator.expectNotNullOrUndefined(
t, n, rightType, message, getNativeType(STRING_TYPE));
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.IN:
left = n.getFirstChild();
right = n.getLastChild();
leftType = getJSType(left);
rightType = getJSType(right);
validator.expectObject(t, n, rightType, ""'in' requires an object"");
validator.expectString(t, left, leftType, ""left side of 'in'"");
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.INSTANCEOF:
left = n.getFirstChild();
right = n.getLastChild();
leftType = getJSType(left);
rightType = getJSType(right).restrictByNotNullOrUndefined();

validator.expectAnyObject(
t, left, leftType, ""deterministic instanceof yields false"");
validator.expectActualObject(
t, right, rightType, ""instanceof requires an object"");
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.ASSIGN:
visitAssign(t, n);
typeable = false;
break;

case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_SUB:
case Token.ASSIGN_ADD:
case Token.ASSIGN_MUL:
case Token.LSH:
case Token.RSH:
case Token.URSH:
case Token.DIV:
case Token.MOD:
case Token.BITOR:
case Token.BITXOR:
case Token.BITAND:
case Token.SUB:
case Token.ADD:
case Token.MUL:
visitBinaryOperator(n.getType(), t, n);
break;

case Token.DELPROP:
if (!isReference(n.getFirstChild())) {
report(t, n, BAD_DELETE);
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.CASE:
JSType switchType = getJSType(parent.getFirstChild());
JSType caseType = getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t, n, switchType, caseType);
typeable = false;
break;

case Token.WITH: {
Node child = n.getFirstChild();
childType = getJSType(child);
validator.expectObject(
t, child, childType, ""with requires an object"");
typeable = false;
break;
}

case Token.FUNCTION:
visitFunction(t, n);
break;

// These nodes have no interesting type behavior.
case Token.LABEL:
case Token.LABEL_NAME:
case Token.SWITCH:
case Token.BREAK:
case Token.CATCH:
case Token.TRY:
case Token.SCRIPT:
case Token.EXPR_RESULT:
case Token.BLOCK:
case Token.EMPTY:
case Token.DEFAULT:
case Token.CONTINUE:
case Token.DEBUGGER:
case Token.THROW:
typeable = false;
break;

// These nodes require data flow analysis.
case Token.DO:
case Token.FOR:
case Token.IF:
case Token.WHILE:
typeable = false;
break;

// These nodes are typed during the type inference.
case Token.AND:
case Token.HOOK:
case Token.OBJECTLIT:
case Token.OR:
if (n.getJSType() != null) { // If we didn't run type inference.
ensureTyped(t, n);
} else {
// If this is an enum, then give that type to the objectlit as well.
if ((n.getType() == Token.OBJECTLIT)
&& (parent.getJSType() instanceof EnumType)) {
ensureTyped(t, n, parent.getJSType());
} else {
ensureTyped(t, n);
}
}
if (n.getType() == Token.OBJECTLIT) {
for (Node key : n.children()) {
visitObjLitKey(t, key, n);
}
}
break;

default:
report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
ensureTyped(t, n);
break;
}

// Don't count externs since the user's code may not even use that part.
typeable = typeable && !inExterns;

if (typeable) {
doPercentTypedAccounting(t, n);
}

checkNoTypeCheckSection(n, false);
}"
Closure_69b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_69_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"private void visitCall(NodeTraversal t, Node n) {
Node child = n.getFirstChild();
JSType childType = getJSType(child).restrictByNotNullOrUndefined();

if (!childType.canBeCalled()) {
report(t, n, NOT_CALLABLE, childType.toString());
ensureTyped(t, n);
return;
}

// A couple of types can be called as if they were functions.
// If it is a function type, then validate parameters.
if (childType instanceof FunctionType) {
FunctionType functionType = (FunctionType) childType;

boolean isExtern = false;
JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();
if(functionJSDocInfo != null) {
String sourceName = functionJSDocInfo.getSourceName();
CompilerInput functionSource = compiler.getInput(sourceName);
isExtern = functionSource.isExtern();
}

// Non-native constructors should not be called directly
// unless they specify a return type and are defined
// in an extern.
if (functionType.isConstructor() &&
!functionType.isNativeObjectType() &&
(functionType.getReturnType().isUnknownType() ||
functionType.getReturnType().isVoidType() ||
!isExtern)) {
report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());
}

// Functions with explcit 'this' types must be called in a GETPROP
// or GETELEM.

visitParameterList(t, n, functionType);
ensureTyped(t, n, functionType.getReturnType());
} else {
ensureTyped(t, n);
}

// TODO: Add something to check for calls of RegExp objects, which is not
// supported by IE.  Either say something about the return type or warn
// about the non-portability of the call or both.
}"
Closure_69b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_69_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"private void checkDeclaredPropertyInheritance(
NodeTraversal t, Node n, FunctionType ctorType, String propertyName,"
Closure_69b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_69_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"private void visitGetElem(NodeTraversal t, Node n) {
Node left = n.getFirstChild();
Node right = n.getLastChild();
validator.expectIndexMatch(t, n, getJSType(left), getJSType(right));
ensureTyped(t, n);
}"
Closure_69b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_69_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"private static boolean hasUnknownOrEmptySupertype(FunctionType ctor) {
Preconditions.checkArgument(ctor.isConstructor() || ctor.isInterface());
Preconditions.checkArgument(!ctor.isUnknownType());

// The type system should notice inheritance cycles on its own
// and break the cycle.
while (true) {
ObjectType maybeSuperInstanceType =
ctor.getPrototype().getImplicitPrototype();
if (maybeSuperInstanceType == null) {
return false;
}
if (maybeSuperInstanceType.isUnknownType() ||
maybeSuperInstanceType.isEmptyType()) {
return true;
}
ctor = maybeSuperInstanceType.getConstructor();
if (ctor == null) {
return false;
}
Preconditions.checkState(ctor.isConstructor() || ctor.isInterface());
}
}"
Closure_70b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_70_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"public Scope createScope(Node root, Scope parent) {
// Constructing the global scope is very different than constructing
// inner scopes, because only global scopes can contain named classes that
// show up in the type registry.
Scope newScope = null;
AbstractScopeBuilder scopeBuilder = null;
if (parent == null) {
// Find all the classes in the global scope.
newScope = createInitialScope(root);

GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);
scopeBuilder = globalScopeBuilder;
NodeTraversal.traverse(compiler, root, scopeBuilder);
} else {
newScope = new Scope(parent, root);
LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);
scopeBuilder = localScopeBuilder;
localScopeBuilder.build();
}

scopeBuilder.resolveStubDeclarations();
scopeBuilder.resolveTypes();

// Gather the properties in each function that we found in the
// global scope, if that function has a @this type that we can
// build properties on.
for (Node functionNode : scopeBuilder.nonExternFunctions) {
JSType type = functionNode.getJSType();
if (type != null && type instanceof FunctionType) {
FunctionType fnType = (FunctionType) type;
ObjectType fnThisType = fnType.getTypeOfThis();
if (!fnThisType.isUnknownType()) {
NodeTraversal.traverse(compiler, functionNode.getLastChild(),
scopeBuilder.new CollectProperties(fnThisType));
}
}
}

if (parent == null) {
codingConvention.defineDelegateProxyPrototypeProperties(
typeRegistry, newScope, delegateProxyPrototypes);
}
return newScope;
}"
Closure_70b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_70_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"private static Node getBestLValue(Node n) {
Node parent = n.getParent();
int parentType = parent.getType();
boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(n);
if (isFunctionDeclaration) {
return n.getFirstChild();
} else if (parentType == Token.NAME) {
return parent;
} else if (parentType == Token.ASSIGN) {
return parent.getFirstChild();
} else if (NodeUtil.isObjectLitKey(parent, parent.getParent())) {
return parent;
}
return null;
}"
Closure_70b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_70_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"static JSDocInfo getBestJSDocInfo(Node n) {
JSDocInfo info = n.getJSDocInfo();
if (info == null) {
Node parent = n.getParent();
int parentType = parent.getType();
if (parentType == Token.NAME) {
info = parent.getJSDocInfo();
if (info == null && parent.getParent().hasOneChild()) {
info = parent.getParent().getJSDocInfo();
}
} else if (parentType == Token.ASSIGN) {
info = parent.getJSDocInfo();
} else if (NodeUtil.isObjectLitKey(parent, parent.getParent())) {
info = parent.getJSDocInfo();
}
}
return info;
}"
Closure_70b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_70_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"private static String getBestLValueName(@Nullable Node lValue) {
if (lValue == null || lValue.getParent() == null) {
return null;
}
if (NodeUtil.isObjectLitKey(lValue, lValue.getParent())) {
Node owner = getBestLValue(lValue.getParent());
if (owner != null) {
String ownerName = getBestLValueName(owner);
if (ownerName != null) {
return ownerName + ""."" + NodeUtil.getObjectLitKeyName(lValue);
}
}
return null;
}
return lValue.getQualifiedName();
}"
Closure_70b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_70_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"return typeRegistry.getNativeType(nativeType);
}

private abstract class AbstractScopeBuilder
implements NodeTraversal.Callback {"
Closure_71b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_71_buggy/src/com/google/javascript/jscomp/CheckAccessControls.java,"private void checkPropertyVisibility(NodeTraversal t,
Node getprop, Node parent) {
ObjectType objectType =
ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
String propertyName = getprop.getLastChild().getString();

if (objectType != null) {
// Is this a normal property access, or are we trying to override
// an existing property?
boolean isOverride = t.inGlobalScope() &&
parent.getType() == Token.ASSIGN &&
parent.getFirstChild() == getprop;

// Find the lowest property defined on a class with visibility
// information.
if (isOverride) {
objectType = objectType.getImplicitPrototype();
}
JSDocInfo docInfo = null;
for (; objectType != null;
objectType = objectType.getImplicitPrototype()) {
docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);
if (docInfo != null &&
docInfo.getVisibility() != Visibility.INHERITED) {
break;
}
}

if (objectType == null) {
// We couldn't find a visibility modifier; assume it's public.
return;
}

boolean sameInput =
t.getInput().getName().equals(docInfo.getSourceName());
Visibility visibility = docInfo.getVisibility();
JSType ownerType = normalizeClassType(objectType);
if (isOverride) {
// Check an ASSIGN statement that's trying to override a property
// on a superclass.
JSDocInfo overridingInfo = parent.getJSDocInfo();
Visibility overridingVisibility = overridingInfo == null ?
Visibility.INHERITED : overridingInfo.getVisibility();

// Check that (a) the property *can* be overridden, and
// (b) that the visibility of the override is the same as the
// visibility of the original property.
if (visibility == Visibility.PRIVATE && !sameInput) {
compiler.report(
t.makeError(getprop, PRIVATE_OVERRIDE,
objectType.toString()));
} else if (overridingVisibility != Visibility.INHERITED &&
overridingVisibility != visibility) {
compiler.report(
t.makeError(getprop, VISIBILITY_MISMATCH,
visibility.name(), objectType.toString(),
overridingVisibility.name()));
}
} else {
if (sameInput) {
// private access is always allowed in the same file.
return;
} else if (visibility == Visibility.PRIVATE &&
(currentClass == null || ownerType.differsFrom(currentClass))) {
if (docInfo.isConstructor() &&
isValidPrivateConstructorAccess(parent)) {
return;
}

// private access is not allowed outside the file from a different
// enclosing class.
compiler.report(
t.makeError(getprop,
BAD_PRIVATE_PROPERTY_ACCESS,
propertyName,
validator.getReadableJSTypeName(
getprop.getFirstChild(), true)));
} else if (visibility == Visibility.PROTECTED) {
// There are 3 types of legal accesses of a protected property:
// 1) Accesses in the same file
// 2) Overriding the property in a subclass
// 3) Accessing the property from inside a subclass
// The first two have already been checked for.
if (currentClass == null || !currentClass.isSubtype(ownerType)) {
compiler.report(
t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,
propertyName,
validator.getReadableJSTypeName(
getprop.getFirstChild(), true)));
}
}
}
}
}"
Closure_71b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_71_buggy/src/com/google/javascript/jscomp/CheckAccessControls.java,"private void checkConstantProperty(NodeTraversal t,
Node getprop) {
// Check whether the property is modified
Node parent = getprop.getParent();
if (!(NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == getprop)
&& (parent.getType() != Token.INC) && (parent.getType() != Token.DEC)) {
return;
}

ObjectType objectType =
ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));
String propertyName = getprop.getLastChild().getString();

// Check whether constant properties are reassigned
if (objectType != null) {
ObjectType oType = objectType;
while (oType != null) {
if (oType.hasReferenceName()) {
if (initializedConstantProperties.containsEntry(
oType.getReferenceName(), propertyName)) {
compiler.report(
t.makeError(getprop, CONST_PROPERTY_REASSIGNED_VALUE,
propertyName));
break;
}
}
oType = oType.getImplicitPrototype();
}

JSDocInfo info = objectType.getOwnPropertyJSDocInfo(propertyName);
if (info != null && info.isConstant()
&& objectType.hasReferenceName()) {
initializedConstantProperties.put(objectType.getReferenceName(),
propertyName);
}

// Add the prototype when we're looking at an instance object
if (objectType.isInstanceType()) {
ObjectType prototype = objectType.getImplicitPrototype();
if (prototype != null) {
JSDocInfo prototypeInfo
= prototype.getOwnPropertyJSDocInfo(propertyName);
if (prototypeInfo != null && prototypeInfo.isConstant()
&& prototype.hasReferenceName()) {
initializedConstantProperties.put(prototype.getReferenceName(),
propertyName);
}
}
}
}
}"
Closure_71b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_71_buggy/src/com/google/javascript/jscomp/CheckAccessControls.java,"private JSType normalizeClassType(JSType type) {
if (type == null || type.isUnknownType()) {
return type;
} else if (type.isConstructor()) {
return ((FunctionType) type).getInstanceType();
} else if (type.isFunctionPrototypeType()) {
FunctionType owner = ((FunctionPrototypeType) type).getOwnerFunction();
if (owner.isConstructor()) {
return owner.getInstanceType();
}
}
return type;
}"
Closure_71b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_71_buggy/src/com/google/javascript/jscomp/CheckAccessControls.java,"private static String getPropertyDeprecationInfo(ObjectType type,
String prop) {
JSDocInfo info = type.getOwnPropertyJSDocInfo(prop);
if (info != null && info.isDeprecated()) {
if (info.getDeprecationReason() != null) {
return info.getDeprecationReason();
}

return """";
}
ObjectType implicitProto = type.getImplicitPrototype();
if (implicitProto != null) {
return getPropertyDeprecationInfo(implicitProto, prop);
}
return null;
}"
Closure_71b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_71_buggy/src/com/google/javascript/jscomp/CheckAccessControls.java,"public void visit(NodeTraversal t, Node n, Node parent) {
switch (n.getType()) {
case Token.NAME:
checkNameDeprecation(t, n, parent);
checkNameVisibility(t, n, parent);
break;
case Token.GETPROP:
checkPropertyDeprecation(t, n, parent);
checkPropertyVisibility(t, n, parent);
checkConstantProperty(t, n);
break;
case Token.NEW:
checkConstructorDeprecation(t, n, parent);
break;
}
}"
Closure_73b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_73_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"static String strEscape(String s, char quote,
String doublequoteEscape,"
Closure_73b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_73_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"appendHexJavaScriptRepresentation(c, sb);
} catch (IOException ex) {"
Closure_73b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_73_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"static String jsString(String s, CharsetEncoder outputCharsetEncoder) {
int singleq = 0, doubleq = 0;

// could count the quotes and pick the optimal quote character
for (int i = 0; i < s.length(); i++) {
switch (s.charAt(i)) {
case '""': doubleq++; break;
case '\'': singleq++; break;
}
}

String doublequote, singlequote;
char quote;
if (singleq < doubleq) {
// more double quotes so escape the single quotes
quote = '\'';
doublequote = ""\"""";
singlequote = ""\\\'"";
} else {
// more single quotes so escape the doubles
quote = '\""';
doublequote = ""\\\"""";
singlequote = ""\'"";
}

return strEscape(s, quote, doublequote, singlequote, ""\\\\"",
outputCharsetEncoder);
}"
Closure_73b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_73_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"cc.add(str);
}

private void addIdentifier(String identifier) {"
Closure_73b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_73_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"cc.addIdentifier(identifierEscape(identifier));
}

void add(Node n) {"
Closure_77b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_77_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"static String strEscape(String s, char quote,
String doublequoteEscape,"
Closure_77b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_77_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"appendHexJavaScriptRepresentation(c, sb);
} catch (IOException ex) {"
Closure_77b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_77_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"static String jsString(String s, CharsetEncoder outputCharsetEncoder) {
int singleq = 0, doubleq = 0;

// could count the quotes and pick the optimal quote character
for (int i = 0; i < s.length(); i++) {
switch (s.charAt(i)) {
case '""': doubleq++; break;
case '\'': singleq++; break;
}
}

String doublequote, singlequote;
char quote;
if (singleq < doubleq) {
// more double quotes so escape the single quotes
quote = '\'';
doublequote = ""\"""";
singlequote = ""\\\'"";
} else {
// more single quotes so escape the doubles
quote = '\""';
doublequote = ""\\\"""";
singlequote = ""\'"";
}

return strEscape(s, quote, doublequote, singlequote, ""\\\\"",
outputCharsetEncoder);
}"
Closure_77b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_77_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"cc.add(str);
}

private void addIdentifier(String identifier) {"
Closure_77b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_77_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"cc.addIdentifier(identifierEscape(identifier));
}

void add(Node n) {"
Closure_78b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_78_buggy/src/com/google/javascript/jscomp/PeepholeFoldConstants.java,"private Node performArithmeticOp(int opType, Node left, Node right) {
// Unlike other operations, ADD operands are not always converted
// to Number.
if (opType == Token.ADD
&& (NodeUtil.mayBeString(left, false)
|| NodeUtil.mayBeString(right, false))) {
return null;
}

double result;

// TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN
// to zero so this is a little akward here.

Double lValObj = NodeUtil.getNumberValue(left);
if (lValObj == null) {
return null;
}
Double rValObj = NodeUtil.getNumberValue(right);
if (rValObj == null) {
return null;
}

double lval = lValObj;
double rval = rValObj;

switch (opType) {
case Token.BITAND:
result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);
break;
case Token.BITOR:
result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);
break;
case Token.BITXOR:
result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);
break;
case Token.ADD:
result = lval + rval;
break;
case Token.SUB:
result = lval - rval;
break;
case Token.MUL:
result = lval * rval;
break;
case Token.MOD:
if (rval == 0) {
error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
return null;
}
result = lval % rval;
break;
case Token.DIV:
if (rval == 0) {
error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
return null;
}
result = lval / rval;
break;
default:
throw new Error(""Unexpected arithmetic operator"");
}

// TODO(johnlenz): consider removing the result length check.
// length of the left and right value plus 1 byte for the operator.
if (String.valueOf(result).length() <=
String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&

// Do not try to fold arithmetic for numbers > 2^53. After that
// point, fixed-point math starts to break down and become inaccurate.
Math.abs(result) <= MAX_FOLD_NUMBER) {
Node newNumber = Node.newNumber(result);
return newNumber;
} else if (Double.isNaN(result)) {
return Node.newString(Token.NAME, ""NaN"");
} else if (result == Double.POSITIVE_INFINITY) {
return Node.newString(Token.NAME, ""Infinity"");
} else if (result == Double.NEGATIVE_INFINITY) {
return new Node(Token.NEG, Node.newString(Token.NAME, ""Infinity""));
}

return null;
}"
Closure_78b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_78_buggy/src/com/google/javascript/jscomp/PeepholeFoldConstants.java,"private Node tryFoldAssign(Node n, Node left, Node right) {
Preconditions.checkArgument(n.getType() == Token.ASSIGN);

// Tries to convert x = x + y -> x += y;
if (!right.hasChildren() ||
right.getFirstChild().getNext() != right.getLastChild()) {
// RHS must have two children.
return n;
}

if (mayHaveSideEffects(left)) {
return n;
}

Node newRight;
if (areNodesEqualForInlining(left, right.getFirstChild())) {
newRight = right.getLastChild();
} else if (NodeUtil.isCommutative(right.getType()) &&
areNodesEqualForInlining(left, right.getLastChild())) {
newRight = right.getFirstChild();
} else {
return n;
}

int newType = -1;
switch (right.getType()) {
case Token.ADD:
newType = Token.ASSIGN_ADD;
break;
case Token.BITAND:
newType = Token.ASSIGN_BITAND;
break;
case Token.BITOR:
newType = Token.ASSIGN_BITOR;
break;
case Token.BITXOR:
newType = Token.ASSIGN_BITXOR;
break;
case Token.DIV:
newType = Token.ASSIGN_DIV;
break;
case Token.LSH:
newType = Token.ASSIGN_LSH;
break;
case Token.MOD:
newType = Token.ASSIGN_MOD;
break;
case Token.MUL:
newType = Token.ASSIGN_MUL;
break;
case Token.RSH:
newType = Token.ASSIGN_RSH;
break;
case Token.SUB:
newType = Token.ASSIGN_SUB;
break;
case Token.URSH:
newType = Token.ASSIGN_URSH;
break;
default:
return n;
}

Node newNode = new Node(newType,
left.detachFromParent(), newRight.detachFromParent());
n.getParent().replaceChild(n, newNode);

reportCodeChange();

return newNode;
}"
Closure_78b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_78_buggy/src/com/google/javascript/jscomp/PeepholeFoldConstants.java,"private Node tryFoldAdd(Node node, Node left, Node right) {
Preconditions.checkArgument(node.getType() == Token.ADD);

if (NodeUtil.mayBeString(node, true)) {
if (NodeUtil.isLiteralValue(left, false) &&
NodeUtil.isLiteralValue(right, false)) {
// '6' + 7
return tryFoldAddConstantString(node, left, right);
} else {
// a + 7 or 6 + a
return tryFoldChildAddString(node, left, right);
}
} else {
// Try arithmetic add
Node result = tryFoldArithmeticOp(node, left, right);
if (result != node) {
return result;
}
return tryFoldLeftChildOp(node, left, right);
}
}"
Closure_78b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_78_buggy/src/com/google/javascript/jscomp/PeepholeFoldConstants.java,"private Node tryFoldBinaryOperator(Node subtree) {
Node left = subtree.getFirstChild();

if (left == null) {
return subtree;
}

Node right = left.getNext();

if (right == null) {
return subtree;
}

// If we've reached here, node is truly a binary operator.
switch(subtree.getType()) {
case Token.GETPROP:
return tryFoldGetProp(subtree, left, right);

case Token.GETELEM:
return tryFoldGetElem(subtree, left, right);

case Token.INSTANCEOF:
return tryFoldInstanceof(subtree, left, right);

case Token.AND:
case Token.OR:
return tryFoldAndOr(subtree, left, right);

case Token.LSH:
case Token.RSH:
case Token.URSH:
return tryFoldShift(subtree, left, right);

case Token.ASSIGN:
return tryFoldAssign(subtree, left, right);

case Token.ADD:
return tryFoldAdd(subtree, left, right);

case Token.SUB:
case Token.DIV:
case Token.MOD:
return tryFoldArithmeticOp(subtree, left, right);

case Token.MUL:
case Token.BITAND:
case Token.BITOR:
case Token.BITXOR:
Node result = tryFoldArithmeticOp(subtree, left, right);
if (result != subtree) {
return result;
}
return tryFoldLeftChildOp(subtree, left, right);

case Token.LT:
case Token.GT:
case Token.LE:
case Token.GE:
case Token.EQ:
case Token.NE:
case Token.SHEQ:
case Token.SHNE:
return tryFoldComparison(subtree, left, right);

default:
return subtree;
}
}"
Closure_78b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_78_buggy/src/com/google/javascript/jscomp/PeepholeFoldConstants.java,"private void tryReduceOperandsForOp(Node n) {
switch (n.getType()) {
case Token.ADD:
Node left = n.getFirstChild();
Node right = n.getLastChild();
if (!NodeUtil.mayBeString(left) && !NodeUtil.mayBeString(right)) {
tryConvertOperandsToNumber(n);
}
break;
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
// TODO(johnlenz): convert these to integers.
case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_SUB:
case Token.ASSIGN_MUL:
case Token.ASSIGN_MOD:
case Token.ASSIGN_DIV:
tryConvertToNumber(n.getLastChild());
break;
case Token.BITNOT:
case Token.BITOR:
case Token.BITXOR:
case Token.BITAND:
case Token.LSH:
case Token.RSH:
case Token.URSH:
case Token.SUB:
case Token.MUL:
case Token.MOD:
case Token.DIV:
case Token.POS:
case Token.NEG:
tryConvertOperandsToNumber(n);
break;
}
}"
Closure_81b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_81_buggy/src/com/google/javascript/jscomp/parsing/IRFactory.java,"private Node transform(AstNode node) {
JSDocInfo jsDocInfo = handleJsDoc(node);
Node irNode = justTransform(node);
if (jsDocInfo != null) {
irNode.setJSDocInfo(jsDocInfo);
}

// If we have a named function, set the position to that of the name.
if (irNode.getType() == Token.FUNCTION &&
irNode.getFirstChild().getLineno() != -1) {
irNode.setLineno(irNode.getFirstChild().getLineno());
irNode.setCharno(irNode.getFirstChild().getCharno());
} else {
if (irNode.getLineno() == -1) {
// If we didn't already set the line, then set it now.  This avoids
// cases like ParenthesizedExpression where we just return a previous
// node, but don't want the new node to get its parent's line number.
int lineno = node.getLineno();
irNode.setLineno(lineno);
int charno = position2charno(node.getAbsolutePosition());
irNode.setCharno(charno);
}
}
return irNode;
}"
Closure_81b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_81_buggy/src/com/google/javascript/jscomp/parsing/IRFactory.java,"private static int transformTokenType(int token) {
switch (token) {
case com.google.javascript.jscomp.mozilla.rhino.Token.ERROR:
return Token.ERROR;
case com.google.javascript.jscomp.mozilla.rhino.Token.EOF:
return Token.EOF;
case com.google.javascript.jscomp.mozilla.rhino.Token.EOL:
return Token.EOL;
case com.google.javascript.jscomp.mozilla.rhino.Token.ENTERWITH:
return Token.ENTERWITH;
case com.google.javascript.jscomp.mozilla.rhino.Token.LEAVEWITH:
return Token.LEAVEWITH;
case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN:
return Token.RETURN;
case com.google.javascript.jscomp.mozilla.rhino.Token.GOTO:
return Token.GOTO;
case com.google.javascript.jscomp.mozilla.rhino.Token.IFEQ:
return Token.IFEQ;
case com.google.javascript.jscomp.mozilla.rhino.Token.IFNE:
return Token.IFNE;
case com.google.javascript.jscomp.mozilla.rhino.Token.SETNAME:
return Token.SETNAME;
case com.google.javascript.jscomp.mozilla.rhino.Token.BITOR:
return Token.BITOR;
case com.google.javascript.jscomp.mozilla.rhino.Token.BITXOR:
return Token.BITXOR;
case com.google.javascript.jscomp.mozilla.rhino.Token.BITAND:
return Token.BITAND;
case com.google.javascript.jscomp.mozilla.rhino.Token.EQ:
return Token.EQ;
case com.google.javascript.jscomp.mozilla.rhino.Token.NE:
return Token.NE;
case com.google.javascript.jscomp.mozilla.rhino.Token.LT:
return Token.LT;
case com.google.javascript.jscomp.mozilla.rhino.Token.LE:
return Token.LE;
case com.google.javascript.jscomp.mozilla.rhino.Token.GT:
return Token.GT;
case com.google.javascript.jscomp.mozilla.rhino.Token.GE:
return Token.GE;
case com.google.javascript.jscomp.mozilla.rhino.Token.LSH:
return Token.LSH;
case com.google.javascript.jscomp.mozilla.rhino.Token.RSH:
return Token.RSH;
case com.google.javascript.jscomp.mozilla.rhino.Token.URSH:
return Token.URSH;
case com.google.javascript.jscomp.mozilla.rhino.Token.ADD:
return Token.ADD;
case com.google.javascript.jscomp.mozilla.rhino.Token.SUB:
return Token.SUB;
case com.google.javascript.jscomp.mozilla.rhino.Token.MUL:
return Token.MUL;
case com.google.javascript.jscomp.mozilla.rhino.Token.DIV:
return Token.DIV;
case com.google.javascript.jscomp.mozilla.rhino.Token.MOD:
return Token.MOD;
case com.google.javascript.jscomp.mozilla.rhino.Token.NOT:
return Token.NOT;
case com.google.javascript.jscomp.mozilla.rhino.Token.BITNOT:
return Token.BITNOT;
case com.google.javascript.jscomp.mozilla.rhino.Token.POS:
return Token.POS;
case com.google.javascript.jscomp.mozilla.rhino.Token.NEG:
return Token.NEG;
case com.google.javascript.jscomp.mozilla.rhino.Token.NEW:
return Token.NEW;
case com.google.javascript.jscomp.mozilla.rhino.Token.DELPROP:
return Token.DELPROP;
case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOF:
return Token.TYPEOF;
case com.google.javascript.jscomp.mozilla.rhino.Token.GETPROP:
return Token.GETPROP;
case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP:
return Token.SETPROP;
case com.google.javascript.jscomp.mozilla.rhino.Token.GETELEM:
return Token.GETELEM;
case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM:
return Token.SETELEM;
case com.google.javascript.jscomp.mozilla.rhino.Token.CALL:
return Token.CALL;
case com.google.javascript.jscomp.mozilla.rhino.Token.NAME:
return Token.NAME;
case com.google.javascript.jscomp.mozilla.rhino.Token.NUMBER:
return Token.NUMBER;
case com.google.javascript.jscomp.mozilla.rhino.Token.STRING:
return Token.STRING;
case com.google.javascript.jscomp.mozilla.rhino.Token.NULL:
return Token.NULL;
case com.google.javascript.jscomp.mozilla.rhino.Token.THIS:
return Token.THIS;
case com.google.javascript.jscomp.mozilla.rhino.Token.FALSE:
return Token.FALSE;
case com.google.javascript.jscomp.mozilla.rhino.Token.TRUE:
return Token.TRUE;
case com.google.javascript.jscomp.mozilla.rhino.Token.SHEQ:
return Token.SHEQ;
case com.google.javascript.jscomp.mozilla.rhino.Token.SHNE:
return Token.SHNE;
case com.google.javascript.jscomp.mozilla.rhino.Token.REGEXP:
return Token.REGEXP;
case com.google.javascript.jscomp.mozilla.rhino.Token.BINDNAME:
return Token.BINDNAME;
case com.google.javascript.jscomp.mozilla.rhino.Token.THROW:
return Token.THROW;
case com.google.javascript.jscomp.mozilla.rhino.Token.RETHROW:
return Token.RETHROW;
case com.google.javascript.jscomp.mozilla.rhino.Token.IN:
return Token.IN;
case com.google.javascript.jscomp.mozilla.rhino.Token.INSTANCEOF:
return Token.INSTANCEOF;
case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_LOAD:
return Token.LOCAL_LOAD;
case com.google.javascript.jscomp.mozilla.rhino.Token.GETVAR:
return Token.GETVAR;
case com.google.javascript.jscomp.mozilla.rhino.Token.SETVAR:
return Token.SETVAR;
case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH_SCOPE:
return Token.CATCH_SCOPE;
case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_KEYS:
return Token.ENUM_INIT_KEYS;
case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_VALUES:
return Token.ENUM_INIT_VALUES;
case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_NEXT:
return Token.ENUM_NEXT;
case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_ID:
return Token.ENUM_ID;
case com.google.javascript.jscomp.mozilla.rhino.Token.THISFN:
return Token.THISFN;
case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN_RESULT:
return Token.RETURN_RESULT;
case com.google.javascript.jscomp.mozilla.rhino.Token.ARRAYLIT:
return Token.ARRAYLIT;
case com.google.javascript.jscomp.mozilla.rhino.Token.OBJECTLIT:
return Token.OBJECTLIT;
case com.google.javascript.jscomp.mozilla.rhino.Token.GET_REF:
return Token.GET_REF;
case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF:
return Token.SET_REF;
case com.google.javascript.jscomp.mozilla.rhino.Token.DEL_REF:
return Token.DEL_REF;
case com.google.javascript.jscomp.mozilla.rhino.Token.REF_CALL:
return Token.REF_CALL;
case com.google.javascript.jscomp.mozilla.rhino.Token.REF_SPECIAL:
return Token.REF_SPECIAL;
case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULTNAMESPACE:
return Token.DEFAULTNAMESPACE;
case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLTEXT:
return Token.ESCXMLTEXT;
case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLATTR:
return Token.ESCXMLATTR;
case com.google.javascript.jscomp.mozilla.rhino.Token.REF_MEMBER:
return Token.REF_MEMBER;
case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_MEMBER:
return Token.REF_NS_MEMBER;
case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NAME:
return Token.REF_NAME;
case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_NAME:
return Token.REF_NS_NAME;
case com.google.javascript.jscomp.mozilla.rhino.Token.TRY:
return Token.TRY;
case com.google.javascript.jscomp.mozilla.rhino.Token.SEMI:
return Token.SEMI;
case com.google.javascript.jscomp.mozilla.rhino.Token.LB:
return Token.LB;
case com.google.javascript.jscomp.mozilla.rhino.Token.RB:
return Token.RB;
case com.google.javascript.jscomp.mozilla.rhino.Token.LC:
return Token.LC;
case com.google.javascript.jscomp.mozilla.rhino.Token.RC:
return Token.RC;
case com.google.javascript.jscomp.mozilla.rhino.Token.LP:
return Token.LP;
case com.google.javascript.jscomp.mozilla.rhino.Token.RP:
return Token.RP;
case com.google.javascript.jscomp.mozilla.rhino.Token.COMMA:
return Token.COMMA;
case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN:
return Token.ASSIGN;
case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITOR:
return Token.ASSIGN_BITOR;
case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITXOR:
return Token.ASSIGN_BITXOR;
case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITAND:
return Token.ASSIGN_BITAND;
case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_LSH:
return Token.ASSIGN_LSH;
case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_RSH:
return Token.ASSIGN_RSH;
case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_URSH:
return Token.ASSIGN_URSH;
case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_ADD:
return Token.ASSIGN_ADD;
case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_SUB:
return Token.ASSIGN_SUB;
case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MUL:
return Token.ASSIGN_MUL;
case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_DIV:
return Token.ASSIGN_DIV;
case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MOD:
return Token.ASSIGN_MOD;
case com.google.javascript.jscomp.mozilla.rhino.Token.HOOK:
return Token.HOOK;
case com.google.javascript.jscomp.mozilla.rhino.Token.COLON:
return Token.COLON;
case com.google.javascript.jscomp.mozilla.rhino.Token.OR:
return Token.OR;
case com.google.javascript.jscomp.mozilla.rhino.Token.AND:
return Token.AND;
case com.google.javascript.jscomp.mozilla.rhino.Token.INC:
return Token.INC;
case com.google.javascript.jscomp.mozilla.rhino.Token.DEC:
return Token.DEC;
case com.google.javascript.jscomp.mozilla.rhino.Token.DOT:
return Token.DOT;
case com.google.javascript.jscomp.mozilla.rhino.Token.FUNCTION:
return Token.FUNCTION;
case com.google.javascript.jscomp.mozilla.rhino.Token.EXPORT:
return Token.EXPORT;
case com.google.javascript.jscomp.mozilla.rhino.Token.IMPORT:
return Token.IMPORT;
case com.google.javascript.jscomp.mozilla.rhino.Token.IF:
return Token.IF;
case com.google.javascript.jscomp.mozilla.rhino.Token.ELSE:
return Token.ELSE;
case com.google.javascript.jscomp.mozilla.rhino.Token.SWITCH:
return Token.SWITCH;
case com.google.javascript.jscomp.mozilla.rhino.Token.CASE:
return Token.CASE;
case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULT:
return Token.DEFAULT;
case com.google.javascript.jscomp.mozilla.rhino.Token.WHILE:
return Token.WHILE;
case com.google.javascript.jscomp.mozilla.rhino.Token.DO:
return Token.DO;
case com.google.javascript.jscomp.mozilla.rhino.Token.FOR:
return Token.FOR;
case com.google.javascript.jscomp.mozilla.rhino.Token.BREAK:
return Token.BREAK;
case com.google.javascript.jscomp.mozilla.rhino.Token.CONTINUE:
return Token.CONTINUE;
case com.google.javascript.jscomp.mozilla.rhino.Token.VAR:
return Token.VAR;
case com.google.javascript.jscomp.mozilla.rhino.Token.WITH:
return Token.WITH;
case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH:
return Token.CATCH;
case com.google.javascript.jscomp.mozilla.rhino.Token.FINALLY:
return Token.FINALLY;
case com.google.javascript.jscomp.mozilla.rhino.Token.VOID:
return Token.VOID;
case com.google.javascript.jscomp.mozilla.rhino.Token.RESERVED:
return Token.RESERVED;
case com.google.javascript.jscomp.mozilla.rhino.Token.EMPTY:
return Token.EMPTY;
case com.google.javascript.jscomp.mozilla.rhino.Token.BLOCK:
return Token.BLOCK;
case com.google.javascript.jscomp.mozilla.rhino.Token.LABEL:
return Token.LABEL;
case com.google.javascript.jscomp.mozilla.rhino.Token.TARGET:
return Token.TARGET;
case com.google.javascript.jscomp.mozilla.rhino.Token.LOOP:
return Token.LOOP;
case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_VOID:
case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_RESULT:
return Token.EXPR_RESULT;
case com.google.javascript.jscomp.mozilla.rhino.Token.JSR:
return Token.JSR;
case com.google.javascript.jscomp.mozilla.rhino.Token.SCRIPT:
return Token.SCRIPT;
case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOFNAME:
return Token.TYPEOFNAME;
case com.google.javascript.jscomp.mozilla.rhino.Token.USE_STACK:
return Token.USE_STACK;
case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP_OP:
return Token.SETPROP_OP;
case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM_OP:
return Token.SETELEM_OP;
case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_BLOCK:
return Token.LOCAL_BLOCK;
case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF_OP:
return Token.SET_REF_OP;
case com.google.javascript.jscomp.mozilla.rhino.Token.DOTDOT:
return Token.DOTDOT;
case com.google.javascript.jscomp.mozilla.rhino.Token.COLONCOLON:
return Token.COLONCOLON;
case com.google.javascript.jscomp.mozilla.rhino.Token.XML:
return Token.XML;
case com.google.javascript.jscomp.mozilla.rhino.Token.DOTQUERY:
return Token.DOTQUERY;
case com.google.javascript.jscomp.mozilla.rhino.Token.XMLATTR:
return Token.XMLATTR;
case com.google.javascript.jscomp.mozilla.rhino.Token.XMLEND:
return Token.XMLEND;
case com.google.javascript.jscomp.mozilla.rhino.Token.TO_OBJECT:
return Token.TO_OBJECT;
case com.google.javascript.jscomp.mozilla.rhino.Token.TO_DOUBLE:
return Token.TO_DOUBLE;
case com.google.javascript.jscomp.mozilla.rhino.Token.GET:
return Token.GET;
case com.google.javascript.jscomp.mozilla.rhino.Token.SET:
return Token.SET;
case com.google.javascript.jscomp.mozilla.rhino.Token.CONST:
return Token.CONST;
case com.google.javascript.jscomp.mozilla.rhino.Token.SETCONST:
return Token.SETCONST;
case com.google.javascript.jscomp.mozilla.rhino.Token.DEBUGGER:
return Token.DEBUGGER;
}

// Token without name
throw new IllegalStateException(String.valueOf(token));
}"
Closure_81b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_81_buggy/src/com/google/javascript/jscomp/parsing/IRFactory.java,"private int position2charno(int position) {
int lineIndex = sourceString.lastIndexOf('\n', position);
if (lineIndex == -1) {
return position;
} else {
// Subtract one for initial position being 0.
return position - lineIndex - 1;
}
}"
Closure_81b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_81_buggy/src/com/google/javascript/jscomp/parsing/IRFactory.java,"private Node newStringNode(int type, String value) {
return Node.newString(type, value).clonePropsFrom(templateNode);
}"
Closure_81b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_81_buggy/src/com/google/javascript/jscomp/parsing/IRFactory.java,"private Node createTemplateNode() {
// The Node type choice is arbitrary.
Node templateNode = new Node(Token.SCRIPT);
templateNode.putProp(Node.SOURCENAME_PROP, sourceName);
return templateNode;
}"
Closure_82b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_82_buggy/src/com/google/javascript/rhino/jstype/JSType.java,"public JSType findPropertyType(String propertyName) {
ObjectType autoboxObjType = ObjectType.cast(autoboxesTo());
if (autoboxObjType != null) {
return autoboxObjType.findPropertyType(propertyName);
}

return null;
}"
Closure_82b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_82_buggy/src/com/google/javascript/rhino/jstype/JSType.java,"public JSType getGreatestSubtype(JSType that) {
if (that.isRecordType()) {
// Record types have their own implementation of getGreatestSubtype.
return that.getGreatestSubtype(this);
}
return getGreatestSubtype(this, that);
}"
Closure_82b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_82_buggy/src/com/google/javascript/rhino/jstype/JSType.java,"public boolean isRecordType() {
return false;
}"
Closure_82b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_82_buggy/src/com/google/javascript/rhino/jstype/JSType.java,"return registry.getNativeType(typeId);
}

/**
* Gets the docInfo for this type. By default, documentation cannot be
* attached to arbitrary types. This must be overridden for
* programmer-defined types.
*/
public JSDocInfo getJSDocInfo() {"
Closure_82b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_82_buggy/src/com/google/javascript/rhino/jstype/JSType.java,"public boolean isNoType() {
return false;
}"
Closure_83b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_83_buggy/src/com/google/javascript/jscomp/CommandLineRunner.java,"private void initConfigFromFlags(String[] args, PrintStream err) {
// Args4j has a different format that the old command-line parser.
// So we use some voodoo to get the args into the format that args4j
// expects.
Pattern argPattern = Pattern.compile(""(--[a-zA-Z_]+)=(.*)"");
Pattern quotesPattern = Pattern.compile(""^['\""](.*)['\""]$"");
List<String> processedArgs = Lists.newArrayList();
for (String arg : args) {
Matcher matcher = argPattern.matcher(arg);
if (matcher.matches()) {
processedArgs.add(matcher.group(1));

String value = matcher.group(2);
Matcher quotesMatcher = quotesPattern.matcher(value);
if (quotesMatcher.matches()) {
processedArgs.add(quotesMatcher.group(1));
} else {
processedArgs.add(value);
}
} else {
processedArgs.add(arg);
}
}

CmdLineParser parser = new CmdLineParser(flags);
isConfigValid = true;
try {
parser.parseArgument(processedArgs.toArray(new String[] {}));
} catch (CmdLineException e) {
err.println(e.getMessage());
isConfigValid = false;
}

if (flags.version) {
ResourceBundle config = ResourceBundle.getBundle(configResource);
err.println(
""Closure Compiler (http://code.google.com/closure/compiler)\n"" +
""Version: "" + config.getString(""compiler.version"") + ""\n"" +
""Built on: "" + config.getString(""compiler.date""));
err.flush();
}

if (!isConfigValid || flags.display_help) {
isConfigValid = false;
parser.printUsage(err);
} else {
getCommandLineConfig()
.setPrintTree(flags.print_tree)
.setComputePhaseOrdering(flags.compute_phase_ordering)
.setPrintAst(flags.print_ast)
.setPrintPassGraph(flags.print_pass_graph)
.setJscompDevMode(flags.jscomp_dev_mode)
.setLoggingLevel(flags.logging_level)
.setExterns(flags.externs)
.setJs(flags.js)
.setJsOutputFile(flags.js_output_file)
.setModule(flags.module)
.setVariableMapInputFile(flags.variable_map_input_file)
.setPropertyMapInputFile(flags.property_map_input_file)
.setVariableMapOutputFile(flags.variable_map_output_file)
.setCreateNameMapFiles(flags.create_name_map_files)
.setPropertyMapOutputFile(flags.property_map_output_file)
.setCodingConvention(flags.third_party ?
new DefaultCodingConvention() :
new ClosureCodingConvention())
.setSummaryDetailLevel(flags.summary_detail_level)
.setOutputWrapper(flags.output_wrapper)
.setOutputWrapperMarker(flags.output_wrapper_marker)
.setModuleWrapper(flags.module_wrapper)
.setModuleOutputPathPrefix(flags.module_output_path_prefix)
.setCreateSourceMap(flags.create_source_map)
.setJscompError(flags.jscomp_error)
.setJscompWarning(flags.jscomp_warning)
.setJscompOff(flags.jscomp_off)
.setDefine(flags.define)
.setCharset(flags.charset)
.setManageClosureDependencies(flags.manage_closure_dependencies)
.setClosureEntryPoints(flags.closure_entry_point)
.setOutputManifest(flags.output_manifest);
}
}"
Closure_83b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_83_buggy/src/com/google/javascript/jscomp/CommandLineRunner.java,"*     MyCommandLineRunner runner = new MyCommandLineRunner(args);
*     if (runner.shouldRunCompiler()) {
*       runner.run();
*     } else {
*       System.exit(-1);
*     }"
Closure_83b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_83_buggy/src/com/google/javascript/jscomp/CommandLineRunner.java,"public boolean shouldRunCompiler() {
return this.isConfigValid;
}"
Closure_86b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_86_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"return functionCallHasSideEffects(callNode, null);
}

/**
* Returns true if calls to this function have side effects.
*
* @param callNode The call node to inspected.
* @param compiler A compiler object to provide program state changing
*     context information. Can be null.
*/
static boolean functionCallHasSideEffects(
Node callNode, @Nullable AbstractCompiler compiler) {"
Closure_86b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_86_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"return evaluatesToLocalValue(value, Predicates.<Node>alwaysFalse());
}

/**
* @param locals A predicate to apply to unknown local values.
* @return Whether the node is known to be a value that is not a reference
*     outside the expression scope.
*/
static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {"
Closure_86b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_86_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static boolean isImmutableValue(Node n) {
switch (n.getType()) {
case Token.STRING:
case Token.NUMBER:
case Token.NULL:
case Token.TRUE:
case Token.FALSE:
return true;
case Token.VOID:
case Token.NEG:
return isImmutableValue(n.getFirstChild());
case Token.NAME:
String name = n.getString();
// We assume here that programs don't change the value of the keyword
// undefined to something other than the value undefined.
return ""undefined"".equals(name)
|| ""Infinity"".equals(name)
|| ""NaN"".equals(name);
}

return false;
}"
Closure_86b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_86_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"return nodeTypeMayHaveSideEffects(n, null);
}

static boolean nodeTypeMayHaveSideEffects(Node n, AbstractCompiler compiler) {"
Closure_86b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_86_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static boolean isThis(Node node) {
return node.getType() == Token.THIS;
}"
Closure_87b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_87_buggy/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,"private Node tryMinimizeIf(Node n) {

Node parent = n.getParent();

Node cond = n.getFirstChild();

/* If the condition is a literal, we'll let other
* optimizations try to remove useless code.
*/
if (NodeUtil.isLiteralValue(cond, true)) {
return n;
}

Node thenBranch = cond.getNext();
Node elseBranch = thenBranch.getNext();

if (elseBranch == null) {
if (isFoldableExpressBlock(thenBranch)) {
Node expr = getBlockExpression(thenBranch);
if (isPropertyAssignmentInExpression(expr)) {
// Keep opportunities for CollapseProperties such as
// a.longIdentifier || a.longIdentifier = ... -> var a = ...;
return n;
}

if (cond.getType() == Token.NOT) {
// if(!x)bar(); -> x||bar();
if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&
isLowerPrecedenceInExpression(expr.getFirstChild(),
OR_PRECEDENCE)) {
// It's not okay to add two sets of parentheses.
return n;
}

Node or = new Node(Token.OR, cond.removeFirstChild(),
expr.removeFirstChild()).copyInformationFrom(n);
Node newExpr = NodeUtil.newExpr(or);
parent.replaceChild(n, newExpr);
reportCodeChange();

return newExpr;
}

// if(x)foo(); -> x&&foo();
if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) ||
isLowerPrecedenceInExpression(expr.getFirstChild(),
AND_PRECEDENCE)) {
// One additional set of parentheses isn't worth it.
return n;
}

n.removeChild(cond);
Node and = new Node(Token.AND, cond, expr.removeFirstChild())
.copyInformationFrom(n);
Node newExpr = NodeUtil.newExpr(and);
parent.replaceChild(n, newExpr);
reportCodeChange();

return newExpr;
}

return n;
}

/* TODO(dcc) This modifies the siblings of n, which is undesirable for a
* peephole optimization. This should probably get moved to another pass.
*/
tryRemoveRepeatedStatements(n);

// if(!x)foo();else bar(); -> if(x)bar();else foo();
// An additional set of curly braces isn't worth it.
if (cond.getType() == Token.NOT && !consumesDanglingElse(elseBranch)) {
n.replaceChild(cond, cond.removeFirstChild());
n.removeChild(thenBranch);
n.addChildToBack(thenBranch);
reportCodeChange();
return n;
}

// if(x)return 1;else return 2; -> return x?1:2;
if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
Node thenExpr = getBlockReturnExpression(thenBranch);
Node elseExpr = getBlockReturnExpression(elseBranch);
n.removeChild(cond);
thenExpr.detachFromParent();
elseExpr.detachFromParent();

// note - we ignore any cases with ""return;"", technically this
// can be converted to ""return undefined;"" or some variant, but
// that does not help code size.
Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)
.copyInformationFrom(n);
Node returnNode = new Node(Token.RETURN, hookNode);
parent.replaceChild(n, returnNode);
reportCodeChange();
return returnNode;
}

boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);

if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
Node thenOp = getBlockExpression(thenBranch).getFirstChild();
Node elseOp = getBlockExpression(elseBranch).getFirstChild();
if (thenOp.getType() == elseOp.getType()) {
// if(x)a=1;else a=2; -> a=x?1:2;
if (NodeUtil.isAssignmentOp(thenOp)) {
Node lhs = thenOp.getFirstChild();
if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&
// if LHS has side effects, don't proceed [since the optimization
// evaluates LHS before cond]
// NOTE - there are some circumstances where we can
// proceed even if there are side effects...
!mayEffectMutableState(lhs)) {

n.removeChild(cond);
Node assignName = thenOp.removeFirstChild();
Node thenExpr = thenOp.removeFirstChild();
Node elseExpr = elseOp.getLastChild();
elseOp.removeChild(elseExpr);

Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)
.copyInformationFrom(n);
Node assign = new Node(thenOp.getType(), assignName, hookNode)
.copyInformationFrom(thenOp);
Node expr = NodeUtil.newExpr(assign);
parent.replaceChild(n, expr);
reportCodeChange();

return expr;
}
} else if (NodeUtil.isCall(thenOp)) {
// if(x)foo();else bar(); -> x?foo():bar()
n.removeChild(cond);
thenOp.detachFromParent();
elseOp.detachFromParent();
Node hookNode = new Node(Token.HOOK, cond, thenOp, elseOp)
.copyInformationFrom(n);
Node expr = NodeUtil.newExpr(hookNode);
parent.replaceChild(n, expr);
reportCodeChange();

return expr;
}
}
return n;
}

boolean thenBranchIsVar = isVarBlock(thenBranch);
boolean elseBranchIsVar = isVarBlock(elseBranch);

// if(x)var y=1;else y=2  ->  var y=x?1:2
if (thenBranchIsVar && elseBranchIsExpressionBlock &&
NodeUtil.isAssign(getBlockExpression(elseBranch).getFirstChild())) {

Node var = getBlockVar(thenBranch);
Node elseAssign = getBlockExpression(elseBranch).getFirstChild();

Node name1 = var.getFirstChild();
Node maybeName2 = elseAssign.getFirstChild();

if (name1.hasChildren()
&& maybeName2.getType() == Token.NAME
&& name1.getString().equals(maybeName2.getString())) {
Node thenExpr = name1.removeChildren();
Node elseExpr = elseAssign.getLastChild().detachFromParent();
cond.detachFromParent();
Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)
.copyInformationFrom(n);
var.detachFromParent();
name1.addChildrenToBack(hookNode);
parent.replaceChild(n, var);
reportCodeChange();
return var;
}

// if(x)y=1;else var y=2  ->  var y=x?1:2
} else if (elseBranchIsVar && thenBranchIsExpressionBlock &&
NodeUtil.isAssign(getBlockExpression(thenBranch).getFirstChild())) {

Node var = getBlockVar(elseBranch);
Node thenAssign = getBlockExpression(thenBranch).getFirstChild();

Node maybeName1 = thenAssign.getFirstChild();
Node name2 = var.getFirstChild();

if (name2.hasChildren()
&& maybeName1.getType() == Token.NAME
&& maybeName1.getString().equals(name2.getString())) {
Node thenExpr = thenAssign.getLastChild().detachFromParent();
Node elseExpr = name2.removeChildren();
cond.detachFromParent();
Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)
.copyInformationFrom(n);
var.detachFromParent();
name2.addChildrenToBack(hookNode);
parent.replaceChild(n, var);
reportCodeChange();

return var;
}
}

return n;
}"
Closure_87b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_87_buggy/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,"private boolean isLowerPrecedenceInExpression(Node n,
final int precedence) {
Predicate<Node> isLowerPrecedencePredicate = new Predicate<Node>() {
@Override
public boolean apply(Node input) {
return NodeUtil.precedence(input.getType()) < precedence;
}
};

return NodeUtil.has(n, isLowerPrecedencePredicate,
DONT_TRAVERSE_FUNCTIONS_PREDICATE);
}"
Closure_87b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_87_buggy/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,"private boolean isPropertyAssignmentInExpression(Node n) {
Predicate<Node> isPropertyAssignmentInExpressionPredicate =
new Predicate<Node>() {
@Override
public boolean apply(Node input) {
return (input.getType() == Token.GETPROP &&
input.getParent().getType() == Token.ASSIGN);
}
};

return NodeUtil.has(n, isPropertyAssignmentInExpressionPredicate,
DONT_TRAVERSE_FUNCTIONS_PREDICATE);
}"
Closure_87b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_87_buggy/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,"private Node maybeReplaceChildWithNumber(Node n, Node parent, int num) {
Node newNode = Node.newNumber(num);
if (!newNode.isEquivalentTo(n)) {
parent.replaceChild(n, newNode);
reportCodeChange();

return newNode;
}

return n;
}"
Closure_87b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_87_buggy/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,"private Node tryMinimizeCondition(Node n) {
Node parent = n.getParent();

switch (n.getType()) {
case Token.NOT:
Node first = n.getFirstChild();
switch (first.getType()) {
case Token.NOT: {
Node newRoot = first.removeFirstChild();
parent.replaceChild(n, newRoot);
reportCodeChange();
// No need to traverse, tryMinimizeCondition is called on the
// NOT children are handled below.
return newRoot;
}
case Token.AND:
case Token.OR: {
Node leftParent = first.getFirstChild();
Node rightParent = first.getLastChild();
if (leftParent.getType() == Token.NOT
&& rightParent.getType() == Token.NOT) {
Node left = leftParent.removeFirstChild();
Node right = rightParent.removeFirstChild();

int newOp = (first.getType() == Token.AND) ? Token.OR : Token.AND;
Node newRoot = new Node(newOp, left, right);
parent.replaceChild(n, newRoot);
reportCodeChange();
// No need to traverse, tryMinimizeCondition is called on the
// AND and OR children below.
return newRoot;
}
}
break;
}
// No need to traverse, tryMinimizeCondition is called on the NOT
// children in the general case in the main post-order traversal.
return n;

case Token.OR:
case Token.AND: {
Node left = n.getFirstChild();
Node right = n.getLastChild();

// Because the expression is in a boolean context minimize
// the children, this can't be done in the general case.
left = tryMinimizeCondition(left);
right = tryMinimizeCondition(right);

// Remove useless conditionals
// Handle four cases:
//   x || false --> x
//   x || true  --> true
//   x && true --> x
//   x && false  --> false
TernaryValue rightVal = NodeUtil.getBooleanValue(right);
if (NodeUtil.getBooleanValue(right) != TernaryValue.UNKNOWN) {
int type = n.getType();
Node replacement = null;
boolean rval = rightVal.toBoolean(true);

// (x || FALSE) => x
// (x && TRUE) => x
if (type == Token.OR && !rval ||
type == Token.AND && rval) {
replacement = left;
} else if (!mayHaveSideEffects(left)) {
replacement = right;
}

if (replacement != null) {
n.detachChildren();
parent.replaceChild(n, replacement);
reportCodeChange();
return replacement;
}
}
return n;
}

case Token.HOOK: {
Node condition = n.getFirstChild();
Node trueNode = n.getFirstChild().getNext();
Node falseNode = n.getLastChild();

// Because the expression is in a boolean context minimize
// the result children, this can't be done in the general case.
// The condition is handled in the general case in #optimizeSubtree
trueNode = tryMinimizeCondition(trueNode);
falseNode = tryMinimizeCondition(falseNode);

// Handle four cases:
//   x ? true : false --> x
//   x ? false : true --> !x
//   x ? true : y     --> x || y
//   x ? y : false    --> x && y
Node replacement = null;
if (NodeUtil.getBooleanValue(trueNode) == TernaryValue.TRUE
&& NodeUtil.getBooleanValue(falseNode) == TernaryValue.FALSE) {
// Remove useless conditionals, keep the condition
condition.detachFromParent();
replacement = condition;
} else if (NodeUtil.getBooleanValue(trueNode) == TernaryValue.FALSE
&& NodeUtil.getBooleanValue(falseNode) == TernaryValue.TRUE) {
// Remove useless conditionals, keep the condition
condition.detachFromParent();
replacement = new Node(Token.NOT, condition);
} else if (NodeUtil.getBooleanValue(trueNode) == TernaryValue.TRUE) {
// Remove useless true case.
n.detachChildren();
replacement = new Node(Token.OR, condition, falseNode);
} else if (NodeUtil.getBooleanValue(falseNode) == TernaryValue.FALSE) {
// Remove useless false case
n.detachChildren();
replacement = new Node(Token.AND, condition, trueNode);
}

if (replacement != null) {
parent.replaceChild(n, replacement);
n = replacement;
reportCodeChange();
}

return n;
}

default:
// while(true) --> while(1)
TernaryValue nVal = NodeUtil.getBooleanValue(n);
if (nVal != TernaryValue.UNKNOWN) {
boolean result = nVal.toBoolean(true);
int equivalentResult = result ? 1 : 0;
return maybeReplaceChildWithNumber(n, parent, equivalentResult);
}
// We can't do anything else currently.
return n;
}
}"
Closure_88b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_88_buggy/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java,"private boolean isVariableStillLiveWithinExpression(
Node n, Node exprRoot, String variable) {
while (n != exprRoot) {
for(Node sibling = n.getNext(); sibling != null;
sibling = sibling.getNext()) {
if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {
VariableLiveness state = isVariableReadBeforeKill(sibling, variable);

// If we see a READ or KILL there is no need to continue.
if (state == VariableLiveness.READ) {
return true;
} else if (state == VariableLiveness.KILL) {
return false;
}
}
}
n = n.getParent();
}
return false;
}"
Closure_88b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_88_buggy/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java,"private VariableLiveness isVariableReadBeforeKill(
Node n, String variable) {
if (NodeUtil.isName(n) && variable.equals(n.getString())) {
if (NodeUtil.isLhs(n, n.getParent())) {
// The expression to which the assignment is made is evaluated before
// the RHS is evaluated (normal left to right evaluation) but the KILL
// occurs after the RHS is evaluated.
return VariableLiveness.KILL;
} else {
return VariableLiveness.READ;
}
}

// Expressions are evaluated left-right, depth first.
for (Node child = n.getFirstChild();
child != null; child = child.getNext()) {
if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION
VariableLiveness state = isVariableReadBeforeKill(child, variable);
if (state != VariableLiveness.MAYBE_LIVE) {
return state;
}
}
}
return VariableLiveness.MAYBE_LIVE;
}"
Closure_88b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_88_buggy/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java,"private void tryRemoveDeadAssignments(NodeTraversal t,
ControlFlowGraph<Node> cfg) {
Iterable<DiGraphNode<Node, Branch>> nodes = cfg.getDirectedGraphNodes();

for (DiGraphNode<Node, Branch> cfgNode : nodes) {
FlowState<LiveVariableLattice> state =
cfgNode.getAnnotation();
Node n = cfgNode.getValue();
if (n == null) {
continue;
}
switch (n.getType()) {
case Token.IF:
case Token.WHILE:
case Token.DO:
tryRemoveAssignment(t, NodeUtil.getConditionExpression(n), state);
continue;
case Token.FOR:
if (!NodeUtil.isForIn(n)) {
tryRemoveAssignment(
t, NodeUtil.getConditionExpression(n), state);
}
continue;
case Token.SWITCH:
case Token.CASE:
case Token.RETURN:
if (n.hasChildren()) {
tryRemoveAssignment(t, n.getFirstChild(), state);
}
continue;
// TODO(user): case Token.VAR: Remove var a=1;a=2;.....
}

tryRemoveAssignment(t, n, state);
}
}"
Closure_88b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_88_buggy/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java,"public void enterScope(NodeTraversal t) {
Scope scope = t.getScope();
// Global scope _SHOULD_ work, however, liveness won't finish without
// -Xmx1024 in closure. We might have to look at coding conventions for
// exported variables as well.
if (scope.isGlobal()) {
return;
}

// We are not going to do any dead assignment elimination in when there is
// at least one inner function because in most browsers, when there is a
// closure, ALL the variables are saved (escaped).
Node fnBlock = t.getScopeRoot().getLastChild();
if (NodeUtil.containsFunction(fnBlock)) {
return;
}

// We don't do any dead assignment elimination if there are no assigns
// to eliminate. :)
if (!NodeUtil.has(fnBlock, matchRemovableAssigns,
Predicates.<Node>alwaysTrue())) {
return;
}

// Computes liveness information first.
ControlFlowGraph<Node> cfg = t.getControlFlowGraph();
liveness = new LiveVariablesAnalysis(cfg, scope, compiler);
liveness.analyze();
tryRemoveDeadAssignments(t, cfg);
}"
Closure_88b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_88_buggy/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java,"public DeadAssignmentsElimination(AbstractCompiler compiler) {
this.compiler = compiler;
}"
Closure_91b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_91_buggy/src/com/google/javascript/jscomp/CheckGlobalThis.java,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

if (n.getType() == Token.FUNCTION) {
// Don't traverse functions that are constructors or have the @this
// or @override annotation.
JSDocInfo jsDoc = getFunctionJsDocInfo(n);
if (jsDoc != null &&
(jsDoc.isConstructor() ||
jsDoc.isInterface() ||
jsDoc.hasThisType() ||
jsDoc.isOverride())) {
return false;
}

// Don't traverse functions unless they would normally
// be able to have a @this annotation associated with them. e.g.,
// var a = function() { }; // or
// function a() {} // or
// a.x = function() {}; // or
// var a = {x: function() {}};
int pType = parent.getType();
if (!(pType == Token.BLOCK ||
pType == Token.SCRIPT ||
pType == Token.NAME ||
pType == Token.ASSIGN ||

// object literal keys
pType == Token.STRING ||
pType == Token.NUMBER)) {
return false;
}

// Don't traverse functions that are getting lent to a prototype.
}

if (parent != null && parent.getType() == Token.ASSIGN) {
Node lhs = parent.getFirstChild();
Node rhs = lhs.getNext();

if (n == lhs) {
// Always traverse the left side of the assignment. To handle
// nested assignments properly (e.g., (a = this).property = c;),
// assignLhsChild should not be overridden.
if (assignLhsChild == null) {
assignLhsChild = lhs;
}
} else {
// Only traverse the right side if it's not an assignment to a prototype
// property or subproperty.
if (NodeUtil.isGet(lhs)) {
if (lhs.getType() == Token.GETPROP &&
lhs.getLastChild().getString().equals(""prototype"")) {
return false;
}
Node llhs = lhs.getFirstChild();
if (llhs.getType() == Token.GETPROP &&
llhs.getLastChild().getString().equals(""prototype"")) {
return false;
}
}
}
}

return true;
}"
Closure_91b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_91_buggy/src/com/google/javascript/jscomp/CheckGlobalThis.java,"private boolean shouldReportThis(Node n, Node parent) {
if (assignLhsChild != null) {
// Always report a THIS on the left side of an assign.
return true;
}

// Also report a THIS with a property access.
return parent != null && NodeUtil.isGet(parent);
}"
Closure_91b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_91_buggy/src/com/google/javascript/jscomp/CheckGlobalThis.java,"public void visit(NodeTraversal t, Node n, Node parent) {
if (n.getType() == Token.THIS && shouldReportThis(n, parent)) {
compiler.report(t.makeError(n, level, GLOBAL_THIS));
}
if (n == assignLhsChild) {
assignLhsChild = null;
}
}"
Closure_91b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_91_buggy/src/com/google/javascript/jscomp/CheckGlobalThis.java,"private JSDocInfo getFunctionJsDocInfo(Node n) {
JSDocInfo jsDoc = n.getJSDocInfo();
Node parent = n.getParent();
if (jsDoc == null) {
int parentType = parent.getType();
if (parentType == Token.NAME || parentType == Token.ASSIGN) {
jsDoc = parent.getJSDocInfo();
if (jsDoc == null && parentType == Token.NAME) {
Node gramps = parent.getParent();
if (gramps.getType() == Token.VAR) {
jsDoc = gramps.getJSDocInfo();
}
}
}
}
return jsDoc;
}"
Closure_92b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_92_buggy/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java,"private static boolean isNamespacePlaceholder(Node n) {
if (!n.getBooleanProp(Node.IS_NAMESPACE)) {
return false;
}

Node value = null;
if (n.getType() == Token.EXPR_RESULT) {
Node assign = n.getFirstChild();
value = assign.getLastChild();
} else if (n.getType() == Token.VAR) {
Node name = n.getFirstChild();
value = name.getFirstChild();
}

return value != null
&& value.getType() == Token.OBJECTLIT
&& !value.hasChildren();
}"
Closure_92b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_92_buggy/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java,"private void registerAnyProvidedPrefixes(
String ns, Node node, JSModule module) {
int pos = ns.indexOf('.');
while (pos != -1) {
String prefixNs = ns.substring(0, pos);
pos = ns.indexOf('.', pos + 1);
if (providedNames.containsKey(prefixNs)) {
providedNames.get(prefixNs).addProvide(
node, module, false /* implicit */);
} else {
providedNames.put(
prefixNs,
new ProvidedName(prefixNs, node, module, false /* implicit */));
}
}
}"
Closure_92b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_92_buggy/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java,"private void processProvideCall(NodeTraversal t, Node n, Node parent) {
Node left = n.getFirstChild();
Node arg = left.getNext();
if (verifyProvide(t, left, arg)) {
String ns = arg.getString();
if (providedNames.containsKey(ns)) {
ProvidedName previouslyProvided = providedNames.get(ns);
if (!previouslyProvided.isExplicitlyProvided()) {
previouslyProvided.addProvide(parent, t.getModule(), true);
} else {
compiler.report(
t.makeError(n, DUPLICATE_NAMESPACE_ERROR, ns));
}
} else {
registerAnyProvidedPrefixes(ns, parent, t.getModule());
providedNames.put(
ns, new ProvidedName(ns, parent, t.getModule(), true));
}
}
}"
Closure_92b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_92_buggy/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java,"private boolean verifyProvide(NodeTraversal t, Node methodName, Node arg) {
if (!verifyArgument(t, methodName, arg)) {
return false;
}

for (String part : arg.getString().split(""\\."")) {
if (!NodeUtil.isValidPropertyName(part)) {
compiler.report(t.makeError(arg, INVALID_PROVIDE_ERROR, part));
return false;
}
}
return true;
}"
Closure_92b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_92_buggy/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java,"public void visit(NodeTraversal t, Node n, Node parent) {
switch (n.getType()) {
case Token.CALL:
boolean isExpr = parent.getType() == Token.EXPR_RESULT;
Node left = n.getFirstChild();
if (left.getType() == Token.GETPROP) {
Node name = left.getFirstChild();
if (name.getType() == Token.NAME &&
GOOG.equals(name.getString())) {
// For the sake of simplicity, we report code changes
// when we see a provides/requires, and don't worry about
// reporting the change when we actually do the replacement.
String methodName = name.getNext().getString();
if (""base"".equals(methodName)) {
processBaseClassCall(t, n);
} else if (!isExpr) {
// All other methods must be called in an EXPR.
break;
} else if (""require"".equals(methodName)) {
processRequireCall(t, n, parent);
} else if (""provide"".equals(methodName)) {
processProvideCall(t, n, parent);
} else if (""exportSymbol"".equals(methodName)) {
Node arg = left.getNext();
if (arg.getType() == Token.STRING) {
int dot = arg.getString().indexOf('.');
if (dot == -1) {
exportedVariables.add(arg.getString());
} else {
exportedVariables.add(arg.getString().substring(0, dot));
}
}
} else if (""addDependency"".equals(methodName)) {
CodingConvention convention = compiler.getCodingConvention();
List<String> typeDecls =
convention.identifyTypeDeclarationCall(n);
if (typeDecls != null) {
for (String typeDecl : typeDecls) {
compiler.getTypeRegistry().forwardDeclareType(typeDecl);
}
}

// We can't modify parent, so just create a node that will
// get compiled out.
parent.replaceChild(n, Node.newNumber(0));
compiler.reportCodeChange();
} else if (""setCssNameMapping"".equals(methodName)) {
processSetCssNameMapping(t, n, parent);
}
}
}
break;
case Token.ASSIGN:
case Token.NAME:
// If this is an assignment to a provided name, remove the provided
// object.
handleCandidateProvideDefinition(t, n, parent);
break;
case Token.FUNCTION:
// If this is a declaration of a provided named function, this is an
// error. Hosited functions will explode if the're provided.
if (t.inGlobalScope() &&
!NodeUtil.isFunctionExpression(n)) {
String name = n.getFirstChild().getString();
ProvidedName pn = providedNames.get(name);
if (pn != null) {
compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));
}
}
break;

case Token.NEW:
trySimplifyNewDate(t, n, parent);
break;

case Token.GETPROP:
if (n.getFirstChild().getType() == Token.NAME &&
parent.getType() != Token.CALL &&
parent.getType() != Token.ASSIGN &&
""goog.base"".equals(n.getQualifiedName())) {
reportBadBaseClassUse(t, n, ""May only be called directly."");
}
break;
}
}"
Closure_94b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_94_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static boolean isValidDefineValue(Node val, Set<String> defines) {
switch (val.getType()) {
case Token.STRING:
case Token.NUMBER:
case Token.TRUE:
case Token.FALSE:
return true;

// Binary operators are only valid if both children are valid.
case Token.BITAND:
case Token.BITNOT:
case Token.BITOR:
case Token.BITXOR:

// Uniary operators are valid if the child is valid.
case Token.NOT:
case Token.NEG:
return isValidDefineValue(val.getFirstChild(), defines);

// Names are valid if and only if they are defines themselves.
case Token.NAME:
case Token.GETPROP:
if (val.isQualifiedName()) {
return defines.contains(val.getQualifiedName());
}
}
return false;
}"
Closure_94b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_94_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static boolean isObjectLitKey(Node node, Node parent) {
if (node.getType() == Token.STRING && parent.getType() == Token.OBJECTLIT) {
int index = 0;
for (Node current = parent.getFirstChild();
current != null;
current = current.getNext()) {
if (current == node) {
return index % 2 == 0;
}
index++;
}
}
return false;
}"
Closure_94b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_94_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static boolean isConstantByConvention(
CodingConvention convention, Node node, Node parent) {
String name = node.getString();
if (parent.getType() == Token.GETPROP &&
node == parent.getLastChild()) {
return convention.isConstantKey(name);
} else if (isObjectLitKey(node, parent)) {
return convention.isConstantKey(name);
} else {
return convention.isConstant(name);
}
}"
Closure_94b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_94_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static JSDocInfo getInfoForNameNode(Node nameNode) {
JSDocInfo info = null;
Node parent = null;
if (nameNode != null) {
info = nameNode.getJSDocInfo();
parent = nameNode.getParent();
}

if (info == null && parent != null &&
((parent.getType() == Token.VAR && parent.hasOneChild()) ||
parent.getType() == Token.FUNCTION)) {
info = parent.getJSDocInfo();
}
return info;
}"
Closure_94b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_94_buggy/src/com/google/javascript/jscomp/NodeUtil.java,"static boolean isControlStructure(Node n) {
switch (n.getType()) {
case Token.FOR:
case Token.DO:
case Token.WHILE:
case Token.WITH:
case Token.IF:
case Token.LABEL:
case Token.TRY:
case Token.CATCH:
case Token.SWITCH:
case Token.CASE:
case Token.DEFAULT:
return true;
default:
return false;
}
}"
Closure_95b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_95_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"private static Node getPrototypePropertyOwner(Node n) {
if (n.getType() == Token.GETPROP) {
Node firstChild = n.getFirstChild();
if (firstChild.getType() == Token.GETPROP &&
firstChild.getLastChild().getString().equals(""prototype"")) {
Node maybeOwner = firstChild.getFirstChild();
if (maybeOwner.isQualifiedName()) {
return maybeOwner;
}
}
}
return null;
}"
Closure_95b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_95_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"private void attachLiteralTypes(Node n) {
switch (n.getType()) {
case Token.NULL:
n.setJSType(getNativeType(NULL_TYPE));
break;

case Token.VOID:
n.setJSType(getNativeType(VOID_TYPE));
break;

case Token.STRING:
n.setJSType(getNativeType(STRING_TYPE));
break;

case Token.NUMBER:
n.setJSType(getNativeType(NUMBER_TYPE));
break;

case Token.TRUE:
case Token.FALSE:
n.setJSType(getNativeType(BOOLEAN_TYPE));
break;

case Token.REGEXP:
n.setJSType(getNativeType(REGEXP_TYPE));
break;

case Token.REF_SPECIAL:
n.setJSType(getNativeType(UNKNOWN_TYPE));
break;

case Token.OBJECTLIT:
if (n.getJSType() == null) {
n.setJSType(typeRegistry.createAnonymousObjectType());
}
break;

// NOTE(nicksantos): If we ever support Array tuples,
// we will need to put ARRAYLIT here as well.
}
}"
Closure_95b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_95_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"public Scope createScope(Node root, Scope parent) {
// Constructing the global scope is very different than constructing
// inner scopes, because only global scopes can contain named classes that
// show up in the type registry.
Scope newScope = null;
AbstractScopeBuilder scopeBuilder = null;
if (parent == null) {
// Find all the classes in the global scope.
newScope = createInitialScope(root);

GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);
scopeBuilder = globalScopeBuilder;
NodeTraversal.traverse(compiler, root, scopeBuilder);
} else {
newScope = new Scope(parent, root);
LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);
scopeBuilder = localScopeBuilder;
localScopeBuilder.build();
}

scopeBuilder.resolveStubDeclarations();
scopeBuilder.resolveTypes();

// Gather the properties in each function that we found in the
// global scope, if that function has a @this type that we can
// build properties on.
for (Node functionNode : scopeBuilder.nonExternFunctions) {
JSType type = functionNode.getJSType();
if (type != null && type instanceof FunctionType) {
FunctionType fnType = (FunctionType) type;
ObjectType fnThisType = fnType.getTypeOfThis();
if (!fnThisType.isUnknownType()) {
NodeTraversal.traverse(compiler, functionNode.getLastChild(),
scopeBuilder.new CollectProperties(fnThisType));
}
}
}

if (parent == null) {
codingConvention.defineDelegateProxyPrototypeProperties(
typeRegistry, newScope, delegateProxyPrototypes);
}
return newScope;
}"
Closure_95b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_95_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"return typeRegistry.getNativeType(nativeType);
}

private abstract class AbstractScopeBuilder
implements NodeTraversal.Callback {"
Closure_95b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_95_buggy/src/com/google/javascript/jscomp/TypedScopeCreator.java,"Scope createInitialScope(Node root) {

NodeTraversal.traverse(compiler, root, new DiscoverEnums(typeRegistry));

Scope s = new Scope(root, compiler);
declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE);
declareNativeFunctionType(s, BOOLEAN_OBJECT_FUNCTION_TYPE);
declareNativeFunctionType(s, DATE_FUNCTION_TYPE);
declareNativeFunctionType(s, ERROR_FUNCTION_TYPE);
declareNativeFunctionType(s, EVAL_ERROR_FUNCTION_TYPE);
declareNativeFunctionType(s, FUNCTION_FUNCTION_TYPE);
declareNativeFunctionType(s, NUMBER_OBJECT_FUNCTION_TYPE);
declareNativeFunctionType(s, OBJECT_FUNCTION_TYPE);
declareNativeFunctionType(s, RANGE_ERROR_FUNCTION_TYPE);
declareNativeFunctionType(s, REFERENCE_ERROR_FUNCTION_TYPE);
declareNativeFunctionType(s, REGEXP_FUNCTION_TYPE);
declareNativeFunctionType(s, STRING_OBJECT_FUNCTION_TYPE);
declareNativeFunctionType(s, SYNTAX_ERROR_FUNCTION_TYPE);
declareNativeFunctionType(s, TYPE_ERROR_FUNCTION_TYPE);
declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE);
declareNativeValueType(s, ""undefined"", VOID_TYPE);

// The typedef construct needs the any type, so that it can be assigned
// to anything. This is kind of a hack, and an artifact of the typedef
// syntax we've chosen.
declareNativeValueType(s, ""goog.typedef"", NO_TYPE);

// ActiveXObject is unqiuely special, because it can be used to construct
// any type (the type that it creates is related to the arguments you
// pass to it).
declareNativeValueType(s, ""ActiveXObject"", NO_OBJECT_TYPE);

return s;
}"
Closure_96b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_96_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"public void visit(NodeTraversal t, Node n, Node parent) {
JSType childType;
JSType leftType, rightType;
Node left, right;
// To be explicitly set to false if the node is not typeable.
boolean typeable = true;

switch (n.getType()) {
case Token.NAME:
typeable = visitName(t, n, parent);
break;

case Token.LP:
// If this is under a FUNCTION node, it is a parameter list and can be
// ignored here.
if (parent.getType() != Token.FUNCTION) {
ensureTyped(t, n, getJSType(n.getFirstChild()));
} else {
typeable = false;
}
break;

case Token.COMMA:
ensureTyped(t, n, getJSType(n.getLastChild()));
break;

case Token.TRUE:
case Token.FALSE:
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.THIS:
ensureTyped(t, n, t.getScope().getTypeOfThis());
break;

case Token.REF_SPECIAL:
ensureTyped(t, n);
break;

case Token.GET_REF:
ensureTyped(t, n, getJSType(n.getFirstChild()));
break;

case Token.NULL:
ensureTyped(t, n, NULL_TYPE);
break;

case Token.NUMBER:
if (n.getParent().getType() != Token.OBJECTLIT) {
ensureTyped(t, n, NUMBER_TYPE);
} else {
typeable = false;
}
break;

case Token.ARRAYLIT:
ensureTyped(t, n, ARRAY_TYPE);
break;

case Token.STRING:
if (n.getParent().getType() != Token.OBJECTLIT) {
ensureTyped(t, n, STRING_TYPE);
} else {
typeable = false;
}
break;

case Token.REGEXP:
ensureTyped(t, n, REGEXP_TYPE);
break;

case Token.GETPROP:
visitGetProp(t, n, parent);
typeable = !(parent.getType() == Token.ASSIGN &&
parent.getFirstChild() == n);
break;

case Token.GETELEM:
visitGetElem(t, n);
// The type of GETELEM is always unknown, so no point counting that.
// If that unknown leaks elsewhere (say by an assignment to another
// variable), then it will be counted.
typeable = false;
break;

case Token.VAR:
visitVar(t, n);
typeable = false;
break;

case Token.NEW:
visitNew(t, n);
typeable = true;
break;

case Token.CALL:
visitCall(t, n);
typeable = !NodeUtil.isExpressionNode(parent);
break;

case Token.RETURN:
visitReturn(t, n);
typeable = false;
break;

case Token.DEC:
case Token.INC:
left = n.getFirstChild();
validator.expectNumber(
t, left, getJSType(left), ""increment/decrement"");
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.NOT:
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.VOID:
ensureTyped(t, n, VOID_TYPE);
break;

case Token.TYPEOF:
ensureTyped(t, n, STRING_TYPE);
break;

case Token.BITNOT:
childType = getJSType(n.getFirstChild());
if (!childType.matchesInt32Context()) {
report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),
childType.toString());
}
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.POS:
case Token.NEG:
left = n.getFirstChild();
validator.expectNumber(t, left, getJSType(left), ""sign operator"");
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.EQ:
case Token.NE: {
leftType = getJSType(n.getFirstChild());
rightType = getJSType(n.getLastChild());

JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
TernaryValue result =
leftTypeRestricted.testForEquality(rightTypeRestricted);
if (result != TernaryValue.UNKNOWN) {
if (n.getType() == Token.NE) {
result = result.not();
}
report(t, n, DETERMINISTIC_TEST, leftType.toString(),
rightType.toString(), result.toString());
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;
}

case Token.SHEQ:
case Token.SHNE: {
leftType = getJSType(n.getFirstChild());
rightType = getJSType(n.getLastChild());

JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();
if (!leftTypeRestricted.canTestForShallowEqualityWith(
rightTypeRestricted)) {
report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),
rightType.toString());
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;
}

case Token.LT:
case Token.LE:
case Token.GT:
case Token.GE:
leftType = getJSType(n.getFirstChild());
rightType = getJSType(n.getLastChild());
if (rightType.isNumber()) {
validator.expectNumber(
t, n, leftType, ""left side of numeric comparison"");
} else if (leftType.isNumber()) {
validator.expectNumber(
t, n, rightType, ""right side of numeric comparison"");
} else if (leftType.matchesNumberContext() &&
rightType.matchesNumberContext()) {
// OK.
} else {
// Whether the comparison is numeric will be determined at runtime
// each time the expression is evaluated. Regardless, both operands
// should match a string context.
String message = ""left side of comparison"";
validator.expectString(t, n, leftType, message);
validator.expectNotVoid(
t, n, leftType, message, getNativeType(STRING_TYPE));
message = ""right side of comparison"";
validator.expectString(t, n, rightType, message);
validator.expectNotVoid(
t, n, rightType, message, getNativeType(STRING_TYPE));
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.IN:
left = n.getFirstChild();
right = n.getLastChild();
leftType = getJSType(left);
rightType = getJSType(right);
validator.expectObject(t, n, rightType, ""'in' requires an object"");
validator.expectString(t, left, leftType, ""left side of 'in'"");
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.INSTANCEOF:
left = n.getFirstChild();
right = n.getLastChild();
leftType = getJSType(left);
rightType = getJSType(right).restrictByNotNullOrUndefined();

validator.expectAnyObject(
t, left, leftType, ""deterministic instanceof yields false"");
validator.expectActualObject(
t, right, rightType, ""instanceof requires an object"");
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.ASSIGN:
visitAssign(t, n);
typeable = false;
break;

case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_SUB:
case Token.ASSIGN_ADD:
case Token.ASSIGN_MUL:
case Token.LSH:
case Token.RSH:
case Token.URSH:
case Token.DIV:
case Token.MOD:
case Token.BITOR:
case Token.BITXOR:
case Token.BITAND:
case Token.SUB:
case Token.ADD:
case Token.MUL:
visitBinaryOperator(n.getType(), t, n);
break;

case Token.DELPROP:
if (!isReference(n.getFirstChild())) {
report(t, n, BAD_DELETE);
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.CASE:
JSType switchType = getJSType(parent.getFirstChild());
JSType caseType = getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t, n, switchType, caseType);
typeable = false;
break;

case Token.WITH: {
Node child = n.getFirstChild();
childType = getJSType(child);
validator.expectObject(
t, child, childType, ""with requires an object"");
typeable = false;
break;
}

case Token.FUNCTION:
visitFunction(t, n);
break;

// These nodes have no interesting type behavior.
case Token.LABEL:
case Token.LABEL_NAME:
case Token.SWITCH:
case Token.BREAK:
case Token.CATCH:
case Token.TRY:
case Token.SCRIPT:
case Token.EXPR_RESULT:
case Token.BLOCK:
case Token.EMPTY:
case Token.DEFAULT:
case Token.CONTINUE:
case Token.DEBUGGER:
case Token.THROW:
typeable = false;
break;

// These nodes require data flow analysis.
case Token.DO:
case Token.FOR:
case Token.IF:
case Token.WHILE:
typeable = false;
break;

// These nodes are typed during the type inference.
case Token.AND:
case Token.HOOK:
case Token.OBJECTLIT:
case Token.OR:
if (n.getJSType() != null) { // If we didn't run type inference.
ensureTyped(t, n);
} else {
// If this is an enum, then give that type to the objectlit as well.
if ((n.getType() == Token.OBJECTLIT)
&& (parent.getJSType() instanceof EnumType)) {
ensureTyped(t, n, parent.getJSType());
} else {
ensureTyped(t, n);
}
}
break;

default:
report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
ensureTyped(t, n);
break;
}

// Don't count externs since the user's code may not even use that part.
typeable = typeable && !inExterns;

if (typeable) {
doPercentTypedAccounting(t, n);
}

checkNoTypeCheckSection(n, false);
}"
Closure_96b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_96_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"private void visitParameterList(NodeTraversal t, Node call,
FunctionType functionType) {
Iterator<Node> arguments = call.children().iterator();
arguments.next(); // skip the function name

Iterator<Node> parameters = functionType.getParameters().iterator();
int ordinal = 0;
Node parameter = null;
Node argument = null;
while (arguments.hasNext() &&
parameters.hasNext()) {
// If there are no parameters left in the list, then the while loop
// above implies that this must be a var_args function.
parameter = parameters.next();
argument = arguments.next();
ordinal++;

validator.expectArgumentMatchesParameter(t, argument,
getJSType(argument), getJSType(parameter), call, ordinal);
}

int numArgs = call.getChildCount() - 1;
int minArgs = functionType.getMinArguments();
int maxArgs = functionType.getMaxArguments();
if (minArgs > numArgs || maxArgs < numArgs) {
report(t, call, WRONG_ARGUMENT_COUNT,
validator.getReadableJSTypeName(call.getFirstChild(), false),
String.valueOf(numArgs), String.valueOf(minArgs),
maxArgs != Integer.MAX_VALUE ?
"" and no more than "" + maxArgs + "" argument(s)"" : """");
}
}"
Closure_96b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_96_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"private void visitCall(NodeTraversal t, Node n) {
Node child = n.getFirstChild();
JSType childType = getJSType(child).restrictByNotNullOrUndefined();

if (!childType.canBeCalled()) {
report(t, n, NOT_CALLABLE, childType.toString());
ensureTyped(t, n);
return;
}

// A couple of types can be called as if they were functions.
// If it is a function type, then validate parameters.
if (childType instanceof FunctionType) {
FunctionType functionType = (FunctionType) childType;

// Non-native constructors should never be called directly.
if (functionType.isConstructor() &&
!functionType.isNativeObjectType()) {
report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());
}

visitParameterList(t, n, functionType);
ensureTyped(t, n, functionType.getReturnType());
} else {
ensureTyped(t, n);
}

// TODO: Add something to check for calls of RegExp objects, which is not
// supported by IE.  Either say something about the return type or warn
// about the non-portability of the call or both.
}"
Closure_96b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_96_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"public void process(Node externsRoot, Node jsRoot) {
Preconditions.checkNotNull(scopeCreator);
Preconditions.checkNotNull(topScope);

Node externsAndJs = jsRoot.getParent();
Preconditions.checkState(externsAndJs != null);
Preconditions.checkState(
externsRoot == null || externsAndJs.hasChild(externsRoot));

if (externsRoot != null) {
check(externsRoot, true);
}
check(jsRoot, false);
}"
Closure_96b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_96_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"public void check(Node node, boolean externs) {
Preconditions.checkNotNull(node);

NodeTraversal t = new NodeTraversal(compiler, this, scopeCreator);
inExterns = externs;
t.traverseWithScope(node, topScope);
if (externs) {
inferJSDocInfo.process(node, null);
} else {
inferJSDocInfo.process(null, node);
}
}"
Closure_97b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_97_buggy/src/com/google/javascript/jscomp/PeepholeFoldConstants.java,"private Node tryFoldShift(Node n, Node left, Node right) {
if (left.getType() == Token.NUMBER &&
right.getType() == Token.NUMBER) {

double result;
double lval = left.getDouble();
double rval = right.getDouble();

// check ranges.  We do not do anything that would clip the double to
// a 32-bit range, since the user likely does not intend that.
if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {
error(BITWISE_OPERAND_OUT_OF_RANGE, left);
return n;
}

// only the lower 5 bits are used when shifting, so don't do anything
// if the shift amount is outside [0,32)
if (!(rval >= 0 && rval < 32)) {
error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);
return n;
}

// Convert the numbers to ints
int lvalInt = (int) lval;
if (lvalInt != lval) {
error(FRACTIONAL_BITWISE_OPERAND, left);
return n;
}

int rvalInt = (int) rval;
if (rvalInt != rval) {
error(FRACTIONAL_BITWISE_OPERAND, right);
return n;
}

switch (n.getType()) {
case Token.LSH:
result = lvalInt << rvalInt;
break;
case Token.RSH:
result = lvalInt >> rvalInt;
break;
case Token.URSH:
// JavaScript handles zero shifts on signed numbers differently than
// Java as an Java int can not represent the unsigned 32-bit number
// where JavaScript can so use a long here.
result = lvalInt >>> rvalInt;
break;
default:
throw new AssertionError(""Unknown shift operator: "" +
Node.tokenToName(n.getType()));
}

Node newNumber = Node.newNumber(result);
n.getParent().replaceChild(n, newNumber);
reportCodeChange();

return newNumber;
}

return n;
}"
Closure_97b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_97_buggy/src/com/google/javascript/jscomp/PeepholeFoldConstants.java,"private Node tryFoldBinaryOperator(Node subtree) {
Node left = subtree.getFirstChild();

if (left == null) {
return subtree;
}

Node right = left.getNext();

if (right == null) {
return subtree;
}

// If we've reached here, node is truly a binary operator.
switch(subtree.getType()) {
case Token.GETPROP:
return tryFoldGetProp(subtree, left, right);

case Token.GETELEM:
return tryFoldGetElem(subtree, left, right);

case Token.INSTANCEOF:
return tryFoldInstanceof(subtree, left, right);

case Token.AND:
case Token.OR:
return tryFoldAndOr(subtree, left, right);

case Token.BITAND:
case Token.BITOR:
return tryFoldBitAndOr(subtree, left, right);

case Token.LSH:
case Token.RSH:
case Token.URSH:
return tryFoldShift(subtree, left, right);

case Token.ASSIGN:
return tryFoldAssign(subtree, left, right);

case Token.ADD:
return tryFoldAdd(subtree, left, right);

case Token.SUB:
case Token.MUL:
case Token.DIV:
return tryFoldArithmetic(subtree, left, right);

case Token.LT:
case Token.GT:
case Token.LE:
case Token.GE:
case Token.EQ:
case Token.NE:
case Token.SHEQ:
case Token.SHNE:
return tryFoldComparison(subtree, left, right);

default:
return subtree;
}
}"
Closure_97b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_97_buggy/src/com/google/javascript/jscomp/PeepholeFoldConstants.java,"private Node tryFoldAssign(Node n, Node left, Node right) {
Preconditions.checkArgument(n.getType() == Token.ASSIGN);

// Tries to convert x = x + y -> x += y;
if (!right.hasChildren() ||
right.getFirstChild().getNext() != right.getLastChild()) {
// RHS must have two children.
return n;
}

if (NodeUtil.mayHaveSideEffects(left)) {
return n;
}

Node leftChild = right.getFirstChild();
if (!areNodesEqualForInlining(left, leftChild)) {
return n;
}

int newType = -1;
switch (right.getType()) {
case Token.ADD:
newType = Token.ASSIGN_ADD;
break;
case Token.BITAND:
newType = Token.ASSIGN_BITAND;
break;
case Token.BITOR:
newType = Token.ASSIGN_BITOR;
break;
case Token.BITXOR:
newType = Token.ASSIGN_BITXOR;
break;
case Token.DIV:
newType = Token.ASSIGN_DIV;
break;
case Token.LSH:
newType = Token.ASSIGN_LSH;
break;
case Token.MOD:
newType = Token.ASSIGN_MOD;
break;
case Token.MUL:
newType = Token.ASSIGN_MUL;
break;
case Token.RSH:
newType = Token.ASSIGN_RSH;
break;
case Token.SUB:
newType = Token.ASSIGN_SUB;
break;
case Token.URSH:
newType = Token.ASSIGN_URSH;
break;
default:
return n;
}

Node newNode = new Node(newType,
left.detachFromParent(), right.getLastChild().detachFromParent());
n.getParent().replaceChild(n, newNode);

reportCodeChange();

return newNode;
}"
Closure_97b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_97_buggy/src/com/google/javascript/jscomp/PeepholeFoldConstants.java,"Node optimizeSubtree(Node subtree) {
switch(subtree.getType()) {
case Token.CALL:
return tryFoldKnownMethods(subtree);

case Token.TYPEOF:
return tryFoldTypeof(subtree);

case Token.NOT:
case Token.NEG:
case Token.BITNOT:
return tryFoldUnaryOperator(subtree);

default:
return tryFoldBinaryOperator(subtree);
}
}"
Closure_99b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_99_buggy/src/com/google/javascript/jscomp/CheckGlobalThis.java,"public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {

if (n.getType() == Token.FUNCTION) {
// Don't traverse functions that are constructors or have the @this
// or @override annotation.
JSDocInfo jsDoc = getFunctionJsDocInfo(n);
if (jsDoc != null &&
(jsDoc.isConstructor() ||
jsDoc.hasThisType() ||
jsDoc.isOverride())) {
return false;
}

// Don't traverse functions unless they would normally
// be able to have a @this annotation associated with them. e.g.,
// var a = function() { }; // or
// function a() {} // or
// a.x = function() {};
int pType = parent.getType();
if (!(pType == Token.BLOCK ||
pType == Token.SCRIPT ||
pType == Token.NAME ||
pType == Token.ASSIGN)) {
return false;
}
}

if (parent != null && parent.getType() == Token.ASSIGN) {
Node lhs = parent.getFirstChild();
Node rhs = lhs.getNext();

if (n == lhs) {
// Always traverse the left side of the assignment. To handle
// nested assignments properly (e.g., (a = this).property = c;),
// assignLhsChild should not be overridden.
if (assignLhsChild == null) {
assignLhsChild = lhs;
}
} else {
// Only traverse the right side if it's not an assignment to a prototype
// property or subproperty.
if (lhs.getType() == Token.GETPROP &&
lhs.getLastChild().getString().equals(""prototype"")) {
return false;
}
if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) {
return false;
}
}
}

return true;
}"
Closure_99b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_99_buggy/src/com/google/javascript/jscomp/CheckGlobalThis.java,"public void visit(NodeTraversal t, Node n, Node parent) {
if (n.getType() == Token.THIS && shouldReportThis(n, parent)) {
compiler.report(t.makeError(n, level, GLOBAL_THIS));
}
if (n == assignLhsChild) {
assignLhsChild = null;
}
}"
Closure_99b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_99_buggy/src/com/google/javascript/jscomp/CheckGlobalThis.java,"private JSDocInfo getFunctionJsDocInfo(Node n) {
JSDocInfo jsDoc = n.getJSDocInfo();
Node parent = n.getParent();
if (jsDoc == null) {
int parentType = parent.getType();
if (parentType == Token.NAME || parentType == Token.ASSIGN) {
jsDoc = parent.getJSDocInfo();
if (jsDoc == null && parentType == Token.NAME) {
Node gramps = parent.getParent();
if (gramps.getType() == Token.VAR) {
jsDoc = gramps.getJSDocInfo();
}
}
}
}
return jsDoc;
}"
Closure_99b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_99_buggy/src/com/google/javascript/jscomp/CheckGlobalThis.java,"private boolean shouldReportThis(Node n, Node parent) {
if (assignLhsChild != null) {
// Always report a THIS on the left side of an assign.
return true;
}

// Also report a THIS with a property access.
return parent != null && NodeUtil.isGet(parent);
}"
Closure_101b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_101_buggy/src/com/google/javascript/jscomp/CommandLineRunner.java,"private void initConfigFromFlags(
String[] args, PrintStream err)"
Closure_101b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_101_buggy/src/com/google/javascript/jscomp/CommandLineRunner.java,"*       (new MyCommandLineRunner(args)).run();
*     } catch (CmdLineException e) {"
Closure_101b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_101_buggy/src/com/google/javascript/jscomp/CommandLineRunner.java,"protected CompilerOptions createOptions() {
CompilerOptions options = new CompilerOptions();
options.setCodingConvention(new ClosureCodingConvention());
CompilationLevel level = flags.compilation_level;
level.setOptionsForCompilationLevel(options);
if (flags.debug) {
level.setDebugOptionsForCompilationLevel(options);
}

WarningLevel wLevel = flags.warning_level;
wLevel.setOptionsForWarningLevel(options);
for (FormattingOption formattingOption : flags.formatting) {
formattingOption.applyToOptions(options);
}
if (flags.process_closure_primitives) {
options.closurePass = true;
}

initOptionsFromFlags(options);
return options;
}"
Closure_101b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_101_buggy/src/com/google/javascript/jscomp/CommandLineRunner.java,"protected Compiler createCompiler() {
return new Compiler(getErrorPrintStream());
}"
Closure_102b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_102_buggy/src/com/google/javascript/jscomp/Normalize.java,"private void splitVarDeclarations(Node n) {
for (Node next, c = n.getFirstChild(); c != null; c = next) {
next = c.getNext();
if (c.getType() == Token.VAR) {
if (assertOnChange && !c.hasChildren()) {
throw new IllegalStateException(""Empty VAR node."");
}

while (c.getFirstChild() != c.getLastChild()) {
Node name = c.getFirstChild();
c.removeChild(name);
Node newVar = new Node(Token.VAR, name, n.getLineno(), n.getCharno());
n.addChildBefore(newVar, c);
reportCodeChange(""VAR with multiple children"");
}
}
}
}"
Closure_102b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_102_buggy/src/com/google/javascript/jscomp/Normalize.java,"private void moveNamedFunctions(Node functionBody) {
Preconditions.checkState(
functionBody.getParent().getType() == Token.FUNCTION);
Node previous = null;
Node current = functionBody.getFirstChild();
// Skip any declarations at the beginning of the function body, they
// are already in the right place.
while (current != null && NodeUtil.isFunctionDeclaration(current)) {
previous = current;
current = current.getNext();
}

// Find any remaining declarations and move them.
Node insertAfter = previous;
while (current != null) {
// Save off the next node as the current node maybe removed.
Node next = current.getNext();
if (NodeUtil.isFunctionDeclaration(current)) {
// Remove the declaration from the body.
Preconditions.checkNotNull(previous);
functionBody.removeChildAfter(previous);

// Readd the function at the top of the function body (after any
// previous declarations).
insertAfter = addToFront(functionBody, current, insertAfter);
compiler.reportCodeChange();
} else {
// Update the previous only if the current node hasn't been moved.
previous = current;
}
current = next;
}
}"
Closure_102b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_102_buggy/src/com/google/javascript/jscomp/Normalize.java,"private void doStatementNormalizations(NodeTraversal t, Node n, Node parent) {
if (n.getType() == Token.LABEL) {
normalizeLabels(n);
}

// Only inspect the children of SCRIPTs, BLOCKs and LABELs, as all these
// are the only legal place for VARs and FOR statements.
if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {
extractForInitializer(n, null, null);
}

// Only inspect the children of SCRIPTs, BLOCKs, as all these
// are the only legal place for VARs.
if (NodeUtil.isStatementBlock(n)) {
splitVarDeclarations(n);
}

if (n.getType() == Token.FUNCTION) {
moveNamedFunctions(n.getLastChild());
}
}"
Closure_102b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_102_buggy/src/com/google/javascript/jscomp/Normalize.java,"Normalize(AbstractCompiler compiler, boolean assertOnChange) {
this.compiler = compiler;
this.assertOnChange = assertOnChange;
}"
Closure_102b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_102_buggy/src/com/google/javascript/jscomp/Normalize.java,"public void process(Node externs, Node root) {
NodeTraversal.traverse(compiler, root, this);
if (MAKE_LOCAL_NAMES_UNIQUE) {
MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
NodeTraversal t = new NodeTraversal(compiler, renamer);
t.traverseRoots(externs, root);
}
removeDuplicateDeclarations(root);
new PropogateConstantAnnotations(compiler, assertOnChange)
.process(externs, root);
}"
Closure_104b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_104_buggy/src/com/google/javascript/rhino/jstype/UnionType.java,"JSType meet(JSType that) {
UnionTypeBuilder builder = new UnionTypeBuilder(registry);
for (JSType alternate : alternates) {
if (alternate.isSubtype(that)) {
builder.addAlternate(alternate);
}
}

if (that instanceof UnionType) {
for (JSType otherAlternate : ((UnionType) that).alternates) {
if (otherAlternate.isSubtype(this)) {
builder.addAlternate(otherAlternate);
}
}
} else if (that.isSubtype(this)) {
builder.addAlternate(that);
}
JSType result = builder.build();
if (result != null) {
return result;
} else if (this.isObject() && that.isObject()) {
return getNativeType(JSTypeNative.NO_OBJECT_TYPE);
} else {
return getNativeType(JSTypeNative.NO_TYPE);
}
}"
Closure_104b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_104_buggy/src/com/google/javascript/rhino/jstype/UnionType.java,"public boolean isUnionType() {
return true;
}"
Closure_104b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_104_buggy/src/com/google/javascript/rhino/jstype/UnionType.java,"public boolean isSubtype(JSType that) {
for (JSType element : alternates) {
if (!element.isSubtype(that)) {
return false;
}
}
return true;
}"
Closure_104b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_104_buggy/src/com/google/javascript/rhino/jstype/UnionType.java,"public boolean isUnknownType() {
for (JSType t : alternates) {
if (t.isUnknownType()) {
return true;
}
}
return false;
}"
Closure_104b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_104_buggy/src/com/google/javascript/rhino/jstype/UnionType.java,"UnionType(JSTypeRegistry registry, Set<JSType> alternates) {
super(registry);
this.alternates = alternates;
}"
Closure_105b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_105_buggy/src/com/google/javascript/jscomp/FoldConstants.java,"void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,
Node parent) {
if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
return;
}

Node arrayNode = left.getFirstChild();
Node functionName = arrayNode.getNext();

if ((arrayNode.getType() != Token.ARRAYLIT) ||
!functionName.getString().equals(""join"")) {
return;
}

String joinString = NodeUtil.getStringValue(right);
List<Node> arrayFoldedChildren = Lists.newLinkedList();
StringBuilder sb = new StringBuilder();
int foldedSize = 0;
Node elem = arrayNode.getFirstChild();
// Merges adjacent String nodes.
while (elem != null) {
if (NodeUtil.isImmutableValue(elem)) {
if (sb.length() > 0) {
sb.append(joinString);
}
sb.append(NodeUtil.getStringValue(elem));
} else {
if (sb.length() > 0) {
// + 2 for the quotes.
foldedSize += sb.length() + 2;
arrayFoldedChildren.add(Node.newString(sb.toString()));
sb = new StringBuilder();
}
foldedSize += InlineCostEstimator.getCost(elem);
arrayFoldedChildren.add(elem);
}
elem = elem.getNext();
}

if (sb.length() > 0) {
// + 2 for the quotes.
foldedSize += sb.length() + 2;
arrayFoldedChildren.add(Node.newString(sb.toString()));
}
// one for each comma.
foldedSize += arrayFoldedChildren.size() - 1;

int originalSize = InlineCostEstimator.getCost(n);
switch (arrayFoldedChildren.size()) {
case 0:
Node emptyStringNode = Node.newString("""");
parent.replaceChild(n, emptyStringNode);
break;

case 1:
Node foldedStringNode = arrayFoldedChildren.remove(0);
if (foldedSize > originalSize) {
return;
}
arrayNode.detachChildren();
if (foldedStringNode.getType() != Token.STRING) {
// If the Node is not a string literal, ensure that
// it is coerced to a string.
Node replacement = new Node(Token.ADD,
Node.newString(""""), foldedStringNode);
foldedStringNode = replacement;
}
parent.replaceChild(n, foldedStringNode);
break;

default:
// No folding could actually be performed.
if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {
return;
}
int kJoinOverhead = ""[].join()"".length();
foldedSize += kJoinOverhead;
foldedSize += InlineCostEstimator.getCost(right);
if (foldedSize > originalSize) {
return;
}
arrayNode.detachChildren();
for (Node node : arrayFoldedChildren) {
arrayNode.addChildToBack(node);
}
break;
}
t.getCompiler().reportCodeChange();
}"
Closure_105b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_105_buggy/src/com/google/javascript/jscomp/FoldConstants.java,"void tryFoldStringIndexOf(NodeTraversal t, Node n, Node left, Node right,
Node parent) {
if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {
return;
}

Node lstringNode = left.getFirstChild();
Node functionName = lstringNode.getNext();

if ((lstringNode.getType() != Token.STRING) ||
(!functionName.getString().equals(""indexOf"") &&
!functionName.getString().equals(""lastIndexOf""))) {
return;
}

String lstring = NodeUtil.getStringValue(lstringNode);
boolean isIndexOf = functionName.getString().equals(""indexOf"");
Node firstArg = right;
Node secondArg = right.getNext();
String searchValue = NodeUtil.getStringValue(firstArg);
// searchValue must be a valid string.
if (searchValue == null) {
return;
}
int fromIndex = isIndexOf ? 0 : lstring.length();
if (secondArg != null) {
// Third-argument and non-numeric second arg are problematic. Discard.
if ((secondArg.getNext() != null) ||
(secondArg.getType() != Token.NUMBER)) {
return;
} else {
fromIndex = (int) secondArg.getDouble();
}
}
int indexVal = isIndexOf ? lstring.indexOf(searchValue, fromIndex)
: lstring.lastIndexOf(searchValue, fromIndex);
Node newNode = Node.newNumber(indexVal);
parent.replaceChild(n, newNode);

t.getCompiler().reportCodeChange();
}"
Closure_105b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_105_buggy/src/com/google/javascript/jscomp/FoldConstants.java,"public void visit(NodeTraversal t, Node n, Node parent) {
int type = n.getType();

if (type == Token.BLOCK) {
tryFoldBlock(t, n, parent);
return;
}

Node left = n.getFirstChild();
if (left == null) {
return;
}

if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {
String newValue = null;

switch (left.getType()) {
case Token.STRING:
newValue = ""string"";
break;
case Token.NUMBER:
newValue = ""number"";
break;
case Token.TRUE:
case Token.FALSE:
newValue = ""boolean"";
break;
case Token.NULL:
case Token.OBJECTLIT:
case Token.ARRAYLIT:
newValue = ""object"";
break;
case Token.NAME:
// We assume here that programs don't change the value of the
// keyword undefined to something other than the value undefined.
if (""undefined"".equals(left.getString())) {
newValue = ""undefined"";
}
break;
}

if (newValue != null) {
parent.replaceChild(n, Node.newString(newValue));
t.getCompiler().reportCodeChange();
}

return;
}

if (type == Token.NOT ||
type == Token.NEG ||
type == Token.BITNOT) {
Preconditions.checkState(n.hasOneChild());

if (NodeUtil.isExpressionNode(parent)) {
// If the value of the NOT isn't used, then just throw
// away the operator
parent.replaceChild(n, n.removeFirstChild());
t.getCompiler().reportCodeChange();
return;
}

// Try to mimize NOT nodes such as !(x==y) into x!=y.
if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {
return;
}

if (!NodeUtil.isLiteralValue(left)) {
return;
}

switch (type) {
case Token.NOT:
int result = NodeUtil.getBooleanValue(left) ? Token.FALSE :
Token.TRUE;
parent.replaceChild(n, new Node(result));
t.getCompiler().reportCodeChange();
break;

case Token.NEG:
try {
if (left.getType() == Token.NAME) {
if (left.getString().equals(""Infinity"")) {
// ""-Infinity"" is valid and a literal, don't modify it.
return;
} else if (left.getString().equals(""NaN"")) {
// ""-NaN"" is ""NaN"".
n.removeChild(left);
parent.replaceChild(n, left);
t.getCompiler().reportCodeChange();
return;
}
}

double negNum = -left.getDouble();
parent.replaceChild(n, Node.newNumber(negNum));
t.getCompiler().reportCodeChange();
} catch (UnsupportedOperationException ex) {
// left is not a number node, so do not replace, but warn the
// user because they can't be doing anything good
error(t, NEGATING_A_NON_NUMBER_ERROR, left);
}
break;

case Token.BITNOT:
try {
double val = left.getDouble();
if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
int intVal = (int) val;
if (intVal == val) {
parent.replaceChild(n, Node.newNumber(~intVal));
t.getCompiler().reportCodeChange();
} else {
error(t, FRACTIONAL_BITWISE_OPERAND, left);
}
} else {
error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);
}
} catch (UnsupportedOperationException ex) {
// left is not a number node, so do not replace, but warn the
// user because they can't be doing anything good
error(t, NEGATING_A_NON_NUMBER_ERROR, left);
}
break;
}
return;
} else if (type == Token.NEW) {
if (Token.NAME == left.getType()) {
String className = left.getString();
if (""RegExp"".equals(className)) {
tryFoldRegularExpressionConstructor(t, n, parent);
} else if (left.getNext() == null) {
if (""Array"".equals(className)) {
tryFoldLiteralConstructor(
t, n, parent, className, Token.ARRAYLIT);
} else if (""Object"".equals(className)) {
tryFoldLiteralConstructor(
t, n, parent, className, Token.OBJECTLIT);
}
}
}
}

if (type == Token.EXPR_RESULT) {
tryMinimizeCondition(t, left, n);
return;
}

if (type == Token.RETURN) {
tryReduceReturn(t, n);
return;
}

Node right = left.getNext();
if (right == null) {
return;
}

// TODO(johnlenz) Use type information if available to fold
// instanceof.
if (type == Token.INSTANCEOF
&& NodeUtil.isLiteralValue(left)
&& !NodeUtil.mayHaveSideEffects(right)) {
if (NodeUtil.isImmutableValue(left)) {
// Non-object types are never instances.
parent.replaceChild(n, new Node(Token.FALSE));
t.getCompiler().reportCodeChange();
return;
}

if (right.getType() == Token.NAME
&& ""Object"".equals(right.getString())) {
parent.replaceChild(n, new Node(Token.TRUE));
t.getCompiler().reportCodeChange();
return;
}
}

if (type == Token.IF || type == Token.HOOK) {
tryMinimizeCondition(t, n.getFirstChild(), n);
boolean changes = tryFoldHookIf(t, n, parent);

// bad cascades can occur if we run the second round
// of IF optimizations immediately
if (type == Token.IF && !changes) {
tryMinimizeIf(t, n, parent);
}
return;
}

if (type == Token.DO) {
tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
tryFoldDo(t, n, parent);
return;
}

if (type == Token.WHILE) {
tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);
tryFoldWhile(t, n, parent);
return;
}

if (type == Token.FOR) {
Node condition = NodeUtil.getConditionExpression(n);
if (condition != null) {
tryMinimizeCondition(t, condition, n);
// The root condition node might have changed, get it again.
condition = NodeUtil.getConditionExpression(n);
this.tryFoldForCondition(condition, n);
}

tryFoldFor(t, n, parent);
return;
}

if (type == Token.AND ||
type == Token.OR) {
tryFoldAndOr(t, n, left, right, parent);
return;
}

if (type == Token.BITOR ||
type == Token.BITAND) {
tryFoldBitAndOr(t, n, left, right, parent);
return;
}

if (type == Token.LSH ||
type == Token.RSH ||
type == Token.URSH) {
tryFoldShift(t, n, left, right, parent);
return;
}

if (type == Token.GETPROP) {
tryFoldGetProp(t, n, left, right, parent);
return;
}

if (type == Token.CALL) {
tryFoldStringJoin(t, n, left, right, parent);
tryFoldStringIndexOf(t, n, left, right, parent);
return;
}

if (type == Token.ASSIGN) {
tryFoldAssign(t, n, left, right);
}

if (!NodeUtil.isLiteralValue(left) ||
!NodeUtil.isLiteralValue(right)) {

if (type == Token.ADD)
tryFoldLeftChildAdd(t, n, left, right, parent);

if (type == Token.LT ||
type == Token.GT) {
tryFoldComparison(t, n, left, right, parent);
}

return; // The subsequent ops only work if the LHS & RHS are consts
}

if (type == Token.ADD) {
tryFoldAdd(t, n, left, right, parent);
return;
}
if (type == Token.SUB ||
type == Token.MUL ||
type == Token.DIV) {
tryFoldArithmetic(t, n, left, right, parent);
return;
}

if (type == Token.LT ||
type == Token.GT ||
type == Token.LE ||
type == Token.GE ||
type == Token.EQ ||
type == Token.NE ||
type == Token.SHEQ ||
type == Token.SHNE) {
tryFoldComparison(t, n, left, right, parent);
return;
}

if (type == Token.GETELEM) {
tryFoldGetElem(t, n, left, right, parent);
return;
}

// other types aren't handled
}"
Closure_105b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_105_buggy/src/com/google/javascript/jscomp/FoldConstants.java,"void tryFoldLeftChildAdd(NodeTraversal t, Node n, Node left, Node right,
Node parent) {

if (NodeUtil.isLiteralValue(right) &&
left.getType() == Token.ADD &&
left.getChildCount() == 2) {

Node ll = left.getFirstChild();
Node lr = ll.getNext();

// Left's right child MUST be a string. We would not want to fold
// foo() + 2 + 'a' because we don't know what foo() will return, and
// therefore we don't know if left is a string concat, or a numeric add.
if (lr.getType() != Token.STRING)
return;

String leftString = NodeUtil.getStringValue(lr);
String rightString = NodeUtil.getStringValue(right);
if (leftString != null && rightString != null) {
left.removeChild(ll);
String result = leftString + rightString;
n.replaceChild(left, ll);
n.replaceChild(right, Node.newString(result));
t.getCompiler().reportCodeChange();
}
}
}"
Closure_105b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_105_buggy/src/com/google/javascript/jscomp/FoldConstants.java,"void tryFoldGetProp(NodeTraversal t, Node n, Node left, Node right,
Node parent) {
if (right.getType() == Token.STRING &&
right.getString().equals(""length"")) {
int knownLength = -1;
switch (left.getType()) {
case Token.ARRAYLIT:
if (NodeUtil.mayHaveSideEffects(left)) {
// Nope, can't fold this, without handling the side-effects.
return;
}
knownLength = left.getChildCount();
break;
case Token.STRING:
knownLength = left.getString().length();
break;
default:
// Not a foldable case, forget it.
return;
}

Preconditions.checkState(knownLength != -1);
Node lengthNode = Node.newNumber(knownLength);
parent.replaceChild(n, lengthNode);
t.getCompiler().reportCodeChange();
}
}"
Closure_107b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_107_buggy/src/com/google/javascript/jscomp/CommandLineRunner.java,"protected CompilerOptions createOptions() {
CompilerOptions options = new CompilerOptions();
if (flags.processJqueryPrimitives) {
options.setCodingConvention(new JqueryCodingConvention());
} else {
options.setCodingConvention(new ClosureCodingConvention());
}

options.setExtraAnnotationNames(flags.extraAnnotationName);

CompilationLevel level = flags.compilationLevel;
level.setOptionsForCompilationLevel(options);

if (flags.debug) {
level.setDebugOptionsForCompilationLevel(options);
}

if (flags.useTypesForOptimization) {
level.setTypeBasedOptimizationOptions(options);
}

if (flags.generateExports) {
options.setGenerateExports(flags.generateExports);
}

WarningLevel wLevel = flags.warningLevel;
wLevel.setOptionsForWarningLevel(options);
for (FormattingOption formattingOption : flags.formatting) {
formattingOption.applyToOptions(options);
}

options.closurePass = flags.processClosurePrimitives;

options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&
flags.processJqueryPrimitives;

options.angularPass = flags.angularPass;

if (!flags.translationsFile.isEmpty()) {
try {
options.messageBundle = new XtbMessageBundle(
new FileInputStream(flags.translationsFile),
flags.translationsProject);
} catch (IOException e) {
throw new RuntimeException(""Reading XTB file"", e);
}
} else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {
// In SIMPLE or WHITESPACE mode, if the user hasn't specified a
// translations file, they might reasonably try to write their own
// implementation of goog.getMsg that makes the substitution at
// run-time.
//
// In ADVANCED mode, goog.getMsg is going to be renamed anyway,
// so we might as well inline it. But shut off the i18n warnings,
// because the user didn't really ask for i18n.
options.messageBundle = new EmptyMessageBundle();
}

return options;
}"
Closure_107b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_107_buggy/src/com/google/javascript/jscomp/CommandLineRunner.java,"private List<String> processArgs(String[] args) {
// Args4j has a different format that the old command-line parser.
// So we use some voodoo to get the args into the format that args4j
// expects.
Pattern argPattern = Pattern.compile(""(--[a-zA-Z_]+)=(.*)"");
Pattern quotesPattern = Pattern.compile(""^['\""](.*)['\""]$"");
List<String> processedArgs = Lists.newArrayList();

for (String arg : args) {
Matcher matcher = argPattern.matcher(arg);
if (matcher.matches()) {
processedArgs.add(matcher.group(1));

String value = matcher.group(2);
Matcher quotesMatcher = quotesPattern.matcher(value);
if (quotesMatcher.matches()) {
processedArgs.add(quotesMatcher.group(1));
} else {
processedArgs.add(value);
}
} else {
processedArgs.add(arg);
}
}

return processedArgs;
}"
Closure_107b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_107_buggy/src/com/google/javascript/jscomp/CommandLineRunner.java,"public boolean shouldRunCompiler() {
return this.isConfigValid;
}"
Closure_107b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_107_buggy/src/com/google/javascript/jscomp/CommandLineRunner.java,"private void initConfigFromFlags(String[] args, PrintStream err) {

List<String> processedArgs = processArgs(args);

CmdLineParser parser = new CmdLineParser(flags);
Flags.guardLevels.clear();
isConfigValid = true;
try {
parser.parseArgument(processedArgs.toArray(new String[] {}));
// For contains --flagfile flag
if (!flags.flagFile.equals("""")) {
processFlagFile(err);
}
} catch (CmdLineException e) {
err.println(e.getMessage());
isConfigValid = false;
} catch (IOException ioErr) {
err.println(""ERROR - "" + flags.flagFile + "" read error."");
isConfigValid = false;
}

if (flags.version) {
err.println(
""Closure Compiler (http://code.google.com/closure/compiler)\n"" +
""Version: "" + Compiler.getReleaseVersion() + ""\n"" +
""Built on: "" + Compiler.getReleaseDate());
err.flush();
}

if (flags.processCommonJsModules) {
flags.processClosurePrimitives = true;
flags.manageClosureDependencies = true;
if (flags.commonJsEntryModule == null) {
err.println(""Please specify --common_js_entry_module."");
err.flush();
isConfigValid = false;
}
flags.closureEntryPoint = Lists.newArrayList(
ProcessCommonJSModules.toModuleName(flags.commonJsEntryModule));
}

if (!isConfigValid || flags.displayHelp) {
isConfigValid = false;
parser.printUsage(err);
} else {
CodingConvention conv;
if (flags.thirdParty) {
conv = CodingConventions.getDefault();
} else if (flags.processJqueryPrimitives) {
conv = new JqueryCodingConvention();
} else {
conv = new ClosureCodingConvention();
}

getCommandLineConfig()
.setPrintTree(flags.printTree)
.setPrintAst(flags.printAst)
.setPrintPassGraph(flags.printPassGraph)
.setJscompDevMode(flags.jscompDevMode)
.setLoggingLevel(flags.loggingLevel)
.setExterns(flags.externs)
.setJs(flags.getJsFiles())
.setJsOutputFile(flags.jsOutputFile)
.setModule(flags.module)
.setVariableMapInputFile(flags.variableMapInputFile)
.setPropertyMapInputFile(flags.propertyMapInputFile)
.setVariableMapOutputFile(flags.variableMapOutputFile)
.setCreateNameMapFiles(flags.createNameMapFiles)
.setPropertyMapOutputFile(flags.propertyMapOutputFile)
.setCodingConvention(conv)
.setSummaryDetailLevel(flags.summaryDetailLevel)
.setOutputWrapper(flags.outputWrapper)
.setModuleWrapper(flags.moduleWrapper)
.setModuleOutputPathPrefix(flags.moduleOutputPathPrefix)
.setCreateSourceMap(flags.createSourceMap)
.setSourceMapFormat(flags.sourceMapFormat)
.setWarningGuardSpec(Flags.getWarningGuardSpec())
.setDefine(flags.define)
.setCharset(flags.charset)
.setManageClosureDependencies(flags.manageClosureDependencies)
.setOnlyClosureDependencies(flags.onlyClosureDependencies)
.setClosureEntryPoints(flags.closureEntryPoint)
.setOutputManifest(ImmutableList.of(flags.outputManifest))
.setOutputModuleDependencies(flags.outputModuleDependencies)
.setAcceptConstKeyword(flags.acceptConstKeyword)
.setLanguageIn(flags.languageIn)
.setProcessCommonJSModules(flags.processCommonJsModules)
.setCommonJSModulePathPrefix(flags.commonJsPathPrefix)
.setTransformAMDToCJSModules(flags.transformAmdModules)
.setWarningsWhitelistFile(flags.warningsWhitelistFile)
.setAngularPass(flags.angularPass)
.setTracerMode(flags.tracerMode);
}
}"
Closure_107b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_107_buggy/src/com/google/javascript/jscomp/CommandLineRunner.java,"protected Compiler createCompiler() {
return new Compiler(getErrorPrintStream());
}"
Closure_109b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_109_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,"private Node parseTypeName(JsDocToken token) {
if (token != JsDocToken.STRING) {
return reportGenericTypeSyntaxWarning();
}

String typeName = stream.getString();
int lineno = stream.getLineno();
int charno = stream.getCharno();
while (match(JsDocToken.EOL) &&
typeName.charAt(typeName.length() - 1) == '.') {
skipEOLs();
if (match(JsDocToken.STRING)) {
next();
typeName += stream.getString();
}
}

Node typeNameNode = newStringNode(typeName, lineno, charno);

if (match(JsDocToken.LT)) {
next();
skipEOLs();
Node memberType = parseTypeExpressionList(next());
if (memberType != null) {
typeNameNode.addChildToFront(memberType);

skipEOLs();
if (!match(JsDocToken.GT)) {
return reportTypeSyntaxWarning(""msg.jsdoc.missing.gt"");
}

next();
}
}
return typeNameNode;
}"
Closure_109b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_109_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,"private Node reportGenericTypeSyntaxWarning() {
return reportTypeSyntaxWarning(""msg.jsdoc.type.syntax"");
}"
Closure_109b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_109_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,"private Node parseContextTypeExpression(JsDocToken token) {
return parseTypeName(token);
}"
Closure_109b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_109_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,"private Node parseFunctionType(JsDocToken token) {
// NOTE(nicksantos): We're not implementing generics at the moment, so
// just throw out TypeParameters.
if (token != JsDocToken.LP) {
restoreLookAhead(token);
return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp"");
}

Node functionType = newNode(Token.FUNCTION);
Node parameters = null;
skipEOLs();
if (!match(JsDocToken.RP)) {
token = next();

boolean hasParams = true;
if (token == JsDocToken.STRING) {
String tokenStr = stream.getString();
boolean isThis = ""this"".equals(tokenStr);
boolean isNew = ""new"".equals(tokenStr);
if (isThis || isNew) {
if (match(JsDocToken.COLON)) {
next();
skipEOLs();
Node contextType = wrapNode(
isThis ? Token.THIS : Token.NEW,
parseContextTypeExpression(next()));
if (contextType == null) {
return null;
}

functionType.addChildToFront(contextType);
} else {
return reportTypeSyntaxWarning(""msg.jsdoc.missing.colon"");
}

if (match(JsDocToken.COMMA)) {
next();
skipEOLs();
token = next();
} else {
hasParams = false;
}
}
}

if (hasParams) {
parameters = parseParametersType(token);
if (parameters == null) {
return null;
}
}
}

if (parameters != null) {
functionType.addChildToBack(parameters);
}

skipEOLs();
if (!match(JsDocToken.RP)) {
return reportTypeSyntaxWarning(""msg.jsdoc.missing.rp"");
}

skipEOLs();
Node resultType = parseResultType(next());
if (resultType == null) {
return null;
} else {
functionType.addChildToBack(resultType);
}
return functionType;
}"
Closure_109b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_109_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,"private Node reportTypeSyntaxWarning(String warning) {
parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno());
return null;
}"
Closure_111b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_111_buggy/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java,"public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,
FlowScope blindScope, boolean outcome) {
if (condition.isCall() && condition.getChildCount() == 2) {
Node callee = condition.getFirstChild();
Node param = condition.getLastChild();
if (callee.isGetProp() && param.isQualifiedName()) {
JSType paramType =  getTypeIfRefinable(param, blindScope);
Node left = callee.getFirstChild();
Node right = callee.getLastChild();
if (left.isName() && ""goog"".equals(left.getString()) &&
right.isString()) {
Function<TypeRestriction, JSType> restricter =
restricters.get(right.getString());
if (restricter != null) {
return restrictParameter(param, paramType, blindScope, restricter,
outcome);
}
}
}
}
return nextPreciserScopeKnowingConditionOutcome(
condition, blindScope, outcome);
}"
Closure_111b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_111_buggy/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java,"private FlowScope restrictParameter(Node parameter, JSType type,
FlowScope blindScope, Function<TypeRestriction, JSType> restriction,"
Closure_112b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_112_buggy/src/com/google/javascript/jscomp/TypeInference.java,"private JSType getPropertyType(JSType objType, String propName,
Node n, FlowScope scope) {
// We often have a couple of different types to choose from for the
// property. Ordered by accuracy, we have
// 1) A locally inferred qualified name (which is in the FlowScope)
// 2) A globally declared qualified name (which is in the FlowScope)
// 3) A property on the owner type (which is on objType)
// 4) A name in the type registry (as a last resort)
JSType propertyType = null;
boolean isLocallyInferred = false;

// Scopes sometimes contain inferred type info about qualified names.
String qualifiedName = n.getQualifiedName();
StaticSlot<JSType> var = scope.getSlot(qualifiedName);
if (var != null) {
JSType varType = var.getType();
if (varType != null) {
boolean isDeclared = !var.isTypeInferred();
isLocallyInferred = (var != syntacticScope.getSlot(qualifiedName));
if (isDeclared || isLocallyInferred) {
propertyType = varType;
}
}
}

if (propertyType == null && objType != null) {
JSType foundType = objType.findPropertyType(propName);
if (foundType != null) {
propertyType = foundType;
}
}

if (propertyType != null && objType != null) {
JSType restrictedObjType = objType.restrictByNotNullOrUndefined();
if (!restrictedObjType.getTemplateTypeMap().isEmpty()
&& propertyType.hasAnyTemplateTypes()) {
TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();
TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(
registry, typeMap);
propertyType = propertyType.visit(replacer);
}
}

if ((propertyType == null || propertyType.isUnknownType())
&& qualifiedName != null) {
// If we find this node in the registry, then we can infer its type.
ObjectType regType = ObjectType.cast(registry.getType(qualifiedName));
if (regType != null) {
propertyType = regType.getConstructor();
}
}

if (propertyType == null) {
return unknownType;
} else if (propertyType.isEquivalentTo(unknownType) && isLocallyInferred) {
// If the type has been checked in this scope,
// then use CHECKED_UNKNOWN_TYPE instead to indicate that.
return getNativeType(CHECKED_UNKNOWN_TYPE);
} else {
return propertyType;
}
}"
Closure_112b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_112_buggy/src/com/google/javascript/jscomp/TypeInference.java,"private Map<TemplateType, JSType> inferTemplateTypesFromParameters(
FunctionType fnType, Node call) {
if (fnType.getTemplateTypeMap().getTemplateKeys().isEmpty()) {
return Collections.emptyMap();
}

Map<TemplateType, JSType> resolvedTypes = Maps.newIdentityHashMap();

Node callTarget = call.getFirstChild();
if (NodeUtil.isGet(callTarget)) {
Node obj = callTarget.getFirstChild();
maybeResolveTemplatedType(
fnType.getTypeOfThis(),
getJSType(obj),
resolvedTypes);
}

if (call.hasMoreThanOneChild()) {
maybeResolveTemplateTypeFromNodes(
fnType.getParameters(),
call.getChildAtIndex(1).siblings(),
resolvedTypes);
}
return resolvedTypes;
}"
Closure_112b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_112_buggy/src/com/google/javascript/jscomp/TypeInference.java,"private static void resolvedTemplateType(
Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {
JSType previous = map.get(template);
if (!resolved.isUnknownType()) {
if (previous == null) {
map.put(template, resolved);
} else {
JSType join = previous.getLeastSupertype(resolved);
map.put(template, join);
}
}
}"
Closure_112b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_112_buggy/src/com/google/javascript/jscomp/TypeInference.java,"private void maybeResolveTemplatedType(
JSType paramType,"
Closure_112b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_112_buggy/src/com/google/javascript/jscomp/TypeInference.java,"maybeResolveTemplateTypeFromNodes(
declParams.iterator(), callParams.iterator(), resolvedTypes);"
Closure_113b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_113_buggy/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java,"public void process(Node externs, Node root) {
new NodeTraversal(compiler, this).traverse(root);

for (Node n : defineCalls) {
replaceGoogDefines(n);
}

for (ProvidedName pn : providedNames.values()) {
pn.replace();
}

if (requiresLevel.isOn()) {
for (UnrecognizedRequire r : unrecognizedRequires) {
DiagnosticType error;
ProvidedName expectedName = providedNames.get(r.namespace);
if (expectedName != null && expectedName.firstNode != null) {
// The namespace ended up getting provided after it was required.
error = LATE_PROVIDE_ERROR;
} else {
error = MISSING_PROVIDE_ERROR;
}

compiler.report(JSError.make(
r.inputName, r.requireNode, requiresLevel, error, r.namespace));
}
}
}"
Closure_113b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_113_buggy/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java,"public void visit(NodeTraversal t, Node n, Node parent) {
switch (n.getType()) {
case Token.CALL:
boolean isExpr = parent.isExprResult();
Node left = n.getFirstChild();
if (left.isGetProp()) {
Node name = left.getFirstChild();
if (name.isName() &&
GOOG.equals(name.getString())) {
// For the sake of simplicity, we report code changes
// when we see a provides/requires, and don't worry about
// reporting the change when we actually do the replacement.
String methodName = name.getNext().getString();
if (""base"".equals(methodName)) {
processBaseClassCall(t, n);
} else if (!isExpr) {
// All other methods must be called in an EXPR.
break;
} else if (""define"".equals(methodName)) {
processDefineCall(t, n, parent);
} else if (""require"".equals(methodName)) {
processRequireCall(t, n, parent);
} else if (""provide"".equals(methodName)) {
processProvideCall(t, n, parent);
} else if (""exportSymbol"".equals(methodName)) {
Node arg = left.getNext();
if (arg.isString()) {
int dot = arg.getString().indexOf('.');
if (dot == -1) {
exportedVariables.add(arg.getString());
} else {
exportedVariables.add(arg.getString().substring(0, dot));
}
}
} else if (""addDependency"".equals(methodName)) {
CodingConvention convention = compiler.getCodingConvention();
List<String> typeDecls =
convention.identifyTypeDeclarationCall(n);
if (typeDecls != null) {
for (String typeDecl : typeDecls) {
compiler.getTypeRegistry().forwardDeclareType(typeDecl);
}
}

// We can't modify parent, so just create a node that will
// get compiled out.
parent.replaceChild(n, IR.number(0));
compiler.reportCodeChange();
} else if (""setCssNameMapping"".equals(methodName)) {
processSetCssNameMapping(t, n, parent);
}
}
}
break;

case Token.ASSIGN:
case Token.NAME:
// If this is an assignment to a provided name, remove the provided
// object.
handleCandidateProvideDefinition(t, n, parent);
break;

case Token.EXPR_RESULT:
handleTypedefDefinition(t, n);
break;

case Token.FUNCTION:
// If this is a declaration of a provided named function, this is an
// error. Hoisted functions will explode if they're provided.
if (t.inGlobalScope() &&
!NodeUtil.isFunctionExpression(n)) {
String name = n.getFirstChild().getString();
ProvidedName pn = providedNames.get(name);
if (pn != null) {
compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));
}
}
break;

case Token.GETPROP:
if (n.getFirstChild().isName() &&
!parent.isCall() &&
!parent.isAssign() &&
""goog.base"".equals(n.getQualifiedName())) {
reportBadBaseClassUse(t, n, ""May only be called directly."");
}
break;
}
}"
Closure_113b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_113_buggy/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java,"private void processRequireCall(NodeTraversal t, Node n, Node parent) {
Node left = n.getFirstChild();
Node arg = left.getNext();
if (verifyLastArgumentIsString(t, left, arg)) {
String ns = arg.getString();
ProvidedName provided = providedNames.get(ns);
if (provided == null || !provided.isExplicitlyProvided()) {
unrecognizedRequires.add(
new UnrecognizedRequire(n, ns, t.getSourceName()));
} else {
JSModule providedModule = provided.explicitModule;

// This must be non-null, because there was an explicit provide.
Preconditions.checkNotNull(providedModule);

JSModule module = t.getModule();
if (moduleGraph != null &&
module != providedModule &&
!moduleGraph.dependsOn(module, providedModule)) {
compiler.report(
t.makeError(n, XMODULE_REQUIRE_ERROR, ns,
providedModule.getName(),
module.getName()));
}
}

maybeAddToSymbolTable(left);
maybeAddStringNodeToSymbolTable(arg);

// Requires should be removed before further processing.
// Some clients run closure pass multiple times, first with
// the checks for broken requires turned off. In these cases, we
// allow broken requires to be preserved by the first run to
// let them be caught in the subsequent run.
if (provided != null) {
parent.detachFromParent();
compiler.reportCodeChange();
}
}
}"
Closure_113b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_113_buggy/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java,"private void handleTypedefDefinition(
NodeTraversal t, Node n) {
JSDocInfo info = n.getFirstChild().getJSDocInfo();
if (t.inGlobalScope() && info != null && info.hasTypedefType()) {
String name = n.getFirstChild().getQualifiedName();
if (name != null) {
ProvidedName pn = providedNames.get(name);
if (pn != null) {
pn.addDefinition(n, t.getModule());
}
}
}
}"
Closure_113b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_113_buggy/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java,"private void handleCandidateProvideDefinition(
NodeTraversal t, Node n, Node parent) {
if (t.inGlobalScope()) {
String name = null;
if (n.isName() && parent.isVar()) {
name = n.getString();
} else if (n.isAssign() &&
parent.isExprResult()) {
name = n.getFirstChild().getQualifiedName();
}

if (name != null) {
if (parent.getBooleanProp(Node.IS_NAMESPACE)) {
processProvideFromPreviousPass(t, name, parent);
} else {
ProvidedName pn = providedNames.get(name);
if (pn != null) {
pn.addDefinition(parent, t.getModule());
}
}
}
}
}"
Closure_114b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_114_buggy/src/com/google/javascript/jscomp/NameAnalyzer.java,"private void replaceWithRhs(Node parent, Node n) {
if (valueConsumedByParent(n, parent)) {
// parent reads from n directly; replace it with n's rhs + lhs
// subexpressions with side effects.
List<Node> replacements = getRhsSubexpressions(n);
List<Node> newReplacements = Lists.newArrayList();
for (int i = 0; i < replacements.size() - 1; i++) {
newReplacements.addAll(getSideEffectNodes(replacements.get(i)));
}
Node valueExpr = replacements.get(replacements.size() - 1);
valueExpr.detachFromParent();
newReplacements.add(valueExpr);
changeProxy.replaceWith(
parent, n, collapseReplacements(newReplacements));
} else if (n.isAssign() && !parent.isFor()) {
// assignment appears in a RHS expression.  we have already
// considered names in the assignment's RHS as being referenced;
// replace the assignment with its RHS.
// TODO(user) make the pass smarter about these cases and/or run
// this pass and RemoveConstantExpressions together in a loop.
Node replacement = n.getLastChild();
replacement.detachFromParent();
changeProxy.replaceWith(parent, n, replacement);
} else {
replaceTopLevelExpressionWithRhs(parent, n);
}
}"
Closure_114b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_114_buggy/src/com/google/javascript/jscomp/NameAnalyzer.java,"private List<NameInformation> getEnclosingFunctionDependencyScope(
NodeTraversal t) {
Node function = t.getEnclosingFunction();
if (function == null) {
return Collections.emptyList();
}

List<NameInformation> refs = scopes.get(function);
if (!refs.isEmpty()) {
return refs;
}

// Function expression.  try to get a name from the parent var
// declaration or assignment.
Node parent = function.getParent();
if (parent != null) {
// Account for functions defined in the form:
//   var a = cond ? function a() {} : function b() {};
while (parent.isHook()) {
parent = parent.getParent();
}

if (parent.isName()) {
return scopes.get(parent);
}

if (parent.isAssign()) {
return scopes.get(parent);
}
}

return Collections.emptyList();
}"
Closure_114b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_114_buggy/src/com/google/javascript/jscomp/NameAnalyzer.java,"private List<Node> getRhsSubexpressions(Node n) {
switch (n.getType()) {
case Token.EXPR_RESULT:
// process body
return getRhsSubexpressions(n.getFirstChild());
case Token.FUNCTION:
// function nodes have no RHS
return Collections.emptyList();
case Token.NAME:
{
// parent is a var node.  RHS is the first child
Node rhs = n.getFirstChild();
if (rhs != null) {
return Lists.newArrayList(rhs);
} else {
return Collections.emptyList();
}
}
case Token.ASSIGN:
{
// add LHS and RHS expressions - LHS may be a complex expression
Node lhs = n.getFirstChild();
Node rhs = lhs.getNext();
return Lists.newArrayList(lhs, rhs);
}
case Token.VAR:
{
// recurse on all children
List<Node> nodes = Lists.newArrayList();
for (Node child : n.children()) {
nodes.addAll(getRhsSubexpressions(child));
}
return nodes;
}
default:
throw new IllegalArgumentException(""AstChangeProxy::getRhs "" + n);
}
}"
Closure_114b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_114_buggy/src/com/google/javascript/jscomp/NameAnalyzer.java,"private NameInformation createNameInformation(NodeTraversal t, Node n) {
Node parent = n.getParent();
// Build the full name and find its root node by iterating down through all
// GETPROP/GETELEM nodes.
String name = """";
Node rootNameNode = n;
boolean bNameWasShortened = false;
while (true) {
if (NodeUtil.isGet(rootNameNode)) {
Node prop = rootNameNode.getLastChild();
if (rootNameNode.isGetProp()) {
name = ""."" + prop.getString() + name;
} else {
// We consider the name to be ""a.b"" in a.b['c'] or a.b[x].d.
bNameWasShortened = true;
name = """";
}
rootNameNode = rootNameNode.getFirstChild();
} else if (NodeUtil.isObjectLitKey(rootNameNode)) {
name = ""."" + rootNameNode.getString() + name;

// Check if this is an object literal assigned to something.
Node objLit = rootNameNode.getParent();
Node objLitParent = objLit.getParent();
if (objLitParent.isAssign()) {
// This must be the right side of the assign.
rootNameNode = objLitParent.getFirstChild();
} else if (objLitParent.isName()) {
// This must be a VAR initialization.
rootNameNode = objLitParent;
} else if (objLitParent.isStringKey()) {
// This must be a object literal key initialization.
rootNameNode = objLitParent;
} else {
return null;
}
} else {
break;
}
}

// Check whether this is a class-defining call. Classes may only be defined
// in the global scope.
if (parent.isCall() && t.inGlobalScope()) {
CodingConvention convention = compiler.getCodingConvention();
SubclassRelationship classes = convention.getClassesDefinedByCall(parent);
if (classes != null) {
NameInformation nameInfo = new NameInformation();
nameInfo.name = classes.subclassName;
nameInfo.onlyAffectsClassDef = true;
nameInfo.superclass = classes.superclassName;
return nameInfo;
}

String singletonGetterClass =
convention.getSingletonGetterClassName(parent);
if (singletonGetterClass != null) {
NameInformation nameInfo = new NameInformation();
nameInfo.name = singletonGetterClass;
nameInfo.onlyAffectsClassDef = true;
return nameInfo;
}
}

switch (rootNameNode.getType()) {
case Token.NAME:
// Check whether this is an assignment to a prototype property
// of an object defined in the global scope.
if (!bNameWasShortened &&
n.isGetProp() &&
parent.isAssign() &&
""prototype"".equals(n.getLastChild().getString())) {
if (createNameInformation(t, n.getFirstChild()) != null) {
name = rootNameNode.getString() + name;
name = name.substring(0, name.length() - PROTOTYPE_SUFFIX_LEN);
NameInformation nameInfo = new NameInformation();
nameInfo.name = name;
return nameInfo;
} else {
return null;
}
}
return createNameInformation(
rootNameNode.getString() + name, t.getScope(), rootNameNode);
case Token.THIS:
if (t.inGlobalScope()) {
NameInformation nameInfo = new NameInformation();
if (name.indexOf('.') == 0) {
nameInfo.name = name.substring(1);  // strip leading "".""
} else {
nameInfo.name = name;
}
nameInfo.isExternallyReferenceable = true;
return nameInfo;
}
return null;
default:
return null;
}
}"
Closure_114b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_114_buggy/src/com/google/javascript/jscomp/NameAnalyzer.java,"private boolean isExternallyReferenceable(Scope scope, String name) {
if (compiler.getCodingConvention().isExported(name)) {
return true;
}
if (scope.isLocal()) {
return false;
}
for (String s : globalNames) {
if (name.startsWith(s)) {
return true;
}
}
return false;
}"
Closure_115b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_115_buggy/src/com/google/javascript/jscomp/FunctionInjector.java,"private CanInlineResult canInlineReferenceDirectly(
Node callNode, Node fnNode) {
if (!isDirectCallNodeReplacementPossible(fnNode)) {
return CanInlineResult.NO;
}

Node block = fnNode.getLastChild();

boolean hasSideEffects = false;
if (block.hasChildren()) {
Preconditions.checkState(block.hasOneChild());
Node stmt = block.getFirstChild();
if (stmt.isReturn()) {
hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
}
}
// CALL NODE: [ NAME, ARG1, ARG2, ... ]
Node cArg = callNode.getFirstChild().getNext();

// Functions called via 'call' and 'apply' have a this-object as
// the first parameter, but this is not part of the called function's
// parameter list.
if (!callNode.getFirstChild().isName()) {
if (NodeUtil.isFunctionObjectCall(callNode)) {
// TODO(johnlenz): Support replace this with a value.
if (cArg == null || !cArg.isThis()) {
return CanInlineResult.NO;
}
cArg = cArg.getNext();
} else {
// "".apply"" call should be filtered before this.
Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));
}
}

// FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]
Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();
while (cArg != null || fnParam != null) {
// For each named parameter check if a mutable argument use more than one.
if (fnParam != null) {
if (cArg != null) {
if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
return CanInlineResult.NO;
}
// Check for arguments that are evaluated more than once.
// Note: Unlike block inlining, there it is not possible that a
// parameter reference will be in a loop.
if (NodeUtil.mayEffectMutableState(cArg, compiler)
&& NodeUtil.getNameReferenceCount(
block, fnParam.getString()) > 1) {
return CanInlineResult.NO;
}
}

// Move to the next name.
fnParam = fnParam.getNext();
}

// For every call argument check for side-effects, even if there
// isn't a named parameter to match.
if (cArg != null) {
if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {
return CanInlineResult.NO;
}
cArg = cArg.getNext();
}
}

return CanInlineResult.YES;
}"
Closure_115b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_115_buggy/src/com/google/javascript/jscomp/FunctionInjector.java,"private CallSiteType classifyCallSite(Node callNode) {
Node parent = callNode.getParent();
Node grandParent = parent.getParent();

// Verify the call site:
if (NodeUtil.isExprCall(parent)) {
// This is a simple call?  Example: ""foo();"".
return CallSiteType.SIMPLE_CALL;
} else if (NodeUtil.isExprAssign(grandParent)
&& !NodeUtil.isVarOrSimpleAssignLhs(callNode, parent)
&& parent.getFirstChild().isName()
&& !NodeUtil.isConstantName(parent.getFirstChild())) {
// This is a simple assignment.  Example: ""x = foo();""
return CallSiteType.SIMPLE_ASSIGNMENT;
} else if (parent.isName()
&& !NodeUtil.isConstantName(parent)
&& grandParent.isVar()
&& grandParent.hasOneChild()) {
// This is a var declaration.  Example: ""var x = foo();""
// TODO(johnlenz): Should we be checking for constants on the
// left-hand-side of the assignments and handling them as EXPRESSION?
return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT;
} else {
Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode);
if (expressionRoot != null) {
ExpressionDecomposer decomposer = new ExpressionDecomposer(
compiler, safeNameIdSupplier, knownConstants);
DecompositionType type = decomposer.canExposeExpression(
callNode);
if (type == DecompositionType.MOVABLE) {
return CallSiteType.EXPRESSION;
} else if (type == DecompositionType.DECOMPOSABLE) {
return CallSiteType.DECOMPOSABLE_EXPRESSION;
} else {
Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE);
}
}
}

return CallSiteType.UNSUPPORTED;
}"
Closure_115b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_115_buggy/src/com/google/javascript/jscomp/FunctionInjector.java,"private ExpressionDecomposer getDecomposer() {
return new ExpressionDecomposer(
compiler, safeNameIdSupplier, knownConstants);
}"
Closure_115b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_115_buggy/src/com/google/javascript/jscomp/FunctionInjector.java,"void maybePrepareCall(Node callNode) {
CallSiteType callSiteType = classifyCallSite(callNode);
callSiteType.prepare(this, callNode);
}"
Closure_115b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_115_buggy/src/com/google/javascript/jscomp/FunctionInjector.java,"private CanInlineResult canInlineReferenceAsStatementBlock(
NodeTraversal t, Node callNode, Node fnNode, Set<String> namesToAlias) {
CallSiteType callSiteType = classifyCallSite(callNode);
if (callSiteType == CallSiteType.UNSUPPORTED) {
return CanInlineResult.NO;
}

if (!allowDecomposition
&& (callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION
|| callSiteType == CallSiteType.EXPRESSION)) {
return CanInlineResult.NO;
}

if (!callMeetsBlockInliningRequirements(
t, callNode, fnNode, namesToAlias)) {
return CanInlineResult.NO;
}

if (callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION
|| callSiteType == CallSiteType.EXPRESSION) {
return CanInlineResult.AFTER_PREPARATION;
} else {
return CanInlineResult.YES;
}
}"
Closure_117b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_117_buggy/src/com/google/javascript/jscomp/TypeValidator.java,"String getReadableJSTypeName(Node n, boolean dereference) {

// The best type name is the actual type name.

// If we're analyzing a GETPROP, the property may be inherited by the
// prototype chain. So climb the prototype chain and find out where
// the property was originally defined.
if (n.isGetProp()) {
ObjectType objectType = getJSType(n.getFirstChild()).dereference();
if (objectType != null) {
String propName = n.getLastChild().getString();
if (objectType.getConstructor() != null &&
objectType.getConstructor().isInterface()) {
objectType = FunctionType.getTopDefiningInterface(
objectType, propName);
} else {
// classes
while (objectType != null && !objectType.hasOwnProperty(propName)) {
objectType = objectType.getImplicitPrototype();
}
}

// Don't show complex function names or anonymous types.
// Instead, try to get a human-readable type name.
if (objectType != null &&
(objectType.getConstructor() != null ||
objectType.isFunctionPrototypeType())) {
return objectType.toString() + ""."" + propName;
}
}
}

JSType type = getJSType(n);
if (dereference) {
ObjectType dereferenced = type.dereference();
if (dereferenced != null) {
type = dereferenced;
}
}
if (type.isFunctionPrototypeType() ||
(type.toObjectType() != null &&
type.toObjectType().getConstructor() != null)) {
return type.toString();
}
String qualifiedName = n.getQualifiedName();
if (qualifiedName != null) {
return qualifiedName;
} else if (type.isFunctionType()) {
// Don't show complex function names.
return ""function"";
} else {
return type.toString();
}
}"
Closure_117b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_117_buggy/src/com/google/javascript/jscomp/TypeValidator.java,"JSType jsType = n.getJSType();
if (jsType == null) {
// TODO(user): This branch indicates a compiler bug, not worthy of
// halting the compilation but we should log this and analyze to track
// down why it happens. This is not critical and will be resolved over
// time as the type checker is extended.
return getNativeType(UNKNOWN_TYPE);
} else {
return jsType;
}"
Closure_117b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_117_buggy/src/com/google/javascript/jscomp/TypeValidator.java,"boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,
JSType leftType, Node owner, String propName) {
// The NoType check is a hack to make typedefs work OK.
if (!leftType.isNoType() && !rightType.isSubtype(leftType)) {
// Do not type-check interface methods, because we expect that
// they will have dummy implementations that do not match the type
// annotations.
JSType ownerType = getJSType(owner);
if (ownerType.isFunctionPrototypeType()) {
FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();
if (ownerFn.isInterface() &&
rightType.isFunctionType() && leftType.isFunctionType()) {
return true;
}
}

mismatch(t, n,
""assignment to property "" + propName + "" of "" +
getReadableJSTypeName(owner, true),
rightType, leftType);
return false;
}
return true;
}"
Closure_117b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_117_buggy/src/com/google/javascript/jscomp/TypeValidator.java,"void expectAllInterfaceProperties(NodeTraversal t, Node n,
FunctionType type) {
ObjectType instance = type.getInstanceType();
for (ObjectType implemented : type.getAllImplementedInterfaces()) {
if (implemented.getImplicitPrototype() != null) {
for (String prop :
implemented.getImplicitPrototype().getOwnPropertyNames()) {
expectInterfaceProperty(t, n, instance, implemented, prop);
}
}
}
}"
Closure_117b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_117_buggy/src/com/google/javascript/jscomp/TypeValidator.java,"boolean expectNotNullOrUndefined(
NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {
if (!type.isNoType() && !type.isUnknownType() &&
type.isSubtype(nullOrUndefined) &&
!containsForwardDeclaredUnresolvedName(type)) {

// There's one edge case right now that we don't handle well, and
// that we don't want to warn about.
// if (this.x == null) {
//   this.initializeX();
//   this.x.foo();
// }
// In this case, we incorrectly type x because of how we
// infer properties locally. See issue 109.
// http://code.google.com/p/closure-compiler/issues/detail?id=109
//
// We do not do this inference globally.
if (n.isGetProp() &&
!t.inGlobalScope() && type.isNullType()) {
return true;
}

mismatch(t, n, msg, type, expectedType);
return false;
}
return true;
}"
Closure_118b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_118_buggy/src/com/google/javascript/jscomp/DisambiguateProperties.java,"void renameProperties() {
int propsRenamed = 0, propsSkipped = 0, instancesRenamed = 0,
instancesSkipped = 0, singleTypeProps = 0;

Set<String> reported = Sets.newHashSet();
for (Property prop : properties.values()) {
if (prop.shouldRename()) {
Map<T, String> propNames = buildPropNames(prop.getTypes(), prop.name);

++propsRenamed;
prop.expandTypesToSkip();
for (Node node : prop.renameNodes) {
T rootType = prop.rootTypes.get(node);
if (prop.shouldRename(rootType)) {
String newName = propNames.get(rootType);
node.setString(newName);
compiler.reportCodeChange();
++instancesRenamed;
} else {
++instancesSkipped;

CheckLevel checkLevelForProp = propertiesToErrorFor.get(prop.name);
if (checkLevelForProp != null &&
checkLevelForProp != CheckLevel.OFF &&
!reported.contains(prop.name)) {
reported.add(prop.name);
compiler.report(JSError.make(
NodeUtil.getSourceName(node), node,
checkLevelForProp,
Warnings.INVALIDATION_ON_TYPE, prop.name,
rootType.toString(), """"));
}
}
}
} else {
if (prop.skipRenaming) {
++propsSkipped;
} else {
++singleTypeProps;
}
}
}
logger.fine(""Renamed "" + instancesRenamed + "" instances of ""
+ propsRenamed + "" properties."");
logger.fine(""Skipped renaming "" + instancesSkipped + "" invalidated ""
+ ""properties, "" + propsSkipped + "" instances of properties ""
+ ""that were skipped for specific types and "" + singleTypeProps
+ "" properties that were referenced from only one type."");
}"
Closure_118b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_118_buggy/src/com/google/javascript/jscomp/DisambiguateProperties.java,"static DisambiguateProperties<JSType> forJSTypeSystem(
AbstractCompiler compiler,"
Closure_118b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_118_buggy/src/com/google/javascript/jscomp/DisambiguateProperties.java,"public void process(Node externs, Node root) {
Preconditions.checkState(
compiler.getLifeCycleStage() == LifeCycleStage.NORMALIZED);
for (TypeMismatch mis : compiler.getTypeValidator().getMismatches()) {
addInvalidatingType(mis.typeA, mis.src);
addInvalidatingType(mis.typeB, mis.src);
}

NodeTraversal.traverse(compiler, externs, new FindExternProperties());
NodeTraversal.traverse(compiler, root, new FindRenameableProperties());
renameProperties();
}"
Closure_118b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_118_buggy/src/com/google/javascript/jscomp/DisambiguateProperties.java,"protected Property getProperty(String name) {
if (!properties.containsKey(name)) {
properties.put(name, new Property(name));
}
return properties.get(name);
}"
Closure_118b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_118_buggy/src/com/google/javascript/jscomp/DisambiguateProperties.java,"private Map<T, String> buildPropNames(UnionFind<T> types, String name) {
Map<T, String> names = Maps.newHashMap();
for (Set<T> set : types.allEquivalenceClasses()) {
checkState(!set.isEmpty());

String typeName = null;
for (T type : set) {
if (typeName == null || type.toString().compareTo(typeName) < 0) {
typeName = type.toString();
}
}

String newName;
if (""{...}"".equals(typeName)) {
newName = name;
} else {
newName = typeName.replaceAll(""[^\\w$]"", ""_"") + ""$"" + name;
}

for (T type : set) {
names.put(type, newName);
}
}
return names;
}"
Closure_119b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_119_buggy/src/com/google/javascript/jscomp/GlobalNamespace.java,"private boolean isGlobalVarReference(String name, Scope s) {
Scope.Var v = s.getVar(name);
if (v == null && externsScope != null) {
v = externsScope.getVar(name);
}
return v != null && !v.isLocal();
}"
Closure_119b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_119_buggy/src/com/google/javascript/jscomp/GlobalNamespace.java,"boolean hasExternsRoot() {
return externsRoot != null;
}"
Closure_119b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_119_buggy/src/com/google/javascript/jscomp/GlobalNamespace.java,"public Name getSlot(String name) {
return getOwnSlot(name);
}"
Closure_119b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_119_buggy/src/com/google/javascript/jscomp/GlobalNamespace.java,"public Name getOwnSlot(String name) {
ensureGenerated();
return nameMap.get(name);
}"
Closure_119b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_119_buggy/src/com/google/javascript/jscomp/GlobalNamespace.java,"private void ensureGenerated() {
if (!generated) {
process();
}
}"
Closure_120b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_120_buggy/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java,"public void exitScope(NodeTraversal t) {
blockStack.pop();
if (t.getScope().isGlobal()) {
// Update global scope reference lists when we are done with it.
compiler.updateGlobalVarReferences(referenceMap, t.getScopeRoot());
behavior.afterExitScope(t, compiler.getGlobalVarReferences());
} else {
behavior.afterExitScope(t, new ReferenceMapWrapper(referenceMap));
}
}"
Closure_120b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_120_buggy/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java,"public void process(Node externs, Node root) {
NodeTraversal.traverseRoots(
compiler, Lists.newArrayList(externs, root), this);
}"
Closure_120b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_120_buggy/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java,"public void visit(NodeTraversal t, Node n, Node parent) {
if (n.isName()) {
Var v;
if (n.getString().equals(""arguments"")) {
v = t.getScope().getArgumentsVar();
} else {
v = t.getScope().getVar(n.getString());
}
if (v != null && varFilter.apply(v)) {
addReference(v, new Reference(n, t, blockStack.peek()));
}
}

if (isBlockBoundary(n, parent)) {
blockStack.pop();
}
}"
Closure_120b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_120_buggy/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java,"public void enterScope(NodeTraversal t) {
Node n = t.getScope().getRootNode();
BasicBlock parent = blockStack.isEmpty() ? null : blockStack.peek();
blockStack.push(new BasicBlock(parent, n));
}"
Closure_120b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_120_buggy/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java,"public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,
Node parent) {
// If node is a new basic block, put on basic block stack
if (isBlockBoundary(n, parent)) {
blockStack.push(new BasicBlock(blockStack.peek(), n));
}
return true;
}"
Closure_121b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_121_buggy/src/com/google/javascript/jscomp/InlineVariables.java,"private Predicate<Var> getFilterForMode() {
switch (mode) {
case ALL:
return Predicates.<Var>alwaysTrue();
case LOCALS_ONLY:
return new IdentifyLocals();
case CONSTANTS_ONLY:
return new IdentifyConstants();
default:
throw new IllegalStateException();
}
}"
Closure_121b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_121_buggy/src/com/google/javascript/jscomp/InlineVariables.java,"public void process(Node externs, Node root) {
ReferenceCollectingCallback callback = new ReferenceCollectingCallback(
compiler, new InliningBehavior(), getFilterForMode());
callback.process(externs, root);
}"
Closure_122b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_122_buggy/src/com/google/javascript/jscomp/parsing/IRFactory.java,"public static Node transformTree(AstRoot node,
StaticSourceFile sourceFile,"
Closure_122b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_122_buggy/src/com/google/javascript/jscomp/parsing/IRFactory.java,"private void handleBlockComment(Comment comment) {
if (comment.getValue().indexOf(""/* @"") != -1 || comment.getValue().indexOf(""\n * @"") != -1) {
errorReporter.warning(
SUSPICIOUS_COMMENT_WARNING,
sourceName,
comment.getLineno(), """", 0);
}
}"
Closure_122b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_122_buggy/src/com/google/javascript/jscomp/parsing/IRFactory.java,"private int position2charno(int position) {
int lineIndex = sourceString.lastIndexOf('\n', position);
if (lineIndex == -1) {
return position;
} else {
// Subtract one for initial position being 0.
return position - lineIndex - 1;
}
}"
Closure_122b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_122_buggy/src/com/google/javascript/jscomp/parsing/IRFactory.java,"private Node newNumberNode(Double value) {
return IR.number(value).clonePropsFrom(templateNode);
}"
Closure_122b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_122_buggy/src/com/google/javascript/jscomp/parsing/IRFactory.java,"private void maybeSetLengthFrom(Node node, AstNode source) {
if (config.isIdeMode) {
node.setLength(source.getLength());
}
}"
Closure_123b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_123_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"private boolean isOneExactlyFunctionOrDo(Node n) {
if (n.isLabel()) {
Node labeledStatement = n.getLastChild();
if (!labeledStatement.isBlock()) {
return isOneExactlyFunctionOrDo(labeledStatement);
} else {
// For labels with block children, we need to ensure that a
// labeled FUNCTION or DO isn't generated when extraneous BLOCKs
// are skipped.
if (getNonEmptyChildCount(n, 2) == 1) {
return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));
} else {
// Either a empty statement or an block with more than one child,
// way it isn't a FUNCTION or DO.
return false;
}
}
} else {
return (n.isFunction() || n.isDo());
}
}"
Closure_123b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_123_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"private static Node getFirstNonEmptyChild(Node n) {
for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
if (c.isBlock()) {
Node result = getFirstNonEmptyChild(c);
if (result != null) {
return result;
}
} else if (!c.isEmpty()) {
return c;
}
}
return null;
}"
Closure_123b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_123_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"private static int getNonEmptyChildCount(Node n, int maxCount) {
int i = 0;
Node c = n.getFirstChild();
for (; c != null && i < maxCount; c = c.getNext()) {
if (c.isBlock()) {
i += getNonEmptyChildCount(c, maxCount - i);
} else if (!c.isEmpty()) {
i++;
}
}
return i;
}"
Closure_123b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_123_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"private boolean isIndirectEval(Node n) {
return n.isName() && ""eval"".equals(n.getString()) &&
!n.getBooleanProp(Node.DIRECT_EVAL);
}"
Closure_123b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_123_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"private String jsString(String s, boolean useSlashV) {
int singleq = 0, doubleq = 0;

// could count the quotes and pick the optimal quote character
for (int i = 0; i < s.length(); i++) {
switch (s.charAt(i)) {
case '""': doubleq++; break;
case '\'': singleq++; break;
}
}

String doublequote, singlequote;
char quote;
if (preferSingleQuotes ?
(singleq <= doubleq) : (singleq < doubleq)) {
// more double quotes so enclose in single quotes.
quote = '\'';
doublequote = ""\"""";
singlequote = ""\\\'"";
} else {
// more single quotes so escape the doubles
quote = '\""';
doublequote = ""\\\"""";
singlequote = ""\'"";
}

return strEscape(s, quote, doublequote, singlequote, ""\\\\"",
outputCharsetEncoder, useSlashV, false);
}"
Closure_124b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_124_buggy/src/com/google/javascript/jscomp/ExploitAssigns.java,"private boolean collapseAssignEqualTo(Node expr, Node exprParent,
Node value) {
Node assign = expr.getFirstChild();
Node parent = exprParent;
Node next = expr.getNext();
while (next != null) {
switch (next.getType()) {
case Token.AND:
case Token.OR:
case Token.HOOK:
case Token.IF:
case Token.RETURN:
case Token.EXPR_RESULT:
// Dive down the left side
parent = next;
next = next.getFirstChild();
break;

case Token.VAR:
if (next.getFirstChild().hasChildren()) {
parent = next.getFirstChild();
next = parent.getFirstChild();
break;
}
return false;

case Token.GETPROP:
case Token.NAME:
if (next.isQualifiedName()) {
String nextName = next.getQualifiedName();
if (value.isQualifiedName() &&
nextName.equals(value.getQualifiedName())) {
// If the previous expression evaluates to value of a
// qualified name, and that qualified name is used again
// shortly, then we can exploit the assign here.

// Verify the assignment doesn't change its own value.
if (!isSafeReplacement(next, assign)) {
return false;
}

exprParent.removeChild(expr);
expr.removeChild(assign);
parent.replaceChild(next, assign);
return true;
}
}
return false;

case Token.ASSIGN:
// Assigns are really tricky. In lots of cases, we want to inline
// into the right side of the assign. But the left side of the
// assign is evaluated first, and it may have convoluted logic:
//   a = null;
//   (a = b).c = null;
// We don't want to exploit the first assign. Similarly:
//   a.b = null;
//   a.b.c = null;
// We don't want to exploit the first assign either.
//
// To protect against this, we simply only inline when the left side
// is guaranteed to evaluate to the same L-value no matter what.
Node leftSide = next.getFirstChild();
if (leftSide.isName() ||
leftSide.isGetProp() &&
leftSide.getFirstChild().isThis()) {
// Dive down the right side of the assign.
parent = next;
next = leftSide.getNext();
break;
} else {
return false;
}

default:
if (NodeUtil.isImmutableValue(next)
&& next.isEquivalentTo(value)) {
// If the r-value of the expr assign is an immutable value,
// and the value is used again shortly, then we can exploit
// the assign here.
exprParent.removeChild(expr);
expr.removeChild(assign);
parent.replaceChild(next, assign);
return true;
}
// Return without inlining a thing
return false;
}
}

return false;
}"
Closure_124b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_124_buggy/src/com/google/javascript/jscomp/ExploitAssigns.java,"private boolean isSafeReplacement(Node node, Node replacement) {
// No checks are needed for simple names.
if (node.isName()) {
return true;
}
Preconditions.checkArgument(node.isGetProp());

node = node.getFirstChild();
if (node.isName()
&& isNameAssignedTo(node.getString(), replacement)) {
return false;
}

return true;
}"
Closure_124b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_124_buggy/src/com/google/javascript/jscomp/ExploitAssigns.java,"private static boolean isCollapsibleValue(Node value, boolean isLValue) {
switch (value.getType()) {
case Token.GETPROP:
// Do not collapse GETPROPs on arbitrary objects, because
// they may be implemented setter functions, and oftentimes
// setter functions fail on native objects. This is OK for ""THIS""
// objects, because we assume that they are non-native.
return !isLValue || value.getFirstChild().isThis();

case Token.NAME:
return true;

default:
return NodeUtil.isImmutableValue(value);
}
}"
Closure_124b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_124_buggy/src/com/google/javascript/jscomp/ExploitAssigns.java,"private void collapseAssign(Node assign, Node expr,
Node exprParent) {
Node leftValue = assign.getFirstChild();
Node rightValue = leftValue.getNext();
if (isCollapsibleValue(leftValue, true) &&
collapseAssignEqualTo(expr, exprParent, leftValue)) {
reportCodeChange();
} else if (isCollapsibleValue(rightValue, false) &&
collapseAssignEqualTo(expr, exprParent, rightValue)) {
reportCodeChange();
} else if (rightValue.isAssign()) {
// Recursively deal with nested assigns.
collapseAssign(rightValue, expr, exprParent);
}
}"
Closure_124b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_124_buggy/src/com/google/javascript/jscomp/ExploitAssigns.java,"Node optimizeSubtree(Node subtree) {
for (Node child = subtree.getFirstChild(); child != null;) {
Node next = child.getNext();
if (NodeUtil.isExprAssign(child)) {
collapseAssign(child.getFirstChild(), child, subtree);
}
child = next;
}
return subtree;
}"
Closure_125b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_125_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"public void visit(NodeTraversal t, Node n, Node parent) {
JSType childType;
JSType leftType, rightType;
Node left, right;
// To be explicitly set to false if the node is not typeable.
boolean typeable = true;

switch (n.getType()) {
case Token.CAST:
Node expr = n.getFirstChild();
JSType exprType = getJSType(expr);
JSType castType = getJSType(n);

// TODO(johnlenz): determine if we can limit object literals in some
// way.
if (!expr.isObjectLit()) {
validator.expectCanCast(t, n, castType, exprType);
}
ensureTyped(t, n, castType);

if (castType.isSubtype(exprType) || expr.isObjectLit()) {
expr.setJSType(castType);
}
break;

case Token.NAME:
typeable = visitName(t, n, parent);
break;

case Token.PARAM_LIST:
typeable = false;
break;

case Token.COMMA:
ensureTyped(t, n, getJSType(n.getLastChild()));
break;

case Token.TRUE:
case Token.FALSE:
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.THIS:
ensureTyped(t, n, t.getScope().getTypeOfThis());
break;

case Token.NULL:
ensureTyped(t, n, NULL_TYPE);
break;

case Token.NUMBER:
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.STRING:
ensureTyped(t, n, STRING_TYPE);
break;

case Token.STRING_KEY:
typeable = false;
break;

case Token.GETTER_DEF:
case Token.SETTER_DEF:
// Object literal keys are handled with OBJECTLIT
break;

case Token.ARRAYLIT:
ensureTyped(t, n, ARRAY_TYPE);
break;

case Token.REGEXP:
ensureTyped(t, n, REGEXP_TYPE);
break;

case Token.GETPROP:
visitGetProp(t, n, parent);
typeable = !(parent.isAssign() &&
parent.getFirstChild() == n);
break;

case Token.GETELEM:
visitGetElem(t, n);
// The type of GETELEM is always unknown, so no point counting that.
// If that unknown leaks elsewhere (say by an assignment to another
// variable), then it will be counted.
typeable = false;
break;

case Token.VAR:
visitVar(t, n);
typeable = false;
break;

case Token.NEW:
visitNew(t, n);
break;

case Token.CALL:
visitCall(t, n);
typeable = !parent.isExprResult();
break;

case Token.RETURN:
visitReturn(t, n);
typeable = false;
break;

case Token.DEC:
case Token.INC:
left = n.getFirstChild();
checkPropCreation(t, left);
validator.expectNumber(t, left, getJSType(left), ""increment/decrement"");
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.NOT:
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.VOID:
ensureTyped(t, n, VOID_TYPE);
break;

case Token.TYPEOF:
ensureTyped(t, n, STRING_TYPE);
break;

case Token.BITNOT:
childType = getJSType(n.getFirstChild());
if (!childType.matchesInt32Context()) {
report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),
childType.toString());
}
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.POS:
case Token.NEG:
left = n.getFirstChild();
validator.expectNumber(t, left, getJSType(left), ""sign operator"");
ensureTyped(t, n, NUMBER_TYPE);
break;

case Token.EQ:
case Token.NE:
case Token.SHEQ:
case Token.SHNE: {
left = n.getFirstChild();
right = n.getLastChild();

if (left.isTypeOf()) {
if (right.isString()) {
checkTypeofString(t, right, right.getString());
}
} else if (right.isTypeOf() && left.isString()) {
checkTypeofString(t, left, left.getString());
}

leftType = getJSType(left);
rightType = getJSType(right);

// We do not want to warn about explicit comparisons to VOID. People
// often do this if they think their type annotations screwed up.
//
// We do want to warn about cases where people compare things like
// (Array|null) == (Function|null)
// because it probably means they screwed up.
//
// This heuristic here is not perfect, but should catch cases we
// care about without too many false negatives.
JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();
JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();

TernaryValue result = TernaryValue.UNKNOWN;
if (n.getType() == Token.EQ || n.getType() == Token.NE) {
result = leftTypeRestricted.testForEquality(rightTypeRestricted);
if (n.isNE()) {
result = result.not();
}
} else {
// SHEQ or SHNE
if (!leftTypeRestricted.canTestForShallowEqualityWith(
rightTypeRestricted)) {
result = n.getType() == Token.SHEQ ?
TernaryValue.FALSE : TernaryValue.TRUE;
}
}

if (result != TernaryValue.UNKNOWN) {
report(t, n, DETERMINISTIC_TEST, leftType.toString(),
rightType.toString(), result.toString());
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;
}

case Token.LT:
case Token.LE:
case Token.GT:
case Token.GE:
leftType = getJSType(n.getFirstChild());
rightType = getJSType(n.getLastChild());
if (rightType.isNumber()) {
validator.expectNumber(
t, n, leftType, ""left side of numeric comparison"");
} else if (leftType.isNumber()) {
validator.expectNumber(
t, n, rightType, ""right side of numeric comparison"");
} else if (leftType.matchesNumberContext() &&
rightType.matchesNumberContext()) {
// OK.
} else {
// Whether the comparison is numeric will be determined at runtime
// each time the expression is evaluated. Regardless, both operands
// should match a string context.
String message = ""left side of comparison"";
validator.expectString(t, n, leftType, message);
validator.expectNotNullOrUndefined(
t, n, leftType, message, getNativeType(STRING_TYPE));
message = ""right side of comparison"";
validator.expectString(t, n, rightType, message);
validator.expectNotNullOrUndefined(
t, n, rightType, message, getNativeType(STRING_TYPE));
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.IN:
left = n.getFirstChild();
right = n.getLastChild();
rightType = getJSType(right);
validator.expectString(t, left, getJSType(left), ""left side of 'in'"");
validator.expectObject(t, n, rightType, ""'in' requires an object"");
if (rightType.isStruct()) {
report(t, right, IN_USED_WITH_STRUCT);
}
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.INSTANCEOF:
left = n.getFirstChild();
right = n.getLastChild();
rightType = getJSType(right).restrictByNotNullOrUndefined();
validator.expectAnyObject(
t, left, getJSType(left), ""deterministic instanceof yields false"");
validator.expectActualObject(
t, right, rightType, ""instanceof requires an object"");
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.ASSIGN:
visitAssign(t, n);
typeable = false;
break;

case Token.ASSIGN_LSH:
case Token.ASSIGN_RSH:
case Token.ASSIGN_URSH:
case Token.ASSIGN_DIV:
case Token.ASSIGN_MOD:
case Token.ASSIGN_BITOR:
case Token.ASSIGN_BITXOR:
case Token.ASSIGN_BITAND:
case Token.ASSIGN_SUB:
case Token.ASSIGN_ADD:
case Token.ASSIGN_MUL:
checkPropCreation(t, n.getFirstChild());
// fall through

case Token.LSH:
case Token.RSH:
case Token.URSH:
case Token.DIV:
case Token.MOD:
case Token.BITOR:
case Token.BITXOR:
case Token.BITAND:
case Token.SUB:
case Token.ADD:
case Token.MUL:
visitBinaryOperator(n.getType(), t, n);
break;

case Token.DELPROP:
ensureTyped(t, n, BOOLEAN_TYPE);
break;

case Token.CASE:
JSType switchType = getJSType(parent.getFirstChild());
JSType caseType = getJSType(n.getFirstChild());
validator.expectSwitchMatchesCase(t, n, switchType, caseType);
typeable = false;
break;

case Token.WITH: {
Node child = n.getFirstChild();
childType = getJSType(child);
validator.expectObject(t, child, childType, ""with requires an object"");
typeable = false;
break;
}

case Token.FUNCTION:
visitFunction(t, n);
break;

// These nodes have no interesting type behavior.
case Token.LABEL:
case Token.LABEL_NAME:
case Token.SWITCH:
case Token.BREAK:
case Token.CATCH:
case Token.TRY:
case Token.SCRIPT:
case Token.EXPR_RESULT:
case Token.BLOCK:
case Token.EMPTY:
case Token.DEFAULT_CASE:
case Token.CONTINUE:
case Token.DEBUGGER:
case Token.THROW:
typeable = false;
break;

// These nodes require data flow analysis.
case Token.DO:
case Token.IF:
case Token.WHILE:
typeable = false;
break;

case Token.FOR:
if (NodeUtil.isForIn(n)) {
Node obj = n.getChildAtIndex(1);
if (getJSType(obj).isStruct()) {
report(t, obj, IN_USED_WITH_STRUCT);
}
}
typeable = false;
break;

// These nodes are typed during the type inference.
case Token.AND:
case Token.HOOK:
case Token.OBJECTLIT:
case Token.OR:
if (n.getJSType() != null) { // If we didn't run type inference.
ensureTyped(t, n);
} else {
// If this is an enum, then give that type to the objectlit as well.
if ((n.isObjectLit())
&& (parent.getJSType() instanceof EnumType)) {
ensureTyped(t, n, parent.getJSType());
} else {
ensureTyped(t, n);
}
}
if (n.isObjectLit()) {
JSType typ = getJSType(n);
for (Node key : n.children()) {
visitObjLitKey(t, key, n, typ);
}
}
break;

default:
report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));
ensureTyped(t, n);
break;
}

// Don't count externs since the user's code may not even use that part.
typeable = typeable && !inExterns;

if (typeable) {
doPercentTypedAccounting(t, n);
}

checkNoTypeCheckSection(n, false);
}"
Closure_125b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_125_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"private void visitFunction(NodeTraversal t, Node n) {
FunctionType functionType = JSType.toMaybeFunctionType(n.getJSType());
String functionPrivateName = n.getFirstChild().getString();
if (functionType.isConstructor()) {
FunctionType baseConstructor = functionType.getSuperClassConstructor();
if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) &&
baseConstructor != null &&
baseConstructor.isInterface()) {
compiler.report(
t.makeError(n, CONFLICTING_EXTENDED_TYPE,
""constructor"", functionPrivateName));
} else {
if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE)) {
ObjectType proto = functionType.getPrototype();
if (functionType.makesStructs() && !proto.isStruct()) {
compiler.report(t.makeError(n, CONFLICTING_SHAPE_TYPE,
""struct"", functionPrivateName));
} else if (functionType.makesDicts() && !proto.isDict()) {
compiler.report(t.makeError(n, CONFLICTING_SHAPE_TYPE,
""dict"", functionPrivateName));
}
}
// All interfaces are properly implemented by a class
for (JSType baseInterface : functionType.getImplementedInterfaces()) {
boolean badImplementedType = false;
ObjectType baseInterfaceObj = ObjectType.cast(baseInterface);
if (baseInterfaceObj != null) {
FunctionType interfaceConstructor =
baseInterfaceObj.getConstructor();
if (interfaceConstructor != null &&
!interfaceConstructor.isInterface()) {
badImplementedType = true;
}
} else {
badImplementedType = true;
}
if (badImplementedType) {
report(t, n, BAD_IMPLEMENTED_TYPE, functionPrivateName);
}
}
// check properties
validator.expectAllInterfaceProperties(t, n, functionType);
}
} else if (functionType.isInterface()) {
// Interface must extend only interfaces
for (ObjectType extInterface : functionType.getExtendedInterfaces()) {
if (extInterface.getConstructor() != null
&& !extInterface.getConstructor().isInterface()) {
compiler.report(
t.makeError(n, CONFLICTING_EXTENDED_TYPE,
""interface"", functionPrivateName));
}
}

// Check whether the extended interfaces have any conflicts
if (functionType.getExtendedInterfacesCount() > 1) {
// Only check when extending more than one interfaces
HashMap<String, ObjectType> properties
= new HashMap<String, ObjectType>();
HashMap<String, ObjectType> currentProperties
= new HashMap<String, ObjectType>();
for (ObjectType interfaceType : functionType.getExtendedInterfaces()) {
currentProperties.clear();
checkInterfaceConflictProperties(t, n, functionPrivateName,
properties, currentProperties, interfaceType);
properties.putAll(currentProperties);
}
}
}
}"
Closure_125b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_125_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"private void visitNew(NodeTraversal t, Node n) {
Node constructor = n.getFirstChild();
JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {
FunctionType fnType = type.toMaybeFunctionType();
if (fnType != null) {
visitParameterList(t, n, fnType);
ensureTyped(t, n, fnType.getInstanceType());
} else {
ensureTyped(t, n);
}
} else {
report(t, n, NOT_A_CONSTRUCTOR);
ensureTyped(t, n);
}
}"
Closure_125b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_125_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"private void visitVar(NodeTraversal t, Node n) {
// TODO(nicksantos): Fix this so that the doc info always shows up
// on the NAME node. We probably want to wait for the parser
// merge to fix this.
JSDocInfo varInfo = n.hasOneChild() ? n.getJSDocInfo() : null;
for (Node name : n.children()) {
Node value = name.getFirstChild();
// A null var would indicate a bug in the scope creation logic.
Var var = t.getScope().getVar(name.getString());

if (value != null) {
JSType valueType = getJSType(value);
JSType nameType = var.getType();
nameType = (nameType == null) ? getNativeType(UNKNOWN_TYPE) : nameType;

JSDocInfo info = name.getJSDocInfo();
if (info == null) {
info = varInfo;
}

checkEnumAlias(t, info, value);
if (var.isTypeInferred()) {
ensureTyped(t, name, valueType);
} else {
validator.expectCanAssignTo(
t, value, valueType, nameType, ""initializing variable"");
}
}
}
}"
Closure_125b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_125_buggy/src/com/google/javascript/jscomp/TypeCheck.java,"private void visitParameterList(NodeTraversal t, Node call,
FunctionType functionType) {
Iterator<Node> arguments = call.children().iterator();
arguments.next(); // skip the function name

Iterator<Node> parameters = functionType.getParameters().iterator();
int ordinal = 0;
Node parameter = null;
Node argument = null;
while (arguments.hasNext() &&
(parameters.hasNext() ||
parameter != null && parameter.isVarArgs())) {
// If there are no parameters left in the list, then the while loop
// above implies that this must be a var_args function.
if (parameters.hasNext()) {
parameter = parameters.next();
}
argument = arguments.next();
ordinal++;

validator.expectArgumentMatchesParameter(t, argument,
getJSType(argument), getJSType(parameter), call, ordinal);
}

int numArgs = call.getChildCount() - 1;
int minArgs = functionType.getMinArguments();
int maxArgs = functionType.getMaxArguments();
if (minArgs > numArgs || maxArgs < numArgs) {
report(t, call, WRONG_ARGUMENT_COUNT,
validator.getReadableJSTypeName(call.getFirstChild(), false),
String.valueOf(numArgs), String.valueOf(minArgs),
maxArgs != Integer.MAX_VALUE ?
"" and no more than "" + maxArgs + "" argument(s)"" : """");
}
}"
Closure_126b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_126_buggy/src/com/google/javascript/jscomp/MinimizeExitPoints.java,"void tryMinimizeExits(Node n, int exitType, String labelName) {

// Just an 'exit'.
if (matchingExitNode(n, exitType, labelName)) {
NodeUtil.removeChild(n.getParent(), n);
compiler.reportCodeChange();
return;
}

// Just an 'if'.
if (n.isIf()) {
Node ifBlock = n.getFirstChild().getNext();
tryMinimizeExits(ifBlock, exitType, labelName);
Node elseBlock = ifBlock.getNext();
if (elseBlock != null) {
tryMinimizeExits(elseBlock, exitType, labelName);
}
return;
}

// Just a 'try/catch/finally'.
if (n.isTry()) {
Node tryBlock = n.getFirstChild();
tryMinimizeExits(tryBlock, exitType, labelName);
Node allCatchNodes = NodeUtil.getCatchBlock(n);
if (NodeUtil.hasCatchHandler(allCatchNodes)) {
Preconditions.checkState(allCatchNodes.hasOneChild());
Node catchNode = allCatchNodes.getFirstChild();
Node catchCodeBlock = catchNode.getLastChild();
tryMinimizeExits(catchCodeBlock, exitType, labelName);
}
/* Don't try to minimize the exits of finally blocks, as this
* can cause problems if it changes the completion type of the finally
* block. See ECMA 262 Sections 8.9 & 12.14
*/
if (NodeUtil.hasFinally(n)) {
Node finallyBlock = n.getLastChild();
tryMinimizeExits(finallyBlock, exitType, labelName);
}
}

// Just a 'label'.
if (n.isLabel()) {
Node labelBlock = n.getLastChild();
tryMinimizeExits(labelBlock, exitType, labelName);
}

// TODO(johnlenz): The last case of SWITCH statement?

// The rest assumes a block with at least one child, bail on anything else.
if (!n.isBlock() || n.getLastChild() == null) {
return;
}

// Multiple if-exits can be converted in a single pass.
// Convert ""if (blah) break;  if (blah2) break; other_stmt;"" to
// become ""if (blah); else { if (blah2); else { other_stmt; } }""
// which will get converted to ""if (!blah && !blah2) { other_stmt; }"".
for (Node c : n.children()) {

// An 'if' block to process below.
if (c.isIf()) {
Node ifTree = c;
Node trueBlock, falseBlock;

// First, the true condition block.
trueBlock = ifTree.getFirstChild().getNext();
falseBlock = trueBlock.getNext();
tryMinimizeIfBlockExits(trueBlock, falseBlock,
ifTree, exitType, labelName);

// Now the else block.
// The if blocks may have changed, get them again.
trueBlock = ifTree.getFirstChild().getNext();
falseBlock = trueBlock.getNext();
if (falseBlock != null) {
tryMinimizeIfBlockExits(falseBlock, trueBlock,
ifTree, exitType, labelName);
}
}

if (c == n.getLastChild()) {
break;
}
}

// Now try to minimize the exits of the last child, if it is removed
// look at what has become the last child.
for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {
tryMinimizeExits(c, exitType, labelName);
// If the node is still the last child, we are done.
if (c == n.getLastChild()) {
break;
}
}
}"
Closure_126b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_126_buggy/src/com/google/javascript/jscomp/MinimizeExitPoints.java,"public void visit(NodeTraversal t, Node n, Node parent) {
switch (n.getType()) {
case Token.LABEL:
tryMinimizeExits(
n.getLastChild(), Token.BREAK, n.getFirstChild().getString());
break;

case Token.FOR:
case Token.WHILE:
tryMinimizeExits(NodeUtil.getLoopCodeBlock(n), Token.CONTINUE, null);
break;

case Token.DO:
tryMinimizeExits(NodeUtil.getLoopCodeBlock(n), Token.CONTINUE, null);

Node cond = NodeUtil.getConditionExpression(n);
if (NodeUtil.getImpureBooleanValue(cond) == TernaryValue.FALSE) {
// Normally, we wouldn't be able to optimize BREAKs inside a loop
// but as we know the condition will always false, we can treat them
// as we would a CONTINUE.
tryMinimizeExits(n.getFirstChild(), Token.BREAK, null);
}
break;

case Token.FUNCTION:
tryMinimizeExits(n.getLastChild(), Token.RETURN, null);
break;
}
}"
Closure_126b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_126_buggy/src/com/google/javascript/jscomp/MinimizeExitPoints.java,"private static boolean matchingExitNode(Node n, int type, String labelName) {
if (n.getType() == type) {
if (type == Token.RETURN) {
// only returns without expressions.
return !n.hasChildren();
} else {
if (labelName == null) {
return !n.hasChildren();
} else {
return n.hasChildren()
&& labelName.equals(n.getFirstChild().getString());
}
}
}
return false;
}"
Closure_126b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_126_buggy/src/com/google/javascript/jscomp/MinimizeExitPoints.java,"MinimizeExitPoints(AbstractCompiler compiler) {
this.compiler = compiler;
}"
Closure_126b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_126_buggy/src/com/google/javascript/jscomp/MinimizeExitPoints.java,"private void tryMinimizeIfBlockExits(Node srcBlock, Node destBlock,
Node ifNode, int exitType, String labelName) {
Node exitNodeParent = null;
Node exitNode = null;

// Pick an exit node candidate.
if (srcBlock.isBlock()) {
if (!srcBlock.hasChildren()) {
return;
}
exitNodeParent = srcBlock;
exitNode = exitNodeParent.getLastChild();
} else {
// Just a single statement, if it isn't an exit bail.
exitNodeParent = ifNode;
exitNode = srcBlock;
}

// Verify the candidate.
if (!matchingExitNode(exitNode, exitType, labelName)) {
return;
}

// Take case of the if nodes siblings, if any.
if (ifNode.getNext() != null) {
// Move siblings of the if block into the opposite
// logic block of the exit.
Node newDestBlock = IR.block().srcref(ifNode);
if (destBlock == null) {
// Only possible if this is the false block.
ifNode.addChildToBack(newDestBlock);
} else if (destBlock.isEmpty()) {
// Use the new block.
ifNode.replaceChild(destBlock, newDestBlock);
} else if (destBlock.isBlock()) {
// Reuse the existing block.
newDestBlock = destBlock;
} else {
// Add the existing statement to the new block.
ifNode.replaceChild(destBlock, newDestBlock);
newDestBlock.addChildToBack(destBlock);
}

// Move all the if node's following siblings.
moveAllFollowing(ifNode, ifNode.getParent(), newDestBlock);
compiler.reportCodeChange();
}
}"
Closure_128b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_128_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"static boolean isSimpleNumber(String s) {
int len = s.length();
for (int index = 0; index < len; index++) {
char c = s.charAt(index);
if (c < '0' || c > '9') {
return false;
}
}
return len > 0 && s.charAt(0) != '0';
}"
Closure_128b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_128_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"static double getSimpleNumber(String s) {
if (isSimpleNumber(s)) {
try {
long l = Long.parseLong(s);
if (l < NodeUtil.MAX_POSITIVE_INTEGER_NUMBER) {
return l;
}
} catch (NumberFormatException e) {
// The number was too long to parse. Fall through to NaN.
}
}
return Double.NaN;
}"
Closure_128b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_128_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"private String jsString(String s, boolean useSlashV) {
int singleq = 0, doubleq = 0;

// could count the quotes and pick the optimal quote character
for (int i = 0; i < s.length(); i++) {
switch (s.charAt(i)) {
case '""': doubleq++; break;
case '\'': singleq++; break;
}
}

String doublequote, singlequote;
char quote;
if (preferSingleQuotes ?
(singleq <= doubleq) : (singleq < doubleq)) {
// more double quotes so enclose in single quotes.
quote = '\'';
doublequote = ""\"""";
singlequote = ""\\\'"";
} else {
// more single quotes so escape the doubles
quote = '\""';
doublequote = ""\\\"""";
singlequote = ""\'"";
}

return strEscape(s, quote, doublequote, singlequote, ""\\\\"",
outputCharsetEncoder, useSlashV, false);
}"
Closure_128b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_128_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"private String strEscape(
String s,"
Closure_128b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_128_buggy/src/com/google/javascript/jscomp/CodeGenerator.java,"private void addJsString(Node n) {
String s = n.getString();
boolean useSlashV = n.getBooleanProp(Node.SLASH_V);
if (useSlashV) {
add(jsString(n.getString(), useSlashV));
} else {
String cached = ESCAPED_JS_STRINGS.get(s);
if (cached == null) {
cached = jsString(n.getString(), useSlashV);
ESCAPED_JS_STRINGS.put(s, cached);
}
add(cached);
}
}"
Closure_129b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_129_buggy/src/com/google/javascript/jscomp/PrepareAst.java,"PrepareAst(AbstractCompiler compiler) {
this(compiler, false);
}"
Closure_129b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_129_buggy/src/com/google/javascript/jscomp/PrepareAst.java,"public void process(Node externs, Node root) {
if (checkOnly) {
normalizeNodeTypes(root);
} else {
// Don't perform ""PrepareAnnotations"" when doing checks as
// they currently aren't valid during sanity checks.  In particular,
// they DIRECT_EVAL shouldn't be applied after inlining has been
// performed.
if (externs != null) {
NodeTraversal.traverse(
compiler, externs, new PrepareAnnotations());
}
if (root != null) {
NodeTraversal.traverse(
compiler, root, new PrepareAnnotations());
}
}
}"
Closure_130b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_130_buggy/src/com/google/javascript/jscomp/CollapseProperties.java,"public void process(Node externs, Node root) {
GlobalNamespace namespace;
if (collapsePropertiesOnExternTypes) {
namespace = new GlobalNamespace(compiler, externs, root);
} else {
namespace = new GlobalNamespace(compiler, root);
}

if (inlineAliases) {
inlineAliases(namespace);
}
nameMap = namespace.getNameIndex();
globalNames = namespace.getNameForest();
checkNamespaces();

for (Name n : globalNames) {
flattenReferencesToCollapsibleDescendantNames(n, n.getBaseName());
}

// We collapse property definitions after collapsing property references
// because this step can alter the parse tree above property references,
// invalidating the node ancestry stored with each reference.
for (Name n : globalNames) {
collapseDeclarationOfNameAndDescendants(n, n.getBaseName());
}
}"
Closure_130b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_130_buggy/src/com/google/javascript/jscomp/CollapseProperties.java,"private void inlineAliases(GlobalNamespace namespace) {
// Invariant: All the names in the worklist meet condition (a).
Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());
while (!workList.isEmpty()) {
Name name = workList.pop();

// Don't attempt to inline a getter or setter property as a variable.
if (name.type == Name.Type.GET || name.type == Name.Type.SET) {
continue;
}

if (name.globalSets == 1 && name.localSets == 0 &&
name.aliasingGets > 0) {
// {@code name} meets condition (b). Find all of its local aliases
// and try to inline them.
List<Ref> refs = Lists.newArrayList(name.getRefs());
for (Ref ref : refs) {
if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {
// {@code name} meets condition (c). Try to inline it.
if (inlineAliasIfPossible(ref, namespace)) {
name.removeRef(ref);
}
}
}
}

// Check if {@code name} has any aliases left after the
// local-alias-inlining above.
if ((name.type == Name.Type.OBJECTLIT ||
name.type == Name.Type.FUNCTION) &&
name.aliasingGets == 0 && name.props != null) {
// All of {@code name}'s children meet condition (a), so they can be
// added to the worklist.
workList.addAll(name.props);
}
}
}"
Closure_130b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_130_buggy/src/com/google/javascript/jscomp/CollapseProperties.java,"private void checkNamespaces() {
for (Name name : nameMap.values()) {
if (name.isNamespace() &&
(name.aliasingGets > 0 || name.localSets + name.globalSets > 1 ||
name.deleteProps > 0)) {
boolean initialized = name.getDeclaration() != null;
for (Ref ref : name.getRefs()) {
if (ref == name.getDeclaration()) {
continue;
}

if (ref.type == Ref.Type.DELETE_PROP) {
if (initialized) {
warnAboutNamespaceRedefinition(name, ref);
}
} else if (
ref.type == Ref.Type.SET_FROM_GLOBAL ||
ref.type == Ref.Type.SET_FROM_LOCAL) {
if (initialized) {
warnAboutNamespaceRedefinition(name, ref);
}

initialized = true;
} else if (ref.type == Ref.Type.ALIASING_GET) {
warnAboutNamespaceAliasing(name, ref);
}
}
}
}
}"
Closure_130b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_130_buggy/src/com/google/javascript/jscomp/CollapseProperties.java,"CollapseProperties(AbstractCompiler compiler,
boolean collapsePropertiesOnExternTypes, boolean inlineAliases) {
this.compiler = compiler;
this.collapsePropertiesOnExternTypes = collapsePropertiesOnExternTypes;
this.inlineAliases = inlineAliases;
}"
Closure_131b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_131_buggy/src/com/google/javascript/rhino/TokenStream.java,"public static boolean isJSIdentifier(String s) {
int length = s.length();

if (length == 0 ||
!Character.isJavaIdentifierStart(s.charAt(0))) {
return false;
}

for (int i = 1; i < length; i++) {
if (
!Character.isJavaIdentifierPart(s.charAt(i))) {
return false;
}
}

return true;
}"
Closure_131b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_131_buggy/src/com/google/javascript/rhino/TokenStream.java,"public static boolean isKeyword(String name) {
boolean id = false;
String s = name;
complete: {
String X = null;
int c;
partial: switch (s.length()) {
case 2: c=s.charAt(1);
if (c=='f') {
if (s.charAt(0)=='i') {id=true; break complete;}
} else if (c=='n') {
if (s.charAt(0)=='i') {id=true; break complete;}
} else if (c=='o') {
if (s.charAt(0)=='d') {id=true; break complete;}
}
break partial;
case 3: switch (s.charAt(0)) {
case 'f':
if (s.charAt(2)=='r' && s.charAt(1)=='o') {
id=true; break complete;
} break partial;
case 'i':
if (s.charAt(2)=='t' && s.charAt(1)=='n') {
id=true; break complete;
} break partial;
case 'n':
if (s.charAt(2)=='w' && s.charAt(1)=='e') {
id=true; break complete;
} break partial;
case 't':
if (s.charAt(2)=='y' && s.charAt(1)=='r') {
id=true; break complete;
} break partial;
case 'v':
if (s.charAt(2)=='r' && s.charAt(1)=='a') {
id=true; break complete;
} break partial;
} break partial;
case 4: switch (s.charAt(0)) {
case 'b': X=""byte"";id=true; break partial;
case 'c': c=s.charAt(3);
if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='a') {
id=true; break complete;} }
else if (c=='r') {
if (s.charAt(2)=='a' && s.charAt(1)=='h') {
id=true; break complete;
}
}
break partial;
case 'e': c=s.charAt(3);
if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='l') {
id=true; break complete;} }
else if (c=='m') {
if (s.charAt(2)=='u' && s.charAt(1)=='n') {
id=true; break complete;} }
break partial;
case 'g': X=""goto"";id=true; break partial;
case 'l': X=""long"";id=true; break partial;
case 'n': X=""null"";id=true; break partial;
case 't': c=s.charAt(3);
if (c=='e') { if (s.charAt(2)=='u' && s.charAt(1)=='r') {
id=true; break complete;} }
else if (c=='s') {
if (s.charAt(2)=='i' && s.charAt(1)=='h') {
id=true; break complete;} }
break partial;
case 'v': X=""void"";id=true; break partial;
case 'w': X=""with"";id=true; break partial;
} break partial;
case 5: switch (s.charAt(2)) {
case 'a': X=""class"";id=true; break partial;
case 'e': X=""break"";id=true; break partial;
case 'i': X=""while"";id=true; break partial;
case 'l': X=""false"";id=true; break partial;
case 'n': c=s.charAt(0);
if (c=='c') { X=""const"";id=true; }
else if (c=='f') { X=""final"";id=true; }
break partial;
case 'o': c=s.charAt(0);
if (c=='f') { X=""float"";id=true; }
else if (c=='s') { X=""short"";id=true; }
break partial;
case 'p': X=""super"";id=true; break partial;
case 'r': X=""throw"";id=true; break partial;
case 't': X=""catch"";id=true; break partial;
} break partial;
case 6: switch (s.charAt(1)) {
case 'a': X=""native"";id=true; break partial;
case 'e': c=s.charAt(0);
if (c=='d') { X=""delete"";id=true; }
else if (c=='r') { X=""return"";id=true; }
break partial;
case 'h': X=""throws"";id=true; break partial;
case 'm': X=""import"";id=true; break partial;
case 'o': X=""double"";id=true; break partial;
case 't': X=""static"";id=true; break partial;
case 'u': X=""public"";id=true; break partial;
case 'w': X=""switch"";id=true; break partial;
case 'x': X=""export"";id=true; break partial;
case 'y': X=""typeof"";id=true; break partial;
} break partial;
case 7: switch (s.charAt(1)) {
case 'a': X=""package"";id=true; break partial;
case 'e': X=""default"";id=true; break partial;
case 'i': X=""finally"";id=true; break partial;
case 'o': X=""boolean"";id=true; break partial;
case 'r': X=""private"";id=true; break partial;
case 'x': X=""extends"";id=true; break partial;
} break partial;
case 8: switch (s.charAt(0)) {
case 'a': X=""abstract"";id=true; break partial;
case 'c': X=""continue"";id=true; break partial;
case 'd': X=""debugger"";id=true; break partial;
case 'f': X=""function"";id=true; break partial;
case 'v': X=""volatile"";id=true; break partial;
} break partial;
case 9: c=s.charAt(0);
if (c=='i') { X=""interface"";id=true; }
else if (c=='p') { X=""protected"";id=true; }
else if (c=='t') { X=""transient"";id=true; }
break partial;
case 10: c=s.charAt(1);
if (c=='m') { X=""implements"";id=true; }
else if (c=='n') { X=""instanceof"";id=true; }
break partial;
case 12: X=""synchronized"";id=true; break partial;
}
// partial match validate the entire string the one possibility
if (X!=null && X!=s && !X.equals(s)) return false;
}
return id;
}"
Closure_132b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_132_buggy/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,"private Node tryMinimizeIf(Node n) {

Node parent = n.getParent();

Node cond = n.getFirstChild();

/* If the condition is a literal, we'll let other
* optimizations try to remove useless code.
*/
if (NodeUtil.isLiteralValue(cond, true)) {
return n;
}

Node thenBranch = cond.getNext();
Node elseBranch = thenBranch.getNext();

if (elseBranch == null) {
if (isFoldableExpressBlock(thenBranch)) {
Node expr = getBlockExpression(thenBranch);
if (!late && isPropertyAssignmentInExpression(expr)) {
// Keep opportunities for CollapseProperties such as
// a.longIdentifier || a.longIdentifier = ... -> var a = ...;
// until CollapseProperties has been run.
return n;
}

if (cond.isNot()) {
// if(!x)bar(); -> x||bar();
if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&
isLowerPrecedenceInExpression(expr.getFirstChild(),
OR_PRECEDENCE)) {
// It's not okay to add two sets of parentheses.
return n;
}

Node or = IR.or(
cond.removeFirstChild(),
expr.removeFirstChild()).srcref(n);
Node newExpr = NodeUtil.newExpr(or);
parent.replaceChild(n, newExpr);
reportCodeChange();

return newExpr;
}

// if(x)foo(); -> x&&foo();
if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&
isLowerPrecedenceInExpression(expr.getFirstChild(),
AND_PRECEDENCE)) {
// One additional set of parentheses is worth the change even if
// there is no immediate code size win. However, two extra pair of
// {}, we would have to think twice. (unless we know for sure the
// we can further optimize its parent.
return n;
}

n.removeChild(cond);
Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);
Node newExpr = NodeUtil.newExpr(and);
parent.replaceChild(n, newExpr);
reportCodeChange();

return newExpr;
} else {

// Try to combine two IF-ELSE
if (NodeUtil.isStatementBlock(thenBranch) &&
thenBranch.hasOneChild()) {
Node innerIf = thenBranch.getFirstChild();

if (innerIf.isIf()) {
Node innerCond = innerIf.getFirstChild();
Node innerThenBranch = innerCond.getNext();
Node innerElseBranch = innerThenBranch.getNext();

if (innerElseBranch == null &&
!(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&
isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {
n.detachChildren();
n.addChildToBack(
IR.and(
cond,
innerCond.detachFromParent())
.srcref(cond));
n.addChildrenToBack(innerThenBranch.detachFromParent());
reportCodeChange();
// Not worth trying to fold the current IF-ELSE into && because
// the inner IF-ELSE wasn't able to be folded into && anyways.
return n;
}
}
}
}

return n;
}

/* TODO(dcc) This modifies the siblings of n, which is undesirable for a
* peephole optimization. This should probably get moved to another pass.
*/
tryRemoveRepeatedStatements(n);

// if(!x)foo();else bar(); -> if(x)bar();else foo();
// An additional set of curly braces isn't worth it.
if (cond.isNot() && !consumesDanglingElse(elseBranch)) {
n.replaceChild(cond, cond.removeFirstChild());
n.removeChild(thenBranch);
n.addChildToBack(thenBranch);
reportCodeChange();
return n;
}

// if(x)return 1;else return 2; -> return x?1:2;
if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {
Node thenExpr = getBlockReturnExpression(thenBranch);
Node elseExpr = getBlockReturnExpression(elseBranch);
n.removeChild(cond);
thenExpr.detachFromParent();
elseExpr.detachFromParent();

// note - we ignore any cases with ""return;"", technically this
// can be converted to ""return undefined;"" or some variant, but
// that does not help code size.
Node returnNode = IR.returnNode(
IR.hook(cond, thenExpr, elseExpr)
.srcref(n));
parent.replaceChild(n, returnNode);
reportCodeChange();
return returnNode;
}

boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);
boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);

if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {
Node thenOp = getBlockExpression(thenBranch).getFirstChild();
Node elseOp = getBlockExpression(elseBranch).getFirstChild();
if (thenOp.getType() == elseOp.getType()) {
// if(x)a=1;else a=2; -> a=x?1:2;
if (NodeUtil.isAssignmentOp(thenOp)) {
Node lhs = thenOp.getFirstChild();
if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&
// if LHS has side effects, don't proceed [since the optimization
// evaluates LHS before cond]
// NOTE - there are some circumstances where we can
// proceed even if there are side effects...
!mayEffectMutableState(lhs)) {

n.removeChild(cond);
Node assignName = thenOp.removeFirstChild();
Node thenExpr = thenOp.removeFirstChild();
Node elseExpr = elseOp.getLastChild();
elseOp.removeChild(elseExpr);

Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);
Node assign = new Node(thenOp.getType(), assignName, hookNode)
.srcref(thenOp);
Node expr = NodeUtil.newExpr(assign);
parent.replaceChild(n, expr);
reportCodeChange();

return expr;
}
}
}
// if(x)foo();else bar(); -> x?foo():bar()
n.removeChild(cond);
thenOp.detachFromParent();
elseOp.detachFromParent();
Node expr = IR.exprResult(
IR.hook(cond, thenOp, elseOp).srcref(n));
parent.replaceChild(n, expr);
reportCodeChange();
return expr;
}

boolean thenBranchIsVar = isVarBlock(thenBranch);
boolean elseBranchIsVar = isVarBlock(elseBranch);

// if(x)var y=1;else y=2  ->  var y=x?1:2
if (thenBranchIsVar && elseBranchIsExpressionBlock &&
getBlockExpression(elseBranch).getFirstChild().isAssign()) {

Node var = getBlockVar(thenBranch);
Node elseAssign = getBlockExpression(elseBranch).getFirstChild();

Node name1 = var.getFirstChild();
Node maybeName2 = elseAssign.getFirstChild();

if (name1.hasChildren()
&& maybeName2.isName()
&& name1.getString().equals(maybeName2.getString())) {
Node thenExpr = name1.removeChildren();
Node elseExpr = elseAssign.getLastChild().detachFromParent();
cond.detachFromParent();
Node hookNode = IR.hook(cond, thenExpr, elseExpr)
.srcref(n);
var.detachFromParent();
name1.addChildrenToBack(hookNode);
parent.replaceChild(n, var);
reportCodeChange();
return var;
}

// if(x)y=1;else var y=2  ->  var y=x?1:2
} else if (elseBranchIsVar && thenBranchIsExpressionBlock &&
getBlockExpression(thenBranch).getFirstChild().isAssign()) {

Node var = getBlockVar(elseBranch);
Node thenAssign = getBlockExpression(thenBranch).getFirstChild();

Node maybeName1 = thenAssign.getFirstChild();
Node name2 = var.getFirstChild();

if (name2.hasChildren()
&& maybeName1.isName()
&& maybeName1.getString().equals(name2.getString())) {
Node thenExpr = thenAssign.getLastChild().detachFromParent();
Node elseExpr = name2.removeChildren();
cond.detachFromParent();
Node hookNode = IR.hook(cond, thenExpr, elseExpr)
.srcref(n);
var.detachFromParent();
name2.addChildrenToBack(hookNode);
parent.replaceChild(n, var);
reportCodeChange();

return var;
}
}

return n;
}"
Closure_132b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_132_buggy/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,"private Node getBlockExpression(Node n) {
Preconditions.checkState(isFoldableExpressBlock(n));
return n.getFirstChild();
}"
Closure_132b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_132_buggy/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,"private void tryRemoveRepeatedStatements(Node n) {
Preconditions.checkState(n.isIf());

Node parent = n.getParent();
if (!NodeUtil.isStatementBlock(parent)) {
// If the immediate parent is something like a label, we
// can't move the statement, so bail.
return;
}

Node cond = n.getFirstChild();
Node trueBranch = cond.getNext();
Node falseBranch = trueBranch.getNext();
Preconditions.checkNotNull(trueBranch);
Preconditions.checkNotNull(falseBranch);

while (true) {
Node lastTrue = trueBranch.getLastChild();
Node lastFalse = falseBranch.getLastChild();
if (lastTrue == null || lastFalse == null
|| !areNodesEqualForInlining(lastTrue, lastFalse)) {
break;
}
lastTrue.detachFromParent();
lastFalse.detachFromParent();
parent.addChildAfter(lastTrue, n);
reportCodeChange();
}
}"
Closure_132b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_132_buggy/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,"private boolean isReturnExpressBlock(Node n) {
if (n.isBlock()) {
if (n.hasOneChild()) {
Node first = n.getFirstChild();
if (first.isReturn()) {
return first.hasOneChild();
}
}
}

return false;
}"
Closure_132b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_132_buggy/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java,"private boolean isFoldableExpressBlock(Node n) {
if (n.isBlock()) {
if (n.hasOneChild()) {
Node maybeExpr = n.getFirstChild();
if (maybeExpr.isExprResult()) {
// IE has a bug where event handlers behave differently when
// their return value is used vs. when their return value is in
// an EXPR_RESULT. It's pretty freaking weird. See:
// http://code.google.com/p/closure-compiler/issues/detail?id=291
// We try to detect this case, and not fold EXPR_RESULTs
// into other expressions.
if (maybeExpr.getFirstChild().isCall()) {
Node calledFn = maybeExpr.getFirstChild().getFirstChild();

// We only have to worry about methods with an implicit 'this'
// param, or this doesn't happen.
if (calledFn.isGetElem()) {
return false;
} else if (calledFn.isGetProp() &&
calledFn.getLastChild().getString().startsWith(""on"")) {
return false;
}
}

return true;
}
return false;
}
}

return false;
}"
Closure_133b_1,/home/common/huangzhili/defects4j_buggy_3/Closure_133_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,"boolean parse() {
int lineno;
int charno;

// JSTypes are represented as Rhino AST nodes, and then resolved later.
JSTypeExpression type;

state = State.SEARCHING_ANNOTATION;
skipEOLs();

JsDocToken token = next();

List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();

// Always record that we have a comment.
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo blockInfo = extractBlockComment(token);
token = blockInfo.token;
if (!blockInfo.string.isEmpty()) {
jsdocBuilder.recordBlockDescription(blockInfo.string);
}
} else {
if (token != JsDocToken.ANNOTATION &&
token != JsDocToken.EOC) {
// Mark that there was a description, but don't bother marking
// what it was.
jsdocBuilder.recordBlockDescription("""");
}
}

// Parse the actual JsDoc.
retry: for (;;) {
switch (token) {
case ANNOTATION:
if (state == State.SEARCHING_ANNOTATION) {
state = State.SEARCHING_NEWLINE;
lineno = stream.getLineno();
charno = stream.getCharno();

String annotationName = stream.getString();
Annotation annotation = annotationNames.get(annotationName);
if (annotation == null) {
parser.addParserWarning(""msg.bad.jsdoc.tag"", annotationName,
stream.getLineno(), stream.getCharno());
} else {
// Mark the beginning of the annotation.
jsdocBuilder.markAnnotation(annotationName, lineno, charno);

switch (annotation) {
case NG_INJECT:
if (jsdocBuilder.isNgInjectRecorded()) {
parser.addParserWarning(""msg.jsdoc.nginject.extra"",
stream.getLineno(), stream.getCharno());
} else {
jsdocBuilder.recordNgInject(true);
}
token = eatTokensUntilEOL();
continue retry;

case AUTHOR:
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo authorInfo = extractSingleLineBlock();
String author = authorInfo.string;

if (author.length() == 0) {
parser.addParserWarning(""msg.jsdoc.authormissing"",
stream.getLineno(), stream.getCharno());
} else {
jsdocBuilder.addAuthor(author);
}
token = authorInfo.token;
} else {
token = eatTokensUntilEOL(token);
}
continue retry;

case CONSISTENTIDGENERATOR:
if (!jsdocBuilder.recordConsistentIdGenerator()) {
parser.addParserWarning(""msg.jsdoc.consistidgen"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case STRUCT:
if (!jsdocBuilder.recordStruct()) {
parser.addTypeWarning(""msg.jsdoc.incompat.type"",
stream.getLineno(),
stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case DICT:
if (!jsdocBuilder.recordDict()) {
parser.addTypeWarning(""msg.jsdoc.incompat.type"",
stream.getLineno(),
stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case CONSTRUCTOR:
if (!jsdocBuilder.recordConstructor()) {
if (jsdocBuilder.isInterfaceRecorded()) {
parser.addTypeWarning(""msg.jsdoc.interface.constructor"",
stream.getLineno(), stream.getCharno());
} else {
parser.addTypeWarning(""msg.jsdoc.incompat.type"",
stream.getLineno(), stream.getCharno());
}
}
token = eatTokensUntilEOL();
continue retry;

case DEPRECATED:
if (!jsdocBuilder.recordDeprecated()) {
parser.addParserWarning(""msg.jsdoc.deprecated"",
stream.getLineno(), stream.getCharno());
}

// Find the reason/description, if any.
ExtractionInfo reasonInfo =
extractMultilineTextualBlock(token);

String reason = reasonInfo.string;

if (reason.length() > 0) {
jsdocBuilder.recordDeprecationReason(reason);
}

token = reasonInfo.token;
continue retry;

case INTERFACE:
if (!jsdocBuilder.recordInterface()) {
if (jsdocBuilder.isConstructorRecorded()) {
parser.addTypeWarning(""msg.jsdoc.interface.constructor"",
stream.getLineno(), stream.getCharno());
} else {
parser.addTypeWarning(""msg.jsdoc.incompat.type"",
stream.getLineno(), stream.getCharno());
}
}
token = eatTokensUntilEOL();
continue retry;

case DESC:
if (jsdocBuilder.isDescriptionRecorded()) {
parser.addParserWarning(""msg.jsdoc.desc.extra"",
stream.getLineno(), stream.getCharno());
token = eatTokensUntilEOL();
continue retry;
} else {
ExtractionInfo descriptionInfo =
extractMultilineTextualBlock(token);

String description = descriptionInfo.string;

jsdocBuilder.recordDescription(description);
token = descriptionInfo.token;
continue retry;
}

case FILE_OVERVIEW:
String fileOverview = """";
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo fileOverviewInfo =
extractMultilineTextualBlock(token,
WhitespaceOption.TRIM);

fileOverview = fileOverviewInfo.string;

token = fileOverviewInfo.token;
} else {
token = eatTokensUntilEOL(token);
}

if (!jsdocBuilder.recordFileOverview(fileOverview)) {
parser.addParserWarning(""msg.jsdoc.fileoverview.extra"",
stream.getLineno(), stream.getCharno());
}
continue retry;

case LICENSE:
case PRESERVE:
ExtractionInfo preserveInfo =
extractMultilineTextualBlock(token,
WhitespaceOption.PRESERVE);

String preserve = preserveInfo.string;

if (preserve.length() > 0) {
if (fileLevelJsDocBuilder != null) {
fileLevelJsDocBuilder.append(preserve);
}
}

token = preserveInfo.token;
continue retry;

case ENUM:
token = next();
lineno = stream.getLineno();
charno = stream.getCharno();

type = null;
if (token != JsDocToken.EOL && token != JsDocToken.EOC) {
type = createJSTypeExpression(
parseAndRecordTypeNode(token));
}

if (type == null) {
type = createJSTypeExpression(newStringNode(""number""));
}
if (!jsdocBuilder.recordEnumParameterType(type)) {
parser.addTypeWarning(
""msg.jsdoc.incompat.type"", lineno, charno);
}
token = eatTokensUntilEOL(token);
continue retry;

case EXPORT:
if (!jsdocBuilder.recordExport()) {
parser.addParserWarning(""msg.jsdoc.export"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case EXPOSE:
if (!jsdocBuilder.recordExpose()) {
parser.addParserWarning(""msg.jsdoc.expose"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case EXTERNS:
if (!jsdocBuilder.recordExterns()) {
parser.addParserWarning(""msg.jsdoc.externs"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case JAVA_DISPATCH:
if (!jsdocBuilder.recordJavaDispatch()) {
parser.addParserWarning(""msg.jsdoc.javadispatch"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case EXTENDS:
case IMPLEMENTS:
skipEOLs();
token = next();
lineno = stream.getLineno();
charno = stream.getCharno();
boolean matchingRc = false;

if (token == JsDocToken.LC) {
token = next();
matchingRc = true;
}

if (token == JsDocToken.STRING) {
Node typeNode = parseAndRecordTypeNameNode(
token, lineno, charno, matchingRc);

lineno = stream.getLineno();
charno = stream.getCharno();

typeNode = wrapNode(Token.BANG, typeNode);
type = createJSTypeExpression(typeNode);

if (annotation == Annotation.EXTENDS) {
// record the extended type, check later
extendedTypes.add(new ExtendedTypeInfo(
type, stream.getLineno(), stream.getCharno()));
} else {
Preconditions.checkState(
annotation == Annotation.IMPLEMENTS);
if (!jsdocBuilder.recordImplementedInterface(type)) {
parser.addTypeWarning(""msg.jsdoc.implements.duplicate"",
lineno, charno);
}
}
token = next();
if (matchingRc) {
if (token != JsDocToken.RC) {
parser.addTypeWarning(""msg.jsdoc.missing.rc"",
stream.getLineno(), stream.getCharno());
}
} else if (token != JsDocToken.EOL &&
token != JsDocToken.EOF && token != JsDocToken.EOC) {
parser.addTypeWarning(""msg.end.annotation.expected"",
stream.getLineno(), stream.getCharno());
}
} else {
parser.addTypeWarning(""msg.no.type.name"", lineno, charno);
}
token = eatTokensUntilEOL(token);
continue retry;

case HIDDEN:
if (!jsdocBuilder.recordHiddenness()) {
parser.addParserWarning(""msg.jsdoc.hidden"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case LENDS:
skipEOLs();

matchingRc = false;
if (match(JsDocToken.LC)) {
token = next();
matchingRc = true;
}

if (match(JsDocToken.STRING)) {
token = next();
if (!jsdocBuilder.recordLends(stream.getString())) {
parser.addTypeWarning(""msg.jsdoc.lends.incompatible"",
stream.getLineno(), stream.getCharno());
}
} else {
parser.addTypeWarning(""msg.jsdoc.lends.missing"",
stream.getLineno(), stream.getCharno());
}

if (matchingRc && !match(JsDocToken.RC)) {
parser.addTypeWarning(""msg.jsdoc.missing.rc"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case MEANING:
ExtractionInfo meaningInfo =
extractMultilineTextualBlock(token);
String meaning = meaningInfo.string;
token = meaningInfo.token;
if (!jsdocBuilder.recordMeaning(meaning)) {
parser.addParserWarning(""msg.jsdoc.meaning.extra"",
stream.getLineno(), stream.getCharno());
}
continue retry;

case NO_ALIAS:
if (!jsdocBuilder.recordNoAlias()) {
parser.addParserWarning(""msg.jsdoc.noalias"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case NO_COMPILE:
if (!jsdocBuilder.recordNoCompile()) {
parser.addParserWarning(""msg.jsdoc.nocompile"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case NO_TYPE_CHECK:
if (!jsdocBuilder.recordNoTypeCheck()) {
parser.addParserWarning(""msg.jsdoc.nocheck"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case NOT_IMPLEMENTED:
token = eatTokensUntilEOL();
continue retry;

case INHERIT_DOC:
case OVERRIDE:
if (!jsdocBuilder.recordOverride()) {
parser.addTypeWarning(""msg.jsdoc.override"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case THROWS:
skipEOLs();
token = next();
lineno = stream.getLineno();
charno = stream.getCharno();
type = null;

if (token == JsDocToken.LC) {
type = createJSTypeExpression(
parseAndRecordTypeNode(token));

if (type == null) {
// parsing error reported during recursive descent
// recovering parsing
token = eatTokensUntilEOL();
continue retry;
}
}

// *Update* the token to that after the type annotation.
token = current();

// Save the throw type.
jsdocBuilder.recordThrowType(type);

// Find the throw's description (if applicable).
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo descriptionInfo =
extractMultilineTextualBlock(token);

String description = descriptionInfo.string;

if (description.length() > 0) {
jsdocBuilder.recordThrowDescription(type, description);
}

token = descriptionInfo.token;
} else {
token = eatTokensUntilEOL(token);
}
continue retry;

case PARAM:
skipEOLs();
token = next();
lineno = stream.getLineno();
charno = stream.getCharno();
type = null;

if (token == JsDocToken.LC) {
type = createJSTypeExpression(
parseAndRecordParamTypeNode(token));

if (type == null) {
// parsing error reported during recursive descent
// recovering parsing
token = eatTokensUntilEOL();
continue retry;
}
skipEOLs();
token = next();
lineno = stream.getLineno();
charno = stream.getCharno();
}

String name = null;
boolean isBracketedParam = JsDocToken.LB == token;
if (isBracketedParam) {
token = next();
}

if (JsDocToken.STRING != token) {
parser.addTypeWarning(""msg.missing.variable.name"",
lineno, charno);
} else {
name = stream.getString();

if (isBracketedParam) {
token = next();

// Throw out JsDocToolkit's ""default"" parameter
// annotation.  It makes no sense under our type
// system.
if (JsDocToken.EQUALS == token) {
token = next();
if (JsDocToken.STRING == token) {
token = next();
}
}

if (JsDocToken.RB != token) {
reportTypeSyntaxWarning(""msg.jsdoc.missing.rb"");
} else if (type != null) {
// Make the type expression optional, if it isn't
// already.
type = JSTypeExpression.makeOptionalArg(type);
}
}

// If the param name has a DOT in it, just throw it out
// quietly. We do not handle the JsDocToolkit method
// for handling properties of params.
if (name.indexOf('.') > -1) {
name = null;
} else if (!jsdocBuilder.recordParameter(name, type)) {
if (jsdocBuilder.hasParameter(name)) {
parser.addTypeWarning(""msg.dup.variable.name"", name,
lineno, charno);
} else {
parser.addTypeWarning(""msg.jsdoc.incompat.type"", name,
lineno, charno);
}
}
}

if (name == null) {
token = eatTokensUntilEOL(token);
continue retry;
}

jsdocBuilder.markName(name, sourceFile, lineno, charno);

// Find the parameter's description (if applicable).
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo paramDescriptionInfo =
extractMultilineTextualBlock(token);

String paramDescription = paramDescriptionInfo.string;

if (paramDescription.length() > 0) {
jsdocBuilder.recordParameterDescription(name,
paramDescription);
}

token = paramDescriptionInfo.token;
} else {
token = eatTokensUntilEOL(token);
}
continue retry;

case PRESERVE_TRY:
if (!jsdocBuilder.recordPreserveTry()) {
parser.addParserWarning(""msg.jsdoc.preservertry"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case NO_SHADOW:
if (!jsdocBuilder.recordNoShadow()) {
parser.addParserWarning(""msg.jsdoc.noshadow"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case NO_SIDE_EFFECTS:
if (!jsdocBuilder.recordNoSideEffects()) {
parser.addParserWarning(""msg.jsdoc.nosideeffects"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case MODIFIES:
token = parseModifiesTag(next());
continue retry;

case IMPLICIT_CAST:
if (!jsdocBuilder.recordImplicitCast()) {
parser.addTypeWarning(""msg.jsdoc.implicitcast"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case SEE:
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo referenceInfo = extractSingleLineBlock();
String reference = referenceInfo.string;

if (reference.length() == 0) {
parser.addParserWarning(""msg.jsdoc.seemissing"",
stream.getLineno(), stream.getCharno());
} else {
jsdocBuilder.addReference(reference);
}

token = referenceInfo.token;
} else {
token = eatTokensUntilEOL(token);
}
continue retry;

case STABLEIDGENERATOR:
if (!jsdocBuilder.recordStableIdGenerator()) {
parser.addParserWarning(""msg.jsdoc.stableidgen"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case SUPPRESS:
token = parseSuppressTag(next());
continue retry;

case TEMPLATE: {
ExtractionInfo templateInfo = extractSingleLineBlock();
List<String> names = Lists.newArrayList(
Splitter.on(',')
.trimResults()
.split(templateInfo.string));

if (names.size() == 0 || names.get(0).length() == 0) {
parser.addTypeWarning(""msg.jsdoc.templatemissing"",
stream.getLineno(), stream.getCharno());
} else if (!jsdocBuilder.recordTemplateTypeNames(names)) {
parser.addTypeWarning(""msg.jsdoc.template.at.most.once"",
stream.getLineno(), stream.getCharno());
}

token = templateInfo.token;
continue retry;
}

case CLASS_TEMPLATE: {
ExtractionInfo classTemplateInfo = extractSingleLineBlock();
List<String> names = Lists.newArrayList(
Splitter.on(',')
.trimResults()
.split(classTemplateInfo.string));

if (names.size() == 0 || names.get(0).length() == 0) {
parser.addTypeWarning(
""msg.jsdoc.classtemplate.missing.type.name"",
stream.getLineno(), stream.getCharno());
} else if (!jsdocBuilder.recordClassTemplateTypeNames(names)) {
parser.addTypeWarning(
""msg.jsdoc.classtemplate.at.most.once"",
stream.getLineno(), stream.getCharno());
}

token = classTemplateInfo.token;
continue retry;
}

case IDGENERATOR:
if (!jsdocBuilder.recordIdGenerator()) {
parser.addParserWarning(""msg.jsdoc.idgen"",
stream.getLineno(), stream.getCharno());
}
token = eatTokensUntilEOL();
continue retry;

case VERSION:
ExtractionInfo versionInfo = extractSingleLineBlock();
String version = versionInfo.string;

if (version.length() == 0) {
parser.addParserWarning(""msg.jsdoc.versionmissing"",
stream.getLineno(), stream.getCharno());
} else {
if (!jsdocBuilder.recordVersion(version)) {
parser.addParserWarning(""msg.jsdoc.extraversion"",
stream.getLineno(), stream.getCharno());
}
}

token = versionInfo.token;
continue retry;

case CONSTANT:
case DEFINE:
case RETURN:
case PRIVATE:
case PROTECTED:
case PUBLIC:
case THIS:
case TYPE:
case TYPEDEF:
lineno = stream.getLineno();
charno = stream.getCharno();

Node typeNode = null;
boolean hasType = lookAheadForTypeAnnotation();
boolean isAlternateTypeAnnotation =
(annotation == Annotation.PRIVATE ||
annotation == Annotation.PROTECTED ||
annotation == Annotation.PUBLIC ||
annotation == Annotation.CONSTANT);
boolean canSkipTypeAnnotation =
(isAlternateTypeAnnotation ||
annotation == Annotation.RETURN);
type = null;
if (hasType || !canSkipTypeAnnotation) {
skipEOLs();
token = next();
typeNode = parseAndRecordTypeNode(token);

if (annotation == Annotation.THIS) {
typeNode = wrapNode(Token.BANG, typeNode);
}
type = createJSTypeExpression(typeNode);
}

// The error was reported during recursive descent
// recovering parsing
boolean hasError = type == null && !canSkipTypeAnnotation;
if (!hasError) {
// Record types for @type.
// If the @private, @protected, or @public annotations
// have a type attached, pretend that they actually wrote:
// @type {type}\n@private
// This will have some weird behavior in some cases
// (for example, @private can now be used as a type-cast),
// but should be mostly OK.
if ((type != null && isAlternateTypeAnnotation)
|| annotation == Annotation.TYPE) {
if (!jsdocBuilder.recordType(type)) {
parser.addTypeWarning(
""msg.jsdoc.incompat.type"", lineno, charno);
}
}

switch (annotation) {
case CONSTANT:
if (!jsdocBuilder.recordConstancy()) {
parser.addParserWarning(""msg.jsdoc.const"",
stream.getLineno(), stream.getCharno());
}
break;

case DEFINE:
if (!jsdocBuilder.recordDefineType(type)) {
parser.addParserWarning(""msg.jsdoc.define"",
lineno, charno);
}
break;

case PRIVATE:
if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {
parser.addParserWarning(
""msg.jsdoc.visibility.private"",
lineno, charno);
}
break;

case PROTECTED:
if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {
parser.addParserWarning(
""msg.jsdoc.visibility.protected"",
lineno, charno);
}
break;

case PUBLIC:
if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {
parser.addParserWarning(
""msg.jsdoc.visibility.public"",
lineno, charno);
}
break;

case RETURN:
if (type == null) {
type = createJSTypeExpression(newNode(Token.QMARK));
}

if (!jsdocBuilder.recordReturnType(type)) {
parser.addTypeWarning(
""msg.jsdoc.incompat.type"", lineno, charno);
break;
}

// Find the return's description (if applicable).
if (jsdocBuilder.shouldParseDocumentation()) {
ExtractionInfo returnDescriptionInfo =
extractMultilineTextualBlock(token);

String returnDescription =
returnDescriptionInfo.string;

if (returnDescription.length() > 0) {
jsdocBuilder.recordReturnDescription(
returnDescription);
}

token = returnDescriptionInfo.token;
} else {
token = eatTokensUntilEOL(token);
}
continue retry;

case THIS:
if (!jsdocBuilder.recordThisType(type)) {
parser.addTypeWarning(
""msg.jsdoc.incompat.type"", lineno, charno);
}
break;

case TYPEDEF:
if (!jsdocBuilder.recordTypedef(type)) {
parser.addTypeWarning(
""msg.jsdoc.incompat.type"", lineno, charno);
}
break;
}
}

token = eatTokensUntilEOL();
continue retry;
}
}
}
break;

case EOC:
if (hasParsedFileOverviewDocInfo()) {
fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();
}
checkExtendedTypes(extendedTypes);
return true;

case EOF:
// discard any accumulated information
jsdocBuilder.build(null);
parser.addParserWarning(""msg.unexpected.eof"",
stream.getLineno(), stream.getCharno());
checkExtendedTypes(extendedTypes);
return false;

case EOL:
if (state == State.SEARCHING_NEWLINE) {
state = State.SEARCHING_ANNOTATION;
}
token = next();
continue retry;

default:
if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {
token = next();
continue retry;
} else {
state = State.SEARCHING_NEWLINE;
token = eatTokensUntilEOL();
continue retry;
}
}

// next token
token = next();
}
}"
Closure_133b_2,/home/common/huangzhili/defects4j_buggy_3/Closure_133_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,"private Node parseBasicTypeExpression(JsDocToken token) {
if (token == JsDocToken.STAR) {
return newNode(Token.STAR);
} else if (token == JsDocToken.LB) {
skipEOLs();
return parseArrayType(next());
} else if (token == JsDocToken.LC) {
skipEOLs();
return parseRecordType(next());
} else if (token == JsDocToken.LP) {
skipEOLs();
return parseUnionType(next());
} else if (token == JsDocToken.STRING) {
String string = stream.getString();
if (""function"".equals(string)) {
skipEOLs();
return parseFunctionType(next());
} else if (""null"".equals(string) || ""undefined"".equals(string)) {
return newStringNode(string);
} else {
return parseTypeName(token);
}
}

restoreLookAhead(token);
return reportGenericTypeSyntaxWarning();
}"
Closure_133b_3,/home/common/huangzhili/defects4j_buggy_3/Closure_133_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,"private Node reportGenericTypeSyntaxWarning() {
return reportTypeSyntaxWarning(""msg.jsdoc.type.syntax"");
}"
Closure_133b_4,/home/common/huangzhili/defects4j_buggy_3/Closure_133_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,"private void restoreLookAhead(JsDocToken token) {
unreadToken = token;
}"
Closure_133b_5,/home/common/huangzhili/defects4j_buggy_3/Closure_133_buggy/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java,"private Node reportTypeSyntaxWarning(String warning) {
parser.addTypeWarning(warning, stream.getLineno(), stream.getCharno());
return null;
}"
Lang_1b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_1_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static Number createNumber(final String str) throws NumberFormatException {
if (str == null) {
return null;
}
if (StringUtils.isBlank(str)) {
throw new NumberFormatException(""A blank string is not a valid number"");
}
// Need to deal with all possible hex prefixes here
final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
int pfxLen = 0;
for(final String pfx : hex_prefixes) {
if (str.startsWith(pfx)) {
pfxLen += pfx.length();
break;
}
}
if (pfxLen > 0) { // we have a hex number
final int hexDigits = str.length() - pfxLen;
if (hexDigits > 16) { // too many for Long
return createBigInteger(str);
}
if (hexDigits > 8) { // too many for an int
return createLong(str);
}
return createInteger(str);
}
final char lastChar = str.charAt(str.length() - 1);
String mant;
String dec;
String exp;
final int decPos = str.indexOf('.');
final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present
// if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
// and the parsing which will detect if e or E appear in a number due to using the wrong offset

int numDecimals = 0; // Check required precision (LANG-693)
if (decPos > -1) { // there is a decimal point

if (expPos > -1) { // there is an exponent
if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
throw new NumberFormatException(str + "" is not a valid number."");
}
dec = str.substring(decPos + 1, expPos);
} else {
dec = str.substring(decPos + 1);
}
mant = str.substring(0, decPos);
numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
} else {
if (expPos > -1) {
if (expPos > str.length()) { // prevents double exponent causing IOOBE
throw new NumberFormatException(str + "" is not a valid number."");
}
mant = str.substring(0, expPos);
} else {
mant = str;
}
dec = null;
}
if (!Character.isDigit(lastChar) && lastChar != '.') {
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length() - 1);
} else {
exp = null;
}
//Requesting a specific type..
final String numeric = str.substring(0, str.length() - 1);
final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
switch (lastChar) {
case 'l' :
case 'L' :
if (dec == null
&& exp == null
&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
try {
return createLong(numeric);
} catch (final NumberFormatException nfe) { // NOPMD
// Too big for a long
}
return createBigInteger(numeric);

}
throw new NumberFormatException(str + "" is not a valid number."");
case 'f' :
case 'F' :
try {
final Float f = NumberUtils.createFloat(numeric);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
//If it's too big for a float or the float value = 0 and the string
//has non-zeros in it, then float does not have the precision we want
return f;
}

} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
//$FALL-THROUGH$
case 'd' :
case 'D' :
try {
final Double d = NumberUtils.createDouble(numeric);
if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
return d;
}
} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
try {
return createBigDecimal(numeric);
} catch (final NumberFormatException e) { // NOPMD
// ignore the bad number
}
//$FALL-THROUGH$
default :
throw new NumberFormatException(str + "" is not a valid number."");

}
}
//User doesn't have a preference on the return type, so let's start
//small and go from there...
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length());
} else {
exp = null;
}
if (dec == null && exp == null) { // no decimal point and no exponent
//Must be an Integer, Long, Biginteger
try {
return createInteger(str);
} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
try {
return createLong(str);
} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
return createBigInteger(str);
}

//Must be a Float, Double, BigDecimal
final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
try {
if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float
final Float f = createFloat(str);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
return f;
}
}
} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
try {
if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double
final Double d = createDouble(str);
if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
return d;
}
}
} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}

return createBigDecimal(str);
}"
Lang_1b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_1_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static Integer createInteger(final String str) {
if (str == null) {
return null;
}
// decode() handles 0xAABD and 0777 (hex and octal) as well.
return Integer.decode(str);
}"
Lang_3b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_3_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static Number createNumber(final String str) throws NumberFormatException {
if (str == null) {
return null;
}
if (StringUtils.isBlank(str)) {
throw new NumberFormatException(""A blank string is not a valid number"");
}
// Need to deal with all possible hex prefixes here
final String[] hex_prefixes = {""0x"", ""0X"", ""-0x"", ""-0X"", ""#"", ""-#""};
int pfxLen = 0;
for(final String pfx : hex_prefixes) {
if (str.startsWith(pfx)) {
pfxLen += pfx.length();
break;
}
}
if (pfxLen > 0) { // we have a hex number
final int hexDigits = str.length() - pfxLen;
if (hexDigits > 16) { // too many for Long
return createBigInteger(str);
}
if (hexDigits > 8) { // too many for an int
return createLong(str);
}
return createInteger(str);
}
final char lastChar = str.charAt(str.length() - 1);
String mant;
String dec;
String exp;
final int decPos = str.indexOf('.');
final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present
// if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)
// and the parsing which will detect if e or E appear in a number due to using the wrong offset

int numDecimals = 0; // Check required precision (LANG-693)
if (decPos > -1) { // there is a decimal point

if (expPos > -1) { // there is an exponent
if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE
throw new NumberFormatException(str + "" is not a valid number."");
}
dec = str.substring(decPos + 1, expPos);
} else {
dec = str.substring(decPos + 1);
}
mant = str.substring(0, decPos);
numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.
} else {
if (expPos > -1) {
if (expPos > str.length()) { // prevents double exponent causing IOOBE
throw new NumberFormatException(str + "" is not a valid number."");
}
mant = str.substring(0, expPos);
} else {
mant = str;
}
dec = null;
}
if (!Character.isDigit(lastChar) && lastChar != '.') {
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length() - 1);
} else {
exp = null;
}
//Requesting a specific type..
final String numeric = str.substring(0, str.length() - 1);
final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
switch (lastChar) {
case 'l' :
case 'L' :
if (dec == null
&& exp == null
&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
try {
return createLong(numeric);
} catch (final NumberFormatException nfe) { // NOPMD
// Too big for a long
}
return createBigInteger(numeric);

}
throw new NumberFormatException(str + "" is not a valid number."");
case 'f' :
case 'F' :
try {
final Float f = NumberUtils.createFloat(numeric);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
//If it's too big for a float or the float value = 0 and the string
//has non-zeros in it, then float does not have the precision we want
return f;
}

} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
//$FALL-THROUGH$
case 'd' :
case 'D' :
try {
final Double d = NumberUtils.createDouble(numeric);
if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
return d;
}
} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
try {
return createBigDecimal(numeric);
} catch (final NumberFormatException e) { // NOPMD
// ignore the bad number
}
//$FALL-THROUGH$
default :
throw new NumberFormatException(str + "" is not a valid number."");

}
}
//User doesn't have a preference on the return type, so let's start
//small and go from there...
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length());
} else {
exp = null;
}
if (dec == null && exp == null) { // no decimal point and no exponent
//Must be an Integer, Long, Biginteger
try {
return createInteger(str);
} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
try {
return createLong(str);
} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
return createBigInteger(str);
}

//Must be a Float, Double, BigDecimal
final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
try {
final Float f = createFloat(str);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
return f;
}
} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
try {
final Double d = createDouble(str);
if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
return d;
}
} catch (final NumberFormatException nfe) { // NOPMD
// ignore the bad number
}

return createBigDecimal(str);
}"
Lang_3b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_3_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"private static boolean isAllZeros(final String str) {
if (str == null) {
return true;
}
for (int i = str.length() - 1; i >= 0; i--) {
if (str.charAt(i) != '0') {
return false;
}
}
return str.length() > 0;
}"
Lang_3b_3,/home/common/huangzhili/defects4j_buggy_3/Lang_3_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static Float createFloat(final String str) {
if (str == null) {
return null;
}
return Float.valueOf(str);
}"
Lang_5b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_5_buggy/src/main/java/org/apache/commons/lang3/LocaleUtils.java,"public static Locale toLocale(final String str) {
if (str == null) {
return null;
}
final int len = str.length();
if (len < 2) {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
final char ch0 = str.charAt(0);
final char ch1 = str.charAt(1);
if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
if (len == 2) {
return new Locale(str);
}
if (len < 5) {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
if (str.charAt(2) != '_') {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
final char ch3 = str.charAt(3);
if (ch3 == '_') {
return new Locale(str.substring(0, 2), """", str.substring(4));
}
final char ch4 = str.charAt(4);
if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
if (len == 5) {
return new Locale(str.substring(0, 2), str.substring(3, 5));
}
if (len < 7) {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
if (str.charAt(5) != '_') {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
}"
Lang_5b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_5_buggy/src/main/java/org/apache/commons/lang3/LocaleUtils.java,"public static List<Locale> availableLocaleList() {
return SyncAvoid.AVAILABLE_LOCALE_LIST;
}"
Lang_5b_3,/home/common/huangzhili/defects4j_buggy_3/Lang_5_buggy/src/main/java/org/apache/commons/lang3/LocaleUtils.java,"public static boolean isAvailableLocale(Locale locale) {
return availableLocaleList().contains(locale);
}"
Lang_6b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_6_buggy/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java,"public final String translate(CharSequence input) {
if (input == null) {
return null;
}
try {
StringWriter writer = new StringWriter(input.length() * 2);
translate(input, writer);
return writer.toString();
} catch (IOException ioe) {
// this should never ever happen while writing to a StringWriter
throw new RuntimeException(ioe);
}
}"
Lang_6b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_6_buggy/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java,"public final CharSequenceTranslator with(CharSequenceTranslator... translators) {
CharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1];
newArray[0] = this;
System.arraycopy(translators, 0, newArray, 1, translators.length);
return new AggregateTranslator(newArray);
}"
Lang_9b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_9_buggy/src/main/java/org/apache/commons/lang3/time/FastDateParser.java,"Pattern getParsePattern() {
return parsePattern;
}"
Lang_9b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_9_buggy/src/main/java/org/apache/commons/lang3/time/FastDateParser.java,"private Strategy getStrategy(String formatField) {
switch(formatField.charAt(0)) {
case '\'':
if(formatField.length()>2) {
formatField= formatField.substring(1, formatField.length()-1);
}
//$FALL-THROUGH$
default:
return new CopyQuotedStrategy(formatField);
case 'D':
return DAY_OF_YEAR_STRATEGY;
case 'E':
return DAY_OF_WEEK_STRATEGY;
case 'F':
return DAY_OF_WEEK_IN_MONTH_STRATEGY;
case 'G':
return ERA_STRATEGY;
case 'H':
return MODULO_HOUR_OF_DAY_STRATEGY;
case 'K':
return HOUR_STRATEGY;
case 'M':
return formatField.length()>=3 ?TEXT_MONTH_STRATEGY :NUMBER_MONTH_STRATEGY;
case 'S':
return MILLISECOND_STRATEGY;
case 'W':
return WEEK_OF_MONTH_STRATEGY;
case 'Z':
break;
case 'a':
return AM_PM_STRATEGY;
case 'd':
return DAY_OF_MONTH_STRATEGY;
case 'h':
return MODULO_HOUR_STRATEGY;
case 'k':
return HOUR_OF_DAY_STRATEGY;
case 'm':
return MINUTE_STRATEGY;
case 's':
return SECOND_STRATEGY;
case 'w':
return WEEK_OF_YEAR_STRATEGY;
case 'y':
return formatField.length()>2 ?LITERAL_YEAR_STRATEGY :ABBREVIATED_YEAR_STRATEGY;
case 'z':
break;
}
TimeZoneStrategy tzs= tzsCache.get(locale);
if(tzs==null) {
tzs= new TimeZoneStrategy(locale);
TimeZoneStrategy inCache= tzsCache.putIfAbsent(locale, tzs);
if(inCache!=null) {
return inCache;
}
}
return tzs;
}"
Lang_9b_3,/home/common/huangzhili/defects4j_buggy_3/Lang_9_buggy/src/main/java/org/apache/commons/lang3/time/FastDateParser.java,"Date date= parse(source, new ParsePosition(0));
if(date==null) {
// Add a note re supported date range
if (locale.equals(JAPANESE_IMPERIAL)) {
throw new ParseException(
""(The "" +locale + "" locale does not support dates before 1868 AD)\n"" +
""Unparseable date: \""""+source+""\"" does not match ""+parsePattern.pattern(), 0);
}
throw new ParseException(""Unparseable date: \""""+source+""\"" does not match ""+parsePattern.pattern(), 0);
}"
Lang_9b_4,/home/common/huangzhili/defects4j_buggy_3/Lang_9_buggy/src/main/java/org/apache/commons/lang3/time/FastDateParser.java,"private void init() {
thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);

nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();

StringBuilder regex= new StringBuilder();
List<Strategy> collector = new ArrayList<Strategy>();

Matcher patternMatcher= formatPattern.matcher(pattern);
if(!patternMatcher.lookingAt()) {
throw new IllegalArgumentException(""Invalid pattern"");
}

currentFormatField= patternMatcher.group();
Strategy currentStrategy= getStrategy(currentFormatField);
for(;;) {
patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());
if(!patternMatcher.lookingAt()) {
nextStrategy = null;
break;
}
String nextFormatField= patternMatcher.group();
nextStrategy = getStrategy(nextFormatField);
if(currentStrategy.addRegex(this, regex)) {
collector.add(currentStrategy);
}
currentFormatField= nextFormatField;
currentStrategy= nextStrategy;
}
if(currentStrategy.addRegex(this, regex)) {
collector.add(currentStrategy);
}
currentFormatField= null;
strategies= collector.toArray(new Strategy[collector.size()]);
parsePattern= Pattern.compile(regex.toString());
}"
Lang_9b_5,/home/common/huangzhili/defects4j_buggy_3/Lang_9_buggy/src/main/java/org/apache/commons/lang3/time/FastDateParser.java,"private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
for(int i= 0; i<value.length(); ++i) {
char c= value.charAt(i);
switch(c) {
case '\'':
if(unquote) {
if(++i==value.length()) {
return regex;
}
c= value.charAt(i);
}
break;
case '?':
case '[':
case ']':
case '(':
case ')':
case '{':
case '}':
case '\\':
case '|':
case '*':
case '+':
case '^':
case '$':
case '.':
regex.append('\\');
}
regex.append(c);
}
return regex;
}"
Lang_10b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_10_buggy/src/main/java/org/apache/commons/lang3/time/FastDateParser.java,"Pattern getParsePattern() {
return parsePattern;
}"
Lang_10b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_10_buggy/src/main/java/org/apache/commons/lang3/time/FastDateParser.java,"KeyValue[] getDisplayNames(int field) {
Integer fieldInt = Integer.valueOf(field);
KeyValue[] fieldKeyValues= nameValues.get(fieldInt);
if(fieldKeyValues==null) {
DateFormatSymbols symbols= DateFormatSymbols.getInstance(locale);
switch(field) {
case Calendar.ERA:
// DateFormatSymbols#getEras() only returns AD/BC or translations
// It does not work for the Thai Buddhist or Japanese Imperial calendars.
// see: https://issues.apache.org/jira/browse/TRINIDAD-2126
Calendar c = Calendar.getInstance(locale);
// N.B. Some calendars have different short and long symbols, e.g. ja_JP_JP
String[] shortEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.SHORT, locale));
String[] longEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.LONG, locale));
fieldKeyValues= createKeyValues(longEras, shortEras);
break;
case Calendar.DAY_OF_WEEK:
fieldKeyValues= createKeyValues(symbols.getWeekdays(), symbols.getShortWeekdays());
break;
case Calendar.AM_PM:
fieldKeyValues= createKeyValues(symbols.getAmPmStrings(), null);
break;
case Calendar.MONTH:
fieldKeyValues= createKeyValues(symbols.getMonths(), symbols.getShortMonths());
break;
default:
throw new IllegalArgumentException(""Invalid field value ""+field);
}
KeyValue[] prior = nameValues.putIfAbsent(fieldInt, fieldKeyValues);
if(prior!=null) {
fieldKeyValues= prior;
}
}
return fieldKeyValues;
}"
Lang_10b_3,/home/common/huangzhili/defects4j_buggy_3/Lang_10_buggy/src/main/java/org/apache/commons/lang3/time/FastDateParser.java,"private Strategy getStrategy(String formatField) {
switch(formatField.charAt(0)) {
case '\'':
if(formatField.length()>2) {
formatField= formatField.substring(1, formatField.length()-1);
}
//$FALL-THROUGH$
default:
return new CopyQuotedStrategy(formatField);
case 'D':
return DAY_OF_YEAR_STRATEGY;
case 'E':
return DAY_OF_WEEK_STRATEGY;
case 'F':
return DAY_OF_WEEK_IN_MONTH_STRATEGY;
case 'G':
return ERA_STRATEGY;
case 'H':
return MODULO_HOUR_OF_DAY_STRATEGY;
case 'K':
return HOUR_STRATEGY;
case 'M':
return formatField.length()>=3 ?TEXT_MONTH_STRATEGY :NUMBER_MONTH_STRATEGY;
case 'S':
return MILLISECOND_STRATEGY;
case 'W':
return WEEK_OF_MONTH_STRATEGY;
case 'Z':
break;
case 'a':
return AM_PM_STRATEGY;
case 'd':
return DAY_OF_MONTH_STRATEGY;
case 'h':
return MODULO_HOUR_STRATEGY;
case 'k':
return HOUR_OF_DAY_STRATEGY;
case 'm':
return MINUTE_STRATEGY;
case 's':
return SECOND_STRATEGY;
case 'w':
return WEEK_OF_YEAR_STRATEGY;
case 'y':
return formatField.length()>2 ?LITERAL_YEAR_STRATEGY :ABBREVIATED_YEAR_STRATEGY;
case 'z':
break;
}
TimeZoneStrategy tzs= tzsCache.get(locale);
if(tzs==null) {
tzs= new TimeZoneStrategy(locale);
TimeZoneStrategy inCache= tzsCache.putIfAbsent(locale, tzs);
if(inCache!=null) {
return inCache;
}
}
return tzs;
}"
Lang_10b_4,/home/common/huangzhili/defects4j_buggy_3/Lang_10_buggy/src/main/java/org/apache/commons/lang3/time/FastDateParser.java,"private static KeyValue[] createKeyValues(String[] longValues, String[] shortValues) {
KeyValue[] fieldKeyValues= new KeyValue[count(longValues)+count(shortValues)];
copy(fieldKeyValues, copy(fieldKeyValues, 0, longValues), shortValues);
Arrays.sort(fieldKeyValues, IGNORE_CASE_COMPARATOR);
return fieldKeyValues;
}"
Lang_10b_5,/home/common/huangzhili/defects4j_buggy_3/Lang_10_buggy/src/main/java/org/apache/commons/lang3/time/FastDateParser.java,"private static int count(String[] values) {
int count= 0;
if(values!=null) {
for(String value : values) {
if(value.length()>0) {
++count;
}
}
}
return count;
}"
Lang_11b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_11_buggy/src/main/java/org/apache/commons/lang3/RandomStringUtils.java,"return random(count, start, end, letters, numbers, null, RANDOM);
}

/**
* <p>Creates a random string based on a variety of options, using
* default source of randomness.</p>
*
* <p>This method has exactly the same semantics as
* {@link #random(int,int,int,boolean,boolean,char[],Random)}, but
* instead of using an externally supplied source of randomness, it uses
* the internal static {@link Random} instance.</p>
*
* @param count  the length of random string to create
* @param start  the position in set of chars to start at
* @param end  the position in set of chars to end before
* @param letters  only allow letters?
* @param numbers  only allow numbers?
* @param chars  the set of chars to choose randoms from.
*  If {@code null}, then it will use the set of all chars.
* @return the random string
* @throws ArrayIndexOutOfBoundsException if there are not
*  {@code (end - start) + 1} characters in the set array.
*/
public static String random(int count, int start, int end, boolean letters, boolean numbers, char... chars) {"
Lang_12b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_12_buggy/src/main/java/org/apache/commons/lang3/RandomStringUtils.java,"return random(count, false, false);
}

/**
* <p>Creates a random string whose length is the number of characters
* specified.</p>
*
* <p>Characters will be chosen from the set of characters whose
* ASCII value is between {@code 32} and {@code 126} (inclusive).</p>
*
* @param count  the length of random string to create
* @return the random string
*/
public static String randomAscii(int count) {"
Lang_14b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_14_buggy/src/main/java/org/apache/commons/lang3/StringUtils.java,"public static boolean equals(CharSequence cs1, CharSequence cs2) {
if (cs1 == cs2) {
return true;
}
if (cs1 == null || cs2 == null) {
return false;
}
return cs1.equals(cs2);
}"
Lang_16b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_16_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static Number createNumber(String str) throws NumberFormatException {
if (str == null) {
return null;
}
if (StringUtils.isBlank(str)) {
throw new NumberFormatException(""A blank string is not a valid number"");
}
if (str.startsWith(""--"")) {
// this is protection for poorness in java.lang.BigDecimal.
// it accepts this as a legal value, but it does not appear
// to be in specification of class. OS X Java parses it to
// a wrong value.
return null;
}
if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
return createInteger(str);
}
char lastChar = str.charAt(str.length() - 1);
String mant;
String dec;
String exp;
int decPos = str.indexOf('.');
int expPos = str.indexOf('e') + str.indexOf('E') + 1;

if (decPos > -1) {

if (expPos > -1) {
if (expPos < decPos || expPos > str.length()) {
throw new NumberFormatException(str + "" is not a valid number."");
}
dec = str.substring(decPos + 1, expPos);
} else {
dec = str.substring(decPos + 1);
}
mant = str.substring(0, decPos);
} else {
if (expPos > -1) {
if (expPos > str.length()) {
throw new NumberFormatException(str + "" is not a valid number."");
}
mant = str.substring(0, expPos);
} else {
mant = str;
}
dec = null;
}
if (!Character.isDigit(lastChar) && lastChar != '.') {
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length() - 1);
} else {
exp = null;
}
//Requesting a specific type..
String numeric = str.substring(0, str.length() - 1);
boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
switch (lastChar) {
case 'l' :
case 'L' :
if (dec == null
&& exp == null
&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
try {
return createLong(numeric);
} catch (NumberFormatException nfe) { // NOPMD
// Too big for a long
}
return createBigInteger(numeric);

}
throw new NumberFormatException(str + "" is not a valid number."");
case 'f' :
case 'F' :
try {
Float f = NumberUtils.createFloat(numeric);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
//If it's too big for a float or the float value = 0 and the string
//has non-zeros in it, then float does not have the precision we want
return f;
}

} catch (NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
//$FALL-THROUGH$
case 'd' :
case 'D' :
try {
Double d = NumberUtils.createDouble(numeric);
if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
return d;
}
} catch (NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
try {
return createBigDecimal(numeric);
} catch (NumberFormatException e) { // NOPMD
// ignore the bad number
}
//$FALL-THROUGH$
default :
throw new NumberFormatException(str + "" is not a valid number."");

}
} else {
//User doesn't have a preference on the return type, so let's start
//small and go from there...
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length());
} else {
exp = null;
}
if (dec == null && exp == null) {
//Must be an int,long,bigint
try {
return createInteger(str);
} catch (NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
try {
return createLong(str);
} catch (NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
return createBigInteger(str);

} else {
//Must be a float,double,BigDec
boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
try {
Float f = createFloat(str);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
return f;
}
} catch (NumberFormatException nfe) { // NOPMD
// ignore the bad number
}
try {
Double d = createDouble(str);
if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
return d;
}
} catch (NumberFormatException nfe) { // NOPMD
// ignore the bad number
}

return createBigDecimal(str);

}
}
}"
Lang_16b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_16_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"private static boolean isAllZeros(String str) {
if (str == null) {
return true;
}
for (int i = str.length() - 1; i >= 0; i--) {
if (str.charAt(i) != '0') {
return false;
}
}
return str.length() > 0;
}"
Lang_16b_3,/home/common/huangzhili/defects4j_buggy_3/Lang_16_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static Float createFloat(String str) {
if (str == null) {
return null;
}
return Float.valueOf(str);
}"
Lang_16b_4,/home/common/huangzhili/defects4j_buggy_3/Lang_16_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static Double createDouble(String str) {
if (str == null) {
return null;
}
return Double.valueOf(str);
}"
Lang_16b_5,/home/common/huangzhili/defects4j_buggy_3/Lang_16_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static Integer createInteger(String str) {
if (str == null) {
return null;
}
// decode() handles 0xAABD and 0777 (hex and octal) as well.
return Integer.decode(str);
}"
Lang_17b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_17_buggy/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java,"public final String translate(CharSequence input) {
if (input == null) {
return null;
}
try {
StringWriter writer = new StringWriter(input.length() * 2);
translate(input, writer);
return writer.toString();
} catch (IOException ioe) {
// this should never ever happen while writing to a StringWriter
throw new RuntimeException(ioe);
}
}"
Lang_17b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_17_buggy/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java,"public final CharSequenceTranslator with(CharSequenceTranslator... translators) {
CharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1];
newArray[0] = this;
System.arraycopy(translators, 0, newArray, 1, translators.length);
return new AggregateTranslator(newArray);
}"
Lang_19b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_19_buggy/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java,"public int translate(CharSequence input, int index, Writer out) throws IOException {
int seqEnd = input.length();
// Uses -2 to ensure there is something after the &#
if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
int start = index + 2;
boolean isHex = false;

char firstChar = input.charAt(start);
if(firstChar == 'x' || firstChar == 'X') {
start++;
isHex = true;

// Check there's more than just an x after the &#
}

int end = start;
// Note that this supports character codes without a ; on the end
while(input.charAt(end) != ';')
{
end++;
}

int entityValue;
try {
if(isHex) {
entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
} else {
entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
}
} catch(NumberFormatException nfe) {
System.err.println(""FAIL: "" + input.subSequence(start, end) + ""["" + start +""][""+ end +""]"");
return 0;
}

if(entityValue > 0xFFFF) {
char[] chrs = Character.toChars(entityValue);
out.write(chrs[0]);
out.write(chrs[1]);
} else {
out.write(entityValue);
}


return 2 + (end - start) + (isHex ? 1 : 0) + 1;
}
return 0;
}"
Lang_21b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_21_buggy/src/main/java/org/apache/commons/lang3/time/DateUtils.java,"public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {
if (cal1 == null || cal2 == null) {
throw new IllegalArgumentException(""The date must not be null"");
}
return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&
cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&
cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&
cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&
cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&
cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&
cal1.getClass() == cal2.getClass());
}"
Lang_22b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_22_buggy/src/main/java/org/apache/commons/lang3/math/Fraction.java,"public static Fraction getReducedFraction(int numerator, int denominator) {
if (denominator == 0) {
throw new ArithmeticException(""The denominator must not be zero"");
}
if (numerator==0) {
return ZERO; // normalize zero.
}
// allow 2^k/-2^31 as a valid fraction (where k>0)
if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {
numerator/=2; denominator/=2;
}
if (denominator < 0) {
if (numerator==Integer.MIN_VALUE ||
denominator==Integer.MIN_VALUE) {
throw new ArithmeticException(""overflow: can't negate"");
}
numerator = -numerator;
denominator = -denominator;
}
// simplify fraction.
int gcd = greatestCommonDivisor(numerator, denominator);
numerator /= gcd;
denominator /= gcd;
return new Fraction(numerator, denominator);
}"
Lang_22b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_22_buggy/src/main/java/org/apache/commons/lang3/math/Fraction.java,"public Fraction reduce() {
if (numerator == 0) {
return equals(ZERO) ? this : ZERO;
}
int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
if (gcd == 1) {
return this;
}
return Fraction.getFraction(numerator / gcd, denominator / gcd);
}"
Lang_22b_3,/home/common/huangzhili/defects4j_buggy_3/Lang_22_buggy/src/main/java/org/apache/commons/lang3/math/Fraction.java,"private static int greatestCommonDivisor(int u, int v) {
// From Commons Math:
//if either operand is abs 1, return 1:
if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {
return 1;
}
// keep u and v negative, as negative integers range down to
// -2^31, while positive numbers can only be as large as 2^31-1
// (i.e. we can't necessarily negate a negative number without
// overflow)
if (u>0) { u=-u; } // make u negative
if (v>0) { v=-v; } // make v negative
// B1. [Find power of 2]
int k=0;
while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...
u/=2; v/=2; k++; // cast out twos.
}
if (k==31) {
throw new ArithmeticException(""overflow: gcd is 2^31"");
}
// B2. Initialize: u and v have been divided by 2^k and at least
//     one is odd.
int t = ((u&1)==1) ? v : -(u/2)/*B3*/;
// t negative: u was odd, v may be even (t replaces v)
// t positive: u was even, v is odd (t replaces u)
do {
/* assert u<0 && v<0; */
// B4/B3: cast out twos from t.
while ((t&1)==0) { // while t is even..
t/=2; // cast out twos
}
// B5 [reset max(u,v)]
if (t>0) {
u = -t;
} else {
v = t;
}
// B6/B3. at this point both u and v should be odd.
t = (v - u)/2;
// |u| larger: t positive (replace u)
// |v| larger: t negative (replace v)
} while (t!=0);
return -u*(1<<k); // gcd is u*2^k
}"
Lang_22b_4,/home/common/huangzhili/defects4j_buggy_3/Lang_22_buggy/src/main/java/org/apache/commons/lang3/math/Fraction.java,"public boolean equals(Object obj) {
if (obj == this) {
return true;
}
if (obj instanceof Fraction == false) {
return false;
}
Fraction other = (Fraction) obj;
return (getNumerator() == other.getNumerator() &&
getDenominator() == other.getDenominator());
}"
Lang_22b_5,/home/common/huangzhili/defects4j_buggy_3/Lang_22_buggy/src/main/java/org/apache/commons/lang3/math/Fraction.java,"public static Fraction getFraction(int numerator, int denominator) {
if (denominator == 0) {
throw new ArithmeticException(""The denominator must not be zero"");
}
if (denominator < 0) {
if (numerator==Integer.MIN_VALUE ||
denominator==Integer.MIN_VALUE) {
throw new ArithmeticException(""overflow: can't negate"");
}
numerator = -numerator;
denominator = -denominator;
}
return new Fraction(numerator, denominator);
}"
Lang_24b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_24_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static Number createNumber(String str) throws NumberFormatException {
if (str == null) {
return null;
}
if (StringUtils.isBlank(str)) {
throw new NumberFormatException(""A blank string is not a valid number"");
}
if (str.startsWith(""--"")) {
// this is protection for poorness in java.lang.BigDecimal.
// it accepts this as a legal value, but it does not appear
// to be in specification of class. OS X Java parses it to
// a wrong value.
return null;
}
if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
return createInteger(str);
}
char lastChar = str.charAt(str.length() - 1);
String mant;
String dec;
String exp;
int decPos = str.indexOf('.');
int expPos = str.indexOf('e') + str.indexOf('E') + 1;

if (decPos > -1) {

if (expPos > -1) {
if (expPos < decPos || expPos > str.length()) {
throw new NumberFormatException(str + "" is not a valid number."");
}
dec = str.substring(decPos + 1, expPos);
} else {
dec = str.substring(decPos + 1);
}
mant = str.substring(0, decPos);
} else {
if (expPos > -1) {
if (expPos > str.length()) {
throw new NumberFormatException(str + "" is not a valid number."");
}
mant = str.substring(0, expPos);
} else {
mant = str;
}
dec = null;
}
if (!Character.isDigit(lastChar) && lastChar != '.') {
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length() - 1);
} else {
exp = null;
}
//Requesting a specific type..
String numeric = str.substring(0, str.length() - 1);
boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
switch (lastChar) {
case 'l' :
case 'L' :
if (dec == null
&& exp == null
&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
try {
return createLong(numeric);
} catch (NumberFormatException nfe) {
//Too big for a long
}
return createBigInteger(numeric);

}
throw new NumberFormatException(str + "" is not a valid number."");
case 'f' :
case 'F' :
try {
Float f = NumberUtils.createFloat(numeric);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
//If it's too big for a float or the float value = 0 and the string
//has non-zeros in it, then float does not have the precision we want
return f;
}

} catch (NumberFormatException nfe) {
// ignore the bad number
}
//$FALL-THROUGH$
case 'd' :
case 'D' :
try {
Double d = NumberUtils.createDouble(numeric);
if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
return d;
}
} catch (NumberFormatException nfe) {
// ignore the bad number
}
try {
return createBigDecimal(numeric);
} catch (NumberFormatException e) {
// ignore the bad number
}
//$FALL-THROUGH$
default :
throw new NumberFormatException(str + "" is not a valid number."");

}
} else {
//User doesn't have a preference on the return type, so let's start
//small and go from there...
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length());
} else {
exp = null;
}
if (dec == null && exp == null) {
//Must be an int,long,bigint
try {
return createInteger(str);
} catch (NumberFormatException nfe) {
// ignore the bad number
}
try {
return createLong(str);
} catch (NumberFormatException nfe) {
// ignore the bad number
}
return createBigInteger(str);

} else {
//Must be a float,double,BigDec
boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
try {
Float f = createFloat(str);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
return f;
}
} catch (NumberFormatException nfe) {
// ignore the bad number
}
try {
Double d = createDouble(str);
if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
return d;
}
} catch (NumberFormatException nfe) {
// ignore the bad number
}

return createBigDecimal(str);

}
}
}"
Lang_24b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_24_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"private static boolean isAllZeros(String str) {
if (str == null) {
return true;
}
for (int i = str.length() - 1; i >= 0; i--) {
if (str.charAt(i) != '0') {
return false;
}
}
return str.length() > 0;
}"
Lang_24b_3,/home/common/huangzhili/defects4j_buggy_3/Lang_24_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static boolean isNumber(String str) {
if (StringUtils.isEmpty(str)) {
return false;
}
char[] chars = str.toCharArray();
int sz = chars.length;
boolean hasExp = false;
boolean hasDecPoint = false;
boolean allowSigns = false;
boolean foundDigit = false;
// deal with any possible sign up front
int start = (chars[0] == '-') ? 1 : 0;
if (sz > start + 1) {
if (chars[start] == '0' && chars[start + 1] == 'x') {
int i = start + 2;
if (i == sz) {
return false; // str == ""0x""
}
// checking hex (it can't be anything else)
for (; i < chars.length; i++) {
if ((chars[i] < '0' || chars[i] > '9')
&& (chars[i] < 'a' || chars[i] > 'f')
&& (chars[i] < 'A' || chars[i] > 'F')) {
return false;
}
}
return true;
}
}
sz--; // don't want to loop to the last char, check it afterwords
// for type qualifiers
int i = start;
// loop to the next to last char or to the last char if we need another digit to
// make a valid number (e.g. chars[0..5] = ""1234E"")
while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {
if (chars[i] >= '0' && chars[i] <= '9') {
foundDigit = true;
allowSigns = false;

} else if (chars[i] == '.') {
if (hasDecPoint || hasExp) {
// two decimal points or dec in exponent
return false;
}
hasDecPoint = true;
} else if (chars[i] == 'e' || chars[i] == 'E') {
// we've already taken care of hex.
if (hasExp) {
// two E's
return false;
}
if (!foundDigit) {
return false;
}
hasExp = true;
allowSigns = true;
} else if (chars[i] == '+' || chars[i] == '-') {
if (!allowSigns) {
return false;
}
allowSigns = false;
foundDigit = false; // we need a digit after the E
} else {
return false;
}
i++;
}
if (i < chars.length) {
if (chars[i] >= '0' && chars[i] <= '9') {
// no type qualifier, OK
return true;
}
if (chars[i] == 'e' || chars[i] == 'E') {
// can't have an E at the last byte
return false;
}
if (chars[i] == '.') {
if (hasDecPoint || hasExp) {
// two decimal points or dec in exponent
return false;
}
// single trailing decimal point after non-exponent is ok
return foundDigit;
}
if (!allowSigns
&& (chars[i] == 'd'
|| chars[i] == 'D'
|| chars[i] == 'f'
|| chars[i] == 'F')) {
return foundDigit;
}
if (chars[i] == 'l'
|| chars[i] == 'L') {
// not allowing L with an exponent or decimal point
return foundDigit && !hasExp;
}
// last character is illegal
return false;
}
// allowSigns is true iff the val ends in 'E'
// found digit it to make sure weird stuff like '.' and '1E-' doesn't pass
return !allowSigns && foundDigit;
}"
Lang_24b_4,/home/common/huangzhili/defects4j_buggy_3/Lang_24_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static Float createFloat(String str) {
if (str == null) {
return null;
}
return Float.valueOf(str);
}"
Lang_24b_5,/home/common/huangzhili/defects4j_buggy_3/Lang_24_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static Double createDouble(String str) {
if (str == null) {
return null;
}
return Double.valueOf(str);
}"
Lang_26b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_26_buggy/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java,"protected List<Rule> parsePattern() {
DateFormatSymbols symbols = new DateFormatSymbols(mLocale);
List<Rule> rules = new ArrayList<Rule>();

String[] ERAs = symbols.getEras();
String[] months = symbols.getMonths();
String[] shortMonths = symbols.getShortMonths();
String[] weekdays = symbols.getWeekdays();
String[] shortWeekdays = symbols.getShortWeekdays();
String[] AmPmStrings = symbols.getAmPmStrings();

int length = mPattern.length();
int[] indexRef = new int[1];

for (int i = 0; i < length; i++) {
indexRef[0] = i;
String token = parseToken(mPattern, indexRef);
i = indexRef[0];

int tokenLen = token.length();
if (tokenLen == 0) {
break;
}

Rule rule;
char c = token.charAt(0);

switch (c) {
case 'G': // era designator (text)
rule = new TextField(Calendar.ERA, ERAs);
break;
case 'y': // year (number)
if (tokenLen >= 4) {
rule = selectNumberRule(Calendar.YEAR, tokenLen);
} else {
rule = TwoDigitYearField.INSTANCE;
}
break;
case 'M': // month in year (text and number)
if (tokenLen >= 4) {
rule = new TextField(Calendar.MONTH, months);
} else if (tokenLen == 3) {
rule = new TextField(Calendar.MONTH, shortMonths);
} else if (tokenLen == 2) {
rule = TwoDigitMonthField.INSTANCE;
} else {
rule = UnpaddedMonthField.INSTANCE;
}
break;
case 'd': // day in month (number)
rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);
break;
case 'h': // hour in am/pm (number, 1..12)
rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));
break;
case 'H': // hour in day (number, 0..23)
rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);
break;
case 'm': // minute in hour (number)
rule = selectNumberRule(Calendar.MINUTE, tokenLen);
break;
case 's': // second in minute (number)
rule = selectNumberRule(Calendar.SECOND, tokenLen);
break;
case 'S': // millisecond (number)
rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);
break;
case 'E': // day in week (text)
rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);
break;
case 'D': // day in year (number)
rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);
break;
case 'F': // day of week in month (number)
rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);
break;
case 'w': // week in year (number)
rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);
break;
case 'W': // week in month (number)
rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);
break;
case 'a': // am/pm marker (text)
rule = new TextField(Calendar.AM_PM, AmPmStrings);
break;
case 'k': // hour in day (1..24)
rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));
break;
case 'K': // hour in am/pm (0..11)
rule = selectNumberRule(Calendar.HOUR, tokenLen);
break;
case 'z': // time zone (text)
if (tokenLen >= 4) {
rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);
} else {
rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);
}
break;
case 'Z': // time zone (value)
if (tokenLen == 1) {
rule = TimeZoneNumberRule.INSTANCE_NO_COLON;
} else {
rule = TimeZoneNumberRule.INSTANCE_COLON;
}
break;
case '\'': // literal text
String sub = token.substring(1);
if (sub.length() == 1) {
rule = new CharacterLiteral(sub.charAt(0));
} else {
rule = new StringLiteral(sub);
}
break;
default:
throw new IllegalArgumentException(""Illegal pattern component: "" + token);
}

rules.add(rule);
}

return rules;
}"
Lang_26b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_26_buggy/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java,"public String format(Date date) {
Calendar c = new GregorianCalendar(mTimeZone);
c.setTime(date);
return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
}"
Lang_26b_3,/home/common/huangzhili/defects4j_buggy_3/Lang_26_buggy/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java,"return getInstance(pattern, null, locale);
}

/**
* <p>Gets a formatter instance using the specified pattern, time zone
* and locale.</p>
*
* @param pattern  {@link java.text.SimpleDateFormat} compatible
*  pattern
* @param timeZone  optional time zone, overrides time zone of
*  formatted date
* @param locale  optional locale, overrides system locale
* @return a pattern based date/time formatter
* @throws IllegalArgumentException if pattern is invalid
*  or <code>null</code>
*/
public static synchronized FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {"
Lang_26b_4,/home/common/huangzhili/defects4j_buggy_3/Lang_26_buggy/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java,"protected String parseToken(String pattern, int[] indexRef) {
StringBuilder buf = new StringBuilder();

int i = indexRef[0];
int length = pattern.length();

char c = pattern.charAt(i);
if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
// Scan a run of the same character, which indicates a time
// pattern.
buf.append(c);

while (i + 1 < length) {
char peek = pattern.charAt(i + 1);
if (peek == c) {
buf.append(c);
i++;
} else {
break;
}
}
} else {
// This will identify token as text.
buf.append('\'');

boolean inLiteral = false;

for (; i < length; i++) {
c = pattern.charAt(i);

if (c == '\'') {
if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
// '' is treated as escaped '
i++;
buf.append(c);
} else {
inLiteral = !inLiteral;
}
} else if (!inLiteral &&
(c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
i--;
break;
} else {
buf.append(c);
}
}
}

indexRef[0] = i;
return buf.toString();
}"
Lang_26b_5,/home/common/huangzhili/defects4j_buggy_3/Lang_26_buggy/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java,"protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {
Rule[] rules = mRules;
int len = mRules.length;
for (int i = 0; i < len; i++) {
rules[i].appendTo(buf, calendar);
}
return buf;
}"
Lang_27b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_27_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static Number createNumber(String str) throws NumberFormatException {
if (str == null) {
return null;
}
if (StringUtils.isBlank(str)) {
throw new NumberFormatException(""A blank string is not a valid number"");
}
if (str.startsWith(""--"")) {
// this is protection for poorness in java.lang.BigDecimal.
// it accepts this as a legal value, but it does not appear
// to be in specification of class. OS X Java parses it to
// a wrong value.
return null;
}
if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
return createInteger(str);
}
char lastChar = str.charAt(str.length() - 1);
String mant;
String dec;
String exp;
int decPos = str.indexOf('.');
int expPos = str.indexOf('e') + str.indexOf('E') + 1;

if (decPos > -1) {

if (expPos > -1) {
if (expPos < decPos) {
throw new NumberFormatException(str + "" is not a valid number."");
}
dec = str.substring(decPos + 1, expPos);
} else {
dec = str.substring(decPos + 1);
}
mant = str.substring(0, decPos);
} else {
if (expPos > -1) {
mant = str.substring(0, expPos);
} else {
mant = str;
}
dec = null;
}
if (!Character.isDigit(lastChar) && lastChar != '.') {
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length() - 1);
} else {
exp = null;
}
//Requesting a specific type..
String numeric = str.substring(0, str.length() - 1);
boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
switch (lastChar) {
case 'l' :
case 'L' :
if (dec == null
&& exp == null
&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
try {
return createLong(numeric);
} catch (NumberFormatException nfe) {
//Too big for a long
}
return createBigInteger(numeric);

}
throw new NumberFormatException(str + "" is not a valid number."");
case 'f' :
case 'F' :
try {
Float f = NumberUtils.createFloat(numeric);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
//If it's too big for a float or the float value = 0 and the string
//has non-zeros in it, then float does not have the precision we want
return f;
}

} catch (NumberFormatException nfe) {
// ignore the bad number
}
//$FALL-THROUGH$
case 'd' :
case 'D' :
try {
Double d = NumberUtils.createDouble(numeric);
if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
return d;
}
} catch (NumberFormatException nfe) {
// ignore the bad number
}
try {
return createBigDecimal(numeric);
} catch (NumberFormatException e) {
// ignore the bad number
}
//$FALL-THROUGH$
default :
throw new NumberFormatException(str + "" is not a valid number."");

}
} else {
//User doesn't have a preference on the return type, so let's start
//small and go from there...
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length());
} else {
exp = null;
}
if (dec == null && exp == null) {
//Must be an int,long,bigint
try {
return createInteger(str);
} catch (NumberFormatException nfe) {
// ignore the bad number
}
try {
return createLong(str);
} catch (NumberFormatException nfe) {
// ignore the bad number
}
return createBigInteger(str);

} else {
//Must be a float,double,BigDec
boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
try {
Float f = createFloat(str);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
return f;
}
} catch (NumberFormatException nfe) {
// ignore the bad number
}
try {
Double d = createDouble(str);
if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
return d;
}
} catch (NumberFormatException nfe) {
// ignore the bad number
}

return createBigDecimal(str);

}
}
}"
Lang_27b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_27_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"private static boolean isAllZeros(String str) {
if (str == null) {
return true;
}
for (int i = str.length() - 1; i >= 0; i--) {
if (str.charAt(i) != '0') {
return false;
}
}
return str.length() > 0;
}"
Lang_27b_3,/home/common/huangzhili/defects4j_buggy_3/Lang_27_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static Float createFloat(String str) {
if (str == null) {
return null;
}
return Float.valueOf(str);
}"
Lang_27b_4,/home/common/huangzhili/defects4j_buggy_3/Lang_27_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static Double createDouble(String str) {
if (str == null) {
return null;
}
return Double.valueOf(str);
}"
Lang_27b_5,/home/common/huangzhili/defects4j_buggy_3/Lang_27_buggy/src/main/java/org/apache/commons/lang3/math/NumberUtils.java,"public static Integer createInteger(String str) {
if (str == null) {
return null;
}
// decode() handles 0xAABD and 0777 (hex and octal) as well.
return Integer.decode(str);
}"
Lang_28b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_28_buggy/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java,"public int translate(CharSequence input, int index, Writer out) throws IOException {
// TODO: Protect from ArrayIndexOutOfBounds
if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {
int start = index + 2;
boolean isHex = false;

char firstChar = input.charAt(start);
if(firstChar == 'x' || firstChar == 'X') {
start++;
isHex = true;
}

int end = start;
while(input.charAt(end) != ';') {
end++;
}

int entityValue;
try {
if(isHex) {
entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);
} else {
entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);
}
} catch(NumberFormatException nfe) {
return 0;
}

out.write(entityValue);
return 2 + (end - start) + (isHex ? 1 : 0) + 1;
}
return 0;
}"
Lang_29b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_29_buggy/src/main/java/org/apache/commons/lang3/SystemUtils.java,"static float toJavaVersionInt(String version) {
return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));
}"
Lang_29b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_29_buggy/src/main/java/org/apache/commons/lang3/SystemUtils.java,"private static int[] toJavaVersionIntArray(String version, int limit) {
if (version == null) {
return ArrayUtils.EMPTY_INT_ARRAY;
}
String[] strings = Pattern.compile(""[^\\d]"").split(version);
int[] ints = new int[Math.min(limit, strings.length)];
int j = 0;
for (int i = 0; i < strings.length && j < limit; i++) {
String s = strings[i];
if (s.length() > 0) {
ints[j++] = Integer.parseInt(s);
}
}
return ints;
}"
Lang_29b_3,/home/common/huangzhili/defects4j_buggy_3/Lang_29_buggy/src/main/java/org/apache/commons/lang3/SystemUtils.java,"private static float getJavaVersionAsFloat() {
return toVersionFloat(toJavaVersionIntArray(SystemUtils.JAVA_VERSION, JAVA_VERSION_TRIM_SIZE));
}"
Lang_29b_4,/home/common/huangzhili/defects4j_buggy_3/Lang_29_buggy/src/main/java/org/apache/commons/lang3/SystemUtils.java,"private static int getJavaVersionAsInt() {
return toVersionInt(toJavaVersionIntArray(SystemUtils.JAVA_VERSION, JAVA_VERSION_TRIM_SIZE));
}"
Lang_29b_5,/home/common/huangzhili/defects4j_buggy_3/Lang_29_buggy/src/main/java/org/apache/commons/lang3/SystemUtils.java,"private static boolean getJavaVersionMatches(String versionPrefix) {
return isJavaVersionMatch(JAVA_VERSION_TRIMMED, versionPrefix);
}"
Lang_31b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_31_buggy/src/main/java/org/apache/commons/lang3/StringUtils.java,"public static boolean containsAny(CharSequence cs, char[] searchChars) {
if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
return false;
}
int csLength = cs.length();
int searchLength = searchChars.length;
for (int i = 0; i < csLength; i++) {
char ch = cs.charAt(i);
for (int j = 0; j < searchLength; j++) {
if (searchChars[j] == ch) {
// ch is a supplementary character
// ch is in the Basic Multilingual Plane
return true;
}
}
}
return false;
}"
Lang_31b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_31_buggy/src/main/java/org/apache/commons/lang3/StringUtils.java,"public static boolean isEmpty(CharSequence cs) {
return cs == null || cs.length() == 0;
}"
Lang_33b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_33_buggy/src/main/java/org/apache/commons/lang3/ClassUtils.java,"public static Class<?>[] toClass(Object[] array) {
if (array == null) {
return null;
} else if (array.length == 0) {
return ArrayUtils.EMPTY_CLASS_ARRAY;
}
Class<?>[] classes = new Class[array.length];
for (int i = 0; i < array.length; i++) {
classes[i] = array[i].getClass();
}
return classes;
}"
Lang_33b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_33_buggy/src/main/java/org/apache/commons/lang3/ClassUtils.java,"private static void addAbbreviation(String primitive, String abbreviation) {
abbreviationMap.put(primitive, abbreviation);
reverseAbbreviationMap.put(abbreviation, primitive);
}"
Lang_37b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_37_buggy/src/java/org/apache/commons/lang3/ArrayUtils.java,"public static <T> T[] addAll(T[] array1, T... array2) {
if (array1 == null) {
return clone(array2);
} else if (array2 == null) {
return clone(array1);
}
final Class<?> type1 = array1.getClass().getComponentType();
T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
System.arraycopy(array1, 0, joinedArray, 0, array1.length);
System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
// Check if problem is incompatible types
return joinedArray;
}"
Lang_38b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_38_buggy/src/java/org/apache/commons/lang3/time/FastDateFormat.java,"protected List<Rule> parsePattern() {
DateFormatSymbols symbols = new DateFormatSymbols(mLocale);
List<Rule> rules = new ArrayList<Rule>();

String[] ERAs = symbols.getEras();
String[] months = symbols.getMonths();
String[] shortMonths = symbols.getShortMonths();
String[] weekdays = symbols.getWeekdays();
String[] shortWeekdays = symbols.getShortWeekdays();
String[] AmPmStrings = symbols.getAmPmStrings();

int length = mPattern.length();
int[] indexRef = new int[1];

for (int i = 0; i < length; i++) {
indexRef[0] = i;
String token = parseToken(mPattern, indexRef);
i = indexRef[0];

int tokenLen = token.length();
if (tokenLen == 0) {
break;
}

Rule rule;
char c = token.charAt(0);

switch (c) {
case 'G': // era designator (text)
rule = new TextField(Calendar.ERA, ERAs);
break;
case 'y': // year (number)
if (tokenLen >= 4) {
rule = selectNumberRule(Calendar.YEAR, tokenLen);
} else {
rule = TwoDigitYearField.INSTANCE;
}
break;
case 'M': // month in year (text and number)
if (tokenLen >= 4) {
rule = new TextField(Calendar.MONTH, months);
} else if (tokenLen == 3) {
rule = new TextField(Calendar.MONTH, shortMonths);
} else if (tokenLen == 2) {
rule = TwoDigitMonthField.INSTANCE;
} else {
rule = UnpaddedMonthField.INSTANCE;
}
break;
case 'd': // day in month (number)
rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);
break;
case 'h': // hour in am/pm (number, 1..12)
rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));
break;
case 'H': // hour in day (number, 0..23)
rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);
break;
case 'm': // minute in hour (number)
rule = selectNumberRule(Calendar.MINUTE, tokenLen);
break;
case 's': // second in minute (number)
rule = selectNumberRule(Calendar.SECOND, tokenLen);
break;
case 'S': // millisecond (number)
rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);
break;
case 'E': // day in week (text)
rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);
break;
case 'D': // day in year (number)
rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);
break;
case 'F': // day of week in month (number)
rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);
break;
case 'w': // week in year (number)
rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);
break;
case 'W': // week in month (number)
rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);
break;
case 'a': // am/pm marker (text)
rule = new TextField(Calendar.AM_PM, AmPmStrings);
break;
case 'k': // hour in day (1..24)
rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));
break;
case 'K': // hour in am/pm (0..11)
rule = selectNumberRule(Calendar.HOUR, tokenLen);
break;
case 'z': // time zone (text)
if (tokenLen >= 4) {
rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.LONG);
} else {
rule = new TimeZoneNameRule(mTimeZone, mTimeZoneForced, mLocale, TimeZone.SHORT);
}
break;
case 'Z': // time zone (value)
if (tokenLen == 1) {
rule = TimeZoneNumberRule.INSTANCE_NO_COLON;
} else {
rule = TimeZoneNumberRule.INSTANCE_COLON;
}
break;
case '\'': // literal text
String sub = token.substring(1);
if (sub.length() == 1) {
rule = new CharacterLiteral(sub.charAt(0));
} else {
rule = new StringLiteral(sub);
}
break;
default:
throw new IllegalArgumentException(""Illegal pattern component: "" + token);
}

rules.add(rule);
}

return rules;
}"
Lang_38b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_38_buggy/src/java/org/apache/commons/lang3/time/FastDateFormat.java,"return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();
}

/**
* <p>Formats a milliseond <code>long</code> value into the
* supplied <code>StringBuffer</code>.</p>
*
* @param millis  the millisecond value to format
* @param buf  the buffer to format into
* @return the specified string buffer
* @since 2.1
*/
public StringBuffer format(long millis, StringBuffer buf) {"
Lang_38b_3,/home/common/huangzhili/defects4j_buggy_3/Lang_38_buggy/src/java/org/apache/commons/lang3/time/FastDateFormat.java,"return getInstance(pattern, timeZone, null);
}

/**
* <p>Gets a formatter instance using the specified pattern and
* locale.</p>
*
* @param pattern  {@link java.text.SimpleDateFormat} compatible
*  pattern
* @param locale  optional locale, overrides system locale
* @return a pattern based date/time formatter
* @throws IllegalArgumentException if pattern is invalid
*/
public static FastDateFormat getInstance(String pattern, Locale locale) {"
Lang_38b_4,/home/common/huangzhili/defects4j_buggy_3/Lang_38_buggy/src/java/org/apache/commons/lang3/time/FastDateFormat.java,"protected String parseToken(String pattern, int[] indexRef) {
StringBuilder buf = new StringBuilder();

int i = indexRef[0];
int length = pattern.length();

char c = pattern.charAt(i);
if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {
// Scan a run of the same character, which indicates a time
// pattern.
buf.append(c);

while (i + 1 < length) {
char peek = pattern.charAt(i + 1);
if (peek == c) {
buf.append(c);
i++;
} else {
break;
}
}
} else {
// This will identify token as text.
buf.append('\'');

boolean inLiteral = false;

for (; i < length; i++) {
c = pattern.charAt(i);

if (c == '\'') {
if (i + 1 < length && pattern.charAt(i + 1) == '\'') {
// '' is treated as escaped '
i++;
buf.append(c);
} else {
inLiteral = !inLiteral;
}
} else if (!inLiteral &&
(c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {
i--;
break;
} else {
buf.append(c);
}
}
}

indexRef[0] = i;
return buf.toString();
}"
Lang_38b_5,/home/common/huangzhili/defects4j_buggy_3/Lang_38_buggy/src/java/org/apache/commons/lang3/time/FastDateFormat.java,"protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {
Rule[] rules = mRules;
int len = mRules.length;
for (int i = 0; i < len; i++) {
rules[i].appendTo(buf, calendar);
}
return buf;
}"
Lang_39b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_39_buggy/src/java/org/apache/commons/lang3/StringUtils.java,"return replaceEach(text, searchList, replacementList, false, 0);
}

/**
* <p>
* Replaces all occurrences of Strings within another String.
* </p>
*
* <p>
* A <code>null</code> reference passed to this method is a no-op, or if
* any ""search string"" or ""string to replace"" is null, that replace will be
* ignored. This will not repeat. For repeating replaces, call the
* overloaded method.
* </p>
*
* <pre>
*  StringUtils.replaceEach(null, *, *, *) = null
*  StringUtils.replaceEach("""", *, *, *) = """"
*  StringUtils.replaceEach(""aba"", null, null, *) = ""aba""
*  StringUtils.replaceEach(""aba"", new String[0], null, *) = ""aba""
*  StringUtils.replaceEach(""aba"", null, new String[0], *) = ""aba""
*  StringUtils.replaceEach(""aba"", new String[]{""a""}, null, *) = ""aba""
*  StringUtils.replaceEach(""aba"", new String[]{""a""}, new String[]{""""}, *) = ""b""
*  StringUtils.replaceEach(""aba"", new String[]{null}, new String[]{""a""}, *) = ""aba""
*  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""w"", ""t""}, *) = ""wcte""
*  (example of how it repeats)
*  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, false) = ""dcte""
*  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""t""}, true) = ""tcte""
*  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, true) = IllegalArgumentException
*  StringUtils.replaceEach(""abcde"", new String[]{""ab"", ""d""}, new String[]{""d"", ""ab""}, false) = ""dcabe""
* </pre>
*
* @param text
*            text to search and replace in, no-op if null
* @param searchList
*            the Strings to search for, no-op if null
* @param replacementList
*            the Strings to replace them with, no-op if null
* @return the text with any replacements processed, <code>null</code> if
*         null String input
* @throws IllegalArgumentException
*             if the search is repeating and there is an endless loop due
*             to outputs of one being inputs to another
* @throws IndexOutOfBoundsException
*             if the lengths of the arrays are not the same (null is ok,
*             and/or size 0)
* @since 2.4
*/
public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {"
Lang_40b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_40_buggy/src/java/org/apache/commons/lang/StringUtils.java,"public static boolean containsIgnoreCase(String str, String searchStr) {
if (str == null || searchStr == null) {
return false;
}
return contains(str.toUpperCase(), searchStr.toUpperCase());
}"
Lang_40b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_40_buggy/src/java/org/apache/commons/lang/StringUtils.java,"public static boolean contains(String str, String searchStr) {
if (str == null || searchStr == null) {
return false;
}
return str.indexOf(searchStr) >= 0;
}"
Lang_42b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_42_buggy/src/java/org/apache/commons/lang/Entities.java,"public void escape(Writer writer, String str) throws IOException {
int len = str.length();
for (int i = 0; i < len; i++) {
char c = str.charAt(i);
String entityName = this.entityName(c);
if (entityName == null) {
if (c > 0x7F) {
writer.write(""&#"");
writer.write(Integer.toString(c, 10));
writer.write(';');
} else {
writer.write(c);
}
} else {
writer.write('&');
writer.write(entityName);
writer.write(';');
}
}
}"
Lang_42b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_42_buggy/src/java/org/apache/commons/lang/Entities.java,"private void doUnescape(Writer writer, String str, int firstAmp) throws IOException {
writer.write(str, 0, firstAmp);
int len = str.length();
for (int i = firstAmp; i < len; i++) {
char c = str.charAt(i);
if (c == '&') {
int nextIdx = i + 1;
int semiColonIdx = str.indexOf(';', nextIdx);
if (semiColonIdx == -1) {
writer.write(c);
continue;
}
int amphersandIdx = str.indexOf('&', i + 1);
if (amphersandIdx != -1 && amphersandIdx < semiColonIdx) {
// Then the text looks like &...&...;
writer.write(c);
continue;
}
String entityContent = str.substring(nextIdx, semiColonIdx);
int entityValue = -1;
int entityContentLen = entityContent.length();
if (entityContentLen > 0) {
if (entityContent.charAt(0) == '#') { // escaped value content is an integer (decimal or
// hexidecimal)
if (entityContentLen > 1) {
char isHexChar = entityContent.charAt(1);
try {
switch (isHexChar) {
case 'X' :
case 'x' : {
entityValue = Integer.parseInt(entityContent.substring(2), 16);
break;
}
default : {
entityValue = Integer.parseInt(entityContent.substring(1), 10);
}
}
if (entityValue > 0xFFFF) {
entityValue = -1;
}
} catch (NumberFormatException e) {
entityValue = -1;
}
}
} else { // escaped value content is an entity name
entityValue = this.entityValue(entityContent);
}
}

if (entityValue == -1) {
writer.write('&');
writer.write(entityContent);
writer.write(';');
} else {
writer.write(entityValue);
}
i = semiColonIdx; // move index up to the semi-colon
} else {
writer.write(c);
}
}
}"
Lang_42b_3,/home/common/huangzhili/defects4j_buggy_3/Lang_42_buggy/src/java/org/apache/commons/lang/Entities.java,"public String entityName(int value) {
return map.name(value);
}"
Lang_42b_4,/home/common/huangzhili/defects4j_buggy_3/Lang_42_buggy/src/java/org/apache/commons/lang/Entities.java,"public void unescape(Writer writer, String str) throws IOException {
int firstAmp = str.indexOf('&');
if (firstAmp < 0) {
writer.write(str);
return;
} else {
doUnescape(writer, str, firstAmp);
}
}"
Lang_42b_5,/home/common/huangzhili/defects4j_buggy_3/Lang_42_buggy/src/java/org/apache/commons/lang/Entities.java,"static void fillWithHtml40Entities(Entities entities) {
entities.addEntities(BASIC_ARRAY);
entities.addEntities(ISO8859_1_ARRAY);
entities.addEntities(HTML40_ARRAY);
}"
Lang_43b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_43_buggy/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java,"public final void applyPattern(String pattern) {
if (registry == null) {
super.applyPattern(pattern);
toPattern = super.toPattern();
return;
}
ArrayList foundFormats = new ArrayList();
ArrayList foundDescriptions = new ArrayList();
StringBuffer stripCustom = new StringBuffer(pattern.length());

ParsePosition pos = new ParsePosition(0);
char[] c = pattern.toCharArray();
int fmtCount = 0;
while (pos.getIndex() < pattern.length()) {
switch (c[pos.getIndex()]) {
case QUOTE:
appendQuotedString(pattern, pos, stripCustom, true);
break;
case START_FE:
fmtCount++;
seekNonWs(pattern, pos);
int start = pos.getIndex();
int index = readArgumentIndex(pattern, next(pos));
stripCustom.append(START_FE).append(index);
seekNonWs(pattern, pos);
Format format = null;
String formatDescription = null;
if (c[pos.getIndex()] == START_FMT) {
formatDescription = parseFormatDescription(pattern,
next(pos));
format = getFormat(formatDescription);
if (format == null) {
stripCustom.append(START_FMT).append(formatDescription);
}
}
foundFormats.add(format);
foundDescriptions.add(format == null ? null : formatDescription);
Validate.isTrue(foundFormats.size() == fmtCount);
Validate.isTrue(foundDescriptions.size() == fmtCount);
if (c[pos.getIndex()] != END_FE) {
throw new IllegalArgumentException(
""Unreadable format element at position "" + start);
}
// fall through
default:
stripCustom.append(c[pos.getIndex()]);
next(pos);
}
}
super.applyPattern(stripCustom.toString());
toPattern = insertFormats(super.toPattern(), foundDescriptions);
if (containsElements(foundFormats)) {
Format[] origFormats = getFormats();
// only loop over what we know we have, as MessageFormat on Java 1.3
// seems to provide an extra format element:
int i = 0;
for (Iterator it = foundFormats.iterator(); it.hasNext(); i++) {
Format f = (Format) it.next();
if (f != null) {
origFormats[i] = f;
}
}
super.setFormats(origFormats);
}
}"
Lang_43b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_43_buggy/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java,"private StringBuffer appendQuotedString(String pattern, ParsePosition pos,
StringBuffer appendTo, boolean escapingOn) {
int start = pos.getIndex();
char[] c = pattern.toCharArray();
if (escapingOn && c[start] == QUOTE) {
return appendTo == null ? null : appendTo.append(QUOTE);
}
int lastHold = start;
for (int i = pos.getIndex(); i < pattern.length(); i++) {
if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {
appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(
QUOTE);
pos.setIndex(i + ESCAPED_QUOTE.length());
lastHold = pos.getIndex();
continue;
}
switch (c[pos.getIndex()]) {
case QUOTE:
next(pos);
return appendTo == null ? null : appendTo.append(c, lastHold,
pos.getIndex() - lastHold);
default:
next(pos);
}
}
throw new IllegalArgumentException(
""Unterminated quoted string at position "" + start);
}"
Lang_43b_3,/home/common/huangzhili/defects4j_buggy_3/Lang_43_buggy/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java,"public ExtendedMessageFormat(String pattern, Map registry) {
this(pattern, Locale.getDefault(), registry);
}"
Lang_43b_4,/home/common/huangzhili/defects4j_buggy_3/Lang_43_buggy/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java,"private ParsePosition next(ParsePosition pos) {
pos.setIndex(pos.getIndex() + 1);
return pos;
}"
Lang_44b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_44_buggy/src/java/org/apache/commons/lang/NumberUtils.java,"public static Number createNumber(String val) throws NumberFormatException {
if (val == null) {
return null;
}
if (val.length() == 0) {
throw new NumberFormatException(""\""\"" is not a valid number."");
}
if (val.startsWith(""--"")) {
// this is protection for poorness in java.lang.BigDecimal.
// it accepts this as a legal value, but it does not appear
// to be in specification of class. OS X Java parses it to
// a wrong value.
return null;
}
if (val.startsWith(""0x"") || val.startsWith(""-0x"")) {
return createInteger(val);
}
char lastChar = val.charAt(val.length() - 1);
String mant;
String dec;
String exp;
int decPos = val.indexOf('.');
int expPos = val.indexOf('e') + val.indexOf('E') + 1;

if (decPos > -1) {

if (expPos > -1) {
if (expPos < decPos) {
throw new NumberFormatException(val + "" is not a valid number."");
}
dec = val.substring(decPos + 1, expPos);
} else {
dec = val.substring(decPos + 1);
}
mant = val.substring(0, decPos);
} else {
if (expPos > -1) {
mant = val.substring(0, expPos);
} else {
mant = val;
}
dec = null;
}
if (!Character.isDigit(lastChar)) {
if (expPos > -1 && expPos < val.length() - 1) {
exp = val.substring(expPos + 1, val.length() - 1);
} else {
exp = null;
}
//Requesting a specific type..
String numeric = val.substring(0, val.length() - 1);
boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
switch (lastChar) {
case 'l' :
case 'L' :
if (dec == null
&& exp == null
&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
try {
return createLong(numeric);
} catch (NumberFormatException nfe) {
//Too big for a long
}
return createBigInteger(numeric);

}
throw new NumberFormatException(val + "" is not a valid number."");
case 'f' :
case 'F' :
try {
Float f = NumberUtils.createFloat(numeric);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
//If it's too big for a float or the float value = 0 and the string
//has non-zeros in it, then float does not have the precision we want
return f;
}

} catch (NumberFormatException e) {
// ignore the bad number
}
//Fall through
case 'd' :
case 'D' :
try {
Double d = NumberUtils.createDouble(numeric);
if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
return d;
}
} catch (NumberFormatException nfe) {
// empty catch
}
try {
return createBigDecimal(numeric);
} catch (NumberFormatException e) {
// empty catch
}
//Fall through
default :
throw new NumberFormatException(val + "" is not a valid number."");

}
} else {
//User doesn't have a preference on the return type, so let's start
//small and go from there...
if (expPos > -1 && expPos < val.length() - 1) {
exp = val.substring(expPos + 1, val.length());
} else {
exp = null;
}
if (dec == null && exp == null) {
//Must be an int,long,bigint
try {
return createInteger(val);
} catch (NumberFormatException nfe) {
// empty catch
}
try {
return createLong(val);
} catch (NumberFormatException nfe) {
// empty catch
}
return createBigInteger(val);

} else {
//Must be a float,double,BigDec
boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
try {
Float f = createFloat(val);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
return f;
}
} catch (NumberFormatException nfe) {
// empty catch
}
try {
Double d = createDouble(val);
if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
return d;
}
} catch (NumberFormatException nfe) {
// empty catch
}

return createBigDecimal(val);

}

}
}"
Lang_44b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_44_buggy/src/java/org/apache/commons/lang/NumberUtils.java,"private static boolean isAllZeros(String s) {
if (s == null) {
return true;
}
for (int i = s.length() - 1; i >= 0; i--) {
if (s.charAt(i) != '0') {
return false;
}
}
return s.length() > 0;
}"
Lang_45b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_45_buggy/src/java/org/apache/commons/lang/WordUtils.java,"public static String abbreviate(String str, int lower, int upper, String appendToEnd) {
// initial parameter checks
if (str == null) {
return null;
}
if (str.length() == 0) {
return StringUtils.EMPTY;
}

// if the lower value is greater than the length of the string,
// set to the length of the string
// if the upper value is -1 (i.e. no limit) or is greater
// than the length of the string, set to the length of the string
if (upper == -1 || upper > str.length()) {
upper = str.length();
}
// if upper is less than lower, raise it to lower
if (upper < lower) {
upper = lower;
}

StringBuffer result = new StringBuffer();
int index = StringUtils.indexOf(str, "" "", lower);
if (index == -1) {
result.append(str.substring(0, upper));
// only if abbreviation has occured do we append the appendToEnd value
if (upper != str.length()) {
result.append(StringUtils.defaultString(appendToEnd));
}
} else if (index > upper) {
result.append(str.substring(0, upper));
result.append(StringUtils.defaultString(appendToEnd));
} else {
result.append(str.substring(0, index));
result.append(StringUtils.defaultString(appendToEnd));
}
return result.toString();
}"
Lang_49b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_49_buggy/src/java/org/apache/commons/lang/math/Fraction.java,"public Fraction reduce() {
int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
if (gcd == 1) {
return this;
}
return Fraction.getFraction(numerator / gcd, denominator / gcd);
}"
Lang_49b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_49_buggy/src/java/org/apache/commons/lang/math/Fraction.java,"public static Fraction getFraction(int numerator, int denominator) {
if (denominator == 0) {
throw new ArithmeticException(""The denominator must not be zero"");
}
if (denominator < 0) {
if (numerator==Integer.MIN_VALUE ||
denominator==Integer.MIN_VALUE) {
throw new ArithmeticException(""overflow: can't negate"");
}
numerator = -numerator;
denominator = -denominator;
}
return new Fraction(numerator, denominator);
}"
Lang_49b_3,/home/common/huangzhili/defects4j_buggy_3/Lang_49_buggy/src/java/org/apache/commons/lang/math/Fraction.java,"private static int greatestCommonDivisor(int u, int v) {
//if either op. is abs 0 or 1, return 1:
if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {
return 1;
}
// keep u and v negative, as negative integers range down to
// -2^31, while positive numbers can only be as large as 2^31-1
// (i.e. we can't necessarily negate a negative number without
// overflow)
if (u>0) { u=-u; } // make u negative
if (v>0) { v=-v; } // make v negative
// B1. [Find power of 2]
int k=0;
while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...
u/=2; v/=2; k++; // cast out twos.
}
if (k==31) {
throw new ArithmeticException(""overflow: gcd is 2^31"");
}
// B2. Initialize: u and v have been divided by 2^k and at least
//     one is odd.
int t = ((u&1)==1) ? v : -(u/2)/*B3*/;
// t negative: u was odd, v may be even (t replaces v)
// t positive: u was even, v is odd (t replaces u)
do {
/* assert u<0 && v<0; */
// B4/B3: cast out twos from t.
while ((t&1)==0) { // while t is even..
t/=2; // cast out twos
}
// B5 [reset max(u,v)]
if (t>0) {
u = -t;
} else {
v = t;
}
// B6/B3. at this point both u and v should be odd.
t = (v - u)/2;
// |u| larger: t positive (replace u)
// |v| larger: t negative (replace v)
} while (t!=0);
return -u*(1<<k); // gcd is u*2^k
}"
Lang_49b_4,/home/common/huangzhili/defects4j_buggy_3/Lang_49_buggy/src/java/org/apache/commons/lang/math/Fraction.java,"public int getNumerator() {
return numerator;
}"
Lang_49b_5,/home/common/huangzhili/defects4j_buggy_3/Lang_49_buggy/src/java/org/apache/commons/lang/math/Fraction.java,"public int getDenominator() {
return denominator;
}"
Lang_51b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_51_buggy/src/java/org/apache/commons/lang/BooleanUtils.java,"public static boolean toBoolean(String str) {
// Previously used equalsIgnoreCase, which was fast for interned 'true'.
// Non interned 'true' matched 15 times slower.
//
// Optimisation provides same performance as before for interned 'true'.
// Similar performance for null, 'false', and other strings not length 2/3/4.
// 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.
if (str == ""true"") {
return true;
}
if (str == null) {
return false;
}
switch (str.length()) {
case 2: {
char ch0 = str.charAt(0);
char ch1 = str.charAt(1);
return
(ch0 == 'o' || ch0 == 'O') &&
(ch1 == 'n' || ch1 == 'N');
}
case 3: {
char ch = str.charAt(0);
if (ch == 'y') {
return
(str.charAt(1) == 'e' || str.charAt(1) == 'E') &&
(str.charAt(2) == 's' || str.charAt(2) == 'S');
}
if (ch == 'Y') {
return
(str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
(str.charAt(2) == 'S' || str.charAt(2) == 's');
}
}
case 4: {
char ch = str.charAt(0);
if (ch == 't') {
return
(str.charAt(1) == 'r' || str.charAt(1) == 'R') &&
(str.charAt(2) == 'u' || str.charAt(2) == 'U') &&
(str.charAt(3) == 'e' || str.charAt(3) == 'E');
}
if (ch == 'T') {
return
(str.charAt(1) == 'R' || str.charAt(1) == 'r') &&
(str.charAt(2) == 'U' || str.charAt(2) == 'u') &&
(str.charAt(3) == 'E' || str.charAt(3) == 'e');
}
}
}
return false;
}"
Lang_52b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_52_buggy/src/java/org/apache/commons/lang/StringEscapeUtils.java,"public static String escapeJavaScript(String str) {
return escapeJavaStyleString(str, true);
}"
Lang_52b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_52_buggy/src/java/org/apache/commons/lang/StringEscapeUtils.java,"private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {
if (str == null) {
return null;
}
try {
StringWriter writer = new StringWriter(str.length() * 2);
escapeJavaStyleString(writer, str, escapeSingleQuotes);
return writer.toString();
} catch (IOException ioe) {
// this should never ever happen while writing to a StringWriter
ioe.printStackTrace();
return null;
}
}"
Lang_53b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_53_buggy/src/java/org/apache/commons/lang/time/DateUtils.java,"public static Date round(Date date, int field) {
if (date == null) {
throw new IllegalArgumentException(""The date must not be null"");
}
Calendar gval = Calendar.getInstance();
gval.setTime(date);
modify(gval, field, true);
return gval.getTime();
}"
Lang_53b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_53_buggy/src/java/org/apache/commons/lang/time/DateUtils.java,"private static void modify(Calendar val, int field, boolean round) {
if (val.get(Calendar.YEAR) > 280000000) {
throw new ArithmeticException(""Calendar value too large for accurate calculations"");
}

if (field == Calendar.MILLISECOND) {
return;
}

// ----------------- Fix for LANG-59 ---------------------- START ---------------
// see http://issues.apache.org/jira/browse/LANG-59
//
// Manually truncate milliseconds, seconds and minutes, rather than using
// Calendar methods.

Date date = val.getTime();
long time = date.getTime();
boolean done = false;

// truncate milliseconds
int millisecs = val.get(Calendar.MILLISECOND);
if (!round || millisecs < 500) {
time = time - millisecs;
if (field == Calendar.SECOND) {
done = true;
}
}

// truncate seconds
int seconds = val.get(Calendar.SECOND);
if (!done && (!round || seconds < 30)) {
time = time - (seconds * 1000L);
if (field == Calendar.MINUTE) {
done = true;
}
}

// truncate minutes
int minutes = val.get(Calendar.MINUTE);
if (!done && (!round || minutes < 30)) {
time = time - (minutes * 60000L);
}

// reset time
if (date.getTime() != time) {
date.setTime(time);
val.setTime(date);
}
// ----------------- Fix for LANG-59 ----------------------- END ----------------

boolean roundUp = false;
for (int i = 0; i < fields.length; i++) {
for (int j = 0; j < fields[i].length; j++) {
if (fields[i][j] == field) {
//This is our field... we stop looping
if (round && roundUp) {
if (field == DateUtils.SEMI_MONTH) {
//This is a special case that's hard to generalize
//If the date is 1, we round up to 16, otherwise
//  we subtract 15 days and add 1 month
if (val.get(Calendar.DATE) == 1) {
val.add(Calendar.DATE, 15);
} else {
val.add(Calendar.DATE, -15);
val.add(Calendar.MONTH, 1);
}
} else {
//We need at add one to this field since the
//  last number causes us to round up
val.add(fields[i][0], 1);
}
}
return;
}
}
//We have various fields that are not easy roundings
int offset = 0;
boolean offsetSet = false;
//These are special types of fields that require different rounding rules
switch (field) {
case DateUtils.SEMI_MONTH:
if (fields[i][0] == Calendar.DATE) {
//If we're going to drop the DATE field's value,
//  we want to do this our own way.
//We need to subtrace 1 since the date has a minimum of 1
offset = val.get(Calendar.DATE) - 1;
//If we're above 15 days adjustment, that means we're in the
//  bottom half of the month and should stay accordingly.
if (offset >= 15) {
offset -= 15;
}
//Record whether we're in the top or bottom half of that range
roundUp = offset > 7;
offsetSet = true;
}
break;
case Calendar.AM_PM:
if (fields[i][0] == Calendar.HOUR_OF_DAY) {
//If we're going to drop the HOUR field's value,
//  we want to do this our own way.
offset = val.get(Calendar.HOUR_OF_DAY);
if (offset >= 12) {
offset -= 12;
}
roundUp = offset > 6;
offsetSet = true;
}
break;
}
if (!offsetSet) {
int min = val.getActualMinimum(fields[i][0]);
int max = val.getActualMaximum(fields[i][0]);
//Calculate the offset from the minimum allowed value
offset = val.get(fields[i][0]) - min;
//Set roundUp if this is more than half way between the minimum and maximum
roundUp = offset > ((max - min) / 2);
}
//We need to remove this field
if (offset != 0) {
val.set(fields[i][0], val.get(fields[i][0]) - offset);
}
}
throw new IllegalArgumentException(""The field "" + field + "" is not supported"");

}"
Lang_54b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_54_buggy/src/java/org/apache/commons/lang/LocaleUtils.java,"public static Locale toLocale(String str) {
if (str == null) {
return null;
}
int len = str.length();
if (len != 2 && len != 5 && len < 7) {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
char ch0 = str.charAt(0);
char ch1 = str.charAt(1);
if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
if (len == 2) {
return new Locale(str, """");
} else {
if (str.charAt(2) != '_') {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
char ch3 = str.charAt(3);
char ch4 = str.charAt(4);
if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
if (len == 5) {
return new Locale(str.substring(0, 2), str.substring(3, 5));
} else {
if (str.charAt(5) != '_') {
throw new IllegalArgumentException(""Invalid locale format: "" + str);
}
return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
}
}
}"
Lang_54b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_54_buggy/src/java/org/apache/commons/lang/LocaleUtils.java,"public static List availableLocaleList() {
return cAvailableLocaleList;
}"
Lang_54b_3,/home/common/huangzhili/defects4j_buggy_3/Lang_54_buggy/src/java/org/apache/commons/lang/LocaleUtils.java,"public static boolean isAvailableLocale(Locale locale) {
return availableLocaleList().contains(locale);
}"
Lang_55b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_55_buggy/src/java/org/apache/commons/lang/time/StopWatch.java,"public void suspend() {
if(this.runningState != STATE_RUNNING) {
throw new IllegalStateException(""Stopwatch must be running to suspend. "");
}
stopTime = System.currentTimeMillis();
this.runningState = STATE_SUSPENDED;
}"
Lang_55b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_55_buggy/src/java/org/apache/commons/lang/time/StopWatch.java,"public long getTime() {
if(this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) {
return this.stopTime - this.startTime;
} else
if(this.runningState == STATE_UNSTARTED) {
return 0;
} else
if(this.runningState == STATE_RUNNING) {
return System.currentTimeMillis() - this.startTime;
}
throw new RuntimeException(""Illegal running state has occured. "");
}"
Lang_55b_3,/home/common/huangzhili/defects4j_buggy_3/Lang_55_buggy/src/java/org/apache/commons/lang/time/StopWatch.java,"public void stop() {
if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
throw new IllegalStateException(""Stopwatch is not running. "");
}
stopTime = System.currentTimeMillis();
this.runningState = STATE_STOPPED;
}"
Lang_55b_4,/home/common/huangzhili/defects4j_buggy_3/Lang_55_buggy/src/java/org/apache/commons/lang/time/StopWatch.java,"public void start() {
if(this.runningState == STATE_STOPPED) {
throw new IllegalStateException(""Stopwatch must be reset before being restarted. "");
}
if(this.runningState != STATE_UNSTARTED) {
throw new IllegalStateException(""Stopwatch already started. "");
}
stopTime = -1;
startTime = System.currentTimeMillis();
this.runningState = STATE_RUNNING;
}"
Lang_57b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_57_buggy/src/java/org/apache/commons/lang/LocaleUtils.java,"public static boolean isAvailableLocale(Locale locale) {
return cAvailableLocaleSet.contains(locale);
}"
Lang_58b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_58_buggy/src/java/org/apache/commons/lang/math/NumberUtils.java,"public static Number createNumber(String str) throws NumberFormatException {
if (str == null) {
return null;
}
if (StringUtils.isBlank(str)) {
throw new NumberFormatException(""A blank string is not a valid number"");
}
if (str.startsWith(""--"")) {
// this is protection for poorness in java.lang.BigDecimal.
// it accepts this as a legal value, but it does not appear
// to be in specification of class. OS X Java parses it to
// a wrong value.
return null;
}
if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
return createInteger(str);
}
char lastChar = str.charAt(str.length() - 1);
String mant;
String dec;
String exp;
int decPos = str.indexOf('.');
int expPos = str.indexOf('e') + str.indexOf('E') + 1;

if (decPos > -1) {

if (expPos > -1) {
if (expPos < decPos) {
throw new NumberFormatException(str + "" is not a valid number."");
}
dec = str.substring(decPos + 1, expPos);
} else {
dec = str.substring(decPos + 1);
}
mant = str.substring(0, decPos);
} else {
if (expPos > -1) {
mant = str.substring(0, expPos);
} else {
mant = str;
}
dec = null;
}
if (!Character.isDigit(lastChar)) {
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length() - 1);
} else {
exp = null;
}
//Requesting a specific type..
String numeric = str.substring(0, str.length() - 1);
boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
switch (lastChar) {
case 'l' :
case 'L' :
if (dec == null
&& exp == null
&& isDigits(numeric.substring(1))
&& (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
try {
return createLong(numeric);
} catch (NumberFormatException nfe) {
//Too big for a long
}
return createBigInteger(numeric);

}
throw new NumberFormatException(str + "" is not a valid number."");
case 'f' :
case 'F' :
try {
Float f = NumberUtils.createFloat(numeric);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
//If it's too big for a float or the float value = 0 and the string
//has non-zeros in it, then float does not have the precision we want
return f;
}

} catch (NumberFormatException nfe) {
// ignore the bad number
}
//Fall through
case 'd' :
case 'D' :
try {
Double d = NumberUtils.createDouble(numeric);
if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {
return d;
}
} catch (NumberFormatException nfe) {
// ignore the bad number
}
try {
return createBigDecimal(numeric);
} catch (NumberFormatException e) {
// ignore the bad number
}
//Fall through
default :
throw new NumberFormatException(str + "" is not a valid number."");

}
} else {
//User doesn't have a preference on the return type, so let's start
//small and go from there...
if (expPos > -1 && expPos < str.length() - 1) {
exp = str.substring(expPos + 1, str.length());
} else {
exp = null;
}
if (dec == null && exp == null) {
//Must be an int,long,bigint
try {
return createInteger(str);
} catch (NumberFormatException nfe) {
// ignore the bad number
}
try {
return createLong(str);
} catch (NumberFormatException nfe) {
// ignore the bad number
}
return createBigInteger(str);

} else {
//Must be a float,double,BigDec
boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
try {
Float f = createFloat(str);
if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
return f;
}
} catch (NumberFormatException nfe) {
// ignore the bad number
}
try {
Double d = createDouble(str);
if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
return d;
}
} catch (NumberFormatException nfe) {
// ignore the bad number
}

return createBigDecimal(str);

}
}
}"
Lang_58b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_58_buggy/src/java/org/apache/commons/lang/math/NumberUtils.java,"public static boolean isDigits(String str) {
if (StringUtils.isEmpty(str)) {
return false;
}
for (int i = 0; i < str.length(); i++) {
if (!Character.isDigit(str.charAt(i))) {
return false;
}
}
return true;
}"
Lang_58b_3,/home/common/huangzhili/defects4j_buggy_3/Lang_58_buggy/src/java/org/apache/commons/lang/math/NumberUtils.java,"private static boolean isAllZeros(String str) {
if (str == null) {
return true;
}
for (int i = str.length() - 1; i >= 0; i--) {
if (str.charAt(i) != '0') {
return false;
}
}
return str.length() > 0;
}"
Lang_58b_4,/home/common/huangzhili/defects4j_buggy_3/Lang_58_buggy/src/java/org/apache/commons/lang/math/NumberUtils.java,"public static Long createLong(String str) {
if (str == null) {
return null;
}
return Long.valueOf(str);
}"
Lang_59b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_59_buggy/src/java/org/apache/commons/lang/text/StrBuilder.java,"public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {
if (width > 0) {
ensureCapacity(size + width);
String str = (obj == null ? getNullText() : obj.toString());
int strLen = str.length();
if (strLen >= width) {
str.getChars(0, strLen, buffer, size);
} else {
int padLen = width - strLen;
str.getChars(0, strLen, buffer, size);
for (int i = 0; i < padLen; i++) {
buffer[size + strLen + i] = padChar;
}
}
size += width;
}
return this;
}"
Lang_59b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_59_buggy/src/java/org/apache/commons/lang/text/StrBuilder.java,"public StrBuilder(int initialCapacity) {
super();
if (initialCapacity <= 0) {
initialCapacity = CAPACITY;
}
buffer = new char[initialCapacity];
}"
Lang_59b_3,/home/common/huangzhili/defects4j_buggy_3/Lang_59_buggy/src/java/org/apache/commons/lang/text/StrBuilder.java,"public StrBuilder ensureCapacity(int capacity) {
if (capacity > buffer.length) {
char[] old = buffer;
buffer = new char[capacity];
System.arraycopy(old, 0, buffer, 0, size);
}
return this;
}"
Lang_61b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_61_buggy/src/java/org/apache/commons/lang/text/StrBuilder.java,"public StrBuilder deleteAll(String str) {
int len = (str == null ? 0 : str.length());
if (len > 0) {
int index = indexOf(str, 0);
while (index >= 0) {
deleteImpl(index, index + len, len);
index = indexOf(str, index);
}
}
return this;
}"
Lang_61b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_61_buggy/src/java/org/apache/commons/lang/text/StrBuilder.java,"public StrBuilder deleteFirst(String str) {
int len = (str == null ? 0 : str.length());
if (len > 0) {
int index = indexOf(str, 0);
if (index >= 0) {
deleteImpl(index, index + len, len);
}
}
return this;
}"
Lang_61b_3,/home/common/huangzhili/defects4j_buggy_3/Lang_61_buggy/src/java/org/apache/commons/lang/text/StrBuilder.java,"return indexOf(str, 0);
}

/**
* Searches the string builder to find the first reference to the specified
* string starting searching from the given index.
* <p>
* Note that a null input string will return -1, whereas the JDK throws an exception.
*
* @param str  the string to find, null returns -1
* @param startIndex  the index to start at, invalid index rounded to edge
* @return the first index of the string, or -1 if not found
*/
public int indexOf(String str, int startIndex) {"
Lang_61b_4,/home/common/huangzhili/defects4j_buggy_3/Lang_61_buggy/src/java/org/apache/commons/lang/text/StrBuilder.java,"private void deleteImpl(int startIndex, int endIndex, int len) {
System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);
size -= len;
}"
Lang_61b_5,/home/common/huangzhili/defects4j_buggy_3/Lang_61_buggy/src/java/org/apache/commons/lang/text/StrBuilder.java,"public StrBuilder(String str) {
super();
if (str == null) {
buffer = new char[CAPACITY];
} else {
buffer = new char[str.length() + CAPACITY];
append(str);
}
}"
Lang_65b_1,/home/common/huangzhili/defects4j_buggy_3/Lang_65_buggy/src/java/org/apache/commons/lang/time/DateUtils.java,"public static Date truncate(Date date, int field) {
if (date == null) {
throw new IllegalArgumentException(""The date must not be null"");
}
Calendar gval = Calendar.getInstance();
gval.setTime(date);
modify(gval, field, false);
return gval.getTime();
}"
Lang_65b_2,/home/common/huangzhili/defects4j_buggy_3/Lang_65_buggy/src/java/org/apache/commons/lang/time/DateUtils.java,"private static void modify(Calendar val, int field, boolean round) {
if (val.get(Calendar.YEAR) > 280000000) {
throw new ArithmeticException(""Calendar value too large for accurate calculations"");
}


// ----------------- Fix for LANG-59 ---------------------- START ---------------
// see http://issues.apache.org/jira/browse/LANG-59
//
// Manually truncate milliseconds, seconds and minutes, rather than using
// Calendar methods.


// truncate milliseconds

// truncate seconds

// truncate minutes

// reset time
// ----------------- Fix for LANG-59 ----------------------- END ----------------

boolean roundUp = false;
for (int i = 0; i < fields.length; i++) {
for (int j = 0; j < fields[i].length; j++) {
if (fields[i][j] == field) {
//This is our field... we stop looping
if (round && roundUp) {
if (field == DateUtils.SEMI_MONTH) {
//This is a special case that's hard to generalize
//If the date is 1, we round up to 16, otherwise
//  we subtract 15 days and add 1 month
if (val.get(Calendar.DATE) == 1) {
val.add(Calendar.DATE, 15);
} else {
val.add(Calendar.DATE, -15);
val.add(Calendar.MONTH, 1);
}
} else {
//We need at add one to this field since the
//  last number causes us to round up
val.add(fields[i][0], 1);
}
}
return;
}
}
//We have various fields that are not easy roundings
int offset = 0;
boolean offsetSet = false;
//These are special types of fields that require different rounding rules
switch (field) {
case DateUtils.SEMI_MONTH:
if (fields[i][0] == Calendar.DATE) {
//If we're going to drop the DATE field's value,
//  we want to do this our own way.
//We need to subtrace 1 since the date has a minimum of 1
offset = val.get(Calendar.DATE) - 1;
//If we're above 15 days adjustment, that means we're in the
//  bottom half of the month and should stay accordingly.
if (offset >= 15) {
offset -= 15;
}
//Record whether we're in the top or bottom half of that range
roundUp = offset > 7;
offsetSet = true;
}
break;
case Calendar.AM_PM:
if (fields[i][0] == Calendar.HOUR_OF_DAY) {
//If we're going to drop the HOUR field's value,
//  we want to do this our own way.
offset = val.get(Calendar.HOUR_OF_DAY);
if (offset >= 12) {
offset -= 12;
}
roundUp = offset > 6;
offsetSet = true;
}
break;
}
if (!offsetSet) {
int min = val.getActualMinimum(fields[i][0]);
int max = val.getActualMaximum(fields[i][0]);
//Calculate the offset from the minimum allowed value
offset = val.get(fields[i][0]) - min;
//Set roundUp if this is more than half way between the minimum and maximum
roundUp = offset > ((max - min) / 2);
}
//We need to remove this field
val.set(fields[i][0], val.get(fields[i][0]) - offset);
}
throw new IllegalArgumentException(""The field "" + field + "" is not supported"");

}"
Math_2b_1,/home/common/huangzhili/defects4j_buggy_3/Math_2_buggy/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java,"public double getNumericalMean() {
return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();
}"
Math_2b_2,/home/common/huangzhili/defects4j_buggy_3/Math_2_buggy/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java,"public double getNumericalVariance() {
if (!numericalVarianceIsCalculated) {
numericalVariance = calculateNumericalVariance();
numericalVarianceIsCalculated = true;
}
return numericalVariance;
}"
Math_2b_3,/home/common/huangzhili/defects4j_buggy_3/Math_2_buggy/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java,"protected double calculateNumericalVariance() {
final double N = getPopulationSize();
final double m = getNumberOfSuccesses();
final double n = getSampleSize();
return (n * m * (N - n) * (N - m)) / (N * N * (N - 1));
}"
Math_2b_4,/home/common/huangzhili/defects4j_buggy_3/Math_2_buggy/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java,"public int getSupportLowerBound() {
return FastMath.max(0,
getSampleSize() + getNumberOfSuccesses() - getPopulationSize());
}"
Math_2b_5,/home/common/huangzhili/defects4j_buggy_3/Math_2_buggy/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java,"public int getSupportUpperBound() {
return FastMath.min(getNumberOfSuccesses(), getSampleSize());
}"
Math_3b_1,/home/common/huangzhili/defects4j_buggy_3/Math_3_buggy/src/main/java/org/apache/commons/math3/util/MathArrays.java,"public static double linearCombination(final double[] a, final double[] b)
throws DimensionMismatchException {
final int len = a.length;
if (len != b.length) {
throw new DimensionMismatchException(len, b.length);
}

// Revert to scalar multiplication.

final double[] prodHigh = new double[len];
double prodLowSum = 0;

for (int i = 0; i < len; i++) {
final double ai = a[i];
final double ca = SPLIT_FACTOR * ai;
final double aHigh = ca - (ca - ai);
final double aLow = ai - aHigh;

final double bi = b[i];
final double cb = SPLIT_FACTOR * bi;
final double bHigh = cb - (cb - bi);
final double bLow = bi - bHigh;
prodHigh[i] = ai * bi;
final double prodLow = aLow * bLow - (((prodHigh[i] -
aHigh * bHigh) -
aLow * bHigh) -
aHigh * bLow);
prodLowSum += prodLow;
}


final double prodHighCur = prodHigh[0];
double prodHighNext = prodHigh[1];
double sHighPrev = prodHighCur + prodHighNext;
double sPrime = sHighPrev - prodHighNext;
double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);

final int lenMinusOne = len - 1;
for (int i = 1; i < lenMinusOne; i++) {
prodHighNext = prodHigh[i + 1];
final double sHighCur = sHighPrev + prodHighNext;
sPrime = sHighCur - prodHighNext;
sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);
sHighPrev = sHighCur;
}

double result = sHighPrev + (prodLowSum + sLowSum);

if (Double.isNaN(result)) {
// either we have split infinite numbers or some coefficients were NaNs,
// just rely on the naive implementation and let IEEE754 handle this
result = 0;
for (int i = 0; i < len; ++i) {
result += a[i] * b[i];
}
}

return result;
}"
Math_5b_1,/home/common/huangzhili/defects4j_buggy_3/Math_5_buggy/src/main/java/org/apache/commons/math3/complex/Complex.java,"public Complex reciprocal() {
if (isNaN) {
return NaN;
}

if (real == 0.0 && imaginary == 0.0) {
return NaN;
}

if (isInfinite) {
return ZERO;
}

if (FastMath.abs(real) < FastMath.abs(imaginary)) {
double q = real / imaginary;
double scale = 1. / (real * q + imaginary);
return createComplex(scale * q, -scale);
} else {
double q = imaginary / real;
double scale = 1. / (imaginary * q + real);
return createComplex(scale, -scale * q);
}
}"
Math_5b_2,/home/common/huangzhili/defects4j_buggy_3/Math_5_buggy/src/main/java/org/apache/commons/math3/complex/Complex.java,"public String toString() {
return ""("" + real + "", "" + imaginary + "")"";
}"
Math_5b_3,/home/common/huangzhili/defects4j_buggy_3/Math_5_buggy/src/main/java/org/apache/commons/math3/complex/Complex.java,"public boolean equals(Object other) {
if (this == other) {
return true;
}
if (other instanceof Complex){
Complex c = (Complex)other;
if (c.isNaN) {
return isNaN;
} else {
return (real == c.real) && (imaginary == c.imaginary);
}
}
return false;
}"
Math_5b_4,/home/common/huangzhili/defects4j_buggy_3/Math_5_buggy/src/main/java/org/apache/commons/math3/complex/Complex.java,"public Complex(double real, double imaginary) {
this.real = real;
this.imaginary = imaginary;

isNaN = Double.isNaN(real) || Double.isNaN(imaginary);
isInfinite = !isNaN &&
(Double.isInfinite(real) || Double.isInfinite(imaginary));
}"
Math_7b_1,/home/common/huangzhili/defects4j_buggy_3/Math_7_buggy/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java,"protected double acceptStep(final AbstractStepInterpolator interpolator,
final double[] y, final double[] yDot, final double tEnd)"
Math_7b_2,/home/common/huangzhili/defects4j_buggy_3/Math_7_buggy/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java,"addEventHandler(handler, maxCheckInterval, convergence,
maxIterationCount,"
Math_7b_3,/home/common/huangzhili/defects4j_buggy_3/Math_7_buggy/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java,"protected void initIntegration(final double t0, final double[] y0, final double t) {

evaluations.resetCount();

for (final EventState state : eventsStates) {
state.getEventHandler().init(t0, y0, t);
}

for (StepHandler handler : stepHandlers) {
handler.init(t0, y0, t);
}

setStateInitialized(false);

}"
Math_7b_4,/home/common/huangzhili/defects4j_buggy_3/Math_7_buggy/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java,"public void addStepHandler(final StepHandler handler) {
stepHandlers.add(handler);
}"
Math_7b_5,/home/common/huangzhili/defects4j_buggy_3/Math_7_buggy/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java,"protected void setEquations(final ExpandableStatefulODE equations) {
this.expandable = equations;
}"
Math_8b_1,/home/common/huangzhili/defects4j_buggy_3/Math_8_buggy/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java,"public DiscreteDistribution(final List<Pair<T, Double>> samples)
throws NotPositiveException, MathArithmeticException, MathIllegalArgumentException {
this(new Well19937c(), samples);
}"
Math_8b_2,/home/common/huangzhili/defects4j_buggy_3/Math_8_buggy/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java,"public T sample() {
final double randomValue = random.nextDouble();
double sum = 0;

for (int i = 0; i < probabilities.length; i++) {
sum += probabilities[i];
if (randomValue < sum) {
return singletons.get(i);
}
}

/* This should never happen, but it ensures we will return a correct
* object in case the loop above has some floating point inequality
* problem on the final iteration. */
return singletons.get(singletons.size() - 1);
}"
Math_9b_1,/home/common/huangzhili/defects4j_buggy_3/Math_9_buggy/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java,"public Line revert() {
final Line reverted = new Line(zero, zero.subtract(direction));
return reverted;
}"
Math_9b_2,/home/common/huangzhili/defects4j_buggy_3/Math_9_buggy/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java,"public Vector3D getDirection() {
return direction;
}"
Math_9b_3,/home/common/huangzhili/defects4j_buggy_3/Math_9_buggy/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java,"public Line(final Vector3D p1, final Vector3D p2) throws MathIllegalArgumentException {
reset(p1, p2);
}"
Math_9b_4,/home/common/huangzhili/defects4j_buggy_3/Math_9_buggy/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java,"public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgumentException {
final Vector3D delta = p2.subtract(p1);
final double norm2 = delta.getNormSq();
if (norm2 == 0.0) {
throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM);
}
this.direction = new Vector3D(1.0 / FastMath.sqrt(norm2), delta);
zero = new Vector3D(1.0, p1, -p1.dotProduct(delta) / norm2, delta);
}"
Math_10b_1,/home/common/huangzhili/defects4j_buggy_3/Math_10_buggy/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java,"public void atan2(final double[] y, final int yOffset,
final double[] x, final int xOffset,"
Math_10b_2,/home/common/huangzhili/defects4j_buggy_3/Math_10_buggy/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java,"public void atan(final double[] operand, final int operandOffset,
final double[] result, final int resultOffset) {

// create the function value and derivatives
double[] function = new double[1 + order];
final double x = operand[operandOffset];
function[0] = FastMath.atan(x);
if (order > 0) {
// the nth order derivative of atan has the form:
// dn(atan(x)/dxn = Q_n(x) / (1 + x^2)^n
// where Q_n(x) is a degree n-1 polynomial with same parity as n-1
// Q_1(x) = 1, Q_2(x) = -2x, Q_3(x) = 6x^2 - 2 ...
// the general recurrence relation for Q_n is:
// Q_n(x) = (1+x^2) Q_(n-1)'(x) - 2(n-1) x Q_(n-1)(x)
// as per polynomial parity, we can store coefficients of both Q_(n-1) and Q_n in the same array
final double[] q = new double[order];
q[0] = 1;
final double x2    = x * x;
final double f     = 1.0 / (1 + x2);
double coeff = f;
function[1] = coeff * q[0];
for (int n = 2; n <= order; ++n) {

// update and evaluate polynomial Q_n(x)
double v = 0;
q[n - 1] = -n * q[n - 2];
for (int k = n - 1; k >= 0; k -= 2) {
v = v * x2 + q[k];
if (k > 2) {
q[k - 2] = (k - 1) * q[k - 1] + (k - 1 - 2 * n) * q[k - 3];
} else if (k == 2) {
q[0] = q[1];
}
}
if ((n & 0x1) == 0) {
v *= x;
}

coeff *= f;
function[n] = coeff * v;

}
}

// apply function composition
compose(operand, operandOffset, function, result, resultOffset);

}"
Math_10b_3,/home/common/huangzhili/defects4j_buggy_3/Math_10_buggy/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java,"public void divide(final double[] lhs, final int lhsOffset,
final double[] rhs, final int rhsOffset,"
Math_10b_4,/home/common/huangzhili/defects4j_buggy_3/Math_10_buggy/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java,"public void rootN(final double[] operand, final int operandOffset, final int n,
final double[] result, final int resultOffset) {

// create the function value and derivatives
// [x^(1/n), (1/n)x^((1/n)-1), (1-n)/n^2x^((1/n)-2), ... ]
double[] function = new double[1 + order];
double xk;
if (n == 2) {
function[0] = FastMath.sqrt(operand[operandOffset]);
xk          = 0.5 / function[0];
} else if (n == 3) {
function[0] = FastMath.cbrt(operand[operandOffset]);
xk          = 1.0 / (3.0 * function[0] * function[0]);
} else {
function[0] = FastMath.pow(operand[operandOffset], 1.0 / n);
xk          = 1.0 / (n * FastMath.pow(function[0], n - 1));
}
final double nReciprocal = 1.0 / n;
final double xReciprocal = 1.0 / operand[operandOffset];
for (int i = 1; i <= order; ++i) {
function[i] = xk;
xk *= xReciprocal * (nReciprocal - i);
}

// apply function composition
compose(operand, operandOffset, function, result, resultOffset);

}"
Math_10b_5,/home/common/huangzhili/defects4j_buggy_3/Math_10_buggy/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java,"public void pow(final double[] operand, final int operandOffset, final int n,
final double[] result, final int resultOffset) {

if (n == 0) {
// special case, x^0 = 1 for all x
result[resultOffset] = 1.0;
Arrays.fill(result, resultOffset + 1, resultOffset + getSize(), 0);
return;
}

// create the power function value and derivatives
// [x^n, nx^(n-1), n(n-1)x^(n-2), ... ]
double[] function = new double[1 + order];

if (n > 0) {
// strictly positive power
final int maxOrder = FastMath.min(order, n);
double xk = FastMath.pow(operand[operandOffset], n - maxOrder);
for (int i = maxOrder; i > 0; --i) {
function[i] = xk;
xk *= operand[operandOffset];
}
function[0] = xk;
} else {
// strictly negative power
final double inv = 1.0 / operand[operandOffset];
double xk = FastMath.pow(inv, -n);
for (int i = 0; i <= order; ++i) {
function[i] = xk;
xk *= inv;
}
}

double coefficient = n;
for (int i = 1; i <= order; ++i) {
function[i] *= coefficient;
coefficient *= n - i;
}

// apply function composition
compose(operand, operandOffset, function, result, resultOffset);

}"
Math_11b_1,/home/common/huangzhili/defects4j_buggy_3/Math_11_buggy/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java,"public double density(final double[] vals) throws DimensionMismatchException {
final int dim = getDimension();
if (vals.length != dim) {
throw new DimensionMismatchException(vals.length, dim);
}

return FastMath.pow(2 * FastMath.PI, -dim / 2) *
FastMath.pow(covarianceMatrixDeterminant, -0.5) *
getExponentTerm(vals);
}"
Math_11b_2,/home/common/huangzhili/defects4j_buggy_3/Math_11_buggy/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java,"private double getExponentTerm(final double[] values) {
final double[] centered = new double[values.length];
for (int i = 0; i < centered.length; i++) {
centered[i] = values[i] - getMeans()[i];
}
final double[] preMultiplied = covarianceMatrixInverse.preMultiply(centered);
double sum = 0;
for (int i = 0; i < preMultiplied.length; i++) {
sum += preMultiplied[i] * centered[i];
}
return FastMath.exp(-0.5 * sum);
}"
Math_11b_3,/home/common/huangzhili/defects4j_buggy_3/Math_11_buggy/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java,"public double[] getMeans() {
return MathArrays.copyOf(means);
}"
Math_11b_4,/home/common/huangzhili/defects4j_buggy_3/Math_11_buggy/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java,"public MultivariateNormalDistribution(final double[] means,
final double[][] covariances)"
Math_13b_1,/home/common/huangzhili/defects4j_buggy_3/Math_13_buggy/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java,"protected AbstractLeastSquaresOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {
super(checker);
}"
Math_13b_2,/home/common/huangzhili/defects4j_buggy_3/Math_13_buggy/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java,"public PointVectorValuePair optimize(int maxEval,
final DifferentiableMultivariateVectorFunction f,"
Math_13b_3,/home/common/huangzhili/defects4j_buggy_3/Math_13_buggy/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java,"return super.optimizeInternal(maxEval, FunctionUtils.toDifferentiableMultivariateVectorFunction(f), optData);
}

/** {@inheritDoc} */
@Override
protected void setUp() {"
Math_13b_4,/home/common/huangzhili/defects4j_buggy_3/Math_13_buggy/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java,super.setUp();
Math_13b_5,/home/common/huangzhili/defects4j_buggy_3/Math_13_buggy/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java,"private RealMatrix squareRoot(RealMatrix m) {
final EigenDecomposition dec = new EigenDecomposition(m);
return dec.getSquareRoot();
}"
Math_17b_1,/home/common/huangzhili/defects4j_buggy_3/Math_17_buggy/src/main/java/org/apache/commons/math3/dfp/Dfp.java,"public Dfp multiply(final Dfp x) {

// make sure we don't mix number with different precision
if (field.getRadixDigits() != x.field.getRadixDigits()) {
field.setIEEEFlagsBits(DfpField.FLAG_INVALID);
final Dfp result = newInstance(getZero());
result.nans = QNAN;
return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);
}

Dfp result = newInstance(getZero());

/* handle special cases */
if (nans != FINITE || x.nans != FINITE) {
if (isNaN()) {
return this;
}

if (x.isNaN()) {
return x;
}

if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {
result = newInstance(this);
result.sign = (byte) (sign * x.sign);
return result;
}

if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {
result = newInstance(x);
result.sign = (byte) (sign * x.sign);
return result;
}

if (x.nans == INFINITE && nans == INFINITE) {
result = newInstance(this);
result.sign = (byte) (sign * x.sign);
return result;
}

if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||
(nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) {
field.setIEEEFlagsBits(DfpField.FLAG_INVALID);
result = newInstance(getZero());
result.nans = QNAN;
result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);
return result;
}
}

int[] product = new int[mant.length*2];  // Big enough to hold even the largest result

for (int i = 0; i < mant.length; i++) {
int rh = 0;  // acts as a carry
for (int j=0; j<mant.length; j++) {
int r = mant[i] * x.mant[j];    // multiply the 2 digits
r = r + product[i+j] + rh;  // add to the product digit with carry in

rh = r / RADIX;
product[i+j] = r - rh * RADIX;
}
product[i+mant.length] = rh;
}

// Find the most sig digit
int md = mant.length * 2 - 1;  // default, in case result is zero
for (int i = mant.length * 2 - 1; i >= 0; i--) {
if (product[i] != 0) {
md = i;
break;
}
}

// Copy the digits into the result
for (int i = 0; i < mant.length; i++) {
result.mant[mant.length - i - 1] = product[md - i];
}

// Fixup the exponent.
result.exp = exp + x.exp + md - 2 * mant.length + 1;
result.sign = (byte)((sign == x.sign)?1:-1);

if (result.mant[mant.length-1] == 0) {
// if result is zero, set exp to zero
result.exp = 0;
}

final int excp;
if (md > (mant.length-1)) {
excp = result.round(product[md-mant.length]);
} else {
excp = result.round(0); // has no effect except to check status
}

if (excp != 0) {
result = dotrap(excp, MULTIPLY_TRAP, x, result);
}

return result;

}"
Math_17b_2,/home/common/huangzhili/defects4j_buggy_3/Math_17_buggy/src/main/java/org/apache/commons/math3/dfp/Dfp.java,"private Dfp multiplyFast(final int x) {
Dfp result = newInstance(this);

/* handle special cases */
if (nans != FINITE) {
if (isNaN()) {
return this;
}

if (nans == INFINITE && x != 0) {
result = newInstance(this);
return result;
}

if (nans == INFINITE && x == 0) {
field.setIEEEFlagsBits(DfpField.FLAG_INVALID);
result = newInstance(getZero());
result.nans = QNAN;
result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);
return result;
}
}

/* range check x */
if (x < 0 || x >= RADIX) {
field.setIEEEFlagsBits(DfpField.FLAG_INVALID);
result = newInstance(getZero());
result.nans = QNAN;
result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);
return result;
}

int rh = 0;
for (int i = 0; i < mant.length; i++) {
final int r = mant[i] * x + rh;
rh = r / RADIX;
result.mant[i] = r - rh * RADIX;
}

int lostdigit = 0;
if (rh != 0) {
lostdigit = result.mant[0];
result.shiftRight();
result.mant[mant.length-1] = rh;
}

if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero
result.exp = 0;
}

final int excp = result.round(lostdigit);
if (excp != 0) {
result = dotrap(excp, MULTIPLY_TRAP, result, result);
}

return result;
}"
Math_17b_3,/home/common/huangzhili/defects4j_buggy_3/Math_17_buggy/src/main/java/org/apache/commons/math3/dfp/Dfp.java,"protected int round(int n) {
boolean inc = false;
switch (field.getRoundingMode()) {
case ROUND_DOWN:
inc = false;
break;

case ROUND_UP:
inc = n != 0;       // round up if n!=0
break;

case ROUND_HALF_UP:
inc = n >= 5000;  // round half up
break;

case ROUND_HALF_DOWN:
inc = n > 5000;  // round half down
break;

case ROUND_HALF_EVEN:
inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1);  // round half-even
break;

case ROUND_HALF_ODD:
inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0);  // round half-odd
break;

case ROUND_CEIL:
inc = sign == 1 && n != 0;  // round ceil
break;

case ROUND_FLOOR:
default:
inc = sign == -1 && n != 0;  // round floor
break;
}

if (inc) {
// increment if necessary
int rh = 1;
for (int i = 0; i < mant.length; i++) {
final int r = mant[i] + rh;
rh = r / RADIX;
mant[i] = r - rh * RADIX;
}

if (rh != 0) {
shiftRight();
mant[mant.length-1] = rh;
}
}

// check for exceptional cases and raise signals if necessary
if (exp < MIN_EXP) {
// Gradual Underflow
field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);
return DfpField.FLAG_UNDERFLOW;
}

if (exp > MAX_EXP) {
// Overflow
field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);
return DfpField.FLAG_OVERFLOW;
}

if (n != 0) {
// Inexact
field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);
return DfpField.FLAG_INEXACT;
}

return 0;

}"
Math_17b_4,/home/common/huangzhili/defects4j_buggy_3/Math_17_buggy/src/main/java/org/apache/commons/math3/dfp/Dfp.java,"public Dfp dotrap(int type, String what, Dfp oper, Dfp result) {
Dfp def = result;

switch (type) {
case DfpField.FLAG_INVALID:
def = newInstance(getZero());
def.sign = result.sign;
def.nans = QNAN;
break;

case DfpField.FLAG_DIV_ZERO:
if (nans == FINITE && mant[mant.length-1] != 0) {
// normal case, we are finite, non-zero
def = newInstance(getZero());
def.sign = (byte)(sign*oper.sign);
def.nans = INFINITE;
}

if (nans == FINITE && mant[mant.length-1] == 0) {
//  0/0
def = newInstance(getZero());
def.nans = QNAN;
}

if (nans == INFINITE || nans == QNAN) {
def = newInstance(getZero());
def.nans = QNAN;
}

if (nans == INFINITE || nans == SNAN) {
def = newInstance(getZero());
def.nans = QNAN;
}
break;

case DfpField.FLAG_UNDERFLOW:
if ( (result.exp+mant.length) < MIN_EXP) {
def = newInstance(getZero());
def.sign = result.sign;
} else {
def = newInstance(result);  // gradual underflow
}
result.exp = result.exp + ERR_SCALE;
break;

case DfpField.FLAG_OVERFLOW:
result.exp = result.exp - ERR_SCALE;
def = newInstance(getZero());
def.sign = result.sign;
def.nans = INFINITE;
break;

default: def = result; break;
}

return trap(type, what, oper, def, result);

}"
Math_17b_5,/home/common/huangzhili/defects4j_buggy_3/Math_17_buggy/src/main/java/org/apache/commons/math3/dfp/Dfp.java,"protected Dfp(final DfpField field, int x) {
this(field, (long) x);
}"
Math_19b_1,/home/common/huangzhili/defects4j_buggy_3/Math_19_buggy/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java,"private void initializeCMA(double[] guess) {
if (lambda <= 0) {
lambda = 4 + (int) (3. * Math.log(dimension));
}
// initialize sigma
double[][] sigmaArray = new double[guess.length][1];
for (int i = 0; i < guess.length; i++) {
final double range =  (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];
sigmaArray[i][0]   = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;
}
RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);
sigma = max(insigma); // overall standard deviation

// initialize termination criteria
stopTolUpX = 1e3 * max(insigma);
stopTolX = 1e-11 * max(insigma);
stopTolFun = 1e-12;
stopTolHistFun = 1e-13;

// initialize selection strategy parameters
mu = lambda / 2; // number of parents/points for recombination
logMu2 = Math.log(mu + 0.5);
weights = log(sequence(1, mu, 1)).scalarMultiply(-1.).scalarAdd(logMu2);
double sumw = 0;
double sumwq = 0;
for (int i = 0; i < mu; i++) {
double w = weights.getEntry(i, 0);
sumw += w;
sumwq += w * w;
}
weights = weights.scalarMultiply(1. / sumw);
mueff = sumw * sumw / sumwq; // variance-effectiveness of sum w_i x_i

// initialize dynamic strategy parameters and constants
cc = (4. + mueff / dimension) /
(dimension + 4. + 2. * mueff / dimension);
cs = (mueff + 2.) / (dimension + mueff + 3.);
damps = (1. + 2. * Math.max(0, Math.sqrt((mueff - 1.) /
(dimension + 1.)) - 1.)) *
Math.max(0.3, 1. - dimension /
(1e-6 + Math.min(maxIterations, getMaxEvaluations() /
lambda))) + cs; // minor increment
ccov1 = 2. / ((dimension + 1.3) * (dimension + 1.3) + mueff);
ccovmu = Math.min(1 - ccov1, 2. * (mueff - 2. + 1. / mueff) /
((dimension + 2.) * (dimension + 2.) + mueff));
ccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) / 3.);
ccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3.);
chiN = Math.sqrt(dimension) *
(1. - 1. / (4. * dimension) + 1 / (21. * dimension * dimension));
// intialize CMA internal values - updated each generation
xmean = MatrixUtils.createColumnRealMatrix(guess); // objective
// variables
diagD = insigma.scalarMultiply(1. / sigma);
diagC = square(diagD);
pc = zeros(dimension, 1); // evolution paths for C and sigma
ps = zeros(dimension, 1); // B defines the coordinate system
normps = ps.getFrobeniusNorm();

B = eye(dimension, dimension);
D = ones(dimension, 1); // diagonal D defines the scaling
BD = times(B, repmat(diagD.transpose(), dimension, 1));
C = B.multiply(diag(square(D)).multiply(B.transpose())); // covariance
historySize = 10 + (int) (3. * 10. * dimension / lambda);
fitnessHistory = new double[historySize]; // history of fitness values
for (int i = 0; i < historySize; i++) {
fitnessHistory[i] = Double.MAX_VALUE;
}
}"
Math_19b_2,/home/common/huangzhili/defects4j_buggy_3/Math_19_buggy/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java,"private void checkParameters() {
final double[] init = getStartPoint();
final double[] lB = getLowerBound();
final double[] uB = getUpperBound();

// Checks whether there is at least one finite bound value.
boolean hasFiniteBounds = false;
for (int i = 0; i < lB.length; i++) {
if (!Double.isInfinite(lB[i]) ||
!Double.isInfinite(uB[i])) {
hasFiniteBounds = true;
break;
}
}
// Checks whether there is at least one infinite bound value.
boolean hasInfiniteBounds = false;
if (hasFiniteBounds) {
for (int i = 0; i < lB.length; i++) {
if (Double.isInfinite(lB[i]) ||
Double.isInfinite(uB[i])) {
hasInfiniteBounds = true;
break;
}
}

if (hasInfiniteBounds) {
// If there is at least one finite bound, none can be infinite,
// because mixed cases are not supported by the current code.
throw new MathUnsupportedOperationException();
} else {
// Convert API to internal handling of boundaries.
boundaries = new double[2][];
boundaries[0] = lB;
boundaries[1] = uB;

// Abort early if the normalization will overflow (cf. ""encode"" method).
}
} else {
// Convert API to internal handling of boundaries.
boundaries = null;
}

if (inputSigma != null) {
if (inputSigma.length != init.length) {
throw new DimensionMismatchException(inputSigma.length, init.length);
}
for (int i = 0; i < init.length; i++) {
if (inputSigma[i] < 0) {
throw new NotPositiveException(inputSigma[i]);
}
if (boundaries != null) {
if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {
throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);
}
}
}
}
}"
Math_19b_3,/home/common/huangzhili/defects4j_buggy_3/Math_19_buggy/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java,"protected PointValuePair doOptimize() {
checkParameters();
// -------------------- Initialization --------------------------------
isMinimize = getGoalType().equals(GoalType.MINIMIZE);
final FitnessFunction fitfun = new FitnessFunction();
final double[] guess = fitfun.encode(getStartPoint());
// number of objective variables/problem dimension
dimension = guess.length;
initializeCMA(guess);
iterations = 0;
double bestValue = fitfun.value(guess);
push(fitnessHistory, bestValue);
PointValuePair optimum = new PointValuePair(getStartPoint(),
isMinimize ? bestValue : -bestValue);
PointValuePair lastResult = null;

// -------------------- Generation Loop --------------------------------

generationLoop:
for (iterations = 1; iterations <= maxIterations; iterations++) {
// Generate and evaluate lambda offspring
RealMatrix arz = randn1(dimension, lambda);
RealMatrix arx = zeros(dimension, lambda);
double[] fitness = new double[lambda];
// generate random offspring
for (int k = 0; k < lambda; k++) {
RealMatrix arxk = null;
for (int i = 0; i < checkFeasableCount+1; i++) {
if (diagonalOnly <= 0) {
arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))
.scalarMultiply(sigma)); // m + sig * Normal(0,C)
} else {
arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))
.scalarMultiply(sigma));
}
if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {
break;
}
// regenerate random arguments for row
arz.setColumn(k, randn(dimension));
}
copyColumn(arxk, 0, arx, k);
try {
fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness
} catch (TooManyEvaluationsException e) {
break generationLoop;
}
}
// Sort by fitness and compute weighted mean into xmean
int[] arindex = sortedIndices(fitness);
// Calculate new xmean, this is selection and recombination
RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)
RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));
xmean = bestArx.multiply(weights);
RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));
RealMatrix zmean = bestArz.multiply(weights);
boolean hsig = updateEvolutionPaths(zmean, xold);
if (diagonalOnly <= 0) {
updateCovariance(hsig, bestArx, arz, arindex, xold);
} else {
updateCovarianceDiagonalOnly(hsig, bestArz, xold);
}
// Adapt step size sigma - Eq. (5)
sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps));
double bestFitness = fitness[arindex[0]];
double worstFitness = fitness[arindex[arindex.length-1]];
if (bestValue > bestFitness) {
bestValue = bestFitness;
lastResult = optimum;
optimum = new PointValuePair(
fitfun.repairAndDecode(bestArx.getColumn(0)),
isMinimize ? bestFitness : -bestFitness);
if (getConvergenceChecker() != null && lastResult != null) {
if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {
break generationLoop;
}
}
}
// handle termination criteria
// Break, if fitness is good enough
if (stopFitness != 0) { // only if stopFitness is defined
if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {
break generationLoop;
}
}
double[] sqrtDiagC = sqrt(diagC).getColumn(0);
double[] pcCol = pc.getColumn(0);
for (int i = 0; i < dimension; i++) {
if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {
break;
}
if (i >= dimension-1) {
break generationLoop;
}
}
for (int i = 0; i < dimension; i++) {
if (sigma*sqrtDiagC[i] > stopTolUpX) {
break generationLoop;
}
}
double historyBest = min(fitnessHistory);
double historyWorst = max(fitnessHistory);
if (iterations > 2 && Math.max(historyWorst, worstFitness) -
Math.min(historyBest, bestFitness) < stopTolFun) {
break generationLoop;
}
if (iterations > fitnessHistory.length &&
historyWorst-historyBest < stopTolHistFun) {
break generationLoop;
}
// condition number of the covariance matrix exceeds 1e14
if (max(diagD)/min(diagD) > 1e7) {
break generationLoop;
}
// user defined termination
if (getConvergenceChecker() != null) {
PointValuePair current =
new PointValuePair(bestArx.getColumn(0),
isMinimize ? bestFitness : -bestFitness);
if (lastResult != null &&
getConvergenceChecker().converged(iterations, current, lastResult)) {
break generationLoop;
}
lastResult = current;
}
// Adjust step size in case of equal function values (flat fitness)
if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {
sigma = sigma * Math.exp(0.2+cs/damps);
}
if (iterations > 2 && Math.max(historyWorst, bestFitness) -
Math.min(historyBest, bestFitness) == 0) {
sigma = sigma * Math.exp(0.2+cs/damps);
}
// store best in history
push(fitnessHistory,bestFitness);
fitfun.setValueRange(worstFitness-bestFitness);
if (generateStatistics) {
statisticsSigmaHistory.add(sigma);
statisticsFitnessHistory.add(bestFitness);
statisticsMeanHistory.add(xmean.transpose());
statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));
}
}
return optimum;
}"
Math_19b_4,/home/common/huangzhili/defects4j_buggy_3/Math_19_buggy/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java,"private static RealMatrix log(final RealMatrix m) {
double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];
for (int r = 0; r < m.getRowDimension(); r++) {
for (int c = 0; c < m.getColumnDimension(); c++) {
d[r][c] = Math.log(m.getEntry(r, c));
}
}
return new Array2DRowRealMatrix(d, false);
}"
Math_19b_5,/home/common/huangzhili/defects4j_buggy_3/Math_19_buggy/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java,"private static RealMatrix square(final RealMatrix m) {
double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];
for (int r = 0; r < m.getRowDimension(); r++) {
for (int c = 0; c < m.getColumnDimension(); c++) {
double e = m.getEntry(r, c);
d[r][c] = e * e;
}
}
return new Array2DRowRealMatrix(d, false);
}"
Math_20b_1,/home/common/huangzhili/defects4j_buggy_3/Math_20_buggy/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java,"protected PointValuePair doOptimize() {
checkParameters();
// -------------------- Initialization --------------------------------
isMinimize = getGoalType().equals(GoalType.MINIMIZE);
final FitnessFunction fitfun = new FitnessFunction();
final double[] guess = fitfun.encode(getStartPoint());
// number of objective variables/problem dimension
dimension = guess.length;
initializeCMA(guess);
iterations = 0;
double bestValue = fitfun.value(guess);
push(fitnessHistory, bestValue);
PointValuePair optimum = new PointValuePair(getStartPoint(),
isMinimize ? bestValue : -bestValue);
PointValuePair lastResult = null;

// -------------------- Generation Loop --------------------------------

generationLoop:
for (iterations = 1; iterations <= maxIterations; iterations++) {
// Generate and evaluate lambda offspring
RealMatrix arz = randn1(dimension, lambda);
RealMatrix arx = zeros(dimension, lambda);
double[] fitness = new double[lambda];
// generate random offspring
for (int k = 0; k < lambda; k++) {
RealMatrix arxk = null;
for (int i = 0; i < checkFeasableCount+1; i++) {
if (diagonalOnly <= 0) {
arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))
.scalarMultiply(sigma)); // m + sig * Normal(0,C)
} else {
arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))
.scalarMultiply(sigma));
}
if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {
break;
}
// regenerate random arguments for row
arz.setColumn(k, randn(dimension));
}
copyColumn(arxk, 0, arx, k);
try {
fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness
} catch (TooManyEvaluationsException e) {
break generationLoop;
}
}
// Sort by fitness and compute weighted mean into xmean
int[] arindex = sortedIndices(fitness);
// Calculate new xmean, this is selection and recombination
RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)
RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));
xmean = bestArx.multiply(weights);
RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));
RealMatrix zmean = bestArz.multiply(weights);
boolean hsig = updateEvolutionPaths(zmean, xold);
if (diagonalOnly <= 0) {
updateCovariance(hsig, bestArx, arz, arindex, xold);
} else {
updateCovarianceDiagonalOnly(hsig, bestArz, xold);
}
// Adapt step size sigma - Eq. (5)
sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps));
double bestFitness = fitness[arindex[0]];
double worstFitness = fitness[arindex[arindex.length-1]];
if (bestValue > bestFitness) {
bestValue = bestFitness;
lastResult = optimum;
optimum = new PointValuePair(
fitfun.repairAndDecode(bestArx.getColumn(0)),
isMinimize ? bestFitness : -bestFitness);
if (getConvergenceChecker() != null && lastResult != null) {
if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {
break generationLoop;
}
}
}
// handle termination criteria
// Break, if fitness is good enough
if (stopFitness != 0) { // only if stopFitness is defined
if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {
break generationLoop;
}
}
double[] sqrtDiagC = sqrt(diagC).getColumn(0);
double[] pcCol = pc.getColumn(0);
for (int i = 0; i < dimension; i++) {
if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {
break;
}
if (i >= dimension-1) {
break generationLoop;
}
}
for (int i = 0; i < dimension; i++) {
if (sigma*sqrtDiagC[i] > stopTolUpX) {
break generationLoop;
}
}
double historyBest = min(fitnessHistory);
double historyWorst = max(fitnessHistory);
if (iterations > 2 && Math.max(historyWorst, worstFitness) -
Math.min(historyBest, bestFitness) < stopTolFun) {
break generationLoop;
}
if (iterations > fitnessHistory.length &&
historyWorst-historyBest < stopTolHistFun) {
break generationLoop;
}
// condition number of the covariance matrix exceeds 1e14
if (max(diagD)/min(diagD) > 1e7) {
break generationLoop;
}
// user defined termination
if (getConvergenceChecker() != null) {
PointValuePair current =
new PointValuePair(bestArx.getColumn(0),
isMinimize ? bestFitness : -bestFitness);
if (lastResult != null &&
getConvergenceChecker().converged(iterations, current, lastResult)) {
break generationLoop;
}
lastResult = current;
}
// Adjust step size in case of equal function values (flat fitness)
if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {
sigma = sigma * Math.exp(0.2+cs/damps);
}
if (iterations > 2 && Math.max(historyWorst, bestFitness) -
Math.min(historyBest, bestFitness) == 0) {
sigma = sigma * Math.exp(0.2+cs/damps);
}
// store best in history
push(fitnessHistory,bestFitness);
fitfun.setValueRange(worstFitness-bestFitness);
if (generateStatistics) {
statisticsSigmaHistory.add(sigma);
statisticsFitnessHistory.add(bestFitness);
statisticsMeanHistory.add(xmean.transpose());
statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));
}
}
return optimum;
}"
Math_20b_2,/home/common/huangzhili/defects4j_buggy_3/Math_20_buggy/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java,"private void initializeCMA(double[] guess) {
if (lambda <= 0) {
lambda = 4 + (int) (3. * Math.log(dimension));
}
// initialize sigma
double[][] sigmaArray = new double[guess.length][1];
for (int i = 0; i < guess.length; i++) {
final double range =  (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];
sigmaArray[i][0]   = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;
}
RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);
sigma = max(insigma); // overall standard deviation

// initialize termination criteria
stopTolUpX = 1e3 * max(insigma);
stopTolX = 1e-11 * max(insigma);
stopTolFun = 1e-12;
stopTolHistFun = 1e-13;

// initialize selection strategy parameters
mu = lambda / 2; // number of parents/points for recombination
logMu2 = Math.log(mu + 0.5);
weights = log(sequence(1, mu, 1)).scalarMultiply(-1.).scalarAdd(logMu2);
double sumw = 0;
double sumwq = 0;
for (int i = 0; i < mu; i++) {
double w = weights.getEntry(i, 0);
sumw += w;
sumwq += w * w;
}
weights = weights.scalarMultiply(1. / sumw);
mueff = sumw * sumw / sumwq; // variance-effectiveness of sum w_i x_i

// initialize dynamic strategy parameters and constants
cc = (4. + mueff / dimension) /
(dimension + 4. + 2. * mueff / dimension);
cs = (mueff + 2.) / (dimension + mueff + 3.);
damps = (1. + 2. * Math.max(0, Math.sqrt((mueff - 1.) /
(dimension + 1.)) - 1.)) *
Math.max(0.3, 1. - dimension /
(1e-6 + Math.min(maxIterations, getMaxEvaluations() /
lambda))) + cs; // minor increment
ccov1 = 2. / ((dimension + 1.3) * (dimension + 1.3) + mueff);
ccovmu = Math.min(1 - ccov1, 2. * (mueff - 2. + 1. / mueff) /
((dimension + 2.) * (dimension + 2.) + mueff));
ccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) / 3.);
ccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3.);
chiN = Math.sqrt(dimension) *
(1. - 1. / (4. * dimension) + 1 / (21. * dimension * dimension));
// intialize CMA internal values - updated each generation
xmean = MatrixUtils.createColumnRealMatrix(guess); // objective
// variables
diagD = insigma.scalarMultiply(1. / sigma);
diagC = square(diagD);
pc = zeros(dimension, 1); // evolution paths for C and sigma
ps = zeros(dimension, 1); // B defines the coordinate system
normps = ps.getFrobeniusNorm();

B = eye(dimension, dimension);
D = ones(dimension, 1); // diagonal D defines the scaling
BD = times(B, repmat(diagD.transpose(), dimension, 1));
C = B.multiply(diag(square(D)).multiply(B.transpose())); // covariance
historySize = 10 + (int) (3. * 10. * dimension / lambda);
fitnessHistory = new double[historySize]; // history of fitness values
for (int i = 0; i < historySize; i++) {
fitnessHistory[i] = Double.MAX_VALUE;
}
}"
Math_20b_3,/home/common/huangzhili/defects4j_buggy_3/Math_20_buggy/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java,"private void updateCovariance(boolean hsig, final RealMatrix bestArx,
final RealMatrix arz, final int[] arindex, final RealMatrix xold) {
double negccov = 0;
if (ccov1 + ccovmu > 0) {
RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu))
.scalarMultiply(1. / sigma); // mu difference vectors
RealMatrix roneu = pc.multiply(pc.transpose())
.scalarMultiply(ccov1); // rank one update
// minor correction if hsig==false
double oldFac = hsig ? 0 : ccov1 * cc * (2. - cc);
oldFac += 1. - ccov1 - ccovmu;
if (isActiveCMA) {
// Adapt covariance matrix C active CMA
negccov = (1. - ccovmu) * 0.25 * mueff /
(Math.pow(dimension + 2., 1.5) + 2. * mueff);
double negminresidualvariance = 0.66;
// keep at least 0.66 in all directions, small popsize are most
// critical
double negalphaold = 0.5; // where to make up for the variance
// loss,
// prepare vectors, compute negative updating matrix Cneg
int[] arReverseIndex = reverse(arindex);
RealMatrix arzneg
= selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu));
RealMatrix arnorms = sqrt(sumRows(square(arzneg)));
int[] idxnorms = sortedIndices(arnorms.getRow(0));
RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms);
int[] idxReverse = reverse(idxnorms);
RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse);
arnorms = divide(arnormsReverse, arnormsSorted);
int[] idxInv = inverse(idxnorms);
RealMatrix arnormsInv = selectColumns(arnorms, idxInv);
// check and set learning rate negccov
double negcovMax = (1. - negminresidualvariance) /
square(arnormsInv).multiply(weights).getEntry(0, 0);
if (negccov > negcovMax) {
negccov = negcovMax;
}
arzneg = times(arzneg, repmat(arnormsInv, dimension, 1));
RealMatrix artmp = BD.multiply(arzneg);
RealMatrix Cneg = artmp.multiply(diag(weights)).multiply(
artmp.transpose());
oldFac += negalphaold * negccov;
C = C.scalarMultiply(oldFac)
// regard old matrix
.add(roneu)
// plus rank one update
.add(arpos.scalarMultiply(
// plus rank mu update
ccovmu + (1. - negalphaold) * negccov)
.multiply(
times(repmat(weights, 1, dimension),
arpos.transpose())))
.subtract(Cneg.scalarMultiply(negccov));
} else {
// Adapt covariance matrix C - nonactive
C = C.scalarMultiply(oldFac) // regard old matrix
.add(roneu)
// plus rank one update
.add(arpos.scalarMultiply(ccovmu) // plus rank mu update
.multiply(
times(repmat(weights, 1, dimension),
arpos.transpose())));
}
}
updateBD(negccov);
}"
Math_20b_4,/home/common/huangzhili/defects4j_buggy_3/Math_20_buggy/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java,"private void checkParameters() {
final double[] init = getStartPoint();
final double[] lB = getLowerBound();
final double[] uB = getUpperBound();

// Checks whether there is at least one finite bound value.
boolean hasFiniteBounds = false;
for (int i = 0; i < lB.length; i++) {
if (!Double.isInfinite(lB[i]) ||
!Double.isInfinite(uB[i])) {
hasFiniteBounds = true;
break;
}
}
// Checks whether there is at least one infinite bound value.
boolean hasInfiniteBounds = false;
if (hasFiniteBounds) {
for (int i = 0; i < lB.length; i++) {
if (Double.isInfinite(lB[i]) ||
Double.isInfinite(uB[i])) {
hasInfiniteBounds = true;
break;
}
}

if (hasInfiniteBounds) {
// If there is at least one finite bound, none can be infinite,
// because mixed cases are not supported by the current code.
throw new MathUnsupportedOperationException();
} else {
// Convert API to internal handling of boundaries.
boundaries = new double[2][];
boundaries[0] = lB;
boundaries[1] = uB;
}
} else {
// Convert API to internal handling of boundaries.
boundaries = null;
}

if (inputSigma != null) {
if (inputSigma.length != init.length) {
throw new DimensionMismatchException(inputSigma.length, init.length);
}
for (int i = 0; i < init.length; i++) {
if (inputSigma[i] < 0) {
throw new NotPositiveException(inputSigma[i]);
}
if (boundaries != null) {
if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {
throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);
}
}
}
}
}"
Math_20b_5,/home/common/huangzhili/defects4j_buggy_3/Math_20_buggy/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java,"private boolean updateEvolutionPaths(RealMatrix zmean, RealMatrix xold) {
ps = ps.scalarMultiply(1. - cs).add(
B.multiply(zmean).scalarMultiply(
Math.sqrt(cs * (2. - cs) * mueff)));
normps = ps.getFrobeniusNorm();
boolean hsig = normps /
Math.sqrt(1. - Math.pow(1. - cs, 2. * iterations)) /
chiN < 1.4 + 2. / (dimension + 1.);
pc = pc.scalarMultiply(1. - cc);
if (hsig) {
pc = pc.add(xmean.subtract(xold).scalarMultiply(
Math.sqrt(cc * (2. - cc) * mueff) / sigma));
}
return hsig;
}"
Math_21b_1,/home/common/huangzhili/defects4j_buggy_3/Math_21_buggy/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java,"public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
throws NonPositiveDefiniteMatrixException {

final int order = matrix.getRowDimension();
final double[][] c = matrix.getData();
final double[][] b = new double[order][order];

int[] swap  = new int[order];
int[] index = new int[order];
for (int i = 0; i < order; ++i) {
index[i] = i;
}

int r = 0;
for (boolean loop = true; loop;) {

// find maximal diagonal element
swap[r] = r;
for (int i = r + 1; i < order; ++i) {
int ii  = index[i];
int isi = index[swap[i]];
if (c[ii][ii] > c[isi][isi]) {
swap[r] = i;
}
}


// swap elements
if (swap[r] != r) {
int tmp = index[r];
index[r] = index[swap[r]];
index[swap[r]] = tmp;
}

// check diagonal element
int ir = index[r];
if (c[ir][ir] < small) {

if (r == 0) {
throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);
}

// check remaining diagonal elements
for (int i = r; i < order; ++i) {
if (c[index[i]][index[i]] < -small) {
// there is at least one sufficiently negative diagonal element,
// the symmetric positive semidefinite matrix is wrong
throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);
}
}

// all remaining diagonal elements are close to zero, we consider we have
// found the rank of the symmetric positive semidefinite matrix
++r;
loop = false;

} else {

// transform the matrix
final double sqrt = FastMath.sqrt(c[ir][ir]);
b[r][r] = sqrt;
final double inverse  = 1 / sqrt;
for (int i = r + 1; i < order; ++i) {
final int ii = index[i];
final double e = inverse * c[ii][ir];
b[i][r] = e;
c[ii][ii] -= e * e;
for (int j = r + 1; j < i; ++j) {
final int ij = index[j];
final double f = c[ii][ij] - e * b[j][r];
c[ii][ij] = f;
c[ij][ii] = f;
}
}

// prepare next iteration
loop = ++r < order;
}
}

// build the root matrix
rank = r;
root = MatrixUtils.createRealMatrix(order, r);
for (int i = 0; i < order; ++i) {
for (int j = 0; j < r; ++j) {
root.setEntry(index[i], j, b[i][j]);
}
}

}"
Math_21b_2,/home/common/huangzhili/defects4j_buggy_3/Math_21_buggy/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java,"public RealMatrix getRootMatrix() {
return root;
}"
Math_23b_1,/home/common/huangzhili/defects4j_buggy_3/Math_23_buggy/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java,"protected UnivariatePointValuePair doOptimize() {
final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
final double lo = getMin();
final double mid = getStartValue();
final double hi = getMax();

// Optional additional convergence criteria.
final ConvergenceChecker<UnivariatePointValuePair> checker
= getConvergenceChecker();

double a;
double b;
if (lo < hi) {
a = lo;
b = hi;
} else {
a = hi;
b = lo;
}

double x = mid;
double v = x;
double w = x;
double d = 0;
double e = 0;
double fx = computeObjectiveValue(x);
if (!isMinim) {
fx = -fx;
}
double fv = fx;
double fw = fx;

UnivariatePointValuePair previous = null;
UnivariatePointValuePair current
= new UnivariatePointValuePair(x, isMinim ? fx : -fx);
// Best point encountered so far (which is the initial guess).

int iter = 0;
while (true) {
final double m = 0.5 * (a + b);
final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
final double tol2 = 2 * tol1;

// Default stopping criterion.
final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
if (!stop) {
double p = 0;
double q = 0;
double r = 0;
double u = 0;

if (FastMath.abs(e) > tol1) { // Fit parabola.
r = (x - w) * (fx - fv);
q = (x - v) * (fx - fw);
p = (x - v) * q - (x - w) * r;
q = 2 * (q - r);

if (q > 0) {
p = -p;
} else {
q = -q;
}

r = e;
e = d;

if (p > q * (a - x) &&
p < q * (b - x) &&
FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
// Parabolic interpolation step.
d = p / q;
u = x + d;

// f must not be evaluated too close to a or b.
if (u - a < tol2 || b - u < tol2) {
if (x <= m) {
d = tol1;
} else {
d = -tol1;
}
}
} else {
// Golden section step.
if (x < m) {
e = b - x;
} else {
e = a - x;
}
d = GOLDEN_SECTION * e;
}
} else {
// Golden section step.
if (x < m) {
e = b - x;
} else {
e = a - x;
}
d = GOLDEN_SECTION * e;
}

// Update by at least ""tol1"".
if (FastMath.abs(d) < tol1) {
if (d >= 0) {
u = x + tol1;
} else {
u = x - tol1;
}
} else {
u = x + d;
}

double fu = computeObjectiveValue(u);
if (!isMinim) {
fu = -fu;
}

// User-defined convergence checker.
previous = current;
current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

if (checker != null) {
if (checker.converged(iter, previous, current)) {
return best(current, previous, isMinim);
}
}

// Update a, b, v, w and x.
if (fu <= fx) {
if (u < x) {
b = x;
} else {
a = x;
}
v = w;
fv = fw;
w = x;
fw = fx;
x = u;
fx = fu;
} else {
if (u < x) {
a = u;
} else {
b = u;
}
if (fu <= fw ||
Precision.equals(w, x)) {
v = w;
fv = fw;
w = u;
fw = fu;
} else if (fu <= fv ||
Precision.equals(v, x) ||
Precision.equals(v, w)) {
v = u;
fv = fu;
}
}
} else { // Default termination (Brent's criterion).
return
best(current,
previous,
isMinim);
}
++iter;
}
}"
Math_23b_2,/home/common/huangzhili/defects4j_buggy_3/Math_23_buggy/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java,"public BrentOptimizer(double rel,
double abs,"
Math_23b_3,/home/common/huangzhili/defects4j_buggy_3/Math_23_buggy/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java,"private UnivariatePointValuePair best(UnivariatePointValuePair a,
UnivariatePointValuePair b,"
Math_24b_1,/home/common/huangzhili/defects4j_buggy_3/Math_24_buggy/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java,"protected UnivariatePointValuePair doOptimize() {
final boolean isMinim = getGoalType() == GoalType.MINIMIZE;
final double lo = getMin();
final double mid = getStartValue();
final double hi = getMax();

// Optional additional convergence criteria.
final ConvergenceChecker<UnivariatePointValuePair> checker
= getConvergenceChecker();

double a;
double b;
if (lo < hi) {
a = lo;
b = hi;
} else {
a = hi;
b = lo;
}

double x = mid;
double v = x;
double w = x;
double d = 0;
double e = 0;
double fx = computeObjectiveValue(x);
if (!isMinim) {
fx = -fx;
}
double fv = fx;
double fw = fx;

UnivariatePointValuePair previous = null;
UnivariatePointValuePair current
= new UnivariatePointValuePair(x, isMinim ? fx : -fx);

int iter = 0;
while (true) {
final double m = 0.5 * (a + b);
final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;
final double tol2 = 2 * tol1;

// Default stopping criterion.
final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);
if (!stop) {
double p = 0;
double q = 0;
double r = 0;
double u = 0;

if (FastMath.abs(e) > tol1) { // Fit parabola.
r = (x - w) * (fx - fv);
q = (x - v) * (fx - fw);
p = (x - v) * q - (x - w) * r;
q = 2 * (q - r);

if (q > 0) {
p = -p;
} else {
q = -q;
}

r = e;
e = d;

if (p > q * (a - x) &&
p < q * (b - x) &&
FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {
// Parabolic interpolation step.
d = p / q;
u = x + d;

// f must not be evaluated too close to a or b.
if (u - a < tol2 || b - u < tol2) {
if (x <= m) {
d = tol1;
} else {
d = -tol1;
}
}
} else {
// Golden section step.
if (x < m) {
e = b - x;
} else {
e = a - x;
}
d = GOLDEN_SECTION * e;
}
} else {
// Golden section step.
if (x < m) {
e = b - x;
} else {
e = a - x;
}
d = GOLDEN_SECTION * e;
}

// Update by at least ""tol1"".
if (FastMath.abs(d) < tol1) {
if (d >= 0) {
u = x + tol1;
} else {
u = x - tol1;
}
} else {
u = x + d;
}

double fu = computeObjectiveValue(u);
if (!isMinim) {
fu = -fu;
}

// User-defined convergence checker.
previous = current;
current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);

if (checker != null) {
if (checker.converged(iter, previous, current)) {
return current;
}
}

// Update a, b, v, w and x.
if (fu <= fx) {
if (u < x) {
b = x;
} else {
a = x;
}
v = w;
fv = fw;
w = x;
fw = fx;
x = u;
fx = fu;
} else {
if (u < x) {
a = u;
} else {
b = u;
}
if (fu <= fw ||
Precision.equals(w, x)) {
v = w;
fv = fw;
w = u;
fw = fu;
} else if (fu <= fv ||
Precision.equals(v, x) ||
Precision.equals(v, w)) {
v = u;
fv = fu;
}
}
} else { // Default termination (Brent's criterion).
return current;
}
++iter;
}
}"
Math_24b_2,/home/common/huangzhili/defects4j_buggy_3/Math_24_buggy/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java,"public BrentOptimizer(double rel,
double abs,"
Math_25b_1,/home/common/huangzhili/defects4j_buggy_3/Math_25_buggy/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java,"private void guessAOmega() {
            // initialize the sums for the linear model between the two integrals
            double sx2 = 0;
            double sy2 = 0;
            double sxy = 0;
            double sxz = 0;
            double syz = 0;

            double currentX = observations[0].getX();
            double currentY = observations[0].getY();
            double f2Integral = 0;
            double fPrime2Integral = 0;
            final double startX = currentX;
            for (int i = 1; i < observations.length; ++i) {
                // one step forward
                final double previousX = currentX;
                final double previousY = currentY;
                currentX = observations[i].getX();
                currentY = observations[i].getY();

                // update the integrals of f<sup>2</sup> and f'<sup>2</sup>
                // considering a linear model for f (and therefore constant f')
                final double dx = currentX - previousX;
                final double dy = currentY - previousY;
                final double f2StepIntegral =
                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;
                final double fPrime2StepIntegral = dy * dy / dx;

                final double x = currentX - startX;
                f2Integral += f2StepIntegral;
                fPrime2Integral += fPrime2StepIntegral;

                sx2 += x * x;
                sy2 += f2Integral * f2Integral;
                sxy += x * f2Integral;
                sxz += x * fPrime2Integral;
                syz += f2Integral * fPrime2Integral;
            }

            // compute the amplitude and pulsation coefficients
            double c1 = sy2 * sxz - sxy * syz;
            double c2 = sxy * sxz - sx2 * syz;
            double c3 = sx2 * sy2 - sxy * sxy;
            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {
                final int last = observations.length - 1;
                // Range of the observations, assuming that the
                // observations are sorted.
                final double xRange = observations[last].getX() - observations[0].getX();
                if (xRange == 0) {
                    throw new ZeroException();
                }
                omega = 2 * Math.PI / xRange;

                double yMin = Double.POSITIVE_INFINITY;
                double yMax = Double.NEGATIVE_INFINITY;
                for (int i = 1; i < observations.length; ++i) {
                    final double y = observations[i].getY();
                    if (y < yMin) {
                        yMin = y;
                    }
                    if (y > yMax) {
                        yMax = y;
                    }
                }
                a = 0.5 * (yMax - yMin);
            } else {
                    // In some ill-conditioned cases (cf. MATH-844), the guesser
                    // procedure cannot produce sensible results.

                a = FastMath.sqrt(c1 / c2);
                omega = FastMath.sqrt(c2 / c3);
            }
        }"
Math_26b_1,/home/common/huangzhili/defects4j_buggy_3/Math_26_buggy/src/main/java/org/apache/commons/math3/fraction/Fraction.java,"public Fraction(double value, double epsilon, int maxIterations)
throws FractionConversionException"
Math_27b_1,/home/common/huangzhili/defects4j_buggy_3/Math_27_buggy/src/main/java/org/apache/commons/math3/fraction/Fraction.java,"public double percentageValue() {
return multiply(100).doubleValue();
}"
Math_27b_2,/home/common/huangzhili/defects4j_buggy_3/Math_27_buggy/src/main/java/org/apache/commons/math3/fraction/Fraction.java,"public Fraction multiply(final int i) {
return new Fraction(numerator * i, denominator);
}"
Math_27b_3,/home/common/huangzhili/defects4j_buggy_3/Math_27_buggy/src/main/java/org/apache/commons/math3/fraction/Fraction.java,"public double doubleValue() {
return (double)numerator / (double)denominator;
}"
Math_27b_4,/home/common/huangzhili/defects4j_buggy_3/Math_27_buggy/src/main/java/org/apache/commons/math3/fraction/Fraction.java,"public Fraction(int num, int den) {
if (den == 0) {
throw new MathArithmeticException(LocalizedFormats.ZERO_DENOMINATOR_IN_FRACTION,
num, den);
}
if (den < 0) {
if (num == Integer.MIN_VALUE ||
den == Integer.MIN_VALUE) {
throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_FRACTION,
num, den);
}
num = -num;
den = -den;
}
// reduce numerator and denominator by greatest common denominator.
final int d = ArithmeticUtils.gcd(num, den);
if (d > 1) {
num /= d;
den /= d;
}

// move sign to numerator.
if (den < 0) {
num = -num;
den = -den;
}
this.numerator   = num;
this.denominator = den;
}"
Math_28b_1,/home/common/huangzhili/defects4j_buggy_3/Math_28_buggy/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java,"private Integer getPivotRow(SimplexTableau tableau, final int col) {
// create a list of all the rows that tie for the lowest score in the minimum ratio test
List<Integer> minRatioPositions = new ArrayList<Integer>();
double minRatio = Double.MAX_VALUE;
for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
final double entry = tableau.getEntry(i, col);

if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
final double ratio = rhs / entry;
// check if the entry is strictly equal to the current min ratio
// do not use a ulp/epsilon check
final int cmp = Double.compare(ratio, minRatio);
if (cmp == 0) {
minRatioPositions.add(i);
} else if (cmp < 0) {
minRatio = ratio;
minRatioPositions = new ArrayList<Integer>();
minRatioPositions.add(i);
}
}
}

if (minRatioPositions.size() == 0) {
return null;
} else if (minRatioPositions.size() > 1) {
// there's a degeneracy as indicated by a tie in the minimum ratio test

// 1. check if there's an artificial variable that can be forced out of the basis
for (Integer row : minRatioPositions) {
for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
int column = i + tableau.getArtificialVariableOffset();
final double entry = tableau.getEntry(row, column);
if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {
return row;
}
}
}

// 2. apply Bland's rule to prevent cycling:
//    take the row for which the corresponding basic variable has the smallest index
//
// see http://www.stanford.edu/class/msande310/blandrule.pdf
// see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)
//
// Additional heuristic: if we did not get a solution after half of maxIterations
//                       revert to the simple case of just returning the top-most row
// This heuristic is based on empirical data gathered while investigating MATH-828.
Integer minRow = null;
int minIndex = tableau.getWidth();
for (Integer row : minRatioPositions) {
int i = tableau.getNumObjectiveFunctions();
for (; i < tableau.getWidth() - 1 && minRow != row; i++) {
if (row == tableau.getBasicRow(i)) {
if (i < minIndex) {
minIndex = i;
minRow = row;
}
}
}
}
return minRow;
}
return minRatioPositions.get(0);
}"
Math_28b_2,/home/common/huangzhili/defects4j_buggy_3/Math_28_buggy/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java,"public PointValuePair doOptimize()
throws MaxCountExceededException, UnboundedSolutionException, NoFeasibleSolutionException {
final SimplexTableau tableau =
new SimplexTableau(getFunction(),
getConstraints(),
getGoalType(),
restrictToNonNegative(),
epsilon,
maxUlps);

solvePhase1(tableau);
tableau.dropPhase1Objective();

while (!tableau.isOptimal()) {
doIteration(tableau);
}
return tableau.getSolution();
}"
Math_28b_3,/home/common/huangzhili/defects4j_buggy_3/Math_28_buggy/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java,"protected void solvePhase1(final SimplexTableau tableau)
throws MaxCountExceededException, UnboundedSolutionException, NoFeasibleSolutionException {

// make sure we're in Phase 1
if (tableau.getNumArtificialVariables() == 0) {
return;
}

while (!tableau.isOptimal()) {
doIteration(tableau);
}

// if W is not zero then we have no feasible solution
if (!Precision.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0d, epsilon)) {
throw new NoFeasibleSolutionException();
}
}"
Math_28b_4,/home/common/huangzhili/defects4j_buggy_3/Math_28_buggy/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java,"private Integer getPivotColumn(SimplexTableau tableau) {
double minValue = 0;
Integer minPos = null;
for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {
final double entry = tableau.getEntry(0, i);
// check if the entry is strictly smaller than the current minimum
// do not use a ulp/epsilon check
if (entry < minValue) {
minValue = entry;
minPos = i;
}
}
return minPos;
}"
Math_28b_5,/home/common/huangzhili/defects4j_buggy_3/Math_28_buggy/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java,"protected void doIteration(final SimplexTableau tableau)
throws MaxCountExceededException, UnboundedSolutionException {

incrementIterationsCounter();

Integer pivotCol = getPivotColumn(tableau);
Integer pivotRow = getPivotRow(tableau, pivotCol);
if (pivotRow == null) {
throw new UnboundedSolutionException();
}

// set the pivot element to 1
double pivotVal = tableau.getEntry(pivotRow, pivotCol);
tableau.divideRow(pivotRow, pivotVal);

// set the rest of the pivot column to 0
for (int i = 0; i < tableau.getHeight(); i++) {
if (i != pivotRow) {
final double multiplier = tableau.getEntry(i, pivotCol);
tableau.subtractRow(i, pivotRow, multiplier);
}
}
}"
Math_30b_1,/home/common/huangzhili/defects4j_buggy_3/Math_30_buggy/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java,"private void ensureDataConformance(final double[] x, final double[] y)
throws NullArgumentException, NoDataException {

if (x == null ||
y == null) {
throw new NullArgumentException();
}
if (x.length == 0 ||
y.length == 0) {
throw new NoDataException();
}
}"
Math_30b_2,/home/common/huangzhili/defects4j_buggy_3/Math_30_buggy/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java,"private double[] concatenateSamples(final double[] x, final double[] y) {
final double[] z = new double[x.length + y.length];

System.arraycopy(x, 0, z, 0, x.length);
System.arraycopy(y, 0, z, x.length, y.length);

return z;
}"
Math_30b_3,/home/common/huangzhili/defects4j_buggy_3/Math_30_buggy/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java,"public double mannWhitneyU(final double[] x, final double[] y)
throws NullArgumentException, NoDataException {

ensureDataConformance(x, y);

final double[] z = concatenateSamples(x, y);
final double[] ranks = naturalRanking.rank(z);

double sumRankX = 0;

/*
* The ranks for x is in the first x.length entries in ranks because x
* is in the first x.length entries in z
*/
for (int i = 0; i < x.length; ++i) {
sumRankX += ranks[i];
}

/*
* U1 = R1 - (n1 * (n1 + 1)) / 2 where R1 is sum of ranks for sample 1,
* e.g. x, n1 is the number of observations in sample 1.
*/
final double U1 = sumRankX - (x.length * (x.length + 1)) / 2;

/*
* It can be shown that U1 + U2 = n1 * n2
*/
final double U2 = x.length * y.length - U1;

return FastMath.max(U1, U2);
}"
Math_30b_4,/home/common/huangzhili/defects4j_buggy_3/Math_30_buggy/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java,"private double calculateAsymptoticPValue(final double Umin,
final int n1,"
Math_30b_5,/home/common/huangzhili/defects4j_buggy_3/Math_30_buggy/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java,"public double mannWhitneyUTest(final double[] x, final double[] y)
throws NullArgumentException, NoDataException,"
Math_31b_1,/home/common/huangzhili/defects4j_buggy_3/Math_31_buggy/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java,"public double evaluate(double x, double epsilon, int maxIterations) {
final double small = 1e-50;
double hPrev = getA(0, x);

// use the value of small as epsilon criteria for zero checks
if (Precision.equals(hPrev, 0.0, small)) {
hPrev = small;
}

int n = 1;
double dPrev = 0.0;
double p0 = 1.0;
double q1 = 1.0;
double cPrev = hPrev;
double hN = hPrev;

while (n < maxIterations) {
final double a = getA(n, x);
final double b = getB(n, x);

double cN = a * hPrev + b * p0;
double q2 = a * q1 + b * dPrev;
if (Double.isInfinite(cN) || Double.isInfinite(q2)) {
double scaleFactor = 1d;
double lastScaleFactor = 1d;
final int maxPower = 5;
final double scale = FastMath.max(a,b);
if (scale <= 0) {  // Can't scale
throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
}
for (int i = 0; i < maxPower; i++) {
lastScaleFactor = scaleFactor;
scaleFactor *= scale;
if (a != 0.0 && a > b) {
cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);
q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);
} else if (b != 0) {
cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;
q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;
}
if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {
break;
}
}
}

final double deltaN = cN / q2 / cPrev;
hN = cPrev * deltaN;

if (Double.isInfinite(hN)) {
throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,
x);
}
if (Double.isNaN(hN)) {
throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,
x);
}

if (FastMath.abs(deltaN - 1.0) < epsilon) {
break;
}

dPrev = q1;
cPrev = cN / q2;
p0 = hPrev;
hPrev = cN;
q1 = q2;
n++;
}

if (n >= maxIterations) {
throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,
maxIterations, x);
}

return hN;
}"
Math_31b_2,/home/common/huangzhili/defects4j_buggy_3/Math_31_buggy/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java,"protected ContinuedFraction() {
super();
}"
Math_32b_1,/home/common/huangzhili/defects4j_buggy_3/Math_32_buggy/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java,"public PolygonsSet() {
super();
}"
Math_32b_2,/home/common/huangzhili/defects4j_buggy_3/Math_32_buggy/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java,"protected void computeGeometricalProperties() {

final Vector2D[][] v = getVertices();

if (v.length == 0) {
final BSPTree<Euclidean2D> tree = getTree(false);
if ((Boolean) tree.getAttribute()) {
// the instance covers the whole space
setSize(Double.POSITIVE_INFINITY);
setBarycenter(Vector2D.NaN);
} else {
setSize(0);
setBarycenter(new Vector2D(0, 0));
}
} else if (v[0][0] == null) {
// there is at least one open-loop: the polygon is infinite
setSize(Double.POSITIVE_INFINITY);
setBarycenter(Vector2D.NaN);
} else {
// all loops are closed, we compute some integrals around the shape

double sum  = 0;
double sumX = 0;
double sumY = 0;

for (Vector2D[] loop : v) {
double x1 = loop[loop.length - 1].getX();
double y1 = loop[loop.length - 1].getY();
for (final Vector2D point : loop) {
final double x0 = x1;
final double y0 = y1;
x1 = point.getX();
y1 = point.getY();
final double factor = x0 * y1 - y0 * x1;
sum  += factor;
sumX += factor * (x0 + x1);
sumY += factor * (y0 + y1);
}
}

if (sum < 0) {
// the polygon as a finite outside surrounded by an infinite inside
setSize(Double.POSITIVE_INFINITY);
setBarycenter(Vector2D.NaN);
} else {
setSize(sum / 2);
setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));
}

}

}"
Math_32b_3,/home/common/huangzhili/defects4j_buggy_3/Math_32_buggy/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java,"public PolygonsSet buildNew(final BSPTree<Euclidean2D> tree) {
return new PolygonsSet(tree);
}"
Math_32b_4,/home/common/huangzhili/defects4j_buggy_3/Math_32_buggy/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java,"public Vector2D[][] getVertices() {
if (vertices == null) {
if (getTree(false).getCut() == null) {
vertices = new Vector2D[0][];
} else {

// sort the segments according to their start point
final SegmentsBuilder visitor = new SegmentsBuilder();
getTree(true).visit(visitor);
final AVLTree<ComparableSegment> sorted = visitor.getSorted();

// identify the loops, starting from the open ones
// (their start segments are naturally at the sorted set beginning)
final ArrayList<List<ComparableSegment>> loops = new ArrayList<List<ComparableSegment>>();
while (!sorted.isEmpty()) {
final AVLTree<ComparableSegment>.Node node = sorted.getSmallest();
final List<ComparableSegment> loop = followLoop(node, sorted);
if (loop != null) {
loops.add(loop);
}
}

// tranform the loops in an array of arrays of points
vertices = new Vector2D[loops.size()][];
int i = 0;

for (final List<ComparableSegment> loop : loops) {
if (loop.size() < 2) {
// single infinite line
final Line line = loop.get(0).getLine();
vertices[i++] = new Vector2D[] {
null,
line.toSpace(new Vector1D(-Float.MAX_VALUE)),
line.toSpace(new Vector1D(+Float.MAX_VALUE))
};
} else if (loop.get(0).getStart() == null) {
// open loop with at least one real point
final Vector2D[] array = new Vector2D[loop.size() + 2];
int j = 0;
for (Segment segment : loop) {

if (j == 0) {
// null point and first dummy point
double x = segment.getLine().toSubSpace(segment.getEnd()).getX();
x -= FastMath.max(1.0, FastMath.abs(x / 2));
array[j++] = null;
array[j++] = segment.getLine().toSpace(new Vector1D(x));
}

if (j < (array.length - 1)) {
// current point
array[j++] = segment.getEnd();
}

if (j == (array.length - 1)) {
// last dummy point
double x = segment.getLine().toSubSpace(segment.getStart()).getX();
x += FastMath.max(1.0, FastMath.abs(x / 2));
array[j++] = segment.getLine().toSpace(new Vector1D(x));
}

}
vertices[i++] = array;
} else {
final Vector2D[] array = new Vector2D[loop.size()];
int j = 0;
for (Segment segment : loop) {
array[j++] = segment.getStart();
}
vertices[i++] = array;
}
}

}
}

return vertices.clone();

}"
Math_33b_1,/home/common/huangzhili/defects4j_buggy_3/Math_33_buggy/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java,"protected PointValuePair getSolution() {
int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);
Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;
double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());

Set<Integer> basicRows = new HashSet<Integer>();
double[] coefficients = new double[getOriginalNumDecisionVariables()];
for (int i = 0; i < coefficients.length; i++) {
int colIndex = columnLabels.indexOf(""x"" + i);
if (colIndex < 0) {
coefficients[i] = 0;
continue;
}
Integer basicRow = getBasicRow(colIndex);
if (basicRow != null && basicRow == 0) {
// if the basic row is found to be the objective function row
// set the coefficient to 0 -> this case handles unconstrained
// variables that are still part of the objective function
coefficients[i] = 0;
} else if (basicRows.contains(basicRow)) {
// if multiple variables can take a given value
// then we choose the first and set the rest equal to 0
coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
} else {
basicRows.add(basicRow);
coefficients[i] =
(basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
(restrictToNonNegative ? 0 : mostNegative);
}
}
return new PointValuePair(coefficients, f.getValue(coefficients));
}"
Math_33b_2,/home/common/huangzhili/defects4j_buggy_3/Math_33_buggy/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java,"protected void dropPhase1Objective() {
if (getNumObjectiveFunctions() == 1) {
return;
}

List<Integer> columnsToDrop = new ArrayList<Integer>();
columnsToDrop.add(0);

// positive cost non-artificial variables
for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
final double entry = tableau.getEntry(0, i);
if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
columnsToDrop.add(i);
}
}

// non-basic artificial variables
for (int i = 0; i < getNumArtificialVariables(); i++) {
int col = i + getArtificialVariableOffset();
if (getBasicRow(col) == null) {
columnsToDrop.add(col);
}
}

double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
for (int i = 1; i < getHeight(); i++) {
int col = 0;
for (int j = 0; j < getWidth(); j++) {
if (!columnsToDrop.contains(j)) {
matrix[i - 1][col++] = tableau.getEntry(i, j);
}
}
}

for (int i = columnsToDrop.size() - 1; i >= 0; i--) {
columnLabels.remove((int) columnsToDrop.get(i));
}

this.tableau = new Array2DRowRealMatrix(matrix);
this.numArtificialVariables = 0;
}"
Math_33b_3,/home/common/huangzhili/defects4j_buggy_3/Math_33_buggy/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java,"private LinearConstraint normalize(final LinearConstraint constraint) {
if (constraint.getValue() < 0) {
return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),
constraint.getRelationship().oppositeRelationship(),
-1 * constraint.getValue());
}
return new LinearConstraint(constraint.getCoefficients(),
constraint.getRelationship(), constraint.getValue());
}"
Math_33b_4,/home/common/huangzhili/defects4j_buggy_3/Math_33_buggy/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java,"protected void initializeColumnLabels() {
if (getNumObjectiveFunctions() == 2) {
columnLabels.add(""W"");
}
columnLabels.add(""Z"");
for (int i = 0; i < getOriginalNumDecisionVariables(); i++) {
columnLabels.add(""x"" + i);
}
if (!restrictToNonNegative) {
columnLabels.add(NEGATIVE_VAR_COLUMN_LABEL);
}
for (int i = 0; i < getNumSlackVariables(); i++) {
columnLabels.add(""s"" + i);
}
for (int i = 0; i < getNumArtificialVariables(); i++) {
columnLabels.add(""a"" + i);
}
columnLabels.add(""RHS"");
}"
Math_33b_5,/home/common/huangzhili/defects4j_buggy_3/Math_33_buggy/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java,"protected RealMatrix createTableau(final boolean maximize) {

// create a matrix of the correct size
int width = numDecisionVariables + numSlackVariables +
numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS
int height = constraints.size() + getNumObjectiveFunctions();
Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);

// initialize the objective function rows
if (getNumObjectiveFunctions() == 2) {
matrix.setEntry(0, 0, -1);
}
int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;
matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1);
RealVector objectiveCoefficients =
maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();
copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]);
matrix.setEntry(zIndex, width - 1,
maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());

if (!restrictToNonNegative) {
matrix.setEntry(zIndex, getSlackVariableOffset() - 1,
getInvertedCoefficientSum(objectiveCoefficients));
}

// initialize the constraint rows
int slackVar = 0;
int artificialVar = 0;
for (int i = 0; i < constraints.size(); i++) {
LinearConstraint constraint = constraints.get(i);
int row = getNumObjectiveFunctions() + i;

// decision variable coefficients
copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]);

// x-
if (!restrictToNonNegative) {
matrix.setEntry(row, getSlackVariableOffset() - 1,
getInvertedCoefficientSum(constraint.getCoefficients()));
}

// RHS
matrix.setEntry(row, width - 1, constraint.getValue());

// slack variables
if (constraint.getRelationship() == Relationship.LEQ) {
matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);  // slack
} else if (constraint.getRelationship() == Relationship.GEQ) {
matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess
}

// artificial variables
if ((constraint.getRelationship() == Relationship.EQ) ||
(constraint.getRelationship() == Relationship.GEQ)) {
matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);
matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);
matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));
}
}

return matrix;
}"
Math_34b_1,/home/common/huangzhili/defects4j_buggy_3/Math_34_buggy/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java,Incomplete method body detected.
Math_34b_2,/home/common/huangzhili/defects4j_buggy_3/Math_34_buggy/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java,"public void addChromosomes(final Collection<Chromosome> chromosomeColl) {
if (chromosomes.size() + chromosomeColl.size() > populationLimit) {
throw new NumberIsTooLargeException(LocalizedFormats.LIST_OF_CHROMOSOMES_BIGGER_THAN_POPULATION_SIZE,
chromosomes.size(), populationLimit, false);
}
this.chromosomes.addAll(chromosomeColl);
}"
Math_34b_3,/home/common/huangzhili/defects4j_buggy_3/Math_34_buggy/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java,"public ListPopulation(final int populationLimit) {
this(Collections.<Chromosome> emptyList(), populationLimit);
}"
Math_38b_1,/home/common/huangzhili/defects4j_buggy_3/Math_38_buggy/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java,"private void prelim(double[] lowerBound,
double[] upperBound) {
printMethod(); // XXX

final int n = currentBest.getDimension();
final int npt = numberOfInterpolationPoints;
final int ndim = bMatrix.getRowDimension();

final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;
final double recip = 1d / rhosq;
final int np = n + 1;

// Set XBASE to the initial vector of variables, and set the initial
// elements of XPT, BMAT, HQ, PQ and ZMAT to zero.

for (int j = 0; j < n; j++) {
originShift.setEntry(j, currentBest.getEntry(j));
for (int k = 0; k < npt; k++) {
interpolationPoints.setEntry(k, j, ZERO);
}
for (int i = 0; i < ndim; i++) {
bMatrix.setEntry(i, j, ZERO);
}
}
for (int i = 0, max = n * np / 2; i < max; i++) {
modelSecondDerivativesValues.setEntry(i, ZERO);
}
for (int k = 0; k < npt; k++) {
modelSecondDerivativesParameters.setEntry(k, ZERO);
for (int j = 0, max = npt - np; j < max; j++) {
zMatrix.setEntry(k, j, ZERO);
}
}

// Begin the initialization procedure. NF becomes one more than the number
// of function values so far. The coordinates of the displacement of the
// next initial interpolation point from XBASE are set in XPT(NF+1,.).

int ipt = 0;
int jpt = 0;
double fbeg = Double.NaN;
do {
final int nfm = getEvaluations();
final int nfx = nfm - n;
final int nfmm = nfm - 1;
final int nfxm = nfx - 1;
double stepa = 0;
double stepb = 0;
if (nfm <= 2 * n) {
if (nfm >= 1 &&
nfm <= n) {
stepa = initialTrustRegionRadius;
if (upperDifference.getEntry(nfmm) == ZERO) {
stepa = -stepa;
throw new PathIsExploredException(); // XXX
}
interpolationPoints.setEntry(nfm, nfmm, stepa);
} else if (nfm > n) {
stepa = interpolationPoints.getEntry(nfx, nfxm);
stepb = -initialTrustRegionRadius;
if (lowerDifference.getEntry(nfxm) == ZERO) {
stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));
throw new PathIsExploredException(); // XXX
}
if (upperDifference.getEntry(nfxm) == ZERO) {
stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));
throw new PathIsExploredException(); // XXX
}
interpolationPoints.setEntry(nfm, nfxm, stepb);
}
} else {
final int tmp1 = (nfm - np) / n;
jpt = nfm - tmp1 * n - n;
ipt = jpt + tmp1;
if (ipt > n) {
final int tmp2 = jpt;
jpt = ipt - n;
ipt = tmp2;
throw new PathIsExploredException(); // XXX
}
final int iptMinus1 = ipt;
final int jptMinus1 = jpt;
interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
}

// Calculate the next value of F. The least function value so far and
// its index are required.

for (int j = 0; j < n; j++) {
currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],
originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),
upperBound[j]));
if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {
currentBest.setEntry(j, lowerBound[j]);
}
if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {
currentBest.setEntry(j, upperBound[j]);
}
}

final double objectiveValue = computeObjectiveValue(currentBest.toArray());
final double f = isMinimize ? objectiveValue : -objectiveValue;
final int numEval = getEvaluations(); // nfm + 1
fAtInterpolationPoints.setEntry(nfm, f);

if (numEval == 1) {
fbeg = f;
trustRegionCenterInterpolationPointIndex = 0;
} else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {
trustRegionCenterInterpolationPointIndex = nfm;
}

// Set the nonzero initial elements of BMAT and the quadratic model in the
// cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions
// of the NF-th and (NF-N)-th interpolation points may be switched, in
// order that the function value at the first of them contributes to the
// off-diagonal second derivative terms of the initial quadratic model.

if (numEval <= 2 * n + 1) {
if (numEval >= 2 &&
numEval <= n + 1) {
gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);
if (npt < numEval + n) {
final double oneOverStepA = ONE / stepa;
bMatrix.setEntry(0, nfmm, -oneOverStepA);
bMatrix.setEntry(nfm, nfmm, oneOverStepA);
bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);
throw new PathIsExploredException(); // XXX
}
} else if (numEval >= n + 2) {
final int ih = nfx * (nfx + 1) / 2 - 1;
final double tmp = (f - fbeg) / stepb;
final double diff = stepb - stepa;
modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);
gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);
if (stepa * stepb < ZERO) {
if (f < fAtInterpolationPoints.getEntry(nfm - n)) {
fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));
fAtInterpolationPoints.setEntry(nfm - n, f);
if (trustRegionCenterInterpolationPointIndex == nfm) {
trustRegionCenterInterpolationPointIndex = nfm - n;
}
interpolationPoints.setEntry(nfm - n, nfxm, stepb);
interpolationPoints.setEntry(nfm, nfxm, stepa);
}
}
bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));
bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));
bMatrix.setEntry(nfm - n, nfxm,
-bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));
zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));
zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);
// zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX ""testAckley"" and ""testDiffPow"" fail.
zMatrix.setEntry(nfm - n, nfxm,
-zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));
}

// Set the off-diagonal second derivatives of the Lagrange functions and
// the initial quadratic model.

} else {
zMatrix.setEntry(0, nfxm, recip);
zMatrix.setEntry(nfm, nfxm, recip);
zMatrix.setEntry(ipt, nfxm, -recip);
zMatrix.setEntry(jpt, nfxm, -recip);

final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
throw new PathIsExploredException(); // XXX
}
} while (getEvaluations() < npt);
} // prelim"
Math_38b_2,/home/common/huangzhili/defects4j_buggy_3/Math_38_buggy/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java,"private static String caller(int n) {
final Throwable t = new Throwable();
final StackTraceElement[] elements = t.getStackTrace();
final StackTraceElement e = elements[n];
return e.getMethodName() + "" (at line "" + e.getLineNumber() + "")"";
}"
Math_38b_3,/home/common/huangzhili/defects4j_buggy_3/Math_38_buggy/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java,"private void setup(double[] lowerBound,
double[] upperBound) {
printMethod(); // XXX

double[] init = getStartPoint();
final int dimension = init.length;

// Check problem dimension.
if (dimension < MINIMUM_PROBLEM_DIMENSION) {
throw new NumberIsTooSmallException(dimension, MINIMUM_PROBLEM_DIMENSION, true);
}
// Check number of interpolation points.
final int[] nPointsInterval = { dimension + 2, (dimension + 2) * (dimension + 1) / 2 };
if (numberOfInterpolationPoints < nPointsInterval[0] ||
numberOfInterpolationPoints > nPointsInterval[1]) {
throw new OutOfRangeException(LocalizedFormats.NUMBER_OF_INTERPOLATION_POINTS,
numberOfInterpolationPoints,
nPointsInterval[0],
nPointsInterval[1]);
}

// Initialize bound differences.
boundDifference = new double[dimension];

double requiredMinDiff = 2 * initialTrustRegionRadius;
double minDiff = Double.POSITIVE_INFINITY;
for (int i = 0; i < dimension; i++) {
boundDifference[i] = upperBound[i] - lowerBound[i];
minDiff = Math.min(minDiff, boundDifference[i]);
}
if (minDiff < requiredMinDiff) {
initialTrustRegionRadius = minDiff / 3.0;
}

// Initialize the data structures used by the ""bobyqa"" method.
bMatrix = new Array2DRowRealMatrix(dimension + numberOfInterpolationPoints,
dimension);
zMatrix = new Array2DRowRealMatrix(numberOfInterpolationPoints,
numberOfInterpolationPoints - dimension - 1);
interpolationPoints = new Array2DRowRealMatrix(numberOfInterpolationPoints,
dimension);
originShift = new ArrayRealVector(dimension);
fAtInterpolationPoints = new ArrayRealVector(numberOfInterpolationPoints);
trustRegionCenterOffset = new ArrayRealVector(dimension);
gradientAtTrustRegionCenter = new ArrayRealVector(dimension);
lowerDifference = new ArrayRealVector(dimension);
upperDifference = new ArrayRealVector(dimension);
modelSecondDerivativesParameters = new ArrayRealVector(numberOfInterpolationPoints);
newPoint = new ArrayRealVector(dimension);
alternativeNewPoint = new ArrayRealVector(dimension);
trialStepPoint = new ArrayRealVector(dimension);
lagrangeValuesAtNewPoint = new ArrayRealVector(dimension + numberOfInterpolationPoints);
modelSecondDerivativesValues = new ArrayRealVector(dimension * (dimension + 1) / 2);
}"
Math_38b_4,/home/common/huangzhili/defects4j_buggy_3/Math_38_buggy/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java,"protected RealPointValuePair doOptimize() {
final double[] lowerBound = getLowerBound();
final double[] upperBound = getUpperBound();

// Validity checks.
setup(lowerBound, upperBound);

isMinimize = (getGoalType() == GoalType.MINIMIZE);
currentBest = new ArrayRealVector(getStartPoint());

final double value = bobyqa(lowerBound, upperBound);

return new RealPointValuePair(currentBest.getDataRef(),
isMinimize ? value : -value);
}"
Math_38b_5,/home/common/huangzhili/defects4j_buggy_3/Math_38_buggy/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java,"private double bobyqa(double[] lowerBound,
double[] upperBound) {
printMethod(); // XXX

final int n = currentBest.getDimension();

// Return if there is insufficient space between the bounds. Modify the
// initial X if necessary in order to avoid conflicts between the bounds
// and the construction of the first quadratic model. The lower and upper
// bounds on moves from the updated X are set now, in the ISL and ISU
// partitions of W, in order to provide useful and exact information about
// components of X that become within distance RHOBEG from their bounds.

for (int j = 0; j < n; j++) {
final double boundDiff = boundDifference[j];
lowerDifference.setEntry(j, lowerBound[j] - currentBest.getEntry(j));
upperDifference.setEntry(j, upperBound[j] - currentBest.getEntry(j));
if (lowerDifference.getEntry(j) >= -initialTrustRegionRadius) {
if (lowerDifference.getEntry(j) >= ZERO) {
currentBest.setEntry(j, lowerBound[j]);
lowerDifference.setEntry(j, ZERO);
upperDifference.setEntry(j, boundDiff);
} else {
currentBest.setEntry(j, lowerBound[j] + initialTrustRegionRadius);
lowerDifference.setEntry(j, -initialTrustRegionRadius);
// Computing MAX
final double deltaOne = upperBound[j] - currentBest.getEntry(j);
upperDifference.setEntry(j, Math.max(deltaOne, initialTrustRegionRadius));
}
} else if (upperDifference.getEntry(j) <= initialTrustRegionRadius) {
if (upperDifference.getEntry(j) <= ZERO) {
currentBest.setEntry(j, upperBound[j]);
lowerDifference.setEntry(j, -boundDiff);
upperDifference.setEntry(j, ZERO);
} else {
currentBest.setEntry(j, upperBound[j] - initialTrustRegionRadius);
// Computing MIN
final double deltaOne = lowerBound[j] - currentBest.getEntry(j);
final double deltaTwo = -initialTrustRegionRadius;
lowerDifference.setEntry(j, Math.min(deltaOne, deltaTwo));
upperDifference.setEntry(j, initialTrustRegionRadius);
}
}
}

// Make the call of BOBYQB.

return bobyqb(lowerBound, upperBound);
} // bobyqa"
Math_39b_1,/home/common/huangzhili/defects4j_buggy_3/Math_39_buggy/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java,"public void integrate(final ExpandableStatefulODE equations, final double t)
throws MathIllegalStateException, MathIllegalArgumentException {

sanityChecks(equations, t);
setEquations(equations);
final boolean forward = t > equations.getTime();

// create some internal working arrays
final double[] y0  = equations.getCompleteState();
final double[] y = y0.clone();
final int stages = c.length + 1;
final double[][] yDotK = new double[stages][y.length];
final double[] yTmp    = y0.clone();
final double[] yDotTmp = new double[y.length];

// set up an interpolator sharing the integrator arrays
final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
interpolator.reinitialize(this, yTmp, yDotK, forward,
equations.getPrimaryMapper(), equations.getSecondaryMappers());
interpolator.storeTime(equations.getTime());

// set up integration control objects
stepStart         = equations.getTime();
double  hNew      = 0;
boolean firstTime = true;
initIntegration(equations.getTime(), y0, t);

// main integration loop
isLastStep = false;
do {

interpolator.shift();

// iterate over step size, ensuring local normalized error is smaller than 1
double error = 10;
while (error >= 1.0) {

if (firstTime || !fsal) {
// first stage
computeDerivatives(stepStart, y, yDotK[0]);
}

if (firstTime) {
final double[] scale = new double[mainSetDimension];
if (vecAbsoluteTolerance == null) {
for (int i = 0; i < scale.length; ++i) {
scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
}
} else {
for (int i = 0; i < scale.length; ++i) {
scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
}
}
hNew = initializeStep(forward, getOrder(), scale,
stepStart, y, yDotK[0], yTmp, yDotK[1]);
firstTime = false;
}

stepSize = hNew;

// next stages
for (int k = 1; k < stages; ++k) {

for (int j = 0; j < y0.length; ++j) {
double sum = a[k-1][0] * yDotK[0][j];
for (int l = 1; l < k; ++l) {
sum += a[k-1][l] * yDotK[l][j];
}
yTmp[j] = y[j] + stepSize * sum;
}

computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);

}

// estimate the state at the end of the step
for (int j = 0; j < y0.length; ++j) {
double sum    = b[0] * yDotK[0][j];
for (int l = 1; l < stages; ++l) {
sum    += b[l] * yDotK[l][j];
}
yTmp[j] = y[j] + stepSize * sum;
}

// estimate the error at the end of the step
error = estimateError(yDotK, y, yTmp, stepSize);
if (error >= 1.0) {
// reject the step and attempt to reduce error by stepsize control
final double factor =
FastMath.min(maxGrowth,
FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
hNew = filterStep(stepSize * factor, forward, false);
}

}

// local error is small enough: accept the step, trigger events and step handlers
interpolator.storeTime(stepStart + stepSize);
System.arraycopy(yTmp, 0, y, 0, y0.length);
System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
stepStart = acceptStep(interpolator, y, yDotTmp, t);
System.arraycopy(y, 0, yTmp, 0, y.length);

if (!isLastStep) {

// prepare next step
interpolator.storeTime(stepStart);

if (fsal) {
// save the last evaluation for the next step
System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
}

// stepsize control for next step
final double factor =
FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
final double  scaledH    = stepSize * factor;
final double  nextT      = stepStart + scaledH;
final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
hNew = filterStep(scaledH, forward, nextIsLast);

final double  filteredNextT      = stepStart + hNew;
final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
if (filteredNextIsLast) {
hNew = t - stepStart;
}

}

} while (!isLastStep);

// dispatch results
equations.setTime(stepStart);
equations.setCompleteState(y);

resetInternalState();

}"
Math_39b_2,/home/common/huangzhili/defects4j_buggy_3/Math_39_buggy/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java,"protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,
final double[] c, final double[][] a, final double[] b,"
Math_39b_3,/home/common/huangzhili/defects4j_buggy_3/Math_39_buggy/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java,"public void setSafety(final double safety) {
this.safety = safety;
}"
Math_39b_4,/home/common/huangzhili/defects4j_buggy_3/Math_39_buggy/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java,"public void setMinReduction(final double minReduction) {
this.minReduction = minReduction;
}"
Math_39b_5,/home/common/huangzhili/defects4j_buggy_3/Math_39_buggy/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java,"public void setMaxGrowth(final double maxGrowth) {
this.maxGrowth = maxGrowth;
}"
Math_40b_1,/home/common/huangzhili/defects4j_buggy_3/Math_40_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java,"public double solve(int maxEval, UnivariateFunction f, double min,
double max, double startValue,"
Math_40b_2,/home/common/huangzhili/defects4j_buggy_3/Math_40_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java,"public BracketingNthOrderBrentSolver(final double relativeAccuracy,
final double absoluteAccuracy,"
Math_40b_3,/home/common/huangzhili/defects4j_buggy_3/Math_40_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java,"protected double doSolve() {

// prepare arrays with the first points
final double[] x = new double[maximalOrder + 1];
final double[] y = new double[maximalOrder + 1];
x[0] = getMin();
x[1] = getStartValue();
x[2] = getMax();
verifySequence(x[0], x[1], x[2]);

// evaluate initial guess
y[1] = computeObjectiveValue(x[1]);
if (Precision.equals(y[1], 0.0, 1)) {
// return the initial guess if it is a perfect root.
return x[1];
}

// evaluate first  endpoint
y[0] = computeObjectiveValue(x[0]);
if (Precision.equals(y[0], 0.0, 1)) {
// return the first endpoint if it is a perfect root.
return x[0];
}

int nbPoints;
int signChangeIndex;
if (y[0] * y[1] < 0) {

// reduce interval if it brackets the root
nbPoints        = 2;
signChangeIndex = 1;

} else {

// evaluate second endpoint
y[2] = computeObjectiveValue(x[2]);
if (Precision.equals(y[2], 0.0, 1)) {
// return the second endpoint if it is a perfect root.
return x[2];
}

if (y[1] * y[2] < 0) {
// use all computed point as a start sampling array for solving
nbPoints        = 3;
signChangeIndex = 2;
} else {
throw new NoBracketingException(x[0], x[2], y[0], y[2]);
}

}

// prepare a work array for inverse polynomial interpolation
final double[] tmpX = new double[x.length];

// current tightest bracketing of the root
double xA    = x[signChangeIndex - 1];
double yA    = y[signChangeIndex - 1];
double absYA = FastMath.abs(yA);
int agingA   = 0;
double xB    = x[signChangeIndex];
double yB    = y[signChangeIndex];
double absYB = FastMath.abs(yB);
int agingB   = 0;

// search loop
while (true) {

// check convergence of bracketing interval
final double xTol = getAbsoluteAccuracy() +
getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));
if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {
switch (allowed) {
case ANY_SIDE :
return absYA < absYB ? xA : xB;
case LEFT_SIDE :
return xA;
case RIGHT_SIDE :
return xB;
case BELOW_SIDE :
return (yA <= 0) ? xA : xB;
case ABOVE_SIDE :
return (yA <  0) ? xB : xA;
default :
// this should never happen
throw new MathInternalError(null);
}
}

// target for the next evaluation point
double targetY;
if (agingA >= MAXIMAL_AGING) {
// we keep updating the high bracket, try to compensate this
targetY = -REDUCTION_FACTOR * yB;
} else if (agingB >= MAXIMAL_AGING) {
// we keep updating the low bracket, try to compensate this
targetY = -REDUCTION_FACTOR * yA;
} else {
// bracketing is balanced, try to find the root itself
targetY = 0;
}

// make a few attempts to guess a root,
double nextX;
int start = 0;
int end   = nbPoints;
do {

// guess a value for current target, using inverse polynomial interpolation
System.arraycopy(x, start, tmpX, start, end - start);
nextX = guessX(targetY, tmpX, y, start, end);

if (!((nextX > xA) && (nextX < xB))) {
// the guessed root is not strictly inside of the tightest bracketing interval

// the guessed root is either not strictly inside the interval or it
// is a NaN (which occurs when some sampling points share the same y)
// we try again with a lower interpolation order
if (signChangeIndex - start >= end - signChangeIndex) {
// we have more points before the sign change, drop the lowest point
++start;
} else {
// we have more points after sign change, drop the highest point
--end;
}

// we need to do one more attempt
nextX = Double.NaN;

}

} while (Double.isNaN(nextX) && (end - start > 1));

if (Double.isNaN(nextX)) {
// fall back to bisection
nextX = xA + 0.5 * (xB - xA);
start = signChangeIndex - 1;
end   = signChangeIndex;
}

// evaluate the function at the guessed root
final double nextY = computeObjectiveValue(nextX);
if (Precision.equals(nextY, 0.0, 1)) {
// we have found an exact root, since it is not an approximation
// we don't need to bother about the allowed solutions setting
return nextX;
}

if ((nbPoints > 2) && (end - start != nbPoints)) {

// we have been forced to ignore some points to keep bracketing,
// they are probably too far from the root, drop them from now on
nbPoints = end - start;
System.arraycopy(x, start, x, 0, nbPoints);
System.arraycopy(y, start, y, 0, nbPoints);
signChangeIndex -= start;

} else  if (nbPoints == x.length) {

// we have to drop one point in order to insert the new one
nbPoints--;

// keep the tightest bracketing interval as centered as possible
if (signChangeIndex >= (x.length + 1) / 2) {
// we drop the lowest point, we have to shift the arrays and the index
System.arraycopy(x, 1, x, 0, nbPoints);
System.arraycopy(y, 1, y, 0, nbPoints);
--signChangeIndex;
}

}

// insert the last computed point
//(by construction, we know it lies inside the tightest bracketing interval)
System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);
x[signChangeIndex] = nextX;
System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);
y[signChangeIndex] = nextY;
++nbPoints;

// update the bracketing interval
if (nextY * yA <= 0) {
// the sign change occurs before the inserted point
xB = nextX;
yB = nextY;
absYB = FastMath.abs(yB);
++agingA;
agingB = 0;
} else {
// the sign change occurs after the inserted point
xA = nextX;
yA = nextY;
absYA = FastMath.abs(yA);
agingA = 0;
++agingB;

// update the sign change index
signChangeIndex++;

}

}

}"
Math_40b_4,/home/common/huangzhili/defects4j_buggy_3/Math_40_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java,"private double guessX(final double targetY, final double[] x, final double[] y,
final int start, final int end) {

// compute Q Newton coefficients by divided differences
for (int i = start; i < end - 1; ++i) {
final int delta = i + 1 - start;
for (int j = end - 1; j > i; --j) {
x[j] = (x[j] - x[j-1]) / (y[j] - y[j - delta]);
}
}

// evaluate Q(targetY)
double x0 = 0;
for (int j = end - 1; j >= start; --j) {
x0 = x[j] + x0 * (targetY - y[j]);
}

return x0;

}"
Math_41b_1,/home/common/huangzhili/defects4j_buggy_3/Math_41_buggy/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java,"public double evaluate(final double[] values, final double[] weights,
final int begin, final int length) {

double var = Double.NaN;

if (test(values, weights,begin, length)) {
clear();
if (length == 1) {
var = 0.0;
} else if (length > 1) {
Mean mean = new Mean();
double m = mean.evaluate(values, weights, begin, length);
var = evaluate(values, weights, m, begin, length);
}
}
return var;
}"
Math_41b_2,/home/common/huangzhili/defects4j_buggy_3/Math_41_buggy/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java,"public void clear() {
if (incMoment) {
moment.clear();
}
}"
Math_42b_1,/home/common/huangzhili/defects4j_buggy_3/Math_42_buggy/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,"protected void dropPhase1Objective() {
if (getNumObjectiveFunctions() == 1) {
return;
}

List<Integer> columnsToDrop = new ArrayList<Integer>();
columnsToDrop.add(0);

// positive cost non-artificial variables
for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
final double entry = tableau.getEntry(0, i);
if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
columnsToDrop.add(i);
}
}

// non-basic artificial variables
for (int i = 0; i < getNumArtificialVariables(); i++) {
int col = i + getArtificialVariableOffset();
if (getBasicRow(col) == null) {
columnsToDrop.add(col);
}
}

double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];
for (int i = 1; i < getHeight(); i++) {
int col = 0;
for (int j = 0; j < getWidth(); j++) {
if (!columnsToDrop.contains(j)) {
matrix[i - 1][col++] = tableau.getEntry(i, j);
}
}
}

for (int i = columnsToDrop.size() - 1; i >= 0; i--) {
columnLabels.remove((int) columnsToDrop.get(i));
}

this.tableau = new Array2DRowRealMatrix(matrix);
this.numArtificialVariables = 0;
}"
Math_42b_2,/home/common/huangzhili/defects4j_buggy_3/Math_42_buggy/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,"protected Integer getBasicRow(final int col) {
Integer row = null;
for (int i = 0; i < getHeight(); i++) {
final double entry = getEntry(i, col);
if (Precision.equals(entry, 1d, maxUlps) && (row == null)) {
row = i;
} else if (!Precision.equals(entry, 0d, maxUlps)) {
return null;
}
}
return row;
}"
Math_42b_3,/home/common/huangzhili/defects4j_buggy_3/Math_42_buggy/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,"protected void initializeColumnLabels() {
if (getNumObjectiveFunctions() == 2) {
columnLabels.add(""W"");
}
columnLabels.add(""Z"");
for (int i = 0; i < getOriginalNumDecisionVariables(); i++) {
columnLabels.add(""x"" + i);
}
if (!restrictToNonNegative) {
columnLabels.add(NEGATIVE_VAR_COLUMN_LABEL);
}
for (int i = 0; i < getNumSlackVariables(); i++) {
columnLabels.add(""s"" + i);
}
for (int i = 0; i < getNumArtificialVariables(); i++) {
columnLabels.add(""a"" + i);
}
columnLabels.add(""RHS"");
}"
Math_42b_4,/home/common/huangzhili/defects4j_buggy_3/Math_42_buggy/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,"protected RealMatrix createTableau(final boolean maximize) {

// create a matrix of the correct size
int width = numDecisionVariables + numSlackVariables +
numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS
int height = constraints.size() + getNumObjectiveFunctions();
Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);

// initialize the objective function rows
if (getNumObjectiveFunctions() == 2) {
matrix.setEntry(0, 0, -1);
}
int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;
matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1);
RealVector objectiveCoefficients =
maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();
copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]);
matrix.setEntry(zIndex, width - 1,
maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());

if (!restrictToNonNegative) {
matrix.setEntry(zIndex, getSlackVariableOffset() - 1,
getInvertedCoefficientSum(objectiveCoefficients));
}

// initialize the constraint rows
int slackVar = 0;
int artificialVar = 0;
for (int i = 0; i < constraints.size(); i++) {
LinearConstraint constraint = constraints.get(i);
int row = getNumObjectiveFunctions() + i;

// decision variable coefficients
copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]);

// x-
if (!restrictToNonNegative) {
matrix.setEntry(row, getSlackVariableOffset() - 1,
getInvertedCoefficientSum(constraint.getCoefficients()));
}

// RHS
matrix.setEntry(row, width - 1, constraint.getValue());

// slack variables
if (constraint.getRelationship() == Relationship.LEQ) {
matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);  // slack
} else if (constraint.getRelationship() == Relationship.GEQ) {
matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess
}

// artificial variables
if ((constraint.getRelationship() == Relationship.EQ) ||
(constraint.getRelationship() == Relationship.GEQ)) {
matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);
matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);
matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));
}
}

return matrix;
}"
Math_42b_5,/home/common/huangzhili/defects4j_buggy_3/Math_42_buggy/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,"protected RealPointValuePair getSolution() {
int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);
Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;
double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());

Set<Integer> basicRows = new HashSet<Integer>();
double[] coefficients = new double[getOriginalNumDecisionVariables()];
for (int i = 0; i < coefficients.length; i++) {
int colIndex = columnLabels.indexOf(""x"" + i);
if (colIndex < 0) {
coefficients[i] = 0;
continue;
}
Integer basicRow = getBasicRow(colIndex);
// if the basic row is found to be the objective function row
// set the coefficient to 0 -> this case handles unconstrained
// variables that are still part of the objective function
if (basicRows.contains(basicRow)) {
// if multiple variables can take a given value
// then we choose the first and set the rest equal to 0
coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
} else {
basicRows.add(basicRow);
coefficients[i] =
(basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
(restrictToNonNegative ? 0 : mostNegative);
}
}
return new RealPointValuePair(coefficients, f.getValue(coefficients));
}"
Math_43b_1,/home/common/huangzhili/defects4j_buggy_3/Math_43_buggy/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java,"private void checkEmpty() {
if (n > 0) {
throw new MathIllegalStateException(
LocalizedFormats.VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC, n);
}
}"
Math_43b_2,/home/common/huangzhili/defects4j_buggy_3/Math_43_buggy/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java,"public void setGeoMeanImpl(StorelessUnivariateStatistic geoMeanImpl) {
checkEmpty();
this.geoMeanImpl = geoMeanImpl;
}"
Math_43b_3,/home/common/huangzhili/defects4j_buggy_3/Math_43_buggy/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java,"public void setVarianceImpl(StorelessUnivariateStatistic varianceImpl) {
checkEmpty();
this.varianceImpl = varianceImpl;
}"
Math_43b_4,/home/common/huangzhili/defects4j_buggy_3/Math_43_buggy/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java,"public void addValue(double value) {
sumImpl.increment(value);
sumsqImpl.increment(value);
minImpl.increment(value);
maxImpl.increment(value);
sumLogImpl.increment(value);
secondMoment.increment(value);
// If mean, variance or geomean have been overridden,
// need to increment these
if (!(meanImpl instanceof Mean)) {
meanImpl.increment(value);
}
if (!(varianceImpl instanceof Variance)) {
varianceImpl.increment(value);
}
if (!(geoMeanImpl instanceof GeometricMean)) {
geoMeanImpl.increment(value);
}
n++;
}"
Math_43b_5,/home/common/huangzhili/defects4j_buggy_3/Math_43_buggy/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java,"public void setMeanImpl(StorelessUnivariateStatistic meanImpl) {
checkEmpty();
this.meanImpl = meanImpl;
}"
Math_44b_1,/home/common/huangzhili/defects4j_buggy_3/Math_44_buggy/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java,"public AbstractIntegrator(final String name) {
this.name = name;
stepHandlers = new ArrayList<StepHandler>();
stepStart = Double.NaN;
stepSize  = Double.NaN;
eventsStates = new ArrayList<EventState>();
statesInitialized = false;
evaluations = new Incrementor();
setMaxEvaluations(-1);
resetEvaluations();
}"
Math_44b_2,/home/common/huangzhili/defects4j_buggy_3/Math_44_buggy/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java,"addEventHandler(handler, maxCheckInterval, convergence,
maxIterationCount,"
Math_44b_3,/home/common/huangzhili/defects4j_buggy_3/Math_44_buggy/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java,"public void setMaxEvaluations(int maxEvaluations) {
evaluations.setMaximalCount((maxEvaluations < 0) ? Integer.MAX_VALUE : maxEvaluations);
}"
Math_44b_4,/home/common/huangzhili/defects4j_buggy_3/Math_44_buggy/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java,"protected void resetEvaluations() {
evaluations.resetCount();
}"
Math_44b_5,/home/common/huangzhili/defects4j_buggy_3/Math_44_buggy/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java,"protected void setEquations(final ExpandableStatefulODE equations) {
this.expandable = equations;
}"
Math_45b_1,/home/common/huangzhili/defects4j_buggy_3/Math_45_buggy/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java,"public OpenMapRealMatrix(int rowDimension, int columnDimension) {
super(rowDimension, columnDimension);
this.rows = rowDimension;
this.columns = columnDimension;
this.entries = new OpenIntToDoubleHashMap(0.0);
}"
Math_48b_1,/home/common/huangzhili/defects4j_buggy_3/Math_48_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java,"public double solve(final int maxEval, final UnivariateRealFunction f,
final double min, final double max, final double startValue,"
Math_48b_2,/home/common/huangzhili/defects4j_buggy_3/Math_48_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java,"protected final double doSolve() {
// Get initial solution
double x0 = getMin();
double x1 = getMax();
double f0 = computeObjectiveValue(x0);
double f1 = computeObjectiveValue(x1);

// If one of the bounds is the exact root, return it. Since these are
// not under-approximations or over-approximations, we can return them
// regardless of the allowed solutions.
if (f0 == 0.0) {
return x0;
}
if (f1 == 0.0) {
return x1;
}

// Verify bracketing of initial solution.
verifyBracketing(x0, x1);

// Get accuracies.
final double ftol = getFunctionValueAccuracy();
final double atol = getAbsoluteAccuracy();
final double rtol = getRelativeAccuracy();

// Keep track of inverted intervals, meaning that the left bound is
// larger than the right bound.
boolean inverted = false;

// Keep finding better approximations.
while (true) {
// Calculate the next approximation.
final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
final double fx = computeObjectiveValue(x);

// If the new approximation is the exact root, return it. Since
// this is not an under-approximation or an over-approximation,
// we can return it regardless of the allowed solutions.
if (fx == 0.0) {
return x;
}

// Update the bounds with the new approximation.
if (f1 * fx < 0) {
// The value of x1 has switched to the other bound, thus inverting
// the interval.
x0 = x1;
f0 = f1;
inverted = !inverted;
} else {
switch (method) {
case ILLINOIS:
f0 *= 0.5;
break;
case PEGASUS:
f0 *= f1 / (f1 + fx);
break;
case REGULA_FALSI:
// Detect early that algorithm is stuck, instead of waiting
// for the maximum number of iterations to be exceeded.
break;
default:
// Should never happen.
throw new MathInternalError();
}
}
// Update from [x0, x1] to [x0, x].
x1 = x;
f1 = fx;

// If the function value of the last approximation is too small,
// given the function value accuracy, then we can't get closer to
// the root than we already are.
if (FastMath.abs(f1) <= ftol) {
switch (allowed) {
case ANY_SIDE:
return x1;
case LEFT_SIDE:
if (inverted) {
return x1;
}
break;
case RIGHT_SIDE:
if (!inverted) {
return x1;
}
break;
case BELOW_SIDE:
if (f1 <= 0) {
return x1;
}
break;
case ABOVE_SIDE:
if (f1 >= 0) {
return x1;
}
break;
default:
throw new MathInternalError();
}
}

// If the current interval is within the given accuracies, we
// are satisfied with the current approximation.
if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
atol)) {
switch (allowed) {
case ANY_SIDE:
return x1;
case LEFT_SIDE:
return inverted ? x1 : x0;
case RIGHT_SIDE:
return inverted ? x0 : x1;
case BELOW_SIDE:
return (f1 <= 0) ? x1 : x0;
case ABOVE_SIDE:
return (f1 >= 0) ? x1 : x0;
default:
throw new MathInternalError();
}
}
}
}"
Math_50b_1,/home/common/huangzhili/defects4j_buggy_3/Math_50_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java,"protected final double doSolve() {
// Get initial solution
double x0 = getMin();
double x1 = getMax();
double f0 = computeObjectiveValue(x0);
double f1 = computeObjectiveValue(x1);

// If one of the bounds is the exact root, return it. Since these are
// not under-approximations or over-approximations, we can return them
// regardless of the allowed solutions.
if (f0 == 0.0) {
return x0;
}
if (f1 == 0.0) {
return x1;
}

// Verify bracketing of initial solution.
verifyBracketing(x0, x1);

// Get accuracies.
final double ftol = getFunctionValueAccuracy();
final double atol = getAbsoluteAccuracy();
final double rtol = getRelativeAccuracy();

// Keep track of inverted intervals, meaning that the left bound is
// larger than the right bound.
boolean inverted = false;

// Keep finding better approximations.
while (true) {
// Calculate the next approximation.
final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
final double fx = computeObjectiveValue(x);

// If the new approximation is the exact root, return it. Since
// this is not an under-approximation or an over-approximation,
// we can return it regardless of the allowed solutions.
if (fx == 0.0) {
return x;
}

// Update the bounds with the new approximation.
if (f1 * fx < 0) {
// The value of x1 has switched to the other bound, thus inverting
// the interval.
x0 = x1;
f0 = f1;
inverted = !inverted;
} else {
switch (method) {
case ILLINOIS:
f0 *= 0.5;
break;
case PEGASUS:
f0 *= f1 / (f1 + fx);
break;
case REGULA_FALSI:
// Nothing.
if (x == x1) {
x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
f0 = computeObjectiveValue(x0);
}
break;
default:
// Should never happen.
throw new MathInternalError();
}
}
// Update from [x0, x1] to [x0, x].
x1 = x;
f1 = fx;

// If the function value of the last approximation is too small,
// given the function value accuracy, then we can't get closer to
// the root than we already are.
if (FastMath.abs(f1) <= ftol) {
switch (allowed) {
case ANY_SIDE:
return x1;
case LEFT_SIDE:
if (inverted) {
return x1;
}
break;
case RIGHT_SIDE:
if (!inverted) {
return x1;
}
break;
case BELOW_SIDE:
if (f1 <= 0) {
return x1;
}
break;
case ABOVE_SIDE:
if (f1 >= 0) {
return x1;
}
break;
default:
throw new MathInternalError();
}
}

// If the current interval is within the given accuracies, we
// are satisfied with the current approximation.
if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
atol)) {
switch (allowed) {
case ANY_SIDE:
return x1;
case LEFT_SIDE:
return inverted ? x1 : x0;
case RIGHT_SIDE:
return inverted ? x0 : x1;
case BELOW_SIDE:
return (f1 <= 0) ? x1 : x0;
case ABOVE_SIDE:
return (f1 >= 0) ? x1 : x0;
default:
throw new MathInternalError();
}
}
}
}"
Math_50b_2,/home/common/huangzhili/defects4j_buggy_3/Math_50_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java,"public double solve(final int maxEval, final UnivariateRealFunction f,
final double min, final double max, final double startValue,"
Math_51b_1,/home/common/huangzhili/defects4j_buggy_3/Math_51_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java,"public double solve(final int maxEval, final UnivariateRealFunction f,
final double min, final double max, final double startValue,"
Math_51b_2,/home/common/huangzhili/defects4j_buggy_3/Math_51_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java,"protected final double doSolve() {
// Get initial solution
double x0 = getMin();
double x1 = getMax();
double f0 = computeObjectiveValue(x0);
double f1 = computeObjectiveValue(x1);

// If one of the bounds is the exact root, return it. Since these are
// not under-approximations or over-approximations, we can return them
// regardless of the allowed solutions.
if (f0 == 0.0) {
return x0;
}
if (f1 == 0.0) {
return x1;
}

// Verify bracketing of initial solution.
verifyBracketing(x0, x1);

// Get accuracies.
final double ftol = getFunctionValueAccuracy();
final double atol = getAbsoluteAccuracy();
final double rtol = getRelativeAccuracy();

// Keep track of inverted intervals, meaning that the left bound is
// larger than the right bound.
boolean inverted = false;

// Keep finding better approximations.
while (true) {
// Calculate the next approximation.
final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));
final double fx = computeObjectiveValue(x);

// If the new approximation is the exact root, return it. Since
// this is not an under-approximation or an over-approximation,
// we can return it regardless of the allowed solutions.
if (fx == 0.0) {
return x;
}

// Update the bounds with the new approximation.
if (f1 * fx < 0) {
// The value of x1 has switched to the other bound, thus inverting
// the interval.
x0 = x1;
f0 = f1;
inverted = !inverted;
} else {
switch (method) {
case ILLINOIS:
f0 *= 0.5;
break;
case PEGASUS:
f0 *= f1 / (f1 + fx);
break;
// Update formula cannot make any progress: Update the
// search interval.
default:
// Should never happen.
}
}
// Update from [x0, x1] to [x0, x].
x1 = x;
f1 = fx;

// If the function value of the last approximation is too small,
// given the function value accuracy, then we can't get closer to
// the root than we already are.
if (FastMath.abs(f1) <= ftol) {
switch (allowed) {
case ANY_SIDE:
return x1;
case LEFT_SIDE:
if (inverted) {
return x1;
}
break;
case RIGHT_SIDE:
if (!inverted) {
return x1;
}
break;
case BELOW_SIDE:
if (f1 <= 0) {
return x1;
}
break;
case ABOVE_SIDE:
if (f1 >= 0) {
return x1;
}
break;
default:
throw new MathInternalError();
}
}

// If the current interval is within the given accuracies, we
// are satisfied with the current approximation.
if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),
atol)) {
switch (allowed) {
case ANY_SIDE:
return x1;
case LEFT_SIDE:
return inverted ? x1 : x0;
case RIGHT_SIDE:
return inverted ? x0 : x1;
case BELOW_SIDE:
return (f1 <= 0) ? x1 : x0;
case ABOVE_SIDE:
return (f1 >= 0) ? x1 : x0;
default:
throw new MathInternalError();
}
}
}
}"
Math_52b_1,/home/common/huangzhili/defects4j_buggy_3/Math_52_buggy/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java,"public Rotation(double q0, double q1, double q2, double q3,
boolean needsNormalization) {

if (needsNormalization) {
// normalization preprocessing
double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);
q0 *= inv;
q1 *= inv;
q2 *= inv;
q3 *= inv;
}

this.q0 = q0;
this.q1 = q1;
this.q2 = q2;
this.q3 = q3;

}"
Math_52b_2,/home/common/huangzhili/defects4j_buggy_3/Math_52_buggy/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java,"public double getQ0() {
return q0;
}"
Math_53b_1,/home/common/huangzhili/defects4j_buggy_3/Math_53_buggy/src/main/java/org/apache/commons/math/complex/Complex.java,"public Complex add(Complex rhs)
throws NullArgumentException {
MathUtils.checkNotNull(rhs);
return createComplex(real + rhs.getReal(),
imaginary + rhs.getImaginary());
}"
Math_53b_2,/home/common/huangzhili/defects4j_buggy_3/Math_53_buggy/src/main/java/org/apache/commons/math/complex/Complex.java,"public boolean isNaN() {
return isNaN;
}"
Math_53b_3,/home/common/huangzhili/defects4j_buggy_3/Math_53_buggy/src/main/java/org/apache/commons/math/complex/Complex.java,"protected Complex createComplex(double realPart, double imaginaryPart) {
return new Complex(realPart, imaginaryPart);
}"
Math_53b_4,/home/common/huangzhili/defects4j_buggy_3/Math_53_buggy/src/main/java/org/apache/commons/math/complex/Complex.java,"public double getReal() {
return real;
}"
Math_53b_5,/home/common/huangzhili/defects4j_buggy_3/Math_53_buggy/src/main/java/org/apache/commons/math/complex/Complex.java,"public double getImaginary() {
return imaginary;
}"
Math_55b_1,/home/common/huangzhili/defects4j_buggy_3/Math_55_buggy/src/main/java/org/apache/commons/math/geometry/Vector3D.java,"public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {


// rescale both vectors without losing precision,
// to ensure their norm are the same order of magnitude

// we reduce cancellation errors by preconditioning,
// we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute
// v3 without loss of precision. See Kahan lecture
// ""Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces""
// available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf

// compute rho as an 8 bits approximation of v1.v2 / v2.v2


// compute cross product from v3 and v2 instead of v1 and v2
return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);

}"
Math_55b_2,/home/common/huangzhili/defects4j_buggy_3/Math_55_buggy/src/main/java/org/apache/commons/math/geometry/Vector3D.java,"public double getX() {
return x;
}"
Math_55b_3,/home/common/huangzhili/defects4j_buggy_3/Math_55_buggy/src/main/java/org/apache/commons/math/geometry/Vector3D.java,"public double getY() {
return y;
}"
Math_55b_4,/home/common/huangzhili/defects4j_buggy_3/Math_55_buggy/src/main/java/org/apache/commons/math/geometry/Vector3D.java,"public double getZ() {
return z;
}"
Math_55b_5,/home/common/huangzhili/defects4j_buggy_3/Math_55_buggy/src/main/java/org/apache/commons/math/geometry/Vector3D.java,"public Vector3D(double x, double y, double z) {
this.x = x;
this.y = y;
this.z = z;
}"
Math_56b_1,/home/common/huangzhili/defects4j_buggy_3/Math_56_buggy/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java,"public int[] getCounts(int index) {
if (index < 0 ||
index >= totalSize) {
throw new OutOfRangeException(index, 0, totalSize);
}

final int[] indices = new int[dimension];

int count = 0;
for (int i = 0; i < last; i++) {
int idx = 0;
final int offset = uniCounterOffset[i];
while (count <= index) {
count += offset;
++idx;
}
--idx;
count -= offset;
indices[i] = idx;
}

int idx = 1;
while (count < index) {
count += idx;
++idx;
}
--idx;
indices[last] = idx;

return indices;
}"
Math_56b_2,/home/common/huangzhili/defects4j_buggy_3/Math_56_buggy/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java,"public int getSize() {
return totalSize;
}"
Math_56b_3,/home/common/huangzhili/defects4j_buggy_3/Math_56_buggy/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java,"public Iterator iterator() {
return new Iterator();
}"
Math_56b_4,/home/common/huangzhili/defects4j_buggy_3/Math_56_buggy/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java,"public int getDimension() {
return dimension;
}"
Math_56b_5,/home/common/huangzhili/defects4j_buggy_3/Math_56_buggy/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java,"public int getCount(int ... c) throws OutOfRangeException {
if (c.length != dimension) {
throw new DimensionMismatchException(c.length, dimension);
}
int count = 0;
for (int i = 0; i < dimension; i++) {
final int index = c[i];
if (index < 0 ||
index >= size[i]) {
throw new OutOfRangeException(index, 0, size[i] - 1);
}
count += uniCounterOffset[i] * c[i];
}
return count + c[last];
}"
Math_57b_1,/home/common/huangzhili/defects4j_buggy_3/Math_57_buggy/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,"public KMeansPlusPlusClusterer(final Random random) {
this(random, EmptyClusterStrategy.LARGEST_VARIANCE);
}"
Math_57b_2,/home/common/huangzhili/defects4j_buggy_3/Math_57_buggy/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,"public List<Cluster<T>> cluster(final Collection<T> points,
final int k, final int maxIterations) {
// create the initial clusters
List<Cluster<T>> clusters = chooseInitialCenters(points, k, random);
assignPointsToClusters(clusters, points);

// iterate through updating the centers until we're done
final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations;
for (int count = 0; count < max; count++) {
boolean clusteringChanged = false;
List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>();
for (final Cluster<T> cluster : clusters) {
final T newCenter;
if (cluster.getPoints().isEmpty()) {
switch (emptyStrategy) {
case LARGEST_VARIANCE :
newCenter = getPointFromLargestVarianceCluster(clusters);
break;
case LARGEST_POINTS_NUMBER :
newCenter = getPointFromLargestNumberCluster(clusters);
break;
case FARTHEST_POINT :
newCenter = getFarthestPoint(clusters);
break;
default :
throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);
}
clusteringChanged = true;
} else {
newCenter = cluster.getCenter().centroidOf(cluster.getPoints());
if (!newCenter.equals(cluster.getCenter())) {
clusteringChanged = true;
}
}
newClusters.add(new Cluster<T>(newCenter));
}
if (!clusteringChanged) {
return clusters;
}
assignPointsToClusters(newClusters, points);
clusters = newClusters;
}
return clusters;
}"
Math_57b_3,/home/common/huangzhili/defects4j_buggy_3/Math_57_buggy/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,"chooseInitialCenters(final Collection<T> points, final int k, final Random random) {

final List<T> pointSet = new ArrayList<T>(points);
final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();

// Choose one center uniformly at random from among the data points.
final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));
resultSet.add(new Cluster<T>(firstPoint));

final double[] dx2 = new double[pointSet.size()];
while (resultSet.size() < k) {
// For each data point x, compute D(x), the distance between x and
// the nearest center that has already been chosen.
int sum = 0;
for (int i = 0; i < pointSet.size(); i++) {
final T p = pointSet.get(i);
final Cluster<T> nearest = getNearestCluster(resultSet, p);
final double d = p.distanceFrom(nearest.getCenter());
sum += d * d;
dx2[i] = sum;
}

// Add one new data point as a center. Each point x is chosen with
// probability proportional to D(x)2
final double r = random.nextDouble() * sum;
for (int i = 0 ; i < dx2.length; i++) {
if (dx2[i] >= r) {
final T p = pointSet.remove(i);
resultSet.add(new Cluster<T>(p));
break;
}
}
}

return resultSet;

}"
Math_57b_4,/home/common/huangzhili/defects4j_buggy_3/Math_57_buggy/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,"assignPointsToClusters(final Collection<Cluster<T>> clusters, final Collection<T> points) {
for (final T p : points) {
Cluster<T> cluster = getNearestCluster(clusters, p);
cluster.addPoint(p);
}
}"
Math_57b_5,/home/common/huangzhili/defects4j_buggy_3/Math_57_buggy/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java,"getNearestCluster(final Collection<Cluster<T>> clusters, final T point) {
double minDistance = Double.MAX_VALUE;
Cluster<T> minCluster = null;
for (final Cluster<T> c : clusters) {
final double distance = point.distanceFrom(c.getCenter());
if (distance < minDistance) {
minDistance = distance;
minCluster = c;
}
}
return minCluster;
}"
Math_58b_1,/home/common/huangzhili/defects4j_buggy_3/Math_58_buggy/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java,"public double[] fit() {
final double[] guess = (new ParameterGuesser(getObservations())).guess();
return fit(new Gaussian.Parametric(), guess);
}"
Math_58b_2,/home/common/huangzhili/defects4j_buggy_3/Math_58_buggy/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java,"public GaussianFitter(DifferentiableMultivariateVectorialOptimizer optimizer) {
super(optimizer);
}"
Math_59b_1,/home/common/huangzhili/defects4j_buggy_3/Math_59_buggy/src/main/java/org/apache/commons/math/util/FastMath.java,"public static float min(final float a, final float b) {
return (a <= b) ? a : (Float.isNaN(a + b) ? Float.NaN : b);
}"
Math_59b_2,/home/common/huangzhili/defects4j_buggy_3/Math_59_buggy/src/main/java/org/apache/commons/math/util/FastMath.java,"public static int max(final int a, final int b) {
return (a <= b) ? b : a;
}"
Math_59b_3,/home/common/huangzhili/defects4j_buggy_3/Math_59_buggy/src/main/java/org/apache/commons/math/util/FastMath.java,"private static double slowexp(final double x, final double result[]) {
final double xs[] = new double[2];
final double ys[] = new double[2];
final double facts[] = new double[2];
final double as[] = new double[2];
split(x, xs);
ys[0] = ys[1] = 0.0;

for (int i = 19; i >= 0; i--) {
splitMult(xs, ys, as);
ys[0] = as[0];
ys[1] = as[1];

split(FACT[i], as);
splitReciprocal(as, facts);

splitAdd(ys, facts, as);
ys[0] = as[0];
ys[1] = as[1];
}

if (result != null) {
result[0] = ys[0];
result[1] = ys[1];
}

return ys[0] + ys[1];
}"
Math_59b_4,/home/common/huangzhili/defects4j_buggy_3/Math_59_buggy/src/main/java/org/apache/commons/math/util/FastMath.java,"private static void split(final double d, final double split[]) {
if (d < 8e298 && d > -8e298) {
final double a = d * 1073741824.0;
split[0] = (d + a) - a;
split[1] = d - split[0];
} else {
final double a = d * 9.31322574615478515625E-10;
split[0] = (d + a - d) * 1073741824.0;
split[1] = d - split[0];
}
}"
Math_59b_5,/home/common/huangzhili/defects4j_buggy_3/Math_59_buggy/src/main/java/org/apache/commons/math/util/FastMath.java,"private static void resplit(final double a[]) {
final double c = a[0] + a[1];
final double d = -(c - a[0] - a[1]);

if (c < 8e298 && c > -8e298) {
double z = c * 1073741824.0;
a[0] = (c + z) - z;
a[1] = c - a[0] + d;
} else {
double z = c * 9.31322574615478515625E-10;
a[0] = (c + z - c) * 1073741824.0;
a[1] = c - a[0] + d;
}
}"
Math_60b_1,/home/common/huangzhili/defects4j_buggy_3/Math_60_buggy/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java,"public double cumulativeProbability(double x) throws MathException {
final double dev = x - mean;
try {
return 0.5 * (1.0 + Erf.erf((dev) /
(standardDeviation * FastMath.sqrt(2.0))));
} catch (MaxIterationsExceededException ex) {
if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
return 0;
} else if (x > (mean + 20 * standardDeviation)) {
return 1;
} else {
throw ex;
}
}
}"
Math_60b_2,/home/common/huangzhili/defects4j_buggy_3/Math_60_buggy/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java,"public NormalDistributionImpl(double mean, double sd){
this(mean, sd, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);
}"
Math_63b_1,/home/common/huangzhili/defects4j_buggy_3/Math_63_buggy/src/main/java/org/apache/commons/math/util/MathUtils.java,"public static boolean equals(double x, double y) {
return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
}"
Math_64b_1,/home/common/huangzhili/defects4j_buggy_3/Math_64_buggy/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java,"private void determineLMParameter(double[] qy, double delta, double[] diag,
double[] work1, double[] work2, double[] work3) {

// compute and store in x the gauss-newton direction, if the
// jacobian is rank-deficient, obtain a least squares solution
for (int j = 0; j < rank; ++j) {
lmDir[permutation[j]] = qy[j];
}
for (int j = rank; j < cols; ++j) {
lmDir[permutation[j]] = 0;
}
for (int k = rank - 1; k >= 0; --k) {
int pk = permutation[k];
double ypk = lmDir[pk] / diagR[pk];
for (int i = 0; i < k; ++i) {
lmDir[permutation[i]] -= ypk * jacobian[i][pk];
}
lmDir[pk] = ypk;
}

// evaluate the function at the origin, and test
// for acceptance of the Gauss-Newton direction
double dxNorm = 0;
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
double s = diag[pj] * lmDir[pj];
work1[pj] = s;
dxNorm += s * s;
}
dxNorm = Math.sqrt(dxNorm);
double fp = dxNorm - delta;
if (fp <= 0.1 * delta) {
lmPar = 0;
return;
}

// if the jacobian is not rank deficient, the Newton step provides
// a lower bound, parl, for the zero of the function,
// otherwise set this bound to zero
double sum2;
double parl = 0;
if (rank == solvedCols) {
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
work1[pj] *= diag[pj] / dxNorm;
}
sum2 = 0;
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
double sum = 0;
for (int i = 0; i < j; ++i) {
sum += jacobian[i][pj] * work1[permutation[i]];
}
double s = (work1[pj] - sum) / diagR[pj];
work1[pj] = s;
sum2 += s * s;
}
parl = fp / (delta * sum2);
}

// calculate an upper bound, paru, for the zero of the function
sum2 = 0;
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
double sum = 0;
for (int i = 0; i <= j; ++i) {
sum += jacobian[i][pj] * qy[i];
}
sum /= diag[pj];
sum2 += sum * sum;
}
double gNorm = Math.sqrt(sum2);
double paru = gNorm / delta;
if (paru == 0) {
// 2.2251e-308 is the smallest positive real for IEE754
paru = 2.2251e-308 / Math.min(delta, 0.1);
}

// if the input par lies outside of the interval (parl,paru),
// set par to the closer endpoint
lmPar = Math.min(paru, Math.max(lmPar, parl));
if (lmPar == 0) {
lmPar = gNorm / dxNorm;
}

for (int countdown = 10; countdown >= 0; --countdown) {

// evaluate the function at the current value of lmPar
if (lmPar == 0) {
lmPar = Math.max(2.2251e-308, 0.001 * paru);
}
double sPar = Math.sqrt(lmPar);
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
work1[pj] = sPar * diag[pj];
}
determineLMDirection(qy, work1, work2, work3);

dxNorm = 0;
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
double s = diag[pj] * lmDir[pj];
work3[pj] = s;
dxNorm += s * s;
}
dxNorm = Math.sqrt(dxNorm);
double previousFP = fp;
fp = dxNorm - delta;

// if the function is small enough, accept the current value
// of lmPar, also test for the exceptional cases where parl is zero
if ((Math.abs(fp) <= 0.1 * delta) ||
((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {
return;
}

// compute the Newton correction
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
work1[pj] = work3[pj] * diag[pj] / dxNorm;
}
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
work1[pj] /= work2[j];
double tmp = work1[pj];
for (int i = j + 1; i < solvedCols; ++i) {
work1[permutation[i]] -= jacobian[i][pj] * tmp;
}
}
sum2 = 0;
for (int j = 0; j < solvedCols; ++j) {
double s = work1[permutation[j]];
sum2 += s * s;
}
double correction = fp / (delta * sum2);

// depending on the sign of the function, update parl or paru.
if (fp > 0) {
parl = Math.max(parl, lmPar);
} else if (fp < 0) {
paru = Math.min(paru, lmPar);
}

// compute an improved estimate for lmPar
lmPar = Math.max(parl, lmPar + correction);

}
}"
Math_64b_2,/home/common/huangzhili/defects4j_buggy_3/Math_64_buggy/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java,"protected VectorialPointValuePair doOptimize()
throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

// arrays shared with the other private methods
solvedCols  = Math.min(rows, cols);
diagR       = new double[cols];
jacNorm     = new double[cols];
beta        = new double[cols];
permutation = new int[cols];
lmDir       = new double[cols];

// local point
double   delta   = 0;
double   xNorm   = 0;
double[] diag    = new double[cols];
double[] oldX    = new double[cols];
double[] oldRes  = new double[rows];
double[] work1   = new double[cols];
double[] work2   = new double[cols];
double[] work3   = new double[cols];

// evaluate the function at the starting point and calculate its norm
updateResidualsAndCost();

// outer loop
lmPar = 0;
boolean firstIteration = true;
VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
while (true) {
incrementIterationsCounter();

// compute the Q.R. decomposition of the jacobian matrix
VectorialPointValuePair previous = current;
updateJacobian();
qrDecomposition();

// compute Qt.res
qTy(residuals);
// now we don't need Q anymore,
// so let jacobian contain the R matrix with its diagonal elements
for (int k = 0; k < solvedCols; ++k) {
int pk = permutation[k];
jacobian[k][pk] = diagR[pk];
}

if (firstIteration) {

// scale the point according to the norms of the columns
// of the initial jacobian
xNorm = 0;
for (int k = 0; k < cols; ++k) {
double dk = jacNorm[k];
if (dk == 0) {
dk = 1.0;
}
double xk = dk * point[k];
xNorm  += xk * xk;
diag[k] = dk;
}
xNorm = Math.sqrt(xNorm);

// initialize the step bound delta
delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);

}

// check orthogonality between function vector and jacobian columns
double maxCosine = 0;
if (cost != 0) {
for (int j = 0; j < solvedCols; ++j) {
int    pj = permutation[j];
double s  = jacNorm[pj];
if (s != 0) {
double sum = 0;
for (int i = 0; i <= j; ++i) {
sum += jacobian[i][pj] * residuals[i];
}
maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
}
}
}
if (maxCosine <= orthoTolerance) {
// convergence has been reached
return current;
}

// rescale if necessary
for (int j = 0; j < cols; ++j) {
diag[j] = Math.max(diag[j], jacNorm[j]);
}

// inner loop
for (double ratio = 0; ratio < 1.0e-4;) {

// save the state
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
oldX[pj] = point[pj];
}
double previousCost = cost;
double[] tmpVec = residuals;
residuals = oldRes;
oldRes    = tmpVec;

// determine the Levenberg-Marquardt parameter
determineLMParameter(oldRes, delta, diag, work1, work2, work3);

// compute the new point and the norm of the evolution direction
double lmNorm = 0;
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
lmDir[pj] = -lmDir[pj];
point[pj] = oldX[pj] + lmDir[pj];
double s = diag[pj] * lmDir[pj];
lmNorm  += s * s;
}
lmNorm = Math.sqrt(lmNorm);
// on the first iteration, adjust the initial step bound.
if (firstIteration) {
delta = Math.min(delta, lmNorm);
}

// evaluate the function at x + p and calculate its norm
updateResidualsAndCost();
current = new VectorialPointValuePair(point, objective);

// compute the scaled actual reduction
double actRed = -1.0;
if (0.1 * cost < previousCost) {
double r = cost / previousCost;
actRed = 1.0 - r * r;
}

// compute the scaled predicted reduction
// and the scaled directional derivative
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
double dirJ = lmDir[pj];
work1[j] = 0;
for (int i = 0; i <= j; ++i) {
work1[i] += jacobian[i][pj] * dirJ;
}
}
double coeff1 = 0;
for (int j = 0; j < solvedCols; ++j) {
coeff1 += work1[j] * work1[j];
}
double pc2 = previousCost * previousCost;
coeff1 = coeff1 / pc2;
double coeff2 = lmPar * lmNorm * lmNorm / pc2;
double preRed = coeff1 + 2 * coeff2;
double dirDer = -(coeff1 + coeff2);

// ratio of the actual to the predicted reduction
ratio = (preRed == 0) ? 0 : (actRed / preRed);

// update the step bound
if (ratio <= 0.25) {
double tmp =
(actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {
tmp = 0.1;
}
delta = tmp * Math.min(delta, 10.0 * lmNorm);
lmPar /= tmp;
} else if ((lmPar == 0) || (ratio >= 0.75)) {
delta = 2 * lmNorm;
lmPar *= 0.5;
}

// test for successful iteration.
if (ratio >= 1.0e-4) {
// successful iteration, update the norm
firstIteration = false;
xNorm = 0;
for (int k = 0; k < cols; ++k) {
double xK = diag[k] * point[k];
xNorm    += xK * xK;
}
xNorm = Math.sqrt(xNorm);

// tests for convergence.
// we use the vectorial convergence checker
} else {
// failed iteration, reset the previous values
cost = previousCost;
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
point[pj] = oldX[pj];
}
tmpVec    = residuals;
residuals = oldRes;
oldRes    = tmpVec;
}
if (checker==null) {
if (((Math.abs(actRed) <= costRelativeTolerance) &&
(preRed <= costRelativeTolerance) &&
(ratio <= 2.0)) ||
(delta <= parRelativeTolerance * xNorm)) {
return current;
}
} else {
if (checker.converged(getIterations(), previous, current)) {
return current;
}
}
// tests for termination and stringent tolerances
// (2.2204e-16 is the machine epsilon for IEEE754)
if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,
costRelativeTolerance);
} else if (delta <= 2.2204e-16 * xNorm) {
throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,
parRelativeTolerance);
} else if (maxCosine <= 2.2204e-16)  {
throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,
orthoTolerance);
}

}

}

}"
Math_64b_3,/home/common/huangzhili/defects4j_buggy_3/Math_64_buggy/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java,"private void determineLMDirection(double[] qy, double[] diag,
double[] lmDiag, double[] work) {

// copy R and Qty to preserve input and initialize s
//  in particular, save the diagonal elements of R in lmDir
for (int j = 0; j < solvedCols; ++j) {
int pj = permutation[j];
for (int i = j + 1; i < solvedCols; ++i) {
jacobian[i][pj] = jacobian[j][permutation[i]];
}
lmDir[j] = diagR[pj];
work[j]  = qy[j];
}

// eliminate the diagonal matrix d using a Givens rotation
for (int j = 0; j < solvedCols; ++j) {

// prepare the row of d to be eliminated, locating the
// diagonal element using p from the Q.R. factorization
int pj = permutation[j];
double dpj = diag[pj];
if (dpj != 0) {
Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);
}
lmDiag[j] = dpj;

//  the transformations to eliminate the row of d
// modify only a single element of Qty
// beyond the first n, which is initially zero.
double qtbpj = 0;
for (int k = j; k < solvedCols; ++k) {
int pk = permutation[k];

// determine a Givens rotation which eliminates the
// appropriate element in the current row of d
if (lmDiag[k] != 0) {

final double sin;
final double cos;
double rkk = jacobian[k][pk];
if (Math.abs(rkk) < Math.abs(lmDiag[k])) {
final double cotan = rkk / lmDiag[k];
sin   = 1.0 / Math.sqrt(1.0 + cotan * cotan);
cos   = sin * cotan;
} else {
final double tan = lmDiag[k] / rkk;
cos = 1.0 / Math.sqrt(1.0 + tan * tan);
sin = cos * tan;
}

// compute the modified diagonal element of R and
// the modified element of (Qty,0)
jacobian[k][pk] = cos * rkk + sin * lmDiag[k];
final double temp = cos * work[k] + sin * qtbpj;
qtbpj = -sin * work[k] + cos * qtbpj;
work[k] = temp;

// accumulate the tranformation in the row of s
for (int i = k + 1; i < solvedCols; ++i) {
double rik = jacobian[i][pk];
final double temp2 = cos * rik + sin * lmDiag[i];
lmDiag[i] = -sin * rik + cos * lmDiag[i];
jacobian[i][pk] = temp2;
}

}
}

// store the diagonal element of s and restore
// the corresponding diagonal element of R
lmDiag[j] = jacobian[j][permutation[j]];
jacobian[j][permutation[j]] = lmDir[j];

}

// solve the triangular system for z, if the system is
// singular, then obtain a least squares solution
int nSing = solvedCols;
for (int j = 0; j < solvedCols; ++j) {
if ((lmDiag[j] == 0) && (nSing == solvedCols)) {
nSing = j;
}
if (nSing < solvedCols) {
work[j] = 0;
}
}
if (nSing > 0) {
for (int j = nSing - 1; j >= 0; --j) {
int pj = permutation[j];
double sum = 0;
for (int i = j + 1; i < nSing; ++i) {
sum += jacobian[i][pj] * work[i];
}
work[j] = (work[j] - sum) / lmDiag[j];
}
}

// permute the components of z back to components of lmDir
for (int j = 0; j < lmDir.length; ++j) {
lmDir[permutation[j]] = work[j];
}

}"
Math_64b_4,/home/common/huangzhili/defects4j_buggy_3/Math_64_buggy/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java,"private void qrDecomposition() throws OptimizationException {

// initializations
for (int k = 0; k < cols; ++k) {
permutation[k] = k;
double norm2 = 0;
for (int i = 0; i < jacobian.length; ++i) {
double akk = jacobian[i][k];
norm2 += akk * akk;
}
jacNorm[k] = Math.sqrt(norm2);
}

// transform the matrix column after column
for (int k = 0; k < cols; ++k) {

// select the column with the greatest norm on active components
int nextColumn = -1;
double ak2 = Double.NEGATIVE_INFINITY;
for (int i = k; i < cols; ++i) {
double norm2 = 0;
for (int j = k; j < jacobian.length; ++j) {
double aki = jacobian[j][permutation[i]];
norm2 += aki * aki;
}
if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {
throw new OptimizationException(LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN,
rows, cols);
}
if (norm2 > ak2) {
nextColumn = i;
ak2        = norm2;
}
}
if (ak2 <= qrRankingThreshold) {
rank = k;
return;
}
int pk                  = permutation[nextColumn];
permutation[nextColumn] = permutation[k];
permutation[k]          = pk;

// choose alpha such that Hk.u = alpha ek
double akk   = jacobian[k][pk];
double alpha = (akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);
double betak = 1.0 / (ak2 - akk * alpha);
beta[pk]     = betak;

// transform the current column
diagR[pk]        = alpha;
jacobian[k][pk] -= alpha;

// transform the remaining columns
for (int dk = cols - 1 - k; dk > 0; --dk) {
double gamma = 0;
for (int j = k; j < jacobian.length; ++j) {
gamma += jacobian[j][pk] * jacobian[j][permutation[k + dk]];
}
gamma *= betak;
for (int j = k; j < jacobian.length; ++j) {
jacobian[j][permutation[k + dk]] -= gamma * jacobian[j][pk];
}
}

}

rank = solvedCols;

}"
Math_64b_5,/home/common/huangzhili/defects4j_buggy_3/Math_64_buggy/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java,"public LevenbergMarquardtOptimizer() {

// set up the superclass with a default  max cost evaluations setting
setMaxIterations(1000);

// default values for the tuning parameters
setConvergenceChecker(null);
setInitialStepBoundFactor(100.0);
setCostRelativeTolerance(1.0e-10);
setParRelativeTolerance(1.0e-10);
setOrthoTolerance(1.0e-10);
setQRRankingThreshold(MathUtils.SAFE_MIN);

}"
Math_69b_1,/home/common/huangzhili/defects4j_buggy_3/Math_69_buggy/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java,"public PearsonsCorrelation(double[][] data) {
this(new BlockRealMatrix(data));
}"
Math_69b_2,/home/common/huangzhili/defects4j_buggy_3/Math_69_buggy/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java,"public RealMatrix getCorrelationPValues() throws MathException {
TDistribution tDistribution = new TDistributionImpl(nObs - 2);
int nVars = correlationMatrix.getColumnDimension();
double[][] out = new double[nVars][nVars];
for (int i = 0; i < nVars; i++) {
for (int j = 0; j < nVars; j++) {
if (i == j) {
out[i][j] = 0d;
} else {
double r = correlationMatrix.getEntry(i, j);
double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));
out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
}
}
}
return new BlockRealMatrix(out);
}"
Math_69b_3,/home/common/huangzhili/defects4j_buggy_3/Math_69_buggy/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java,"public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {
int nVars = matrix.getColumnDimension();
RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);
for (int i = 0; i < nVars; i++) {
for (int j = 0; j < i; j++) {
double corr = correlation(matrix.getColumn(i), matrix.getColumn(j));
outMatrix.setEntry(i, j, corr);
outMatrix.setEntry(j, i, corr);
}
outMatrix.setEntry(i, i, 1d);
}
return outMatrix;
}"
Math_69b_4,/home/common/huangzhili/defects4j_buggy_3/Math_69_buggy/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java,"private void checkSufficientData(final RealMatrix matrix) {
int nRows = matrix.getRowDimension();
int nCols = matrix.getColumnDimension();
if (nRows < 2 || nCols < 2) {
throw MathRuntimeException.createIllegalArgumentException(
""insufficient data: only {0} rows and {1} columns."",
nRows, nCols);
}
}"
Math_69b_5,/home/common/huangzhili/defects4j_buggy_3/Math_69_buggy/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java,"public double correlation(final double[] xArray, final double[] yArray) throws IllegalArgumentException {
SimpleRegression regression = new SimpleRegression();
if(xArray.length == yArray.length && xArray.length > 1) {
for(int i=0; i<xArray.length; i++) {
regression.addData(xArray[i], yArray[i]);
}
return regression.getR();
}
else {
throw MathRuntimeException.createIllegalArgumentException(
""invalid array dimensions. xArray has size {0}; yArray has {1} elements"",
xArray.length, yArray.length);
}
}"
Math_70b_1,/home/common/huangzhili/defects4j_buggy_3/Math_70_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java,"return solve(f, min, max);
}

/** {@inheritDoc} */
public double solve(final UnivariateRealFunction f, double min, double max, double initial)
throws MaxIterationsExceededException, FunctionEvaluationException {"
Math_70b_2,/home/common/huangzhili/defects4j_buggy_3/Math_70_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java,"public BisectionSolver() {
super(100, 1E-6);
}"
Math_72b_1,/home/common/huangzhili/defects4j_buggy_3/Math_72_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java,"public double solve(final UnivariateRealFunction f,
final double min, final double max, final double initial)"
Math_72b_2,/home/common/huangzhili/defects4j_buggy_3/Math_72_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java,"public BrentSolver() {
super(100, 1E-6);
}"
Math_73b_1,/home/common/huangzhili/defects4j_buggy_3/Math_73_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java,"public double solve(final UnivariateRealFunction f,
final double min, final double max, final double initial)"
Math_73b_2,/home/common/huangzhili/defects4j_buggy_3/Math_73_buggy/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java,"public BrentSolver() {
super(100, 1E-6);
}"
Math_74b_1,/home/common/huangzhili/defects4j_buggy_3/Math_74_buggy/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java,"public double integrate(final FirstOrderDifferentialEquations equations,
final double t0, final double[] y0,"
Math_74b_2,/home/common/huangzhili/defects4j_buggy_3/Math_74_buggy/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java,"protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,
final double[] c, final double[][] a, final double[] b,"
Math_74b_3,/home/common/huangzhili/defects4j_buggy_3/Math_74_buggy/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java,"public void setSafety(final double safety) {
this.safety = safety;
}"
Math_74b_4,/home/common/huangzhili/defects4j_buggy_3/Math_74_buggy/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java,"public void setMinReduction(final double minReduction) {
this.minReduction = minReduction;
}"
Math_74b_5,/home/common/huangzhili/defects4j_buggy_3/Math_74_buggy/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java,"public void setMaxGrowth(final double maxGrowth) {
this.maxGrowth = maxGrowth;
}"
Math_75b_1,/home/common/huangzhili/defects4j_buggy_3/Math_75_buggy/src/main/java/org/apache/commons/math/stat/Frequency.java,"public double getPct(Object v) {
return getCumPct((Comparable<?>) v);
}"
Math_75b_2,/home/common/huangzhili/defects4j_buggy_3/Math_75_buggy/src/main/java/org/apache/commons/math/stat/Frequency.java,"public long getCumFreq(Comparable<?> v) {
if (getSumFreq() == 0) {
return 0;
}
if (v instanceof Integer) {
return getCumFreq(((Integer) v).longValue());
}
Comparator<Comparable<?>> c = (Comparator<Comparable<?>>) freqTable.comparator();
if (c == null) {
c = new NaturalComparator();
}
long result = 0;

try {
Long value = freqTable.get(v);
if (value != null) {
result = value.longValue();
}
} catch (ClassCastException ex) {
return result;   // v is not comparable
}

if (c.compare(v, freqTable.firstKey()) < 0) {
return 0;  // v is comparable, but less than first value
}

if (c.compare(v, freqTable.lastKey()) >= 0) {
return getSumFreq();    // v is comparable, but greater than the last value
}

Iterator<Comparable<?>> values = valuesIterator();
while (values.hasNext()) {
Comparable<?> nextValue = values.next();
if (c.compare(v, nextValue) > 0) {
result += getCount(nextValue);
} else {
return result;
}
}
return result;
}"
Math_75b_3,/home/common/huangzhili/defects4j_buggy_3/Math_75_buggy/src/main/java/org/apache/commons/math/stat/Frequency.java,"public void addValue(Comparable<?> v){
Comparable<?> obj = v;
if (v instanceof Integer) {
obj = Long.valueOf(((Integer) v).longValue());
}
try {
Long count = freqTable.get(obj);
if (count == null) {
freqTable.put(obj, Long.valueOf(1));
} else {
freqTable.put(obj, Long.valueOf(count.longValue() + 1));
}
} catch (ClassCastException ex) {
//TreeMap will throw ClassCastException if v is not comparable
throw MathRuntimeException.createIllegalArgumentException(
""instance of class {0} not comparable to existing values"",
v.getClass().getName());
}
}"
Math_75b_4,/home/common/huangzhili/defects4j_buggy_3/Math_75_buggy/src/main/java/org/apache/commons/math/stat/Frequency.java,"public long getSumFreq() {
long result = 0;
Iterator<Long> iterator = freqTable.values().iterator();
while (iterator.hasNext())  {
result += iterator.next().longValue();
}
return result;
}"
Math_75b_5,/home/common/huangzhili/defects4j_buggy_3/Math_75_buggy/src/main/java/org/apache/commons/math/stat/Frequency.java,"public long getCount(Comparable<?> v) {
if (v instanceof Integer) {
return getCount(((Integer) v).longValue());
}
long result = 0;
try {
Long count =  freqTable.get(v);
if (count != null) {
result = count.longValue();
}
} catch (ClassCastException ex) {
// ignore and return 0 -- ClassCastException will be thrown if value is not comparable
}
return result;
}"
Math_78b_1,/home/common/huangzhili/defects4j_buggy_3/Math_78_buggy/src/main/java/org/apache/commons/math/ode/events/EventState.java,"public EventState(final EventHandler handler, final double maxCheckInterval,
final double convergence, final int maxIterationCount) {
this.handler           = handler;
this.maxCheckInterval  = maxCheckInterval;
this.convergence       = Math.abs(convergence);
this.maxIterationCount = maxIterationCount;

// some dummy values ...
t0                = Double.NaN;
g0                = Double.NaN;
g0Positive        = true;
pendingEvent      = false;
pendingEventTime  = Double.NaN;
previousEventTime = Double.NaN;
increasing        = true;
nextAction        = EventHandler.CONTINUE;

}"
Math_78b_2,/home/common/huangzhili/defects4j_buggy_3/Math_78_buggy/src/main/java/org/apache/commons/math/ode/events/EventState.java,"public void reinitializeBegin(final double tStart, final double[] yStart)
throws EventException {
t0 = tStart;
g0 = handler.g(tStart, yStart);
g0Positive = g0 >= 0;
}"
Math_78b_3,/home/common/huangzhili/defects4j_buggy_3/Math_78_buggy/src/main/java/org/apache/commons/math/ode/events/EventState.java,"public boolean evaluateStep(final StepInterpolator interpolator)
throws DerivativeException, EventException, ConvergenceException {

try {

forward = interpolator.isForward();
final double t1 = interpolator.getCurrentTime();
final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));
final double h  = (t1 - t0) / n;

double ta = t0;
double ga = g0;
double tb = t0 + (interpolator.isForward() ? convergence : -convergence);
for (int i = 0; i < n; ++i) {

// evaluate handler value at the end of the substep
tb += h;
interpolator.setInterpolatedTime(tb);
final double gb = handler.g(tb, interpolator.getInterpolatedState());

// check events occurrence
if (g0Positive ^ (gb >= 0)) {
// there is a sign change: an event is expected during this step

// this is a corner case:
// - there was an event near ta,
// - there is another event between ta and tb
// - when ta was computed, convergence was reached on the ""wrong side"" of the interval
// this implies that the real sign of ga is the same as gb, so we need to slightly
// shift ta to make sure ga and gb get opposite signs and the solver won't complain
// about bracketing
// this should never happen

// variation direction, with respect to the integration direction
increasing = gb >= ga;

final UnivariateRealFunction f = new UnivariateRealFunction() {
public double value(final double t) throws FunctionEvaluationException {
try {
interpolator.setInterpolatedTime(t);
return handler.g(t, interpolator.getInterpolatedState());
} catch (DerivativeException e) {
throw new FunctionEvaluationException(e, t);
} catch (EventException e) {
throw new FunctionEvaluationException(e, t);
}
}
};
final BrentSolver solver = new BrentSolver();
solver.setAbsoluteAccuracy(convergence);
solver.setMaximalIterationCount(maxIterationCount);
final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);
if ((Math.abs(root - ta) <= convergence) &&
(Math.abs(root - previousEventTime) <= convergence)) {
// we have either found nothing or found (again ?) a past event, we simply ignore it
ta = tb;
ga = gb;
} else if (Double.isNaN(previousEventTime) ||
(Math.abs(previousEventTime - root) > convergence)) {
pendingEventTime = root;
if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {
// we were already waiting for this event which was
// found during a previous call for a step that was
// rejected, this step must now be accepted since it
// properly ends exactly at the event occurrence
return false;
}
// either we were not waiting for the event or it has
// moved in such a way the step cannot be accepted
pendingEvent = true;
return true;
}

} else {
// no sign change: there is no event for now
ta = tb;
ga = gb;
}

}

// no event during the whole step
pendingEvent     = false;
pendingEventTime = Double.NaN;
return false;

} catch (FunctionEvaluationException e) {
final Throwable cause = e.getCause();
if ((cause != null) && (cause instanceof DerivativeException)) {
throw (DerivativeException) cause;
} else if ((cause != null) && (cause instanceof EventException)) {
throw (EventException) cause;
}
throw new EventException(e);
}

}"
Math_78b_4,/home/common/huangzhili/defects4j_buggy_3/Math_78_buggy/src/main/java/org/apache/commons/math/ode/events/EventState.java,"public double getEventTime() {
return pendingEventTime;
}"
Math_78b_5,/home/common/huangzhili/defects4j_buggy_3/Math_78_buggy/src/main/java/org/apache/commons/math/ode/events/EventState.java,"public void stepAccepted(final double t, final double[] y)
throws EventException {

t0 = t;
g0 = handler.g(t, y);

if (pendingEvent) {
// force the sign to its value ""just after the event""
previousEventTime = t;
g0Positive        = increasing;
nextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));
} else {
g0Positive = g0 >= 0;
nextAction = EventHandler.CONTINUE;
}
}"
Math_79b_1,/home/common/huangzhili/defects4j_buggy_3/Math_79_buggy/src/main/java/org/apache/commons/math/util/MathUtils.java,"public static double distance(int[] p1, int[] p2) {
int sum = 0;
for (int i = 0; i < p1.length; i++) {
final int dp = p1[i] - p2[i];
sum += dp * dp;
}
return Math.sqrt(sum);
}"
Math_80b_1,/home/common/huangzhili/defects4j_buggy_3/Math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java,"private void processGeneralBlock(final int n)
throws InvalidMatrixException {

// check decomposed matrix data range
double sumOffDiag = 0;
for (int i = 0; i < n - 1; ++i) {
final int fourI = 4 * i;
final double ei = work[fourI + 2];
sumOffDiag += ei;
}

if (sumOffDiag == 0) {
// matrix is already diagonal
return;
}

// initial checks for splits (see Parlett & Marques section 3.3)
flipIfWarranted(n, 2);

// two iterations with Li's test for initial splits
initialSplits(n);

// initialize parameters used by goodStep
tType = 0;
dMin1 = 0;
dMin2 = 0;
dN    = 0;
dN1   = 0;
dN2   = 0;
tau   = 0;

// process split segments
int i0 = 0;
int n0 = n;
while (n0 > 0) {

// retrieve shift that was temporarily stored as a negative off-diagonal element
sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];
sigmaLow = 0;

// find start of a new split segment to process
double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];
double offDiagMax = 0;
double diagMax    = work[4 * n0 - 4];
double diagMin    = diagMax;
i0 = 0;
for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {
if (work[i + 2] <= 0) {
i0 = 1 + i / 4;
break;
}
if (diagMin >= 4 * offDiagMax) {
diagMin    = Math.min(diagMin, work[i + 4]);
offDiagMax = Math.max(offDiagMax, work[i + 2]);
}
diagMax    = Math.max(diagMax, work[i] + work[i + 2]);
offDiagMin = Math.min(offDiagMin, work[i + 2]);
}
work[4 * n0 - 2] = offDiagMin;

// lower bound of Gershgorin disk
dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));

pingPong = 0;
int maxIter = 30 * (n0 - i0);
for (int k = 0; i0 < n0; ++k) {
if (k >= maxIter) {
throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));
}

// perform one step
n0 = goodStep(i0, n0);
pingPong = 1 - pingPong;

// check for new splits after ""ping"" steps
// when the last elements of qd array are very small
if ((pingPong == 0) && (n0 - i0 > 3) &&
(work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) &&
(work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {
int split  = i0 - 1;
diagMax    = work[4 * i0];
offDiagMin = work[4 * i0 + 2];
double previousEMin = work[4 * i0 + 3];
for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {
if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||
(work[i + 2] <= TOLERANCE_2 * sigma)) {
// insert a split
work[i + 2]  = -sigma;
split        = i / 4;
diagMax      = 0;
offDiagMin   = work[i + 6];
previousEMin = work[i + 7];
} else {
diagMax      = Math.max(diagMax, work[i + 4]);
offDiagMin   = Math.min(offDiagMin, work[i + 2]);
previousEMin = Math.min(previousEMin, work[i + 3]);
}
}
work[4 * n0 - 2] = offDiagMin;
work[4 * n0 - 1] = previousEMin;
i0 = split + 1;
}
}

}

}"
Math_80b_2,/home/common/huangzhili/defects4j_buggy_3/Math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java,"private void initialSplits(final int n) {

pingPong = 0;
for (int k = 0; k < 2; ++k) {

// apply Li's reverse test
double d = work[4 * (n - 1) + pingPong];
for (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) {
if (work[i + 2] <= TOLERANCE_2 * d) {
work[i + 2] = -0.0;
d = work[i];
} else {
d *= work[i] / (d + work[i + 2]);
}
}

// apply dqd plus Li's forward test.
d = work[pingPong];
for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) {
final int j = i - 2 * pingPong - 1;
work[j] = d + work[i];
if (work[i] <= TOLERANCE_2 * d) {
work[i]     = -0.0;
work[j]     = d;
work[j + 2] = 0.0;
d = work[i + 2];
} else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&
(MathUtils.SAFE_MIN * work[j] < work[i + 2])) {
final double tmp = work[i + 2] / work[j];
work[j + 2] = work[i] * tmp;
d *= tmp;
} else {
work[j + 2] = work[i + 2] * (work[i] / work[j]);
d *= work[i + 2] / work[j];
}
}
work[4 * n - 3 - pingPong] = d;

// from ping to pong
pingPong = 1 - pingPong;

}

}"
Math_80b_3,/home/common/huangzhili/defects4j_buggy_3/Math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java,"private int goodStep(final int start, final int end) {

g = 0.0;

// step 1: accepting realEigenvalues
int deflatedEnd = end;
for (boolean deflating = true; deflating;) {

if (start >= deflatedEnd) {
// the array has been completely deflated
return deflatedEnd;
}

final int k = 4 * deflatedEnd + pingPong - 1;

if ((start == deflatedEnd - 1) ||
((start != deflatedEnd - 2) &&
((work[k - 5] <= TOLERANCE_2 * (sigma + work[k - 3])) ||
(work[k - 2 * pingPong - 4] <= TOLERANCE_2 * work[k - 7])))) {

// one eigenvalue found, deflate array
work[4 * deflatedEnd - 4] = sigma + work[4 * deflatedEnd - 4 + pingPong];
deflatedEnd -= 1;

} else if ((start == deflatedEnd - 2) ||
(work[k - 9] <= TOLERANCE_2 * sigma) ||
(work[k - 2 * pingPong - 8] <= TOLERANCE_2 * work[k - 11])) {

// two realEigenvalues found, deflate array
if (work[k - 3] > work[k - 7]) {
final double tmp = work[k - 3];
work[k - 3] = work[k - 7];
work[k - 7] = tmp;
}

if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {
double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);
double s = work[k - 3] * (work[k - 5] / t);
if (s <= t) {
s = work[k - 3] * work[k - 5] / (t * (1 + Math.sqrt(1 + s / t)));
} else {
s = work[k - 3] * work[k - 5] / (t + Math.sqrt(t * (t + s)));
}
t = work[k - 7] + (s + work[k - 5]);
work[k - 3] *= work[k - 7] / t;
work[k - 7]  = t;
}
work[4 * deflatedEnd - 8] = sigma + work[k - 7];
work[4 * deflatedEnd - 4] = sigma + work[k - 3];
deflatedEnd -= 2;
} else {

// no more realEigenvalues found, we need to iterate
deflating = false;

}

}

final int l = 4 * deflatedEnd + pingPong - 1;

// step 2: flip array if needed
if ((dMin <= 0) || (deflatedEnd < end)) {
if (flipIfWarranted(deflatedEnd, 1)) {
dMin2 = Math.min(dMin2, work[l - 1]);
work[l - 1] =
Math.min(work[l - 1],
Math.min(work[3 + pingPong], work[7 + pingPong]));
work[l - 2 * pingPong] =
Math.min(work[l - 2 * pingPong],
Math.min(work[6 + pingPong], work[6 + pingPong]));
qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));
dMin  = -0.0;
}
}

if ((dMin < 0) ||
(MathUtils.SAFE_MIN * qMax < Math.min(work[l - 1],
Math.min(work[l - 9],
dMin2 + work[l - 2 * pingPong])))) {
// step 3: choose a shift
computeShiftIncrement(start, deflatedEnd, end - deflatedEnd);

// step 4a: dqds
for (boolean loop = true; loop;) {

// perform one dqds step with the chosen shift
dqds(start, deflatedEnd);

// check result of the dqds step
if ((dMin >= 0) && (dMin1 > 0)) {
// the shift was good
updateSigma(tau);
return deflatedEnd;
} else if ((dMin < 0.0) &&
(dMin1 > 0.0) &&
(work[4 * deflatedEnd - 5 - pingPong] < TOLERANCE * (sigma + dN1)) &&
(Math.abs(dN) < TOLERANCE * sigma)) {
// convergence hidden by negative DN.
work[4 * deflatedEnd - 3 - pingPong] = 0.0;
dMin = 0.0;
updateSigma(tau);
return deflatedEnd;
} else if (dMin < 0.0) {
// tau too big. Select new tau and try again.
if (tType < -22) {
// failed twice. Play it safe.
tau = 0.0;
} else if (dMin1 > 0.0) {
// late failure. Gives excellent shift.
tau = (tau + dMin) * (1.0 - 2.0 * MathUtils.EPSILON);
tType -= 11;
} else {
// early failure. Divide by 4.
tau *= 0.25;
tType -= 12;
}
} else if (Double.isNaN(dMin)) {
tau = 0.0;
} else {
// possible underflow. Play it safe.
loop = false;
}
}

}

// perform a dqd step (i.e. no shift)
dqd(start, deflatedEnd);

return deflatedEnd;

}"
Math_80b_4,/home/common/huangzhili/defects4j_buggy_3/Math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java,"private boolean flipIfWarranted(final int n, final int step) {
if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
// flip array
int j = 4 * n - 1;
for (int i = 0; i < j; i += 4) {
for (int k = 0; k < 4; k += step) {
final double tmp = work[i + k];
work[i + k] = work[j - k];
work[j - k] = tmp;
}
j -= 4;
}
return true;
}
return false;
}"
Math_80b_5,/home/common/huangzhili/defects4j_buggy_3/Math_80_buggy/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java,"private void dqd(final int start, final int end) {

eMin = work[4 * start + pingPong + 4];
double d = work[4 * start + pingPong];
dMin = d;

if (pingPong == 0) {
for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {
work[j4 - 2] = d + work[j4 - 1];
if (work[j4 - 2] == 0.0) {
work[j4] = 0.0;
d = work[j4 + 1];
dMin = d;
eMin = 0.0;
} else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&
(MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {
final double tmp = work[j4 + 1] / work[j4 - 2];
work[j4] = work[j4 - 1] * tmp;
d *= tmp;
} else {
work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);
d *= work[j4 + 1] / work[j4 - 2];
}
dMin = Math.min(dMin, d);
eMin = Math.min(eMin, work[j4]);
}
} else {
for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {
work[j4 - 3] = d + work[j4];
if (work[j4 - 3] == 0.0) {
work[j4 - 1] = 0.0;
d = work[j4 + 2];
dMin = d;
eMin = 0.0;
} else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&
(MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {
final double tmp = work[j4 + 2] / work[j4 - 3];
work[j4 - 1] = work[j4] * tmp;
d *= tmp;
} else {
work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]);
d *= work[j4 + 2] / work[j4 - 3];
}
dMin = Math.min(dMin, d);
eMin = Math.min(eMin, work[j4 - 1]);
}
}

// Unroll last two steps
dN2   = d;
dMin2 = dMin;
int j4 = 4 * (end - 2) - pingPong - 1;
int j4p2 = j4 + 2 * pingPong - 1;
work[j4 - 2] = dN2 + work[j4p2];
if (work[j4 - 2] == 0.0) {
work[j4] = 0.0;
dN1  = work[j4p2 + 2];
dMin = dN1;
eMin = 0.0;
} else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
(MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
final double tmp = work[j4p2 + 2] / work[j4 - 2];
work[j4] = work[j4p2] * tmp;
dN1 = dN2 * tmp;
} else {
work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);
}
dMin = Math.min(dMin, dN1);

dMin1 = dMin;
j4 = j4 + 4;
j4p2 = j4 + 2 * pingPong - 1;
work[j4 - 2] = dN1 + work[j4p2];
if (work[j4 - 2] == 0.0) {
work[j4] = 0.0;
dN   = work[j4p2 + 2];
dMin = dN;
eMin = 0.0;
} else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&
(MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {
final double tmp = work[j4p2 + 2] / work[j4 - 2];
work[j4] = work[j4p2] * tmp;
dN = dN1 * tmp;
} else {
work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);
dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);
}
dMin = Math.min(dMin, dN);

work[j4 + 2] = dN;
work[4 * end - pingPong - 1] = eMin;

}"
Math_82b_1,/home/common/huangzhili/defects4j_buggy_3/Math_82_buggy/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java,"protected void solvePhase1(final SimplexTableau tableau)
throws OptimizationException {
// make sure we're in Phase 1
if (tableau.getNumArtificialVariables() == 0) {
return;
}

while (!isPhase1Solved(tableau)) {
doIteration(tableau);
}

// if W is not zero then we have no feasible solution
if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon)) {
throw new NoFeasibleSolutionException();
}
}"
Math_82b_2,/home/common/huangzhili/defects4j_buggy_3/Math_82_buggy/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java,"public boolean isOptimal(final SimplexTableau tableau) {
if (tableau.getNumArtificialVariables() > 0) {
return false;
}
for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {
if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0) {
return false;
}
}
return true;
}"
Math_82b_3,/home/common/huangzhili/defects4j_buggy_3/Math_82_buggy/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java,"public RealPointValuePair doOptimize()
throws OptimizationException {
final SimplexTableau tableau =
new SimplexTableau(f, constraints, goalType, restrictToNonNegative, epsilon);
solvePhase1(tableau);
tableau.discardArtificialVariables();
while (!isOptimal(tableau)) {
doIteration(tableau);
}
return tableau.getSolution();
}"
Math_82b_4,/home/common/huangzhili/defects4j_buggy_3/Math_82_buggy/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java,"public SimplexSolver() {
this(DEFAULT_EPSILON);
}"
Math_82b_5,/home/common/huangzhili/defects4j_buggy_3/Math_82_buggy/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java,"private Integer getPivotColumn(SimplexTableau tableau) {
double minValue = 0;
Integer minPos = null;
for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {
if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {
minValue = tableau.getEntry(0, i);
minPos = i;
}
}
return minPos;
}"
Math_84b_1,/home/common/huangzhili/defects4j_buggy_3/Math_84_buggy/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java,"public MultiDirectional() {
this.khi   = 2.0;
this.gamma = 0.5;
}"
Math_84b_2,/home/common/huangzhili/defects4j_buggy_3/Math_84_buggy/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java,"protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {

while (true) {

incrementIterationsCounter();

// save the original vertex
final RealPointValuePair[] original = simplex;
final RealPointValuePair best = original[0];

// perform a reflection step
final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);
if (comparator.compare(reflected, best) < 0) {

// compute the expanded simplex
final RealPointValuePair[] reflectedSimplex = simplex;
final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);
if (comparator.compare(reflected, expanded) <= 0) {
// accept the reflected simplex
simplex = reflectedSimplex;
}

return;

}

// compute the contracted simplex
final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
if (comparator.compare(contracted, best) < 0) {
// accept the contracted simplex

// check convergence
return;
}

}

}"
Math_84b_3,/home/common/huangzhili/defects4j_buggy_3/Math_84_buggy/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java,"private RealPointValuePair evaluateNewSimplex(final RealPointValuePair[] original,
final double coeff,"
Math_85b_1,/home/common/huangzhili/defects4j_buggy_3/Math_85_buggy/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java,"return bracket( function, initial, lowerBound, upperBound,
Integer.MAX_VALUE ) ;"
Math_86b_1,/home/common/huangzhili/defects4j_buggy_3/Math_86_buggy/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java,"public CholeskyDecompositionImpl(final RealMatrix matrix)
throws NonSquareMatrixException,"
Math_86b_2,/home/common/huangzhili/defects4j_buggy_3/Math_86_buggy/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java,"public RealMatrix getL() {
if (cachedL == null) {
cachedL = getLT().transpose();
}
return cachedL;
}"
Math_86b_3,/home/common/huangzhili/defects4j_buggy_3/Math_86_buggy/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java,"public RealMatrix getLT() {

if (cachedLT == null) {
cachedLT = MatrixUtils.createRealMatrix(lTData);
}

// return the cached matrix
return cachedLT;

}"
Math_87b_1,/home/common/huangzhili/defects4j_buggy_3/Math_87_buggy/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,"protected void discardArtificialVariables() {
if (numArtificialVariables == 0) {
return;
}
int width = getWidth() - numArtificialVariables - 1;
int height = getHeight() - 1;
double[][] matrix = new double[height][width];
for (int i = 0; i < height; i++) {
for (int j = 0; j < width - 1; j++) {
matrix[i][j] = getEntry(i + 1, j + 1);
}
matrix[i][width - 1] = getEntry(i + 1, getRhsOffset());
}
this.tableau = new RealMatrixImpl(matrix);
this.numArtificialVariables = 0;
}"
Math_87b_2,/home/common/huangzhili/defects4j_buggy_3/Math_87_buggy/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,"protected double[][] createTableau(final boolean maximize) {

// create a matrix of the correct size
List<LinearConstraint> constraints = getNormalizedConstraints();
int width = numDecisionVariables + numSlackVariables +
numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS
int height = constraints.size() + getNumObjectiveFunctions();
double[][] matrix = new double[height][width];

// initialize the objective function rows
if (getNumObjectiveFunctions() == 2) {
matrix[0][0] = -1;
}
int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;
matrix[zIndex][zIndex] = maximize ? 1 : -1;
RealVector objectiveCoefficients =
maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();
copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());
matrix[zIndex][width - 1] =
maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();

if (!restrictToNonNegative) {
matrix[zIndex][getSlackVariableOffset() - 1] =
getInvertedCoeffiecientSum(objectiveCoefficients);
}

// initialize the constraint rows
int slackVar = 0;
int artificialVar = 0;
for (int i = 0; i < constraints.size(); i++) {
LinearConstraint constraint = constraints.get(i);
int row = getNumObjectiveFunctions() + i;

// decision variable coefficients
copyArray(constraint.getCoefficients().getData(), matrix[row], 1);

// x-
if (!restrictToNonNegative) {
matrix[row][getSlackVariableOffset() - 1] =
getInvertedCoeffiecientSum(constraint.getCoefficients());
}

// RHS
matrix[row][width - 1] = constraint.getValue();

// slack variables
if (constraint.getRelationship() == Relationship.LEQ) {
matrix[row][getSlackVariableOffset() + slackVar++] = 1;  // slack
} else if (constraint.getRelationship() == Relationship.GEQ) {
matrix[row][getSlackVariableOffset() + slackVar++] = -1; // excess
}

// artificial variables
if ((constraint.getRelationship() == Relationship.EQ) ||
(constraint.getRelationship() == Relationship.GEQ)) {
matrix[0][getArtificialVariableOffset() + artificialVar] = 1;
matrix[row][getArtificialVariableOffset() + artificialVar++] = 1;
}
}

return matrix;
}"
Math_87b_3,/home/common/huangzhili/defects4j_buggy_3/Math_87_buggy/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,"protected static double getInvertedCoeffiecientSum(final RealVector coefficients) {
double sum = 0;
for (double coefficient : coefficients.getData()) {
sum -= coefficient;
}
return sum;
}"
Math_87b_4,/home/common/huangzhili/defects4j_buggy_3/Math_87_buggy/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,"protected RealPointValuePair getSolution() {
double[] coefficients = new double[getOriginalNumDecisionVariables()];
Integer basicRow =
getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
Set<Integer> basicRows = new HashSet<Integer>();
for (int i = 0; i < coefficients.length; i++) {
basicRow = getBasicRow(getNumObjectiveFunctions() + i);
if (basicRows.contains(basicRow)) {
// if multiple variables can take a given value
// then we choose the first and set the rest equal to 0
coefficients[i] = 0;
} else {
basicRows.add(basicRow);
coefficients[i] =
(basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
(restrictToNonNegative ? 0 : mostNegative);
}
}
return new RealPointValuePair(coefficients, f.getValue(coefficients));
}"
Math_87b_5,/home/common/huangzhili/defects4j_buggy_3/Math_87_buggy/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,"protected final int getOriginalNumDecisionVariables() {
return restrictToNonNegative ? numDecisionVariables : numDecisionVariables - 1;
}"
Math_88b_1,/home/common/huangzhili/defects4j_buggy_3/Math_88_buggy/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,"protected RealPointValuePair getSolution() {
double[] coefficients = new double[getOriginalNumDecisionVariables()];
Integer basicRow =
getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
for (int i = 0; i < coefficients.length; i++) {
basicRow = getBasicRow(getNumObjectiveFunctions() + i);
// if multiple variables can take a given value
// then we choose the first and set the rest equal to 0
coefficients[i] =
(basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
(restrictToNonNegative ? 0 : mostNegative);
if (basicRow != null) {
for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {
if (tableau.getEntry(basicRow, j) == 1) {
coefficients[i] = 0;
}
}
}
}
return new RealPointValuePair(coefficients, f.getValue(coefficients));
}"
Math_88b_2,/home/common/huangzhili/defects4j_buggy_3/Math_88_buggy/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,"protected double[][] createTableau(final boolean maximize) {

// create a matrix of the correct size
List<LinearConstraint> constraints = getNormalizedConstraints();
int width = numDecisionVariables + numSlackVariables +
numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS
int height = constraints.size() + getNumObjectiveFunctions();
double[][] matrix = new double[height][width];

// initialize the objective function rows
if (getNumObjectiveFunctions() == 2) {
matrix[0][0] = -1;
}
int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;
matrix[zIndex][zIndex] = maximize ? 1 : -1;
RealVector objectiveCoefficients =
maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();
copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());
matrix[zIndex][width - 1] =
maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();

if (!restrictToNonNegative) {
matrix[zIndex][getSlackVariableOffset() - 1] =
getInvertedCoeffiecientSum(objectiveCoefficients);
}

// initialize the constraint rows
int slackVar = 0;
int artificialVar = 0;
for (int i = 0; i < constraints.size(); i++) {
LinearConstraint constraint = constraints.get(i);
int row = getNumObjectiveFunctions() + i;

// decision variable coefficients
copyArray(constraint.getCoefficients().getData(), matrix[row], 1);

// x-
if (!restrictToNonNegative) {
matrix[row][getSlackVariableOffset() - 1] =
getInvertedCoeffiecientSum(constraint.getCoefficients());
}

// RHS
matrix[row][width - 1] = constraint.getValue();

// slack variables
if (constraint.getRelationship() == Relationship.LEQ) {
matrix[row][getSlackVariableOffset() + slackVar++] = 1;  // slack
} else if (constraint.getRelationship() == Relationship.GEQ) {
matrix[row][getSlackVariableOffset() + slackVar++] = -1; // excess
}

// artificial variables
if ((constraint.getRelationship() == Relationship.EQ) ||
(constraint.getRelationship() == Relationship.GEQ)) {
matrix[0][getArtificialVariableOffset() + artificialVar] = 1;
matrix[row][getArtificialVariableOffset() + artificialVar++] = 1;
}
}

return matrix;
}"
Math_88b_3,/home/common/huangzhili/defects4j_buggy_3/Math_88_buggy/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,"private Integer getBasicRow(final int col) {
Integer row = null;
for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
if (row == null) {
row = i;
} else {
return null;
}
}
}
return row;
}"
Math_88b_4,/home/common/huangzhili/defects4j_buggy_3/Math_88_buggy/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,"protected void discardArtificialVariables() {
if (numArtificialVariables == 0) {
return;
}
int width = getWidth() - numArtificialVariables - 1;
int height = getHeight() - 1;
double[][] matrix = new double[height][width];
for (int i = 0; i < height; i++) {
for (int j = 0; j < width - 1; j++) {
matrix[i][j] = getEntry(i + 1, j + 1);
}
matrix[i][width - 1] = getEntry(i + 1, getRhsOffset());
}
this.tableau = new RealMatrixImpl(matrix);
this.numArtificialVariables = 0;
}"
Math_88b_5,/home/common/huangzhili/defects4j_buggy_3/Math_88_buggy/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java,"protected final int getOriginalNumDecisionVariables() {
return restrictToNonNegative ? numDecisionVariables : numDecisionVariables - 1;
}"
Math_89b_1,/home/common/huangzhili/defects4j_buggy_3/Math_89_buggy/src/java/org/apache/commons/math/stat/Frequency.java,"addValue((Comparable<?>) v);
}

/**
* Adds 1 to the frequency count for v.
* <p>
* If other objects have already been added to this Frequency, v must
* be comparable to those that have already been added.
* </p>
*
* @param v the value to add.
* @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries
*/
public void addValue(Comparable<?>v){"
Math_89b_2,/home/common/huangzhili/defects4j_buggy_3/Math_89_buggy/src/java/org/apache/commons/math/stat/Frequency.java,"public Frequency() {
freqTable = new TreeMap();
}"
Math_91b_1,/home/common/huangzhili/defects4j_buggy_3/Math_91_buggy/src/java/org/apache/commons/math/fraction/Fraction.java,"public int compareTo(Fraction object) {
double nOd = doubleValue();
double dOn = object.doubleValue();
return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
}"
Math_91b_2,/home/common/huangzhili/defects4j_buggy_3/Math_91_buggy/src/java/org/apache/commons/math/fraction/Fraction.java,"public double doubleValue() {
return (double)numerator / (double)denominator;
}"
Math_91b_3,/home/common/huangzhili/defects4j_buggy_3/Math_91_buggy/src/java/org/apache/commons/math/fraction/Fraction.java,"public Fraction(int num, int den) {
super();
if (den == 0) {
throw MathRuntimeException.createArithmeticException(""zero denominator in fraction {0}/{1}"",
num, den);
}
if (den < 0) {
if (num == Integer.MIN_VALUE || den == Integer.MIN_VALUE) {
throw MathRuntimeException.createArithmeticException(""overflow in fraction {0}/{1}, cannot negate"",
num, den);
}
num = -num;
den = -den;
}
// reduce numerator and denominator by greatest common denominator.
int d = MathUtils.gcd(num, den);
if (d > 1) {
num /= d;
den /= d;
}

// move sign to numerator.
if (den < 0) {
num *= -1;
den *= -1;
}
this.numerator = num;
this.denominator = den;
}"
Math_94b_1,/home/common/huangzhili/defects4j_buggy_3/Math_94_buggy/src/java/org/apache/commons/math/util/MathUtils.java,"public static int gcd(int u, int v) {
if (u * v == 0) {
return (Math.abs(u) + Math.abs(v));
}
// keep u and v negative, as negative integers range down to
// -2^31, while positive numbers can only be as large as 2^31-1
// (i.e. we can't necessarily negate a negative number without
// overflow)
/* assert u!=0 && v!=0; */
if (u > 0) {
u = -u;
} // make u negative
if (v > 0) {
v = -v;
} // make v negative
// B1. [Find power of 2]
int k = 0;
while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are
// both even...
u /= 2;
v /= 2;
k++; // cast out twos.
}
if (k == 31) {
throw new ArithmeticException(""overflow: gcd is 2^31"");
}
// B2. Initialize: u and v have been divided by 2^k and at least
// one is odd.
int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;
// t negative: u was odd, v may be even (t replaces v)
// t positive: u was even, v is odd (t replaces u)
do {
/* assert u<0 && v<0; */
// B4/B3: cast out twos from t.
while ((t & 1) == 0) { // while t is even..
t /= 2; // cast out twos
}
// B5 [reset max(u,v)]
if (t > 0) {
u = -t;
} else {
v = t;
}
// B6/B3. at this point both u and v should be odd.
t = (v - u) / 2;
// |u| larger: t positive (replace u)
// |v| larger: t negative (replace v)
} while (t != 0);
return -u * (1 << k); // gcd is u*2^k
}"
Math_95b_1,/home/common/huangzhili/defects4j_buggy_3/Math_95_buggy/src/java/org/apache/commons/math/distribution/FDistributionImpl.java,"protected double getDomainLowerBound(double p) {
return 0.0;
}"
Math_95b_2,/home/common/huangzhili/defects4j_buggy_3/Math_95_buggy/src/java/org/apache/commons/math/distribution/FDistributionImpl.java,"protected double getDomainUpperBound(double p) {
return Double.MAX_VALUE;
}"
Math_95b_3,/home/common/huangzhili/defects4j_buggy_3/Math_95_buggy/src/java/org/apache/commons/math/distribution/FDistributionImpl.java,"protected double getInitialDomain(double p) {
double ret;
double d = getDenominatorDegreesOfFreedom();
// use mean
ret = d / (d - 2.0);
return ret;
}"
Math_95b_4,/home/common/huangzhili/defects4j_buggy_3/Math_95_buggy/src/java/org/apache/commons/math/distribution/FDistributionImpl.java,"public double inverseCumulativeProbability(final double p)
throws MathException {
if (p == 0) {
return 0d;
}
if (p == 1) {
return Double.POSITIVE_INFINITY;
}
return super.inverseCumulativeProbability(p);
}"
Math_95b_5,/home/common/huangzhili/defects4j_buggy_3/Math_95_buggy/src/java/org/apache/commons/math/distribution/FDistributionImpl.java,"public double cumulativeProbability(double x) throws MathException {
double ret;
if (x <= 0.0) {
ret = 0.0;
} else {
double n = getNumeratorDegreesOfFreedom();
double m = getDenominatorDegreesOfFreedom();

ret = Beta.regularizedBeta((n * x) / (m + n * x),
0.5 * n,
0.5 * m);
}
return ret;
}"
Math_96b_1,/home/common/huangzhili/defects4j_buggy_3/Math_96_buggy/src/java/org/apache/commons/math/complex/Complex.java,"public int hashCode() {
if (isNaN()) {
return 7;
}
return 37 * (17 * MathUtils.hash(imaginary) +
MathUtils.hash(real));
}"
Math_96b_2,/home/common/huangzhili/defects4j_buggy_3/Math_96_buggy/src/java/org/apache/commons/math/complex/Complex.java,"public boolean equals(Object other) {
boolean ret;

if (this == other) {
ret = true;
} else if (other == null) {
ret = false;
} else  {
try {
Complex rhs = (Complex)other;
if (rhs.isNaN()) {
ret = this.isNaN();
} else {
ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));
}
} catch (ClassCastException ex) {
// ignore exception
ret = false;
}
}

return ret;
}"
Math_96b_3,/home/common/huangzhili/defects4j_buggy_3/Math_96_buggy/src/java/org/apache/commons/math/complex/Complex.java,"public Complex multiply(Complex rhs) {
if (isNaN() || rhs.isNaN()) {
return NaN;
}
if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||
Double.isInfinite(rhs.real)|| Double.isInfinite(rhs.imaginary)) {
// we don't use Complex.isInfinite() to avoid testing for NaN again
return INF;
}
return createComplex(real * rhs.real - imaginary * rhs.imaginary,
real * rhs.imaginary + imaginary * rhs.real);
}"
Math_96b_4,/home/common/huangzhili/defects4j_buggy_3/Math_96_buggy/src/java/org/apache/commons/math/complex/Complex.java,"protected Complex createComplex(double real, double imaginary) {
return new Complex(real, imaginary);
}"
Math_96b_5,/home/common/huangzhili/defects4j_buggy_3/Math_96_buggy/src/java/org/apache/commons/math/complex/Complex.java,"public double getReal() {
return real;
}"
Math_97b_1,/home/common/huangzhili/defects4j_buggy_3/Math_97_buggy/src/java/org/apache/commons/math/analysis/BrentSolver.java,"public double solve(double min, double max) throws MaxIterationsExceededException,
FunctionEvaluationException {

clearResult();
verifyInterval(min, max);

double ret = Double.NaN;

double yMin = f.value(min);
double yMax = f.value(max);

// Verify bracketing
double sign = yMin * yMax;
if (sign >= 0) {
// check if either value is close to a zero
// neither value is close to zero and min and max do not bracket root.
throw new IllegalArgumentException
(""Function values at endpoints do not have different signs."" +
""  Endpoints: ["" + min + "","" + max + ""]"" +
""  Values: ["" + yMin + "","" + yMax + ""]"");
} else {
// solve using only the first endpoint as initial guess
ret = solve(min, yMin, max, yMax, min, yMin);
// either min or max is a root
}

return ret;
}"
Math_97b_2,/home/common/huangzhili/defects4j_buggy_3/Math_97_buggy/src/java/org/apache/commons/math/analysis/BrentSolver.java,"public BrentSolver(UnivariateRealFunction f) {
super(f, 100, 1E-6);
}"
Math_101b_1,/home/common/huangzhili/defects4j_buggy_3/Math_101_buggy/src/java/org/apache/commons/math/complex/ComplexFormat.java,"public Complex parse(String source, ParsePosition pos) {
int initialIndex = pos.getIndex();

// parse whitespace
parseAndIgnoreWhitespace(source, pos);

// parse real
Number re = parseNumber(source, getRealFormat(), pos);
if (re == null) {
// invalid real number
// set index back to initial, error index should already be set
// character examined.
pos.setIndex(initialIndex);
return null;
}

// parse sign
int startIndex = pos.getIndex();
char c = parseNextCharacter(source, pos);
int sign = 0;
switch (c) {
case 0 :
// no sign
// return real only complex number
return new Complex(re.doubleValue(), 0.0);
case '-' :
sign = -1;
break;
case '+' :
sign = 1;
break;
default :
// invalid sign
// set index back to initial, error index should be the last
// character examined.
pos.setIndex(initialIndex);
pos.setErrorIndex(startIndex);
return null;
}

// parse whitespace
parseAndIgnoreWhitespace(source, pos);

// parse imaginary
Number im = parseNumber(source, getRealFormat(), pos);
if (im == null) {
// invalid imaginary number
// set index back to initial, error index should already be set
// character examined.
pos.setIndex(initialIndex);
return null;
}

// parse imaginary character
int n = getImaginaryCharacter().length();
startIndex = pos.getIndex();
int endIndex = startIndex + n;
if (
source.substring(startIndex, endIndex).compareTo(
getImaginaryCharacter()) != 0) {
// set index back to initial, error index should be the start index
// character examined.
pos.setIndex(initialIndex);
pos.setErrorIndex(startIndex);
return null;
}
pos.setIndex(endIndex);

return new Complex(re.doubleValue(), im.doubleValue() * sign);
}"
Math_101b_2,/home/common/huangzhili/defects4j_buggy_3/Math_101_buggy/src/java/org/apache/commons/math/complex/ComplexFormat.java,"public ComplexFormat() {
this(DEFAULT_IMAGINARY_CHARACTER, getDefaultNumberFormat());
}"
Math_101b_3,/home/common/huangzhili/defects4j_buggy_3/Math_101_buggy/src/java/org/apache/commons/math/complex/ComplexFormat.java,"return getDefaultNumberFormat(Locale.getDefault());
}

/**
* Create a default number format.  The default number format is based on
* {@link NumberFormat#getInstance(java.util.Locale)} with the only
* customizing is the maximum number of fraction digits, which is set to 2.
* @param locale the specific locale used by the format.
* @return the default number format specific to the given locale.
*/
private static NumberFormat getDefaultNumberFormat(Locale locale) {"
Math_101b_4,/home/common/huangzhili/defects4j_buggy_3/Math_101_buggy/src/java/org/apache/commons/math/complex/ComplexFormat.java,"private void parseAndIgnoreWhitespace(String source, ParsePosition pos) {
parseNextCharacter(source, pos);
pos.setIndex(pos.getIndex() - 1);
}"
Math_101b_5,/home/common/huangzhili/defects4j_buggy_3/Math_101_buggy/src/java/org/apache/commons/math/complex/ComplexFormat.java,"private char parseNextCharacter(String source, ParsePosition pos) {
int index = pos.getIndex();
int n = source.length();
char ret = 0;

if (index < n) {
char c;
do {
c = source.charAt(index++);
} while (Character.isWhitespace(c) && index < n);
pos.setIndex(index);

if (index < n) {
ret = c;
}
}

return ret;
}"
Math_102b_1,/home/common/huangzhili/defects4j_buggy_3/Math_102_buggy/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java,"public double chiSquare(double[] expected, long[] observed)
throws IllegalArgumentException {
if ((expected.length < 2) || (expected.length != observed.length)) {
throw new IllegalArgumentException(
""observed, expected array lengths incorrect"");
}
if (!isPositive(expected) || !isNonNegative(observed)) {
throw new IllegalArgumentException(
""observed counts must be non-negative and expected counts must be postive"");
}
double sumSq = 0.0d;
double dev = 0.0d;
for (int i = 0; i < observed.length; i++) {
dev = ((double) observed[i] - expected[i]);
sumSq += dev * dev / expected[i];
}
return sumSq;
}"
Math_102b_2,/home/common/huangzhili/defects4j_buggy_3/Math_102_buggy/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java,"public double chiSquareTest(double[] expected, long[] observed)
throws IllegalArgumentException, MathException {
distribution.setDegreesOfFreedom(expected.length - 1.0);
return 1.0 - distribution.cumulativeProbability(
chiSquare(expected, observed));
}"
Math_102b_3,/home/common/huangzhili/defects4j_buggy_3/Math_102_buggy/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java,"private boolean isPositive(double[] in) {
for (int i = 0; i < in.length; i ++) {
if (in[i] <= 0) {
return false;
}
}
return true;
}"
Math_102b_4,/home/common/huangzhili/defects4j_buggy_3/Math_102_buggy/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java,"private boolean isNonNegative(long[] in) {
for (int i = 0; i < in.length; i ++) {
if (in[i] < 0) {
return false;
}
}
return true;
}"
Math_102b_5,/home/common/huangzhili/defects4j_buggy_3/Math_102_buggy/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java,"public ChiSquareTestImpl() {
this(new ChiSquaredDistributionImpl(1.0));
}"
Math_103b_1,/home/common/huangzhili/defects4j_buggy_3/Math_103_buggy/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java,"public double cumulativeProbability(double x) throws MathException {
return 0.5 * (1.0 + Erf.erf((x - mean) /
(standardDeviation * Math.sqrt(2.0))));
}"
Math_103b_2,/home/common/huangzhili/defects4j_buggy_3/Math_103_buggy/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java,"public void setMean(double mean) {
this.mean = mean;
}"
Math_103b_3,/home/common/huangzhili/defects4j_buggy_3/Math_103_buggy/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java,"public void setStandardDeviation(double sd) {
if (sd <= 0.0) {
throw new IllegalArgumentException(
""Standard deviation must be positive."");
}
standardDeviation = sd;
}"
Math_105b_1,/home/common/huangzhili/defects4j_buggy_3/Math_105_buggy/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java,"public void addData(double x, double y) {
if (n == 0) {
xbar = x;
ybar = y;
} else {
double dx = x - xbar;
double dy = y - ybar;
sumXX += dx * dx * (double) n / (double) (n + 1.0);
sumYY += dy * dy * (double) n / (double) (n + 1.0);
sumXY += dx * dy * (double) n / (double) (n + 1.0);
xbar += dx / (double) (n + 1.0);
ybar += dy / (double) (n + 1.0);
}
sumX += x;
sumY += y;
n++;
}"
Math_105b_2,/home/common/huangzhili/defects4j_buggy_3/Math_105_buggy/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java,"public double getSumSquaredErrors() {
return sumYY - sumXY * sumXY / sumXX;
}"
Math_106b_1,/home/common/huangzhili/defects4j_buggy_3/Math_106_buggy/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java,"Fraction ret = super.parse(source, pos);
if (ret != null) {
return ret;
}"
Math_106b_2,/home/common/huangzhili/defects4j_buggy_3/Math_106_buggy/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java,"public NumberFormat getWholeFormat() {
return wholeFormat;
}"
Math_106b_3,/home/common/huangzhili/defects4j_buggy_3/Math_106_buggy/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java,"public ProperFractionFormat(NumberFormat format) {
this(format, (NumberFormat)format.clone(), (NumberFormat)format.clone());
}"
Math_106b_4,/home/common/huangzhili/defects4j_buggy_3/Math_106_buggy/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java,"public void setWholeFormat(NumberFormat format) {
if (format == null) {
throw new IllegalArgumentException(
""whole format can not be null."");
}
this.wholeFormat = format;
}"
Mockito_1b_1,/home/common/huangzhili/defects4j_buggy_3/Mockito_1_buggy/src/org/mockito/internal/invocation/InvocationMatcher.java,"public void captureArgumentsFrom(Invocation invocation) {
        if (invocation.getMethod().isVarArgs()) {
            int indexOfVararg = invocation.getRawArguments().length - 1;
            throw new UnsupportedOperationException();

        } else {
            for (int position = 0; position < matchers.size(); position++) {
                Matcher m = matchers.get(position);
                if (m instanceof CapturesArguments) {
                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
                }
            }
        }"
Mockito_5b_1,/home/common/huangzhili/defects4j_buggy_3/Mockito_5_buggy/src/org/mockito/internal/verification/VerificationOverTimeImpl.java,"public void verify(VerificationData data) {
        AssertionError error = null;

        timer.start();
        while (timer.isCounting()) {
            try {
                delegate.verify(data);

                if (returnOnSuccess) {
                    return;
                } else {
                    error = null;
                }
            } catch (MockitoAssertionError e) {
                error = handleVerifyException(e);
            }
            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {
                error = handleVerifyException(e);
            }
        }

        if (error != null) {
            throw error;
        }
    }"
Mockito_7b_1,/home/common/huangzhili/defects4j_buggy_3/Mockito_7_buggy/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java,"private void readTypeVariables() {
            for (Type type : typeVariable.getBounds()) {
                registerTypeVariablesOn(type);
            }
            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));
        }"
Mockito_8b_1,/home/common/huangzhili/defects4j_buggy_3/Mockito_8_buggy/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java,"protected void registerTypeVariablesOn(Type classType) {
if (!(classType instanceof ParameterizedType)) {
return;
}
ParameterizedType parameterizedType = (ParameterizedType) classType;
TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();
Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
for (int i = 0; i < actualTypeArguments.length; i++) {
TypeVariable typeParameter = typeParameters[i];
Type actualTypeArgument = actualTypeArguments[i];

if (actualTypeArgument instanceof WildcardType) {
contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
} else {
contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
}
// logger.log(""For '"" + parameterizedType + ""' found type variable : { '"" + typeParameter + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' : '"" + actualTypeArgument + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' }"");
}
}"
Mockito_8b_2,/home/common/huangzhili/defects4j_buggy_3/Mockito_8_buggy/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java,"public static GenericMetadataSupport inferFrom(Type type) {
Checks.checkNotNull(type, ""type"");
if (type instanceof Class) {
return new FromClassGenericMetadataSupport((Class<?>) type);
}
if (type instanceof ParameterizedType) {
return new FromParameterizedTypeGenericMetadataSupport((ParameterizedType) type);
}

throw new MockitoException(""Type meta-data for this Type ("" + type.getClass().getCanonicalName() + "") is not supported : "" + type);
}"
Mockito_8b_3,/home/common/huangzhili/defects4j_buggy_3/Mockito_8_buggy/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java,"protected void registerTypeParametersOn(TypeVariable[] typeParameters) {
for (TypeVariable typeVariable : typeParameters) {
registerTypeVariableIfNotPresent(typeVariable);
}
}"
Mockito_8b_4,/home/common/huangzhili/defects4j_buggy_3/Mockito_8_buggy/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java,"private void registerTypeVariableIfNotPresent(TypeVariable typeVariable) {
if (!contextualActualTypeParameters.containsKey(typeVariable)) {
contextualActualTypeParameters.put(typeVariable, boundsOf(typeVariable));
// logger.log(""For '"" + typeVariable.getGenericDeclaration() + ""' found type variable : { '"" + typeVariable + ""("" + System.identityHashCode(typeVariable) + "")"" + ""' : '"" + boundsOf(typeVariable) + ""' }"");
}
}"
Mockito_8b_5,/home/common/huangzhili/defects4j_buggy_3/Mockito_8_buggy/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java,"private BoundedType boundsOf(TypeVariable typeParameter) {
if (typeParameter.getBounds()[0] instanceof TypeVariable) {
return boundsOf((TypeVariable) typeParameter.getBounds()[0]);
}
return new TypeVarBoundedType(typeParameter);
}"
Mockito_12b_1,/home/common/huangzhili/defects4j_buggy_3/Mockito_12_buggy/src/org/mockito/internal/util/reflection/GenericMaster.java,"Type generic = field.getGenericType();
if (generic != null && generic instanceof ParameterizedType) {
Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];
return (Class) actual;
//in case of nested generics we don't go deep
}"
Mockito_13b_1,/home/common/huangzhili/defects4j_buggy_3/Mockito_13_buggy/src/org/mockito/internal/MockHandler.java,"public Object handle(Invocation invocation) throws Throwable {
        if (invocationContainerImpl.hasAnswersForStubbing()) {
            // stubbing voids with stubVoid() or doAnswer() style
            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress
                            .getArgumentMatcherStorage(), invocation);
            invocationContainerImpl.setMethodForStubbing(invocationMatcher);
            return null;
        }
        VerificationMode verificationMode = mockingProgress.pullVerificationMode();

        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),
                        invocation);

        mockingProgress.validateState();

        //if verificationMode is not null then someone is doing verify()        
        if (verificationMode != null) {
            //We need to check if verification was started on the correct mock 
            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                
                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            
                verificationMode.verify(data);
                return null;
                // this means there is an invocation on a different mock. Re-adding verification mode 
                // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
            }
        }
        
        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);
        mockingProgress.reportOngoingStubbing(ongoingStubbing);

        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);

        if (stubbedInvocation != null) {
            stubbedInvocation.captureArgumentsFrom(invocation);
            return stubbedInvocation.answer(invocation);
        } else {
            Object ret = mockSettings.getDefaultAnswer().answer(invocation);

            // redo setting invocation for potential stubbing in case of partial
            // mocks / spies.
            // Without it, the real method inside 'when' might have delegated
            // to other self method and overwrite the intended stubbed method
            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.
            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
            return ret;
        }
    }"
Mockito_18b_1,/home/common/huangzhili/defects4j_buggy_3/Mockito_18_buggy/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java,"Object returnValueFor(Class<?> type) {
        if (Primitives.isPrimitiveOrWrapper(type)) {
            return Primitives.defaultValueForPrimitiveOrWrapper(type);
            //new instances are used instead of Collections.emptyList(), etc.
            //to avoid UnsupportedOperationException if code under test modifies returned collection
        } else if (type == Collection.class) {
            return new LinkedList<Object>();
        } else if (type == Set.class) {
            return new HashSet<Object>();
        } else if (type == HashSet.class) {
            return new HashSet<Object>();
        } else if (type == SortedSet.class) {
            return new TreeSet<Object>();
        } else if (type == TreeSet.class) {
            return new TreeSet<Object>();
        } else if (type == LinkedHashSet.class) {
            return new LinkedHashSet<Object>();
        } else if (type == List.class) {
            return new LinkedList<Object>();
        } else if (type == LinkedList.class) {
            return new LinkedList<Object>();
        } else if (type == ArrayList.class) {
            return new ArrayList<Object>();
        } else if (type == Map.class) {
            return new HashMap<Object, Object>();
        } else if (type == HashMap.class) {
            return new HashMap<Object, Object>();
        } else if (type == SortedMap.class) {
            return new TreeMap<Object, Object>();
        } else if (type == TreeMap.class) {
            return new TreeMap<Object, Object>();
        } else if (type == LinkedHashMap.class) {
            return new LinkedHashMap<Object, Object>();
        }
        //Let's not care about the rest of collections.
        return null;
    }"
Mockito_20b_1,/home/common/huangzhili/defects4j_buggy_3/Mockito_20_buggy/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java,"public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
            throw new MockitoException(""Serialization across classloaders not yet supported with ByteBuddyMockMaker"");
        }
        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(
                settings.getTypeToMock(),
                settings.getExtraInterfaces()
        );
        T mockInstance = null;
        try {
            mockInstance = classInstantiator.instantiate(mockedProxyType);
            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));

            return ensureMockIsAssignableToMockedType(settings, mockInstance);
        } catch (ClassCastException cce) {
            throw new MockitoException(join(
                    ""ClassCastException occurred while creating the mockito mock :"",
                    ""  class to mock : "" + describeClass(mockedProxyType),
                    ""  created class : "" + describeClass(settings.getTypeToMock()),
                    ""  proxy instance class : "" + describeClass(mockInstance),
                    ""  instance creation by : "" + classInstantiator.getClass().getSimpleName(),
                    """",
                    ""You might experience classloading issues, please ask the mockito mailing-list."",
                    """"
            ),cce);
        } catch (org.mockito.internal.creation.instance.InstantiationException e) {
            throw new MockitoException(""Unable to create mock instance of type '"" + mockedProxyType.getSuperclass().getSimpleName() + ""'"", e);
        }
    }"
Mockito_22b_1,/home/common/huangzhili/defects4j_buggy_3/Mockito_22_buggy/src/org/mockito/internal/matchers/Equality.java,"public static boolean areEqual(Object o1, Object o2) {
        if (o1 == null || o2 == null) {
            return o1 == null && o2 == null;
        } else if (isArray(o1)) {
            return isArray(o2) && areArraysEqual(o1, o2);
        } else {
            return o1.equals(o2);
        }
    }"
Mockito_24b_1,/home/common/huangzhili/defects4j_buggy_3/Mockito_24_buggy/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java,"public Object answer(InvocationOnMock invocation) {
        if (methodsGuru.isToString(invocation.getMethod())) {
            Object mock = invocation.getMock();
            MockName name = mockUtil.getMockName(mock);
            if (name.isDefault()) {
                return ""Mock for "" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + "", hashCode: "" + mock.hashCode();
            } else {
                return name.toString();
            }
        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {
            //see issue 184.
            //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).
            //Only for compareTo() method by the Comparable interface
            return 1;
        }
        
        Class<?> returnType = invocation.getMethod().getReturnType();
        return returnValueFor(returnType);
    }"
Mockito_26b_1,/home/common/huangzhili/defects4j_buggy_3/Mockito_26_buggy/src/org/mockito/internal/util/Primitives.java,"public static <T> T primitiveValueOrNullFor(Class<T> primitiveType) {
return (T) primitiveValues.get(primitiveType);
}"
Mockito_26b_2,/home/common/huangzhili/defects4j_buggy_3/Mockito_26_buggy/src/org/mockito/internal/util/Primitives.java,"public static boolean isPrimitiveWrapper(Class<?> type) {
return wrapperReturnValues.containsKey(type);
}"
Mockito_27b_1,/home/common/huangzhili/defects4j_buggy_3/Mockito_27_buggy/src/org/mockito/internal/util/MockUtil.java,"public <T> void resetMock(T mock) {
        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);
        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);
        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));
        ((Factory) mock).setCallback(0, newFilter);
    }"
Mockito_28b_1,/home/common/huangzhili/defects4j_buggy_3/Mockito_28_buggy/src/org/mockito/internal/configuration/DefaultInjectionEngine.java,"private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
        }
    }"
Mockito_29b_1,/home/common/huangzhili/defects4j_buggy_3/Mockito_29_buggy/src/org/mockito/internal/matchers/Same.java,"public void describeTo(Description description) {
        description.appendText(""same("");
        appendQuoting(description);
        description.appendText(wanted.toString());
        appendQuoting(description);
        description.appendText("")"");
    }"
Mockito_33b_1,/home/common/huangzhili/defects4j_buggy_3/Mockito_33_buggy/src/org/mockito/internal/invocation/InvocationMatcher.java,"public boolean hasSameMethod(Invocation candidate) {        
        //not using method.equals() for 1 good reason:
        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest
        Method m1 = invocation.getMethod();
        Method m2 = candidate.getMethod();
        
         /* Avoid unnecessary cloning */
        return m1.equals(m2);
    }"
Mockito_34b_1,/home/common/huangzhili/defects4j_buggy_3/Mockito_34_buggy/src/org/mockito/internal/invocation/InvocationMatcher.java,"public void captureArgumentsFrom(Invocation i) {
        int k = 0;
        for (Matcher m : matchers) {
            if (m instanceof CapturesArguments) {
                ((CapturesArguments) m).captureFrom(i.getArguments()[k]);
            }
            k++;
        }
    }"
Mockito_38b_1,/home/common/huangzhili/defects4j_buggy_3/Mockito_38_buggy/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java,"public Integer[] getSuspiciouslyNotMatchingArgsIndexes(List<Matcher> matchers, Object[] arguments) {
if (matchers.size() != arguments.length) {
return new Integer[0];
}

List<Integer> suspicious = new LinkedList<Integer>();
int i = 0;
for (Matcher m : matchers) {
if (m instanceof ContainsExtraTypeInformation
&& !safelyMatches(m, arguments[i])
&& toStringEquals(m, arguments[i])
&& !((ContainsExtraTypeInformation) m).typeMatches(arguments[i])) {
suspicious.add(i);
}
i++;
}
return suspicious.toArray(new Integer[0]);
}"
Mockito_38b_2,/home/common/huangzhili/defects4j_buggy_3/Mockito_38_buggy/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java,"private boolean toStringEquals(Matcher m, Object arg) {
return StringDescription.toString(m).equals(arg.toString());
}"
Mockito_38b_3,/home/common/huangzhili/defects4j_buggy_3/Mockito_38_buggy/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java,"private boolean safelyMatches(Matcher m, Object arg) {
try {
return m.matches(arg);
} catch (Throwable t) {
return false;
}
}"
Time_4b_1,/home/common/huangzhili/defects4j_buggy_3/Time_4_buggy/src/main/java/org/joda/time/Partial.java,"public Partial with(DateTimeFieldType fieldType, int value) {
if (fieldType == null) {
throw new IllegalArgumentException(""The field type must not be null"");
}
int index = indexOf(fieldType);
if (index == -1) {
DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];
int[] newValues = new int[newTypes.length];

// find correct insertion point to keep largest-smallest order
int i = 0;
DurationField unitField = fieldType.getDurationType().getField(iChronology);
if (unitField.isSupported()) {
for (; i < iTypes.length; i++) {
DateTimeFieldType loopType = iTypes[i];
DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
if (loopUnitField.isSupported()) {
int compare = unitField.compareTo(loopUnitField);
if (compare > 0) {
break;
} else if (compare == 0) {
DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
if (rangeField.compareTo(loopRangeField) > 0) {
break;
}
}
}
}
}
System.arraycopy(iTypes, 0, newTypes, 0, i);
System.arraycopy(iValues, 0, newValues, 0, i);
newTypes[i] = fieldType;
newValues[i] = value;
System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);
System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
// use public constructor to ensure full validation
// this isn't overly efficient, but is safe
Partial newPartial = new Partial(iChronology, newTypes, newValues);
iChronology.validate(newPartial, newValues);
return newPartial;
}
if (value == getValue(index)) {
return this;
}
int[] newValues = getValues();
newValues = getField(index).set(this, index, newValues, value);
return new Partial(this, newValues);
}"
Time_4b_2,/home/common/huangzhili/defects4j_buggy_3/Time_4_buggy/src/main/java/org/joda/time/Partial.java,"public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
super();
chronology = DateTimeUtils.getChronology(chronology).withUTC();
iChronology = chronology;
if (types == null) {
throw new IllegalArgumentException(""Types array must not be null"");
}
if (values == null) {
throw new IllegalArgumentException(""Values array must not be null"");
}
if (values.length != types.length) {
throw new IllegalArgumentException(""Values array must be the same length as the types array"");
}
if (types.length == 0) {
iTypes = types;
iValues = values;
return;
}
for (int i = 0; i < types.length; i++) {
if (types[i] == null) {
throw new IllegalArgumentException(""Types array must not contain null: index "" + i);
}
}
DurationField lastUnitField = null;
for (int i = 0; i < types.length; i++) {
DateTimeFieldType loopType = types[i];
DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
if (i > 0) {
int compare = lastUnitField.compareTo(loopUnitField);
if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
types[i - 1].getName() + "" < "" + loopType.getName());
} else if (compare == 0) {
if (types[i - 1].getRangeDurationType() == null) {
if (loopType.getRangeDurationType() == null) {
throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
}
} else {
if (loopType.getRangeDurationType() == null) {
throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
types[i - 1].getName() + "" < "" + loopType.getName());
}
DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);
DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
if (lastRangeField.compareTo(loopRangeField) < 0) {
throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
types[i - 1].getName() + "" < "" + loopType.getName());
}
if (lastRangeField.compareTo(loopRangeField) == 0) {
throw new IllegalArgumentException(""Types array must not contain duplicate: "" + loopType.getName());
}
}
}
}
lastUnitField = loopUnitField;
}

iTypes = (DateTimeFieldType[]) types.clone();
chronology.validate(this, values);
iValues = (int[]) values.clone();
}"
Time_4b_3,/home/common/huangzhili/defects4j_buggy_3/Time_4_buggy/src/main/java/org/joda/time/Partial.java,"public DateTimeFieldType getFieldType(int index) {
return iTypes[index];
}"
Time_4b_4,/home/common/huangzhili/defects4j_buggy_3/Time_4_buggy/src/main/java/org/joda/time/Partial.java,"public Chronology getChronology() {
return iChronology;
}"
Time_4b_5,/home/common/huangzhili/defects4j_buggy_3/Time_4_buggy/src/main/java/org/joda/time/Partial.java,"return iTypes[index].getField(chrono);
}

/**
* Gets the field type at the specified index.
*
* @param index  the index to retrieve
* @return the field at the specified index
* @throws IndexOutOfBoundsException if the index is invalid
*/
public DateTimeFieldType getFieldType(int index) {"
Time_5b_1,/home/common/huangzhili/defects4j_buggy_3/Time_5_buggy/src/main/java/org/joda/time/Period.java,"public Period normalizedStandard(PeriodType type) {
type = DateTimeUtils.getPeriodType(type);
long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs
millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));
millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));
millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));
millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));
millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));
Period result = new Period(millis, type, ISOChronology.getInstanceUTC());
int years = getYears();
int months = getMonths();
if (years != 0 || months != 0) {
years = FieldUtils.safeAdd(years, months / 12);
months = months % 12;
if (years != 0) {
result = result.withYears(years);
}
if (months != 0) {
result = result.withMonths(months);
}
}
return result;
}"
Time_5b_2,/home/common/huangzhili/defects4j_buggy_3/Time_5_buggy/src/main/java/org/joda/time/Period.java,"public Period withYears(int years) {
int[] values = getValues();  // cloned
getPeriodType().setIndexedField(this, PeriodType.YEAR_INDEX, values, years);
return new Period(values, getPeriodType());
}"
Time_5b_3,/home/common/huangzhili/defects4j_buggy_3/Time_5_buggy/src/main/java/org/joda/time/Period.java,"public Period() {
super(0L, null, null);
}"
Time_5b_4,/home/common/huangzhili/defects4j_buggy_3/Time_5_buggy/src/main/java/org/joda/time/Period.java,"public int getYears() {
return getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);
}"
Time_5b_5,/home/common/huangzhili/defects4j_buggy_3/Time_5_buggy/src/main/java/org/joda/time/Period.java,"public int getMonths() {
return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);
}"
Time_7b_1,/home/common/huangzhili/defects4j_buggy_3/Time_7_buggy/src/main/java/org/joda/time/format/DateTimeFormatter.java,"public DateTimeFormatter withLocale(Locale locale) {
if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {
return this;
}
return new DateTimeFormatter(iPrinter, iParser, locale,
iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);
}"
Time_7b_2,/home/common/huangzhili/defects4j_buggy_3/Time_7_buggy/src/main/java/org/joda/time/format/DateTimeFormatter.java,"public Locale getLocale() {
return iLocale;
}"
Time_7b_3,/home/common/huangzhili/defects4j_buggy_3/Time_7_buggy/src/main/java/org/joda/time/format/DateTimeFormatter.java,"public int parseInto(ReadWritableInstant instant, String text, int position) {
DateTimeParser parser = requireParser();
if (instant == null) {
throw new IllegalArgumentException(""Instant must not be null"");
}

long instantMillis = instant.getMillis();
Chronology chrono = instant.getChronology();
long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
chrono = selectChronology(chrono);
int defaultYear = chrono.year().get(instantLocal);

DateTimeParserBucket bucket = new DateTimeParserBucket(
instantLocal, chrono, iLocale, iPivotYear, defaultYear);
int newPos = parser.parseInto(bucket, text, position);
instant.setMillis(bucket.computeMillis(false, text));
if (iOffsetParsed && bucket.getOffsetInteger() != null) {
int parsedOffset = bucket.getOffsetInteger();
DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
chrono = chrono.withZone(parsedZone);
} else if (bucket.getZone() != null) {
chrono = chrono.withZone(bucket.getZone());
}
instant.setChronology(chrono);
if (iZone != null) {
instant.setZone(iZone);
}
return newPos;
}"
Time_7b_4,/home/common/huangzhili/defects4j_buggy_3/Time_7_buggy/src/main/java/org/joda/time/format/DateTimeFormatter.java,"private DateTimeParser requireParser() {
DateTimeParser parser = iParser;
if (parser == null) {
throw new UnsupportedOperationException(""Parsing not supported"");
}
return parser;
}"
Time_7b_5,/home/common/huangzhili/defects4j_buggy_3/Time_7_buggy/src/main/java/org/joda/time/format/DateTimeFormatter.java,"public DateTimeFormatter(
DateTimePrinter printer, DateTimeParser parser) {
super();
iPrinter = printer;
iParser = parser;
iLocale = null;
iOffsetParsed = false;
iChrono = null;
iZone = null;
iPivotYear = null;
iDefaultYear = 2000;
}"
Time_8b_1,/home/common/huangzhili/defects4j_buggy_3/Time_8_buggy/src/main/java/org/joda/time/DateTimeZone.java,"public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {
if (hoursOffset == 0 && minutesOffset == 0) {
return DateTimeZone.UTC;
}
if (hoursOffset < -23 || hoursOffset > 23) {
throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
}
if (minutesOffset < 0 || minutesOffset > 59) {
throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
}
int offset = 0;
try {
int hoursInMinutes = hoursOffset * 60;
if (hoursInMinutes < 0) {
minutesOffset = hoursInMinutes - minutesOffset;
} else {
minutesOffset = hoursInMinutes + minutesOffset;
}
offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
} catch (ArithmeticException ex) {
throw new IllegalArgumentException(""Offset is too large"");
}
return forOffsetMillis(offset);
}"
Time_8b_2,/home/common/huangzhili/defects4j_buggy_3/Time_8_buggy/src/main/java/org/joda/time/DateTimeZone.java,"public static DateTimeZone forID(String id) {
if (id == null) {
return getDefault();
}
if (id.equals(""UTC"")) {
return DateTimeZone.UTC;
}
DateTimeZone zone = cProvider.getZone(id);
if (zone != null) {
return zone;
}
if (id.startsWith(""+"") || id.startsWith(""-"")) {
int offset = parseOffset(id);
if (offset == 0L) {
return DateTimeZone.UTC;
} else {
id = printOffset(offset);
return fixedOffsetZone(id, offset);
}
}
throw new IllegalArgumentException(""The datetime zone id '"" + id + ""' is not recognised"");
}"
Time_8b_3,/home/common/huangzhili/defects4j_buggy_3/Time_8_buggy/src/main/java/org/joda/time/DateTimeZone.java,"public static DateTimeZone forOffsetMillis(int millisOffset) {
if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) {
throw new IllegalArgumentException(""Millis out of range: "" + millisOffset);
}
String id = printOffset(millisOffset);
return fixedOffsetZone(id, millisOffset);
}"
Time_8b_4,/home/common/huangzhili/defects4j_buggy_3/Time_8_buggy/src/main/java/org/joda/time/DateTimeZone.java,"private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {
if (offset == 0) {
return DateTimeZone.UTC;
}
if (iFixedOffsetCache == null) {
iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();
}
DateTimeZone zone;
Reference<DateTimeZone> ref = iFixedOffsetCache.get(id);
if (ref != null) {
zone = ref.get();
if (zone != null) {
return zone;
}
}
zone = new FixedDateTimeZone(id, null, offset, offset);
iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));
return zone;
}"
Time_8b_5,/home/common/huangzhili/defects4j_buggy_3/Time_8_buggy/src/main/java/org/joda/time/DateTimeZone.java,"private static String printOffset(int offset) {
StringBuffer buf = new StringBuffer();
if (offset >= 0) {
buf.append('+');
} else {
buf.append('-');
offset = -offset;
}

int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;
FormatUtils.appendPaddedInteger(buf, hours, 2);
offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;

int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;
buf.append(':');
FormatUtils.appendPaddedInteger(buf, minutes, 2);
offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;
if (offset == 0) {
return buf.toString();
}

int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;
buf.append(':');
FormatUtils.appendPaddedInteger(buf, seconds, 2);
offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;
if (offset == 0) {
return buf.toString();
}

buf.append('.');
FormatUtils.appendPaddedInteger(buf, offset, 3);
return buf.toString();
}"
Time_11b_1,/home/common/huangzhili/defects4j_buggy_3/Time_11_buggy/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java,"public static boolean verbose() {
return cVerbose.get();
}"
Time_14b_1,/home/common/huangzhili/defects4j_buggy_3/Time_14_buggy/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java,"public long add(long instant, int months) {
if (months == 0) {
return instant; // the easy case
}
//
// Save time part first.
//
long timePart = iChronology.getMillisOfDay(instant);
//
//
// Get this year and month.
//
int thisYear = iChronology.getYear(instant);
int thisMonth = iChronology.getMonthOfYear(instant, thisYear);
// ----------------------------------------------------------
//
// Do not refactor without careful consideration.
// Order of calculation is important.
//
int yearToUse;
// Initially, monthToUse is zero-based
int monthToUse = thisMonth - 1 + months;
if (monthToUse >= 0) {
yearToUse = thisYear + (monthToUse / iMax);
monthToUse = (monthToUse % iMax) + 1;
} else {
yearToUse = thisYear + (monthToUse / iMax) - 1;
monthToUse = Math.abs(monthToUse);
int remMonthToUse = monthToUse % iMax;
// Take care of the boundary condition
if (remMonthToUse == 0) {
remMonthToUse = iMax;
}
monthToUse = iMax - remMonthToUse + 1;
// Take care of the boundary condition
if (monthToUse == 1) {
yearToUse += 1;
}
}
// End of do not refactor.
// ----------------------------------------------------------

//
// Quietly force DOM to nearest sane value.
//
int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);
int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);
if (dayToUse > maxDay) {
dayToUse = maxDay;
}
//
// get proper date part, and return result
//
long datePart =
iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse);
return datePart + timePart;
}"
Time_14b_2,/home/common/huangzhili/defects4j_buggy_3/Time_14_buggy/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java,"public int getMinimumValue() {
return MIN;
}"
Time_14b_3,/home/common/huangzhili/defects4j_buggy_3/Time_14_buggy/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java,"public int getMaximumValue() {
return iMax;
}"
Time_14b_4,/home/common/huangzhili/defects4j_buggy_3/Time_14_buggy/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java,"BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {
super(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());
iChronology = chronology;
iMax = iChronology.getMaxMonth();
iLeapMonth = leapMonth;
}"
Time_14b_5,/home/common/huangzhili/defects4j_buggy_3/Time_14_buggy/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java,"public int get(long instant) {
return iChronology.getMonthOfYear(instant);
}"
Time_15b_1,/home/common/huangzhili/defects4j_buggy_3/Time_15_buggy/src/main/java/org/joda/time/field/FieldUtils.java,"public static long safeMultiply(long val1, int val2) {
switch (val2) {
case -1:
return -val1;
case 0:
return 0L;
case 1:
return val1;
}
long total = val1 * val2;
if (total / val2 != val1) {
throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
}
return total;
}"
Time_16b_1,/home/common/huangzhili/defects4j_buggy_3/Time_16_buggy/src/main/java/org/joda/time/format/DateTimeFormatter.java,"public String print(ReadableInstant instant) {
StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());
printTo(buf, instant);
return buf.toString();
}"
Time_16b_2,/home/common/huangzhili/defects4j_buggy_3/Time_16_buggy/src/main/java/org/joda/time/format/DateTimeFormatter.java,"public void printTo(StringBuffer buf, ReadableInstant instant) {
long millis = DateTimeUtils.getInstantMillis(instant);
Chronology chrono = DateTimeUtils.getInstantChronology(instant);
printTo(buf, millis, chrono);
}"
Time_16b_3,/home/common/huangzhili/defects4j_buggy_3/Time_16_buggy/src/main/java/org/joda/time/format/DateTimeFormatter.java,"public int parseInto(ReadWritableInstant instant, String text, int position) {
DateTimeParser parser = requireParser();
if (instant == null) {
throw new IllegalArgumentException(""Instant must not be null"");
}

long instantMillis = instant.getMillis();
Chronology chrono = instant.getChronology();
long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
chrono = selectChronology(chrono);

DateTimeParserBucket bucket = new DateTimeParserBucket(
instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
int newPos = parser.parseInto(bucket, text, position);
instant.setMillis(bucket.computeMillis(false, text));
if (iOffsetParsed && bucket.getOffsetInteger() != null) {
int parsedOffset = bucket.getOffsetInteger();
DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);
chrono = chrono.withZone(parsedZone);
} else if (bucket.getZone() != null) {
chrono = chrono.withZone(bucket.getZone());
}
instant.setChronology(chrono);
if (iZone != null) {
instant.setZone(iZone);
}
return newPos;
}"
Time_16b_4,/home/common/huangzhili/defects4j_buggy_3/Time_16_buggy/src/main/java/org/joda/time/format/DateTimeFormatter.java,"private DateTimePrinter requirePrinter() {
DateTimePrinter printer = iPrinter;
if (printer == null) {
throw new UnsupportedOperationException(""Printing not supported"");
}
return printer;
}"
Time_16b_5,/home/common/huangzhili/defects4j_buggy_3/Time_16_buggy/src/main/java/org/joda/time/format/DateTimeFormatter.java,"public DateTimeFormatter withLocale(Locale locale) {
if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {
return this;
}
return new DateTimeFormatter(iPrinter, iParser, locale,
iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);
}"
Time_17b_1,/home/common/huangzhili/defects4j_buggy_3/Time_17_buggy/src/main/java/org/joda/time/DateTimeZone.java,"public long adjustOffset(long instant, boolean earlierOrLater) {
// a bit messy, but will work in all non-pathological cases

// evaluate 3 hours before and after to work out if anything is happening
long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);
if (instantBefore == instantAfter) {
return instant;  // not an overlap (less than is a gap, equal is normal case)
}

// work out range of instants that have duplicate local times
long local = convertUTCToLocal(instant);
return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);

// calculate result
// currently in later offset
// currently in earlier offset
}"
Time_17b_2,/home/common/huangzhili/defects4j_buggy_3/Time_17_buggy/src/main/java/org/joda/time/DateTimeZone.java,"public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {
int offsetOriginal = getOffset(originalInstantUTC);
long instantUTC = instantLocal - offsetOriginal;
int offsetLocalFromOriginal = getOffset(instantUTC);
if (offsetLocalFromOriginal == offsetOriginal) {
return instantUTC;
}
return convertLocalToUTC(instantLocal, strict);
}"
Time_17b_3,/home/common/huangzhili/defects4j_buggy_3/Time_17_buggy/src/main/java/org/joda/time/DateTimeZone.java,"public long convertUTCToLocal(long instantUTC) {
int offset = getOffset(instantUTC);
long instantLocal = instantUTC + offset;
// If there is a sign change, but the two values have the same sign...
if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {
throw new ArithmeticException(""Adding time zone offset caused overflow"");
}
return instantLocal;
}"
Time_17b_4,/home/common/huangzhili/defects4j_buggy_3/Time_17_buggy/src/main/java/org/joda/time/DateTimeZone.java,"public int getOffsetFromLocal(long instantLocal) {
// get the offset at instantLocal (first estimate)
final int offsetLocal = getOffset(instantLocal);
// adjust instantLocal using the estimate and recalc the offset
final long instantAdjusted = instantLocal - offsetLocal;
final int offsetAdjusted = getOffset(instantAdjusted);
// if the offsets differ, we must be near a DST boundary
if (offsetLocal != offsetAdjusted) {
// we need to ensure that time is always after the DST gap
// this happens naturally for positive offsets, but not for negative
if ((offsetLocal - offsetAdjusted) < 0) {
// if we just return offsetAdjusted then the time is pushed
// back before the transition, whereas it should be
// on or after the transition
long nextLocal = nextTransition(instantAdjusted);
long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
if (nextLocal != nextAdjusted) {
return offsetLocal;
}
}
} else if (offsetLocal >= 0) {
long prev = previousTransition(instantAdjusted);
if (prev < instantAdjusted) {
int offsetPrev = getOffset(prev);
int diff = offsetPrev - offsetLocal;
if (instantAdjusted - prev <= diff) {
return offsetPrev;
}
}
}
return offsetAdjusted;
}"
Time_17b_5,/home/common/huangzhili/defects4j_buggy_3/Time_17_buggy/src/main/java/org/joda/time/DateTimeZone.java,"protected DateTimeZone(String id) {
if (id == null) {
throw new IllegalArgumentException(""Id must not be null"");
}
iID = id;
}"
Time_18b_1,/home/common/huangzhili/defects4j_buggy_3/Time_18_buggy/src/main/java/org/joda/time/chrono/GJChronology.java,"public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
int hourOfDay, int minuteOfHour,"
Time_18b_2,/home/common/huangzhili/defects4j_buggy_3/Time_18_buggy/src/main/java/org/joda/time/chrono/GJChronology.java,"public static GJChronology getInstanceUTC() {
return getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);
}"
Time_18b_3,/home/common/huangzhili/defects4j_buggy_3/Time_18_buggy/src/main/java/org/joda/time/chrono/GJChronology.java,"private GJChronology(JulianChronology julian,
GregorianChronology gregorian,"
Time_18b_4,/home/common/huangzhili/defects4j_buggy_3/Time_18_buggy/src/main/java/org/joda/time/chrono/GJChronology.java,"private static long convertByYear(long instant, Chronology from, Chronology to) {
return to.getDateTimeMillis
(from.year().get(instant),
from.monthOfYear().get(instant),
from.dayOfMonth().get(instant),
from.millisOfDay().get(instant));
}"
Time_18b_5,/home/common/huangzhili/defects4j_buggy_3/Time_18_buggy/src/main/java/org/joda/time/chrono/GJChronology.java,"public static synchronized GJChronology getInstance(
DateTimeZone zone,"
Time_19b_1,/home/common/huangzhili/defects4j_buggy_3/Time_19_buggy/src/main/java/org/joda/time/DateTimeZone.java,"public int getOffsetFromLocal(long instantLocal) {
// get the offset at instantLocal (first estimate)
final int offsetLocal = getOffset(instantLocal);
// adjust instantLocal using the estimate and recalc the offset
final long instantAdjusted = instantLocal - offsetLocal;
final int offsetAdjusted = getOffset(instantAdjusted);
// if the offsets differ, we must be near a DST boundary
if (offsetLocal != offsetAdjusted) {
// we need to ensure that time is always after the DST gap
// this happens naturally for positive offsets, but not for negative
if ((offsetLocal - offsetAdjusted) < 0) {
// if we just return offsetAdjusted then the time is pushed
// back before the transition, whereas it should be
// on or after the transition
long nextLocal = nextTransition(instantAdjusted);
long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
if (nextLocal != nextAdjusted) {
return offsetLocal;
}
}
} else if (offsetLocal > 0) {
long prev = previousTransition(instantAdjusted);
if (prev < instantAdjusted) {
int offsetPrev = getOffset(prev);
int diff = offsetPrev - offsetLocal;
if (instantAdjusted - prev <= diff) {
return offsetPrev;
}
}
}
return offsetAdjusted;
}"
Time_19b_2,/home/common/huangzhili/defects4j_buggy_3/Time_19_buggy/src/main/java/org/joda/time/DateTimeZone.java,"protected DateTimeZone(String id) {
if (id == null) {
throw new IllegalArgumentException(""Id must not be null"");
}
iID = id;
}"
Time_19b_3,/home/common/huangzhili/defects4j_buggy_3/Time_19_buggy/src/main/java/org/joda/time/DateTimeZone.java,"public static DateTimeZone forID(String id) {
if (id == null) {
return getDefault();
}
if (id.equals(""UTC"")) {
return DateTimeZone.UTC;
}
DateTimeZone zone = cProvider.getZone(id);
if (zone != null) {
return zone;
}
if (id.startsWith(""+"") || id.startsWith(""-"")) {
int offset = parseOffset(id);
if (offset == 0L) {
return DateTimeZone.UTC;
} else {
id = printOffset(offset);
return fixedOffsetZone(id, offset);
}
}
throw new IllegalArgumentException(""The datetime zone id '"" + id + ""' is not recognised"");
}"
Time_19b_4,/home/common/huangzhili/defects4j_buggy_3/Time_19_buggy/src/main/java/org/joda/time/DateTimeZone.java,"private static void setProvider0(Provider provider) {
if (provider == null) {
provider = getDefaultProvider();
}
Set<String> ids = provider.getAvailableIDs();
if (ids == null || ids.size() == 0) {
throw new IllegalArgumentException
(""The provider doesn't have any available ids"");
}
if (!ids.contains(""UTC"")) {
throw new IllegalArgumentException(""The provider doesn't support UTC"");
}
if (!UTC.equals(provider.getZone(""UTC""))) {
throw new IllegalArgumentException(""Invalid UTC zone provided"");
}
cProvider = provider;
cAvailableIDs = ids;
}"
Time_19b_5,/home/common/huangzhili/defects4j_buggy_3/Time_19_buggy/src/main/java/org/joda/time/DateTimeZone.java,"private static Provider getDefaultProvider() {
Provider provider = null;

try {
String providerClass =
System.getProperty(""org.joda.time.DateTimeZone.Provider"");
if (providerClass != null) {
try {
provider = (Provider) Class.forName(providerClass).newInstance();
} catch (Exception ex) {
Thread thread = Thread.currentThread();
thread.getThreadGroup().uncaughtException(thread, ex);
}
}
} catch (SecurityException ex) {
// ignored
}

if (provider == null) {
try {
provider = new ZoneInfoProvider(""org/joda/time/tz/data"");
} catch (Exception ex) {
Thread thread = Thread.currentThread();
thread.getThreadGroup().uncaughtException(thread, ex);
}
}

if (provider == null) {
provider = new UTCProvider();
}

return provider;
}"
Time_20b_1,/home/common/huangzhili/defects4j_buggy_3/Time_20_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java,"public DateTimeFormatterBuilder appendTimeZoneId() {
return append0(TimeZoneId.INSTANCE, TimeZoneId.INSTANCE);
}"
Time_20b_2,/home/common/huangzhili/defects4j_buggy_3/Time_20_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java,"public DateTimeFormatterBuilder appendPattern(String pattern) {
DateTimeFormat.appendPatternTo(this, pattern);
return this;
}"
Time_20b_3,/home/common/huangzhili/defects4j_buggy_3/Time_20_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java,"private DateTimeFormatterBuilder append0(Object element) {
iFormatter = null;
// Add the element as both a printer and parser.
iElementPairs.add(element);
iElementPairs.add(element);
return this;
}"
Time_20b_4,/home/common/huangzhili/defects4j_buggy_3/Time_20_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java,"public DateTimeFormatterBuilder appendDecimal(
DateTimeFieldType fieldType, int minDigits, int maxDigits) {
if (fieldType == null) {
throw new IllegalArgumentException(""Field type must not be null"");
}
if (maxDigits < minDigits) {
maxDigits = minDigits;
}
if (minDigits < 0 || maxDigits <= 0) {
throw new IllegalArgumentException();
}
if (minDigits <= 1) {
return append0(new UnpaddedNumber(fieldType, maxDigits, false));
} else {
return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));
}
}"
Time_20b_5,/home/common/huangzhili/defects4j_buggy_3/Time_20_buggy/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java,"public DateTimeFormatterBuilder appendSignedDecimal(
DateTimeFieldType fieldType, int minDigits, int maxDigits) {
if (fieldType == null) {
throw new IllegalArgumentException(""Field type must not be null"");
}
if (maxDigits < minDigits) {
maxDigits = minDigits;
}
if (minDigits < 0 || maxDigits <= 0) {
throw new IllegalArgumentException();
}
if (minDigits <= 1) {
return append0(new UnpaddedNumber(fieldType, maxDigits, true));
} else {
return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));
}
}"
Time_22b_1,/home/common/huangzhili/defects4j_buggy_3/Time_22_buggy/src/main/java/org/joda/time/base/BasePeriod.java,"protected BasePeriod(long duration) {
this(duration, null, null);
// bug [3264409]
}"
Time_22b_2,/home/common/huangzhili/defects4j_buggy_3/Time_22_buggy/src/main/java/org/joda/time/base/BasePeriod.java,"return iType.getFieldType(index);
}

/**
* Gets the value at the specified index.
*
* @param index  the index to retrieve
* @return the value of the field at the specified index
* @throws IndexOutOfBoundsException if the index is invalid
*/
public int getValue(int index) {"
Time_22b_3,/home/common/huangzhili/defects4j_buggy_3/Time_22_buggy/src/main/java/org/joda/time/base/BasePeriod.java,"public PeriodType getPeriodType() {
return iType;
}"
Time_22b_4,/home/common/huangzhili/defects4j_buggy_3/Time_22_buggy/src/main/java/org/joda/time/base/BasePeriod.java,"public int getValue(int index) {
return iValues[index];
}"
Time_22b_5,/home/common/huangzhili/defects4j_buggy_3/Time_22_buggy/src/main/java/org/joda/time/base/BasePeriod.java,"protected PeriodType checkPeriodType(PeriodType type) {
return DateTimeUtils.getPeriodType(type);
}"
Time_23b_1,/home/common/huangzhili/defects4j_buggy_3/Time_23_buggy/src/main/java/org/joda/time/DateTimeZone.java,"public static DateTimeZone forTimeZone(TimeZone zone) {
if (zone == null) {
return getDefault();
}
final String id = zone.getID();
if (id.equals(""UTC"")) {
return DateTimeZone.UTC;
}

// Convert from old alias before consulting provider since they may differ.
DateTimeZone dtz = null;
String convId = getConvertedId(id);
if (convId != null) {
dtz = cProvider.getZone(convId);
}
if (dtz == null) {
dtz = cProvider.getZone(id);
}
if (dtz != null) {
return dtz;
}

// Support GMT+/-hh:mm formats
if (convId == null) {
convId = zone.getDisplayName();
if (convId.startsWith(""GMT+"") || convId.startsWith(""GMT-"")) {
convId = convId.substring(3);
int offset = parseOffset(convId);
if (offset == 0L) {
return DateTimeZone.UTC;
} else {
convId = printOffset(offset);
return fixedOffsetZone(convId, offset);
}
}
}
throw new IllegalArgumentException(""The datetime zone id '"" + id + ""' is not recognised"");
}"
Time_23b_2,/home/common/huangzhili/defects4j_buggy_3/Time_23_buggy/src/main/java/org/joda/time/DateTimeZone.java,"protected DateTimeZone(String id) {
if (id == null) {
throw new IllegalArgumentException(""Id must not be null"");
}
iID = id;
}"
Time_23b_3,/home/common/huangzhili/defects4j_buggy_3/Time_23_buggy/src/main/java/org/joda/time/DateTimeZone.java,"public static DateTimeZone getDefault() {
DateTimeZone zone = cDefault;
if (zone == null) {
synchronized(DateTimeZone.class) {
zone = cDefault;
if (zone == null) {
DateTimeZone temp = null;
try {
try {
String id = System.getProperty(""user.timezone"");
if (id != null) {  // null check avoids stack overflow
temp = forID(id);
}
} catch (RuntimeException ex) {
// ignored
}
if (temp == null) {
temp = forTimeZone(TimeZone.getDefault());
}
} catch (IllegalArgumentException ex) {
// ignored
}
if (temp == null) {
temp = UTC;
}
cDefault = zone = temp;
}
}
}
return zone;
}"
Time_23b_4,/home/common/huangzhili/defects4j_buggy_3/Time_23_buggy/src/main/java/org/joda/time/DateTimeZone.java,"public static void setDefault(DateTimeZone zone) throws SecurityException {
SecurityManager sm = System.getSecurityManager();
if (sm != null) {
sm.checkPermission(new JodaTimePermission(""DateTimeZone.setDefault""));
}
if (zone == null) {
throw new IllegalArgumentException(""The datetime zone must not be null"");
}
synchronized(DateTimeZone.class) {
cDefault = zone;
}
}"
Time_23b_5,/home/common/huangzhili/defects4j_buggy_3/Time_23_buggy/src/main/java/org/joda/time/DateTimeZone.java,"public static DateTimeZone forID(String id) {
if (id == null) {
return getDefault();
}
if (id.equals(""UTC"")) {
return DateTimeZone.UTC;
}
DateTimeZone zone = cProvider.getZone(id);
if (zone != null) {
return zone;
}
if (id.startsWith(""+"") || id.startsWith(""-"")) {
int offset = parseOffset(id);
if (offset == 0L) {
return DateTimeZone.UTC;
} else {
id = printOffset(offset);
return fixedOffsetZone(id, offset);
}
}
throw new IllegalArgumentException(""The datetime zone id '"" + id + ""' is not recognised"");
}"
Time_24b_1,/home/common/huangzhili/defects4j_buggy_3/Time_24_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java,"public DateTimeZone getZone() {
return iZone;
}"
Time_24b_2,/home/common/huangzhili/defects4j_buggy_3/Time_24_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java,"public int getOffset() {
return iOffset;
}"
Time_24b_3,/home/common/huangzhili/defects4j_buggy_3/Time_24_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java,"static int compareReverse(DurationField a, DurationField b) {
if (a == null || !a.isSupported()) {
if (b == null || !b.isSupported()) {
return 0;
}
return -1;
}
if (b == null || !b.isSupported()) {
return 1;
}
return -a.compareTo(b);
}"
Time_24b_4,/home/common/huangzhili/defects4j_buggy_3/Time_24_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java,"public long computeMillis(boolean resetFields, String text) {
SavedField[] savedFields = iSavedFields;
int count = iSavedFieldsCount;
if (iSavedFieldsShared) {
iSavedFields = savedFields = (SavedField[])iSavedFields.clone();
iSavedFieldsShared = false;
}
sort(savedFields, count);
if (count > 0) {
// alter base year for parsing if first field is month or day
DurationField months = DurationFieldType.months().getField(iChrono);
DurationField days = DurationFieldType.days().getField(iChrono);
DurationField first = savedFields[0].iField.getDurationField();
if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {
saveField(DateTimeFieldType.year(), iDefaultYear);
return computeMillis(resetFields, text);
}
}

long millis = iMillis;
try {
for (int i = 0; i < count; i++) {
millis = savedFields[i].set(millis, resetFields);
}
} catch (IllegalFieldValueException e) {
if (text != null) {
e.prependMessage(""Cannot parse \"""" + text + '""');
}
throw e;
}

if (iZone == null) {
millis -= iOffset;
} else {
int offset = iZone.getOffsetFromLocal(millis);
millis -= offset;
if (offset != iZone.getOffset(millis)) {
String message =
""Illegal instant due to time zone offset transition ("" + iZone + ')';
if (text != null) {
message = ""Cannot parse \"""" + text + ""\"": "" + message;
}
throw new IllegalArgumentException(message);
}
}

return millis;
}"
Time_24b_5,/home/common/huangzhili/defects4j_buggy_3/Time_24_buggy/src/main/java/org/joda/time/format/DateTimeParserBucket.java,"public void setZone(DateTimeZone zone) {
iSavedState = null;
iZone = zone == DateTimeZone.UTC ? null : zone;
iOffset = 0;
}"
Time_25b_1,/home/common/huangzhili/defects4j_buggy_3/Time_25_buggy/src/main/java/org/joda/time/DateTimeZone.java,"public int getOffsetFromLocal(long instantLocal) {
// get the offset at instantLocal (first estimate)
final int offsetLocal = getOffset(instantLocal);
// adjust instantLocal using the estimate and recalc the offset
final long instantAdjusted = instantLocal - offsetLocal;
final int offsetAdjusted = getOffset(instantAdjusted);
// if the offsets differ, we must be near a DST boundary
if (offsetLocal != offsetAdjusted) {
// we need to ensure that time is always after the DST gap
// this happens naturally for positive offsets, but not for negative
if ((offsetLocal - offsetAdjusted) < 0) {
// if we just return offsetAdjusted then the time is pushed
// back before the transition, whereas it should be
// on or after the transition
long nextLocal = nextTransition(instantAdjusted);
long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);
if (nextLocal != nextAdjusted) {
return offsetLocal;
}
}
}
return offsetAdjusted;
}"
Time_25b_2,/home/common/huangzhili/defects4j_buggy_3/Time_25_buggy/src/main/java/org/joda/time/DateTimeZone.java,"protected DateTimeZone(String id) {
if (id == null) {
throw new IllegalArgumentException(""Id must not be null"");
}
iID = id;
}"
Time_25b_3,/home/common/huangzhili/defects4j_buggy_3/Time_25_buggy/src/main/java/org/joda/time/DateTimeZone.java,"public static DateTimeZone forID(String id) {
if (id == null) {
return getDefault();
}
if (id.equals(""UTC"")) {
return DateTimeZone.UTC;
}
DateTimeZone zone = cProvider.getZone(id);
if (zone != null) {
return zone;
}
if (id.startsWith(""+"") || id.startsWith(""-"")) {
int offset = parseOffset(id);
if (offset == 0L) {
return DateTimeZone.UTC;
} else {
id = printOffset(offset);
return fixedOffsetZone(id, offset);
}
}
throw new IllegalArgumentException(""The datetime zone id '"" + id + ""' is not recognised"");
}"
Time_25b_4,/home/common/huangzhili/defects4j_buggy_3/Time_25_buggy/src/main/java/org/joda/time/DateTimeZone.java,"private static void setProvider0(Provider provider) {
if (provider == null) {
provider = getDefaultProvider();
}
Set<String> ids = provider.getAvailableIDs();
if (ids == null || ids.size() == 0) {
throw new IllegalArgumentException
(""The provider doesn't have any available ids"");
}
if (!ids.contains(""UTC"")) {
throw new IllegalArgumentException(""The provider doesn't support UTC"");
}
if (!UTC.equals(provider.getZone(""UTC""))) {
throw new IllegalArgumentException(""Invalid UTC zone provided"");
}
cProvider = provider;
cAvailableIDs = ids;
}"
Time_25b_5,/home/common/huangzhili/defects4j_buggy_3/Time_25_buggy/src/main/java/org/joda/time/DateTimeZone.java,"private static Provider getDefaultProvider() {
Provider provider = null;

try {
String providerClass =
System.getProperty(""org.joda.time.DateTimeZone.Provider"");
if (providerClass != null) {
try {
provider = (Provider) Class.forName(providerClass).newInstance();
} catch (Exception ex) {
Thread thread = Thread.currentThread();
thread.getThreadGroup().uncaughtException(thread, ex);
}
}
} catch (SecurityException ex) {
// ignored
}

if (provider == null) {
try {
provider = new ZoneInfoProvider(""org/joda/time/tz/data"");
} catch (Exception ex) {
Thread thread = Thread.currentThread();
thread.getThreadGroup().uncaughtException(thread, ex);
}
}

if (provider == null) {
provider = new UTCProvider();
}

return provider;
}"
Time_27b_1,/home/common/huangzhili/defects4j_buggy_3/Time_27_buggy/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java,"public PeriodFormatterBuilder append(PeriodFormatter formatter) {
if (formatter == null) {
throw new IllegalArgumentException(""No formatter supplied"");
}
clearPrefix();
append0(formatter.getPrinter(), formatter.getParser());
return this;
}"
Time_27b_2,/home/common/huangzhili/defects4j_buggy_3/Time_27_buggy/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java,"public PeriodFormatterBuilder appendSecondsWithOptionalMillis() {
appendField(SECONDS_OPTIONAL_MILLIS);
return this;
}"
Time_27b_3,/home/common/huangzhili/defects4j_buggy_3/Time_27_buggy/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java,"public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {
return appendSeparator(text, text, null, false, true);
}"
Time_27b_4,/home/common/huangzhili/defects4j_buggy_3/Time_27_buggy/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java,"private static Object[] createComposite(List<Object> elementPairs) {
switch (elementPairs.size()) {
case 0:
return new Object[] {Literal.EMPTY, Literal.EMPTY};
case 1:
return new Object[] {elementPairs.get(0), elementPairs.get(1)};
default:
Composite comp = new Composite(elementPairs);
return new Object[] {comp, comp};
}
}"
Time_27b_5,/home/common/huangzhili/defects4j_buggy_3/Time_27_buggy/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java,"public PeriodFormatterBuilder appendMinutes() {
appendField(MINUTES);
return this;
}"
