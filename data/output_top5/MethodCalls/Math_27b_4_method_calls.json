[
  {
    "method": "org.apache.commons.math3.util.ArithmeticUtils.gcd",
    "doc": "/**\n     * <p>\n     * Gets the greatest common divisor of the absolute value of two numbers,\n     * using the \"binary gcd\" method which avoids division and modulo\n     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n     * Stein (1961).\n     * </p>\n     * Special cases:\n     * <ul>\n     * <li>The invocations\n     * {@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},\n     * {@code gcd(Integer.MIN_VALUE, 0)} and\n     * {@code gcd(0, Integer.MIN_VALUE)} throw an\n     * {@code ArithmeticException}, because the result would be 2^31, which\n     * is too large for an int value.</li>\n     * <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and\n     * {@code gcd(x, 0)} is the absolute value of {@code x}, except\n     * for the special cases above.\n     * <li>The invocation {@code gcd(0, 0)} is the only one which returns\n     * {@code 0}.</li>\n     * </ul>\n     *\n     * @param p Number.\n     * @param q Number.\n     * @return the greatest common divisor, never negative.\n     * @throws MathArithmeticException if the result cannot be represented as\n     * a non-negative {@code int} value.\n     * @since 1.1\n     */",
    "code": "public static int gcd(final int p, final int q) {\n        int u = p;\n        int v = q;\n        if ((u == 0) || (v == 0)) {\n            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n                throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,\n                                                  p, q);\n            }\n            return FastMath.abs(u) + FastMath.abs(v);\n        }\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,\n                                              p, q);\n        }\n        do {\n            while ((t & 1) == 0) { // while t is even..\n                t /= 2; // cast out twos\n            }\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            t = (v - u) / 2;\n        } while (t != 0);\n        return -u * (1 << k); // gcd is u*2^k\n    }"
  }
]