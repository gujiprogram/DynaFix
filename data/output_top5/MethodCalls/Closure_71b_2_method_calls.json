[
  {
    "method": "com.google.common.collect.Multimap.containsEntry",
    "doc": "[Source file not found]",
    "code": ""
  },
  {
    "method": "com.google.javascript.rhino.JSDocInfo.isConstant",
    "doc": "/**\n   * Returns whether the {@code @const} annotation is present on this\n   * {@link JSDocInfo}.\n   */",
    "code": "public boolean isConstant() {\n    return getFlag(MASK_CONSTANT) || isDefine();\n  }"
  },
  {
    "method": "com.google.javascript.rhino.jstype.ObjectType.getImplicitPrototype",
    "doc": "/**\n   * Gets the docInfo for this type.\n   */",
    "code": "return getImplicitPrototype().getJSDocInfo();\n    } else {"
  },
  {
    "method": "com.google.javascript.rhino.jstype.ObjectType.getOwnPropertyJSDocInfo",
    "doc": "/**\n   * Gets the docInfo on the specified property on this type.  This should not\n   * be done implemented recursively, as you generally need to know exactly on\n   * which type in the prototype chain the JSDocInfo exists.\n   */",
    "code": "public JSDocInfo getOwnPropertyJSDocInfo(String propertyName) {\n    return null;\n  }"
  },
  {
    "method": "com.google.javascript.rhino.jstype.ObjectType.getReferenceName",
    "doc": "/**\n   * Gets the reference name for this object. This includes named types\n   * like constructors, prototypes, and enums. It notably does not include\n   * literal types like strings and booleans and structural types.\n   * @return the object's name or {@code null} if this is an anonymous\n   *         object\n   */",
    "code": "public abstract String getReferenceName();"
  },
  {
    "method": "com.google.javascript.rhino.jstype.ObjectType.hasReferenceName",
    "doc": "/**\n   * Returns true if the object is named.\n   * @return true if the object is named, false if it is anonymous\n   */",
    "code": "public boolean hasReferenceName() {\n    return false;\n  }"
  },
  {
    "method": "com.google.javascript.rhino.jstype.ObjectType.isInstanceType",
    "doc": "[No documentation]",
    "code": "[No method body]"
  }
]