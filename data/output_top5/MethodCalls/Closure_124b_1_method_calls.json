[
  {
    "method": "com.google.javascript.jscomp.ExploitAssigns.isSafeReplacement",
    "doc": "/**\n   * Checks name referenced in node to determine if it might have\n   * changed.\n   * @return Whether the replacement can be made.\n   */",
    "code": "private boolean isSafeReplacement(Node node, Node replacement) {\n    if (node.isName()) {\n      return true;\n    }\n    Preconditions.checkArgument(node.isGetProp());\n\n      node = node.getFirstChild();\n    if (node.isName()\n        && isNameAssignedTo(node.getString(), replacement)) {\n      return false;\n    }\n\n    return true;\n  }"
  },
  {
    "method": "com.google.javascript.rhino.Node.getFirstChild",
    "doc": "/**\n     * This should only be called for STRING nodes created in object lits.\n     */",
    "code": "public Node getFirstChild() {\n    return first;\n  }"
  },
  {
    "method": "com.google.javascript.rhino.Node.getNext",
    "doc": "/**\n     * This should only be called for STRING nodes created in object lits.\n     */",
    "code": "PropListItem getNext();\n    PropListItem chain(PropListItem next);"
  },
  {
    "method": "com.google.javascript.rhino.Node.getQualifiedName",
    "doc": "/**\n   * This function takes a set of GETPROP nodes and produces a string that is\n   * each property separated by dots. If the node ultimately under the left\n   * sub-tree is not a simple name, this is not a valid qualified name.\n   *\n   * @return a null if this is not a qualified name, or a dot-separated string\n   *         of the name and properties.\n   */",
    "code": "public String getQualifiedName() {\n    if (type == Token.NAME) {\n      String name = getString();\n      return name.isEmpty() ? null : name;\n    } else if (type == Token.GETPROP) {\n      String left = getFirstChild().getQualifiedName();\n      if (left == null) {\n        return null;\n      }\n      return left + \".\" + getLastChild().getString();\n    } else if (type == Token.THIS) {\n      return \"this\";\n    } else {\n      return null;\n    }\n  }"
  },
  {
    "method": "com.google.javascript.rhino.Node.isQualifiedName",
    "doc": "/**\n   * Returns whether a node corresponds to a simple or a qualified name, such as\n   * <code>x</code> or <code>a.b.c</code> or <code>this.a</code>.\n   */",
    "code": "public boolean isQualifiedName() {\n    switch (getType()) {\n      case Token.NAME:\n        return getString().isEmpty() ? false : true;\n      case Token.THIS:\n        return true;\n      case Token.GETPROP:\n        return getFirstChild().isQualifiedName();\n      default:\n        return false;\n    }\n  }"
  },
  {
    "method": "com.google.javascript.rhino.Node.removeChild",
    "doc": "/**\n   * Detach a child from its parent and siblings.\n   */",
    "code": "public void removeChild(Node child) {\n    Node prev = getChildBefore(child);\n    if (prev == null) {\n      first = first.next;\n    } else {\n      prev.next = child.next;\n    }\n    if (child == last) {\n      last = prev;\n    }\n    child.next = null;\n    child.parent = null;\n  }"
  },
  {
    "method": "com.google.javascript.rhino.Node.replaceChild",
    "doc": "/**\n   * Detaches child from Node and replaces it with newChild.\n   */",
    "code": "public void replaceChild(Node child, Node newChild) {\n    Preconditions.checkArgument(newChild.next == null,\n        \"The new child node has siblings.\");\n    Preconditions.checkArgument(newChild.parent == null,\n        \"The new child node already has a parent.\");\n\n    newChild.copyInformationFrom(child);\n\n    newChild.next = child.next;\n    newChild.parent = this;\n    if (child == first) {\n      first = newChild;\n    } else {\n      Node prev = getChildBefore(child);\n      prev.next = newChild;\n    }\n    if (child == last) {\n      last = newChild;\n    }\n    child.next = null;\n    child.parent = null;\n  }"
  }
]