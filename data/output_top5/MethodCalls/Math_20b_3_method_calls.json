[
  {
    "method": "org.apache.commons.math3.linear.RealMatrix.add",
    "doc": "/**\n     * Returns the sum of {@code this} and {@code m}.\n     *\n     * @param m matrix to be added\n     * @return {@code this + m}\n     * @throws MatrixDimensionMismatchException if {@code m} is not the same\n     * size as {@code this}.\n     */",
    "code": "RealMatrix add(RealMatrix m)\n        throws MatrixDimensionMismatchException;"
  },
  {
    "method": "org.apache.commons.math3.linear.RealMatrix.getEntry",
    "doc": "/**\n     * Get the entry in the specified row and column. Row and column indices\n     * start at 0.\n     *\n     * @param row Row index of entry to be fetched.\n     * @param column Column index of entry to be fetched.\n     * @return the matrix entry at {@code (row, column)}.\n     * @throws OutOfRangeException if the row or column index is not valid.\n     */",
    "code": "double getEntry(int row, int column) throws OutOfRangeException;"
  },
  {
    "method": "org.apache.commons.math3.linear.RealMatrix.multiply",
    "doc": "/**\n     * Returns the result of postmultiplying {@code this} by {@code m}.\n     *\n     * @param m matrix to postmultiply by\n     * @return {@code this * m}\n     * @throws DimensionMismatchException if\n     * {@code columnDimension(this) != rowDimension(m)}\n     */",
    "code": "RealMatrix multiply(RealMatrix m)\n        throws DimensionMismatchException;"
  },
  {
    "method": "org.apache.commons.math3.linear.RealMatrix.scalarMultiply",
    "doc": "/**\n     * Returns the result of multiplying each entry of {@code this} by\n     * {@code d}.\n     *\n     * @param d value to multiply all entries by\n     * @return {@code d * this}\n     */",
    "code": "RealMatrix scalarMultiply(double d);"
  },
  {
    "method": "org.apache.commons.math3.linear.RealMatrix.subtract",
    "doc": "/**\n     * Returns {@code this} minus {@code m}.\n     *\n     * @param m matrix to be subtracted\n     * @return {@code this - m}\n     * @throws MatrixDimensionMismatchException if {@code m} is not the same\n     * size as {@code this}.\n     */",
    "code": "RealMatrix subtract(RealMatrix m)\n        throws MatrixDimensionMismatchException;"
  },
  {
    "method": "org.apache.commons.math3.linear.RealMatrix.transpose",
    "doc": "/**\n     * Returns the transpose of this matrix.\n     *\n     * @return transpose matrix\n     */",
    "code": "RealMatrix transpose();"
  },
  {
    "method": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.diag",
    "doc": "/**\n     * @param m Input matrix.\n     * @return the diagonal n-by-n matrix if m is a column matrix or the column\n     * matrix representing the diagonal if m is a n-by-n matrix.\n     */",
    "code": "private static RealMatrix diag(final RealMatrix m) {\n        if (m.getColumnDimension() == 1) {\n            double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n            for (int i = 0; i < m.getRowDimension(); i++) {\n                d[i][i] = m.getEntry(i, 0);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        } else {\n            double[][] d = new double[m.getRowDimension()][1];\n            for (int i = 0; i < m.getColumnDimension(); i++) {\n                d[i][0] = m.getEntry(i, i);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        }\n    }"
  },
  {
    "method": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.divide",
    "doc": "/**\n     * @param m Input matrix 1.\n     * @param n Input matrix 2.\n     * @return Matrix where the elements of m and n are element-wise divided.\n     */",
    "code": "private static RealMatrix divide(final RealMatrix m, final RealMatrix n) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) / n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }"
  },
  {
    "method": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.inverse",
    "doc": "/**\n     * @param indices Input index array.\n     * @return the inverse of the mapping defined by indices.\n     */",
    "code": "private static int[] inverse(final int[] indices) {\n        int[] inverse = new int[indices.length];\n        for (int i = 0; i < indices.length; i++) {\n            inverse[indices[i]] = i;\n        }\n        return inverse;\n    }"
  },
  {
    "method": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.repmat",
    "doc": "/**\n     * @param mat Input matrix.\n     * @param n Number of row replicates.\n     * @param m Number of column replicates.\n     * @return a matrix which replicates the input matrix in both directions.\n     */",
    "code": "private static RealMatrix repmat(final RealMatrix mat, int n, int m) {\n        int rd = mat.getRowDimension();\n        int cd = mat.getColumnDimension();\n        double[][] d = new double[n * rd][m * cd];\n        for (int r = 0; r < n * rd; r++) {\n            for (int c = 0; c < m * cd; c++) {\n                d[r][c] = mat.getEntry(r % rd, c % cd);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }"
  },
  {
    "method": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.reverse",
    "doc": "/**\n     * @param indices Input index array.\n     * @return the indices in inverse order (last is first).\n     */",
    "code": "private static int[] reverse(final int[] indices) {\n        int[] reverse = new int[indices.length];\n        for (int i = 0; i < indices.length; i++) {\n            reverse[i] = indices[indices.length - i - 1];\n        }\n        return reverse;\n    }"
  },
  {
    "method": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.selectColumns",
    "doc": "/**\n     * @param m Input matrix.\n     * @param cols Columns to select.\n     * @return Matrix representing the selected columns.\n     */",
    "code": "private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) {\n        double[][] d = new double[m.getRowDimension()][cols.length];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < cols.length; c++) {\n                d[r][c] = m.getEntry(r, cols[c]);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }"
  },
  {
    "method": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.square",
    "doc": "/**\n     * @param m Input matrix\n     * @return Matrix representing the element-wise square (^2) of m.\n     */",
    "code": "private static RealMatrix square(final RealMatrix m) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                d[r][c] = e * e;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }"
  },
  {
    "method": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.times",
    "doc": "/**\n     * @param m Input matrix 1.\n     * @param n Input matrix 2.\n     * @return the matrix where the elements of m and n are element-wise multiplied.\n     */",
    "code": "private static RealMatrix times(final RealMatrix m, final RealMatrix n) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) * n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }"
  },
  {
    "method": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.updateBD",
    "doc": "/**\n     * Update B and D from C.\n     *\n     * @param negccov Negative covariance factor.\n     */",
    "code": "private void updateBD(double negccov) {\n        if (ccov1 + ccovmu + negccov > 0 &&\n                (iterations % 1. / (ccov1 + ccovmu + negccov) / dimension / 10.) < 1.) {\n            C = triu(C, 0).add(triu(C, 1).transpose());\n            EigenDecomposition eig = new EigenDecomposition(C);\n            B = eig.getV(); // eigen decomposition, B==normalized eigenvectors\n            D = eig.getD();\n            diagD = diag(D);\n            if (min(diagD) <= 0) {\n                for (int i = 0; i < dimension; i++) {\n                    if (diagD.getEntry(i, 0) < 0) {\n                        diagD.setEntry(i, 0, 0.);\n                    }\n                }\n                double tfac = max(diagD) / 1e14;\n                C = C.add(eye(dimension, dimension).scalarMultiply(tfac));\n                diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));\n            }\n            if (max(diagD) > 1e14 * min(diagD)) {\n                double tfac = max(diagD) / 1e14 - min(diagD);\n                C = C.add(eye(dimension, dimension).scalarMultiply(tfac));\n                diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));\n            }\n            diagC = diag(C);\n            diagD = sqrt(diagD); // D contains standard deviations now\n            BD = times(B, repmat(diagD.transpose(), dimension, 1)); // O(n^2)\n        }\n    }"
  }
]