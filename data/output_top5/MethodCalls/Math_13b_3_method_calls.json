[
  {
    "method": "org.apache.commons.math3.analysis.FunctionUtils.toDifferentiableMultivariateVectorFunction",
    "doc": "/** {@inheritDoc}\n             * @exception DimensionMismatchException if number of parameters or derivation\n             * order are higher than 1\n             */",
    "code": "public static DifferentiableMultivariateVectorFunction toDifferentiableMultivariateVectorFunction(final MultivariateDifferentiableVectorFunction f) {\n        return new DifferentiableMultivariateVectorFunction() {\n\n    @Deprecated\n    public static MultivariateDifferentiableVectorFunction toMultivariateDifferentiableVectorFunction(final DifferentiableMultivariateVectorFunction f) {\n        return new MultivariateDifferentiableVectorFunction() {\n\n            public DerivativeStructure[] value(final DerivativeStructure[] t)\n                throws DimensionMismatchException, NumberIsTooLargeException {\n\n                final int parameters = t[0].getFreeParameters();\n                final int order      = t[0].getOrder();\n                final int n          = t.length;\n                if (order > 1) {\n                    throw new NumberIsTooLargeException(order, 1, true);\n                }\n\n                for (int i = 0; i < n; ++i) {\n                    if (t[i].getFreeParameters() != parameters) {\n                        throw new DimensionMismatchException(t[i].getFreeParameters(), parameters);\n                    }\n\n                    if (t[i].getOrder() != order) {\n                        throw new DimensionMismatchException(t[i].getOrder(), order);\n                    }\n                }\n\n                final double[] point = new double[n];\n                for (int i = 0; i < n; ++i) {\n                    point[i] = t[i].getValue();\n                }\n                final double[] value      = f.value(point);\n                final double[][] jacobian = f.jacobian().value(point);\n\n                final DerivativeStructure[] merged = new DerivativeStructure[value.length];\n                for (int k = 0; k < merged.length; ++k) {\n                    final double[] derivatives = new double[parameters + 1];\n                    derivatives[0] = value[k];\n                    final int[] orders = new int[parameters];\n                    for (int i = 0; i < parameters; ++i) {\n                        orders[i] = 1;\n                        for (int j = 0; j < n; ++j) {\n                            derivatives[i + 1] += jacobian[k][j] * t[j].getPartialDerivative(orders);\n                        }\n                        orders[i] = 0;\n                    }\n                    merged[k] = new DerivativeStructure(parameters, order, derivatives);\n                }\n\n                return merged;\n\n            }\n\n        };\n    }\n\n}"
  },
  {
    "method": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateVectorOptimizer.optimizeInternal",
    "doc": "/**\n     * Optimize an objective function.\n     *\n     * @param maxEval Allowed number of evaluations of the objective function.\n     * @param f Objective function.\n     * @param optData Optimization data. The following data will be looked for:\n     * <ul>\n     *  <li>{@link Target}</li>\n     *  <li>{@link Weight}</li>\n     *  <li>{@link InitialGuess}</li>\n     * </ul>\n     * @return the point/value pair giving the optimal value of the objective\n     * function.\n     * @throws TooManyEvaluationsException if the maximal number of\n     * evaluations is exceeded.\n     * @throws DimensionMismatchException if the initial guess, target, and weight\n     * arguments have inconsistent dimensions.\n     *\n     * @since 3.1\n     */",
    "code": "return optimizeInternal(maxEval, f, t, w, startPoint);\n    }\n\n    protected PointVectorValuePair optimize(int maxEval,\n                                            FUNC f,\n                                            OptimizationData... optData)\n        throws TooManyEvaluationsException,\n               DimensionMismatchException {"
  }
]