[
  {
    "method": "com.google.javascript.jscomp.CheckAccessControls.checkConstantProperty",
    "doc": "/**\n   * Determines whether the given property with @const tag got reassigned\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   */",
    "code": "private void checkConstantProperty(NodeTraversal t,\n      Node getprop) {\n    Node parent = getprop.getParent();\n    if (!(NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == getprop)\n        && (parent.getType() != Token.INC) && (parent.getType() != Token.DEC)) {\n      return;\n    }\n\n    ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n\n    if (objectType != null) {\n      ObjectType oType = objectType;\n      while (oType != null) {\n        if (oType.hasReferenceName()) {\n          if (initializedConstantProperties.containsEntry(\n                  oType.getReferenceName(), propertyName)) {\n            compiler.report(\n                t.makeError(getprop, CONST_PROPERTY_REASSIGNED_VALUE,\n                    propertyName));\n            break;\n          }\n        }\n        oType = oType.getImplicitPrototype();\n      }\n\n      JSDocInfo info = objectType.getOwnPropertyJSDocInfo(propertyName);\n      if (info != null && info.isConstant()\n          && objectType.hasReferenceName()) {\n        initializedConstantProperties.put(objectType.getReferenceName(),\n            propertyName);\n      }\n\n      if (objectType.isInstanceType()) {\n        ObjectType prototype = objectType.getImplicitPrototype();\n        if (prototype != null) {\n          JSDocInfo prototypeInfo\n            = prototype.getOwnPropertyJSDocInfo(propertyName);\n          if (prototypeInfo != null && prototypeInfo.isConstant()\n              && prototype.hasReferenceName()) {\n            initializedConstantProperties.put(prototype.getReferenceName(),\n                propertyName);\n          }\n        }\n      }\n    }\n  }"
  },
  {
    "method": "com.google.javascript.jscomp.CheckAccessControls.checkNameDeprecation",
    "doc": "/**\n   * Checks the given NAME node to ensure that access restrictions are obeyed.\n   */",
    "code": "private void checkNameDeprecation(NodeTraversal t, Node n, Node parent) {\n    if (parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR ||\n        parent.getType() == Token.NEW) {\n      return;\n    }\n\n    Scope.Var var = t.getScope().getVar(n.getString());\n    JSDocInfo docInfo = var == null ? null : var.getJSDocInfo();\n\n    if (docInfo != null && docInfo.isDeprecated() &&\n        shouldEmitDeprecationWarning(t, n, parent)) {\n\n      if (docInfo.getDeprecationReason() != null) {\n        compiler.report(\n            t.makeError(n, DEPRECATED_NAME_REASON, n.getString(),\n                docInfo.getDeprecationReason()));\n      } else {\n        compiler.report(\n            t.makeError(n, DEPRECATED_NAME, n.getString()));\n      }\n    }\n  }"
  },
  {
    "method": "com.google.javascript.jscomp.CheckAccessControls.checkNameVisibility",
    "doc": "/**\n   * Determines whether the given name is visible in the current context.\n   * @param t The current traversal.\n   * @param name The name node.\n   */",
    "code": "private void checkNameVisibility(NodeTraversal t, Node name, Node parent) {\n    Var var = t.getScope().getVar(name.getString());\n    if (var != null) {\n      JSDocInfo docInfo = var.getJSDocInfo();\n      if (docInfo != null) {\n        Visibility visibility = docInfo.getVisibility();\n        if (visibility == Visibility.PRIVATE &&\n            !t.getInput().getName().equals(docInfo.getSourceName())) {\n          if (docInfo.isConstructor() &&\n              isValidPrivateConstructorAccess(parent)) {\n            return;\n          }\n\n          compiler.report(\n              t.makeError(name, BAD_PRIVATE_GLOBAL_ACCESS,\n                  name.getString(), docInfo.getSourceName()));\n        }\n      }\n    }\n  }"
  },
  {
    "method": "com.google.javascript.jscomp.CheckAccessControls.checkPropertyDeprecation",
    "doc": "/**\n   * Checks the given GETPROP node to ensure that access restrictions are\n   * obeyed.\n   */",
    "code": "private void checkPropertyDeprecation(NodeTraversal t, Node n, Node parent) {\n    if (parent.getType() == Token.NEW) {\n      return;\n    }\n\n    ObjectType objectType =\n        ObjectType.cast(dereference(n.getFirstChild().getJSType()));\n    String propertyName = n.getLastChild().getString();\n\n    if (objectType != null) {\n      String deprecationInfo\n          = getPropertyDeprecationInfo(objectType, propertyName);\n\n      if (deprecationInfo != null &&\n          shouldEmitDeprecationWarning(t, n, parent)) {\n\n        if (!deprecationInfo.isEmpty()) {\n          compiler.report(\n              t.makeError(n, DEPRECATED_PROP_REASON, propertyName,\n                  validator.getReadableJSTypeName(n.getFirstChild(), true),\n                  deprecationInfo));\n        } else {\n          compiler.report(\n              t.makeError(n, DEPRECATED_PROP, propertyName,\n                  validator.getReadableJSTypeName(n.getFirstChild(), true)));\n        }\n      }\n    }\n  }"
  },
  {
    "method": "com.google.javascript.jscomp.CheckAccessControls.checkPropertyVisibility",
    "doc": "/**\n   * Determines whether the given property is visible in the current context.\n   * @param t The current traversal.\n   * @param getprop The getprop node.\n   */",
    "code": "private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent) {\n    ObjectType objectType =\n        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n\n    if (objectType != null) {\n      boolean isOverride = t.inGlobalScope() &&\n          parent.getType() == Token.ASSIGN &&\n          parent.getFirstChild() == getprop;\n\n      if (isOverride) {\n        objectType = objectType.getImplicitPrototype();\n      }\n      JSDocInfo docInfo = null;\n      for (; objectType != null;\n           objectType = objectType.getImplicitPrototype()) {\n        docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n        if (docInfo != null &&\n            docInfo.getVisibility() != Visibility.INHERITED) {\n          break;\n        }\n      }\n\n      if (objectType == null) {\n        return;\n      }\n\n      boolean sameInput =\n          t.getInput().getName().equals(docInfo.getSourceName());\n      Visibility visibility = docInfo.getVisibility();\n      JSType ownerType = normalizeClassType(objectType);\n      if (isOverride) {\n        JSDocInfo overridingInfo = parent.getJSDocInfo();\n        Visibility overridingVisibility = overridingInfo == null ?\n            Visibility.INHERITED : overridingInfo.getVisibility();\n\n        if (visibility == Visibility.PRIVATE && !sameInput) {\n          compiler.report(\n              t.makeError(getprop, PRIVATE_OVERRIDE,\n                  objectType.toString()));\n        } else if (overridingVisibility != Visibility.INHERITED &&\n            overridingVisibility != visibility) {\n          compiler.report(\n              t.makeError(getprop, VISIBILITY_MISMATCH,\n                  visibility.name(), objectType.toString(),\n                  overridingVisibility.name()));\n        }\n      } else {\n        if (sameInput) {\n          return;\n        } else if (visibility == Visibility.PRIVATE &&\n            (currentClass == null || ownerType.differsFrom(currentClass))) {\n          if (docInfo.isConstructor() &&\n              isValidPrivateConstructorAccess(parent)) {\n            return;\n          }\n\n          compiler.report(\n              t.makeError(getprop,\n                  BAD_PRIVATE_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        } else if (visibility == Visibility.PROTECTED) {\n          if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n            compiler.report(\n                t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                    propertyName,\n                    validator.getReadableJSTypeName(\n                        getprop.getFirstChild(), true)));\n          }\n        }\n      }\n    }\n  }"
  },
  {
    "method": "com.google.javascript.rhino.Node.getType",
    "doc": "/**\n     * This should only be called for STRING nodes created in object lits.\n     */",
    "code": "public int getType() {\n    return type;\n  }"
  }
]