[
  {
    "method": "org.apache.commons.math3.analysis.FunctionUtils.toMultivariateDifferentiableVectorFunction",
    "doc": "/** {@inheritDoc}\n             * @exception DimensionMismatchException if number of parameters or derivation\n             * order are higher than 1\n             */",
    "code": "public static MultivariateDifferentiableVectorFunction toMultivariateDifferentiableVectorFunction(final DifferentiableMultivariateVectorFunction f) {\n        return new MultivariateDifferentiableVectorFunction() {\n\n            public DerivativeStructure[] value(final DerivativeStructure[] t)\n                throws DimensionMismatchException, NumberIsTooLargeException {\n\n                final int parameters = t[0].getFreeParameters();\n                final int order      = t[0].getOrder();\n                final int n          = t.length;\n                if (order > 1) {\n                    throw new NumberIsTooLargeException(order, 1, true);\n                }\n\n                for (int i = 0; i < n; ++i) {\n                    if (t[i].getFreeParameters() != parameters) {\n                        throw new DimensionMismatchException(t[i].getFreeParameters(), parameters);\n                    }\n\n                    if (t[i].getOrder() != order) {\n                        throw new DimensionMismatchException(t[i].getOrder(), order);\n                    }\n                }\n\n                final double[] point = new double[n];\n                for (int i = 0; i < n; ++i) {\n                    point[i] = t[i].getValue();\n                }\n                final double[] value      = f.value(point);\n                final double[][] jacobian = f.jacobian().value(point);\n\n                final DerivativeStructure[] merged = new DerivativeStructure[value.length];\n                for (int k = 0; k < merged.length; ++k) {\n                    final double[] derivatives = new double[parameters + 1];\n                    derivatives[0] = value[k];\n                    final int[] orders = new int[parameters];\n                    for (int i = 0; i < parameters; ++i) {\n                        orders[i] = 1;\n                        for (int j = 0; j < n; ++j) {\n                            derivatives[i + 1] += jacobian[k][j] * t[j].getPartialDerivative(orders);\n                        }\n                        orders[i] = 0;\n                    }\n                    merged[k] = new DerivativeStructure(parameters, order, derivatives);\n                }\n\n                return merged;\n\n            }\n\n        };\n    }"
  },
  {
    "method": "org.apache.commons.math3.optimization.general.AbstractLeastSquaresOptimizer.optimizeInternal",
    "doc": "/** {@inheritDoc}\n     * @deprecated As of 3.1. Please use\n     * {@link BaseAbstractMultivariateVectorOptimizer#optimize(int,MultivariateVectorFunction,OptimizationData[])\n     * optimize(int,MultivariateDifferentiableVectorFunction,OptimizationData...)}\n     * instead.\n     */",
    "code": "return optimizeInternal(maxEval,\n                                FunctionUtils.toMultivariateDifferentiableVectorFunction(f),"
  }
]