[
  {
    "method": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer.bobyqa",
    "doc": "/**\n     *     This subroutine seeks the least value of a function of many variables,\n     *     by applying a trust region method that forms quadratic models by\n     *     interpolation. There is usually some freedom in the interpolation\n     *     conditions, which is taken up by minimizing the Frobenius norm of\n     *     the change to the second derivative of the model, beginning with the\n     *     zero matrix. The values of the variables are constrained by upper and\n     *     lower bounds. The arguments of the subroutine are as follows.\n     *\n     *     N must be set to the number of variables and must be at least two.\n     *     NPT is the number of interpolation conditions. Its value must be in\n     *       the interval [N+2,(N+1)(N+2)/2]. Choices that exceed 2*N+1 are not\n     *       recommended.\n     *     Initial values of the variables must be set in X(1),X(2),...,X(N). They\n     *       will be changed to the values that give the least calculated F.\n     *     For I=1,2,...,N, XL(I) and XU(I) must provide the lower and upper\n     *       bounds, respectively, on X(I). The construction of quadratic models\n     *       requires XL(I) to be strictly less than XU(I) for each I. Further,\n     *       the contribution to a model from changes to the I-th variable is\n     *       damaged severely by rounding errors if XU(I)-XL(I) is too small.\n     *     RHOBEG and RHOEND must be set to the initial and final values of a trust\n     *       region radius, so both must be positive with RHOEND no greater than\n     *       RHOBEG. Typically, RHOBEG should be about one tenth of the greatest\n     *       expected change to a variable, while RHOEND should indicate the\n     *       accuracy that is required in the final values of the variables. An\n     *       error return occurs if any of the differences XU(I)-XL(I), I=1,...,N,\n     *       is less than 2*RHOBEG.\n     *     MAXFUN must be set to an upper bound on the number of calls of CALFUN.\n     *     The array W will be used for working space. Its length must be at least\n     *       (NPT+5)*(NPT+N)+3*N*(N+5)/2.\n     *\n     * @param lowerBound Lower bounds.\n     * @param upperBound Upper bounds.\n     * @return the value of the objective at the optimum.\n     */",
    "code": "private double bobyqa(double[] lowerBound,\n                          double[] upperBound) {\n        printMethod(); // XXX\n\n        final int n = currentBest.getDimension();\n\n\n        for (int j = 0; j < n; j++) {\n            final double boundDiff = boundDifference[j];\n            lowerDifference.setEntry(j, lowerBound[j] - currentBest.getEntry(j));\n            upperDifference.setEntry(j, upperBound[j] - currentBest.getEntry(j));\n            if (lowerDifference.getEntry(j) >= -initialTrustRegionRadius) {\n                if (lowerDifference.getEntry(j) >= ZERO) {\n                    currentBest.setEntry(j, lowerBound[j]);\n                    lowerDifference.setEntry(j, ZERO);\n                    upperDifference.setEntry(j, boundDiff);\n                } else {\n                    currentBest.setEntry(j, lowerBound[j] + initialTrustRegionRadius);\n                    lowerDifference.setEntry(j, -initialTrustRegionRadius);\n                    final double deltaOne = upperBound[j] - currentBest.getEntry(j);\n                    upperDifference.setEntry(j, Math.max(deltaOne, initialTrustRegionRadius));\n                }\n            } else if (upperDifference.getEntry(j) <= initialTrustRegionRadius) {\n                if (upperDifference.getEntry(j) <= ZERO) {\n                    currentBest.setEntry(j, upperBound[j]);\n                    lowerDifference.setEntry(j, -boundDiff);\n                    upperDifference.setEntry(j, ZERO);\n                } else {\n                    currentBest.setEntry(j, upperBound[j] - initialTrustRegionRadius);\n                    final double deltaOne = lowerBound[j] - currentBest.getEntry(j);\n                    final double deltaTwo = -initialTrustRegionRadius;\n                    lowerDifference.setEntry(j, Math.min(deltaOne, deltaTwo));\n                    upperDifference.setEntry(j, initialTrustRegionRadius);\n                }\n            }\n        }\n\n\n        return bobyqb(lowerBound, upperBound);\n    } // bobyqa"
  },
  {
    "method": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer.getGoalType",
    "doc": "[No documentation]",
    "code": "[No method body]"
  },
  {
    "method": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer.getLowerBound",
    "doc": "[No documentation]",
    "code": "[No method body]"
  },
  {
    "method": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer.getStartPoint",
    "doc": "[No documentation]",
    "code": "[No method body]"
  },
  {
    "method": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer.getUpperBound",
    "doc": "[No documentation]",
    "code": "[No method body]"
  },
  {
    "method": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer.setup",
    "doc": "/**\n     * Performs validity checks.\n     *\n     * @param lowerBound Lower bounds (constraints) of the objective variables.\n     * @param upperBound Upperer bounds (constraints) of the objective variables.\n     */",
    "code": "private void setup(double[] lowerBound,\n                       double[] upperBound) {\n        printMethod(); // XXX\n\n        double[] init = getStartPoint();\n        final int dimension = init.length;\n\n        if (dimension < MINIMUM_PROBLEM_DIMENSION) {\n            throw new NumberIsTooSmallException(dimension, MINIMUM_PROBLEM_DIMENSION, true);\n        }\n        final int[] nPointsInterval = { dimension + 2, (dimension + 2) * (dimension + 1) / 2 };\n        if (numberOfInterpolationPoints < nPointsInterval[0] ||\n            numberOfInterpolationPoints > nPointsInterval[1]) {\n            throw new OutOfRangeException(LocalizedFormats.NUMBER_OF_INTERPOLATION_POINTS,\n                                          numberOfInterpolationPoints,\n                                          nPointsInterval[0],\n                                          nPointsInterval[1]);\n        }\n\n        boundDifference = new double[dimension];\n\n        double requiredMinDiff = 2 * initialTrustRegionRadius;\n        double minDiff = Double.POSITIVE_INFINITY;\n        for (int i = 0; i < dimension; i++) {\n            boundDifference[i] = upperBound[i] - lowerBound[i];\n            minDiff = Math.min(minDiff, boundDifference[i]);\n        }\n        if (minDiff < requiredMinDiff) {\n            initialTrustRegionRadius = minDiff / 3.0;\n        }\n\n        bMatrix = new Array2DRowRealMatrix(dimension + numberOfInterpolationPoints,\n                                           dimension);\n        zMatrix = new Array2DRowRealMatrix(numberOfInterpolationPoints,\n                                           numberOfInterpolationPoints - dimension - 1);\n        interpolationPoints = new Array2DRowRealMatrix(numberOfInterpolationPoints,\n                                                       dimension);\n        originShift = new ArrayRealVector(dimension);\n        fAtInterpolationPoints = new ArrayRealVector(numberOfInterpolationPoints);\n        trustRegionCenterOffset = new ArrayRealVector(dimension);\n        gradientAtTrustRegionCenter = new ArrayRealVector(dimension);\n        lowerDifference = new ArrayRealVector(dimension);\n        upperDifference = new ArrayRealVector(dimension);\n        modelSecondDerivativesParameters = new ArrayRealVector(numberOfInterpolationPoints);\n        newPoint = new ArrayRealVector(dimension);\n        alternativeNewPoint = new ArrayRealVector(dimension);\n        trialStepPoint = new ArrayRealVector(dimension);\n        lagrangeValuesAtNewPoint = new ArrayRealVector(dimension + numberOfInterpolationPoints);\n        modelSecondDerivativesValues = new ArrayRealVector(dimension * (dimension + 1) / 2);\n    }"
  }
]