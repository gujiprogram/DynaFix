[
  {
    "method": "com.google.common.collect.Lists.newArrayList",
    "doc": "[Source file not found]",
    "code": ""
  },
  {
    "method": "com.google.javascript.jscomp.parsing.Annotation.ordinal",
    "doc": "[No documentation]",
    "code": "[No method body]"
  },
  {
    "method": "com.google.javascript.jscomp.parsing.JsDocInfoParser$ExtractionInfo.access$300",
    "doc": "[Source file not found]",
    "code": ""
  },
  {
    "method": "com.google.javascript.jscomp.parsing.JsDocInfoParser$ExtractionInfo.access$400",
    "doc": "[Source file not found]",
    "code": ""
  },
  {
    "method": "com.google.javascript.jscomp.parsing.JsDocInfoParser.checkExtendedTypes",
    "doc": "/**\n   * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n   * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n   * {@link JsDocToken#EOC} is returned.\n   *\n   * @return {@code true} if JSDoc information was correctly parsed,\n   *     {@code false} otherwise\n   */",
    "code": "private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) {\n    for (ExtendedTypeInfo typeInfo : extendedTypes) {\n      if (jsdocBuilder.isInterfaceRecorded()) {\n        if (!jsdocBuilder.recordExtendedInterface(typeInfo.type)) {\n          parser.addParserWarning(\"msg.jsdoc.extends.duplicate\",\n              typeInfo.lineno, typeInfo.charno);\n        }\n      } else {\n        if (!jsdocBuilder.recordBaseType(typeInfo.type)) {\n          parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n              typeInfo.lineno, typeInfo.charno);\n        }\n      }\n    }\n  }"
  },
  {
    "method": "com.google.javascript.jscomp.parsing.JsDocInfoParser.extractMultilineTextualBlock",
    "doc": "/**\n   * Extracts the text found on the current line starting at token. Note that\n   * token = token.info; should be called after this method is used to update\n   * the token properly in the parser.\n   *\n   * @return The extraction information.\n   */",
    "code": "private ExtractionInfo extractMultilineTextualBlock(JsDocToken token) {\n    return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE);\n  }"
  },
  {
    "method": "com.google.javascript.jscomp.parsing.JsDocInfoParser.hasParsedFileOverviewDocInfo",
    "doc": "/**\n   * Determines whether the parser has been populated with docinfo with a\n   * fileoverview tag.\n   */",
    "code": "private boolean hasParsedFileOverviewDocInfo() {\n    return jsdocBuilder.isPopulatedWithFileOverview();\n  }"
  },
  {
    "method": "com.google.javascript.jscomp.parsing.JsDocInfoParser.next",
    "doc": "/**\n   * Gets the next token of the token stream or the buffered token if a matching\n   * was previously made.\n   */",
    "code": "private JsDocToken next() {\n    if (unreadToken == NO_UNREAD_TOKEN) {\n      return stream.getJsDocToken();\n    } else {\n      return current();\n    }\n  }"
  },
  {
    "method": "com.google.javascript.jscomp.parsing.JsDocInfoParser.skipEOLs",
    "doc": "/**\n   * Skips all EOLs and all empty lines in the JSDoc. Call this method if you\n   * want the JSDoc entry to span multiple lines.\n   */",
    "code": "private void skipEOLs() {\n    while (match(JsDocToken.EOL)) {\n      next();\n      if (match(JsDocToken.STAR)) {\n        next();\n      }\n    }\n  }"
  },
  {
    "method": "com.google.javascript.jscomp.parsing.JsDocToken.ordinal",
    "doc": "[No documentation]",
    "code": "[No method body]"
  },
  {
    "method": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getCharno",
    "doc": "/**\n   * Gets the remaining JSDoc line without the {@link JsDocToken#EOL},\n   * {@link JsDocToken#EOF} or {@link JsDocToken#EOC}.\n   */",
    "code": "final int getCharno() {\n    return lineno == initLineno? initCharno + charno : charno;\n  }"
  },
  {
    "method": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getLineno",
    "doc": "/**\n   * Gets the remaining JSDoc line without the {@link JsDocToken#EOL},\n   * {@link JsDocToken#EOF} or {@link JsDocToken#EOC}.\n   */",
    "code": "final int getLineno() { return lineno; }"
  },
  {
    "method": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getString",
    "doc": "/**\n   * Gets the remaining JSDoc line without the {@link JsDocToken#EOL},\n   * {@link JsDocToken#EOF} or {@link JsDocToken#EOC}.\n   */",
    "code": "final String getString() { return string; }"
  },
  {
    "method": "com.google.javascript.rhino.JSDocInfoBuilder.markAnnotation",
    "doc": "/**\n   * Adds a marker to the current JSDocInfo and populates the marker with the\n   * annotation information.\n   */",
    "code": "public void markAnnotation(String annotation, int lineno, int charno) {\n    JSDocInfo.Marker marker = currentInfo.addMarker();\n\n    if (marker != null) {\n      JSDocInfo.TrimmedStringPosition position =\n          new JSDocInfo.TrimmedStringPosition();\n      position.setItem(annotation);\n      position.setPositionInformation(lineno, charno, lineno,\n          charno + annotation.length());\n      marker.setAnnotation(position);\n      populated = true;\n    }\n\n    currentMarker = marker;\n  }"
  },
  {
    "method": "com.google.javascript.rhino.JSDocInfoBuilder.shouldParseDocumentation",
    "doc": "/**\n   * Sets the original JSDoc comment string. This is a no-op if the builder\n   * isn't configured to record documentation.\n   */",
    "code": "public boolean shouldParseDocumentation() {\n    return parseDocumentation;\n  }"
  },
  {
    "method": "com.google.javascript.rhino.Node$FileLevelJsDocBuilder.append",
    "doc": "[Source file not found]",
    "code": ""
  }
]