[
  {
    "method": "org.apache.commons.math3.ode.AbstractIntegrator.computeDerivatives",
    "doc": "/** Compute the derivatives and check the number of evaluations.\n     * @param t current value of the independent <I>time</I> variable\n     * @param y array containing the current value of the state vector\n     * @param yDot placeholder array where to put the time derivative of the state vector\n     * @exception MaxCountExceededException if the number of functions evaluations is exceeded\n     * @exception DimensionMismatchException if arrays dimensions do not match equations settings\n     */",
    "code": "public void computeDerivatives(final double t, final double[] y, final double[] yDot)\n        throws MaxCountExceededException, DimensionMismatchException {\n        evaluations.incrementCount();\n        expandable.computeDerivatives(t, y, yDot);\n    }"
  },
  {
    "method": "org.apache.commons.math3.ode.events.EventState.evaluateStep",
    "doc": "/** Evaluate the impact of the proposed step on the event handler.\n     * @param interpolator step interpolator for the proposed step\n     * @return true if the event handler triggers an event before\n     * the end of the proposed step\n     * @exception MaxCountExceededException if the interpolator throws one because\n     * the number of functions evaluations is exceeded\n     * @exception NoBracketingException if the event cannot be bracketed\n     */",
    "code": "public boolean evaluateStep(final StepInterpolator interpolator)\n        throws MaxCountExceededException, NoBracketingException {\n\n        try {\n            forward = interpolator.isForward();\n            final double t1 = interpolator.getCurrentTime();\n            final double dt = t1 - t0;\n            if (FastMath.abs(dt) < convergence) {\n                return false;\n            }\n            final int    n = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval));\n            final double h = dt / n;\n\n            final UnivariateFunction f = new UnivariateFunction() {\n                public double value(final double t) throws LocalMaxCountExceededException {\n                    try {\n                        interpolator.setInterpolatedTime(t);\n                        return handler.g(t, interpolator.getInterpolatedState());\n                    } catch (MaxCountExceededException mcee) {\n                        throw new LocalMaxCountExceededException(mcee);\n                    }\n                }\n            };\n\n            double ta = t0;\n            double ga = g0;\n            for (int i = 0; i < n; ++i) {\n\n                final double tb = t0 + (i + 1) * h;\n                interpolator.setInterpolatedTime(tb);\n                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n                if (g0Positive ^ (gb >= 0)) {\n\n                    increasing = gb >= ga;\n\n                    final double root;\n                    if (solver instanceof BracketedUnivariateSolver<?>) {\n                        @SuppressWarnings(\"unchecked\")\n                        BracketedUnivariateSolver<UnivariateFunction> bracketing =\n                                (BracketedUnivariateSolver<UnivariateFunction>) solver;\n                        root = forward ?\n                               bracketing.solve(maxIterationCount, f, ta, tb, AllowedSolution.RIGHT_SIDE) :\n                               bracketing.solve(maxIterationCount, f, tb, ta, AllowedSolution.LEFT_SIDE);\n                    } else {\n                        final double baseRoot = forward ?\n                                                solver.solve(maxIterationCount, f, ta, tb) :\n                                                solver.solve(maxIterationCount, f, tb, ta);\n                        final int remainingEval = maxIterationCount - solver.getEvaluations();\n                        BracketedUnivariateSolver<UnivariateFunction> bracketing =\n                                new PegasusSolver(solver.getRelativeAccuracy(), solver.getAbsoluteAccuracy());\n                        root = forward ?\n                               UnivariateSolverUtils.forceSide(remainingEval, f, bracketing,\n                                                                   baseRoot, ta, tb, AllowedSolution.RIGHT_SIDE) :\n                               UnivariateSolverUtils.forceSide(remainingEval, f, bracketing,\n                                                                   baseRoot, tb, ta, AllowedSolution.LEFT_SIDE);\n                    }\n\n                    if ((!Double.isNaN(previousEventTime)) &&\n                        (FastMath.abs(root - ta) <= convergence) &&\n                        (FastMath.abs(root - previousEventTime) <= convergence)) {\n                        ta = forward ? ta + convergence : ta - convergence;\n                        ga = f.value(ta);\n                        --i;\n                    } else if (Double.isNaN(previousEventTime) ||\n                               (FastMath.abs(previousEventTime - root) > convergence)) {\n                        pendingEventTime = root;\n                        pendingEvent = true;\n                        return true;\n                    } else {\n                        ta = tb;\n                        ga = gb;\n                    }\n\n                } else {\n                    ta = tb;\n                    ga = gb;\n                }\n\n            }\n\n            pendingEvent     = false;\n            pendingEventTime = Double.NaN;\n            return false;\n\n        } catch (LocalMaxCountExceededException lmcee) {\n            throw lmcee.getException();\n        }\n\n    }"
  },
  {
    "method": "org.apache.commons.math3.ode.events.EventState.reset",
    "doc": "/** Let the event handler reset the state if it wants.\n     * @param t value of the independent <i>time</i> variable at the\n     * beginning of the next step\n     * @param y array were to put the desired state vector at the beginning\n     * of the next step\n     * @return true if the integrator should reset the derivatives too\n     */",
    "code": "public boolean reset(final double t, final double[] y) {\n\n        if (!(pendingEvent && (FastMath.abs(pendingEventTime - t) <= convergence))) {\n            return false;\n        }\n\n        if (nextAction == EventHandler.Action.RESET_STATE) {\n            handler.resetState(t, y);\n        }\n        pendingEvent      = false;\n        pendingEventTime  = Double.NaN;\n\n        return (nextAction == EventHandler.Action.RESET_STATE) ||\n               (nextAction == EventHandler.Action.RESET_DERIVATIVES);\n\n    }"
  },
  {
    "method": "org.apache.commons.math3.ode.sampling.AbstractStepInterpolator.getGlobalCurrentTime",
    "doc": "/**\n   * Get the current global grid point time.\n   * @return current global grid point time\n   */",
    "code": "public double getGlobalCurrentTime() {\n    return globalCurrentTime;\n  }"
  },
  {
    "method": "org.apache.commons.math3.ode.sampling.AbstractStepInterpolator.getGlobalPreviousTime",
    "doc": "/**\n   * Get the previous global grid point time.\n   * @return previous global grid point time\n   */",
    "code": "public double getGlobalPreviousTime() {\n    return globalPreviousTime;\n  }"
  },
  {
    "method": "org.apache.commons.math3.ode.sampling.AbstractStepInterpolator.isForward",
    "doc": "[No documentation]",
    "code": "[No method body]"
  },
  {
    "method": "org.apache.commons.math3.ode.sampling.StepHandler.handleStep",
    "doc": "/**\n     * Handle the last accepted step\n     * @param interpolator interpolator for the last accepted step. For\n     * efficiency purposes, the various integrators reuse the same\n     * object on each call, so if the instance wants to keep it across\n     * all calls (for example to provide at the end of the integration a\n     * continuous model valid throughout the integration range, as the\n     * {@link org.apache.commons.math3.ode.ContinuousOutputModel\n     * ContinuousOutputModel} class does), it should build a local copy\n     * using the clone method of the interpolator and store this copy.\n     * Keeping only a reference to the interpolator and reusing it will\n     * result in unpredictable behavior (potentially crashing the application).\n     * @param isLast true if the step is the last one\n     * @exception MaxCountExceededException if the interpolator throws one because\n     * the number of functions evaluations is exceeded\n     */",
    "code": "void handleStep(StepInterpolator interpolator, boolean isLast)\n        throws MaxCountExceededException;"
  }
]